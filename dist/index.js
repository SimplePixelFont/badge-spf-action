import require$$0, { promises, existsSync } from 'fs';
import require$$0$1 from 'util';
import require$$1 from 'stream';
import require$$1$1 from 'zlib';
import require$$0$2 from 'assert';
import require$$7 from 'buffer';
import require$$1$2 from 'path';
import require$$0$3 from 'os';
import require$$0$4 from 'crypto';
import require$$2$1 from 'http';
import require$$3$1 from 'https';
import require$$0$5 from 'net';
import require$$1$3 from 'tls';
import require$$4$1 from 'events';
import require$$8 from 'querystring';
import require$$14 from 'stream/web';
import require$$0$7 from 'node:stream';
import require$$1$4 from 'node:util';
import require$$0$6 from 'node:events';
import require$$0$8 from 'worker_threads';
import require$$2$2 from 'perf_hooks';
import require$$5 from 'util/types';
import require$$4$2 from 'async_hooks';
import require$$1$5 from 'console';
import require$$1$6 from 'url';
import require$$1$7 from 'string_decoder';
import require$$0$9 from 'diagnostics_channel';
import require$$2$3 from 'child_process';
import require$$4$3 from 'timers';

var HeaderTypes;
(function (HeaderTypes) {
    HeaderTypes[HeaderTypes["BITMAP_INFO_HEADER"] = 40] = "BITMAP_INFO_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V2_INFO_HEADER"] = 52] = "BITMAP_V2_INFO_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V3_INFO_HEADER"] = 56] = "BITMAP_V3_INFO_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V4_HEADER"] = 108] = "BITMAP_V4_HEADER";
    HeaderTypes[HeaderTypes["BITMAP_V5_HEADER"] = 124] = "BITMAP_V5_HEADER";
})(HeaderTypes || (HeaderTypes = {}));

// We have these:
//
// const sample = 0101 0101 0101 0101
// const mask   = 0111 1100 0000 0000
// 256        === 0000 0001 0000 0000
//
// We want to take the sample and turn it into an 8-bit value.
//
// 1. We extract the last bit of the mask:
//
// 0000 0100 0000 0000
//       ^
//
// Like so:
//
// const a = ~mask =    1000 0011 1111 1111
// const b = a + 1 =    1000 0100 0000 0000
// const c = b & mask = 0000 0100 0000 0000
//
// 2. We shift it to the right and extract the bit before the first:
//
// 0000 0000 0010 0000
//             ^
//
// Like so:
//
// const d = mask / c = 0000 0000 0001 1111
// const e = mask + 1 = 0000 0000 0010 0000
//
// 3. We apply the mask and the two values above to a sample:
//
// const f = sample & mask = 0101 0100 0000 0000
// const g = f / c =         0000 0000 0001 0101
// const h = 256 / e =       0000 0000 0000 0100
// const i = g * h =         0000 0000 1010 1000
//                                     ^^^^ ^
//
// Voila, we have extracted a sample and "stretched" it to 8 bits. For samples
// which are already 8-bit, h === 1 and g === i.
function maskColor(maskRed, maskGreen, maskBlue, maskAlpha) {
    const maskRedR = (~maskRed + 1) & maskRed;
    const maskGreenR = (~maskGreen + 1) & maskGreen;
    const maskBlueR = (~maskBlue + 1) & maskBlue;
    const maskAlphaR = (~maskAlpha + 1) & maskAlpha;
    const shiftedMaskRedL = maskRed / maskRedR + 1;
    const shiftedMaskGreenL = maskGreen / maskGreenR + 1;
    const shiftedMaskBlueL = maskBlue / maskBlueR + 1;
    const shiftedMaskAlphaL = maskAlpha / maskAlphaR + 1;
    return {
        shiftRed: (x) => (((x & maskRed) / maskRedR) * 0x100) / shiftedMaskRedL,
        shiftGreen: (x) => (((x & maskGreen) / maskGreenR) * 0x100) / shiftedMaskGreenL,
        shiftBlue: (x) => (((x & maskBlue) / maskBlueR) * 0x100) / shiftedMaskBlueL,
        shiftAlpha: maskAlpha !== 0
            ? (x) => (((x & maskAlpha) / maskAlphaR) * 0x100) / shiftedMaskAlphaL
            : () => 255,
    };
}

var BmpCompression;
(function (BmpCompression) {
    BmpCompression[BmpCompression["NONE"] = 0] = "NONE";
    BmpCompression[BmpCompression["BI_RLE8"] = 1] = "BI_RLE8";
    BmpCompression[BmpCompression["BI_RLE4"] = 2] = "BI_RLE4";
    BmpCompression[BmpCompression["BI_BIT_FIELDS"] = 3] = "BI_BIT_FIELDS";
    BmpCompression[BmpCompression["BI_ALPHA_BIT_FIELDS"] = 6] = "BI_ALPHA_BIT_FIELDS";
})(BmpCompression || (BmpCompression = {}));

class BmpDecoder {
    // Header
    flag;
    fileSize;
    reserved1;
    reserved2;
    offset;
    headerSize;
    width;
    height;
    planes;
    bitPP;
    compression;
    rawSize;
    hr;
    vr;
    colors;
    importantColors;
    palette;
    data;
    maskRed;
    maskGreen;
    maskBlue;
    maskAlpha;
    toRGBA;
    pos;
    bottomUp;
    buffer;
    locRed;
    locGreen;
    locBlue;
    locAlpha;
    shiftRed;
    shiftGreen;
    shiftBlue;
    shiftAlpha;
    constructor(buffer, { toRGBA } = { toRGBA: false }) {
        this.buffer = buffer;
        this.toRGBA = !!toRGBA;
        this.pos = 0;
        this.bottomUp = true;
        this.flag = this.buffer.toString('utf-8', 0, (this.pos += 2));
        if (this.flag !== 'BM') {
            throw new Error('Invalid BMP File');
        }
        this.locRed = this.toRGBA ? 0 : 3;
        this.locGreen = this.toRGBA ? 1 : 2;
        this.locBlue = this.toRGBA ? 2 : 1;
        this.locAlpha = this.toRGBA ? 3 : 0;
        this.parseHeader();
        this.parseRGBA();
    }
    parseHeader() {
        this.fileSize = this.readUInt32LE();
        this.reserved1 = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.reserved2 = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.offset = this.readUInt32LE();
        // End of BITMAP_FILE_HEADER
        this.headerSize = this.readUInt32LE();
        if (!(this.headerSize in HeaderTypes)) {
            throw new Error(`Unsupported BMP header size ${this.headerSize}`);
        }
        this.width = this.readUInt32LE();
        this.height = this.readUInt32LE();
        // negative value are possible here => implies bottom down
        this.height =
            this.height > 0x7fffffff ? this.height - 0x100000000 : this.height;
        this.planes = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.bitPP = this.buffer.readUInt16LE(this.pos);
        this.pos += 2;
        this.compression = this.readUInt32LE();
        this.rawSize = this.readUInt32LE();
        this.hr = this.readUInt32LE();
        this.vr = this.readUInt32LE();
        this.colors = this.readUInt32LE();
        this.importantColors = this.readUInt32LE();
        // De facto defaults
        if (this.bitPP === 32) {
            this.maskAlpha = 0;
            this.maskRed = 0x00ff0000;
            this.maskGreen = 0x0000ff00;
            this.maskBlue = 0x000000ff;
        }
        else if (this.bitPP === 16) {
            this.maskAlpha = 0;
            this.maskRed = 0x7c00;
            this.maskGreen = 0x03e0;
            this.maskBlue = 0x001f;
        }
        // End of BITMAP_INFO_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_INFO_HEADER ||
            this.compression === BmpCompression.BI_BIT_FIELDS ||
            this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
            this.maskRed = this.readUInt32LE();
            this.maskGreen = this.readUInt32LE();
            this.maskBlue = this.readUInt32LE();
        }
        // End of BITMAP_V2_INFO_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_V2_INFO_HEADER ||
            this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) {
            this.maskAlpha = this.readUInt32LE();
        }
        // End of BITMAP_V3_INFO_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_V3_INFO_HEADER) {
            this.pos +=
                HeaderTypes.BITMAP_V4_HEADER - HeaderTypes.BITMAP_V3_INFO_HEADER;
        }
        // End of BITMAP_V4_HEADER
        if (this.headerSize > HeaderTypes.BITMAP_V4_HEADER) {
            this.pos += HeaderTypes.BITMAP_V5_HEADER - HeaderTypes.BITMAP_V4_HEADER;
        }
        // End of BITMAP_V5_HEADER
        if (this.bitPP <= 8 || this.colors > 0) {
            const len = this.colors === 0 ? 1 << this.bitPP : this.colors;
            this.palette = new Array(len);
            for (let i = 0; i < len; i++) {
                const blue = this.buffer.readUInt8(this.pos++);
                const green = this.buffer.readUInt8(this.pos++);
                const red = this.buffer.readUInt8(this.pos++);
                const quad = this.buffer.readUInt8(this.pos++);
                this.palette[i] = {
                    red,
                    green,
                    blue,
                    quad,
                };
            }
        }
        // End of color table
        // Can the height ever be negative?
        if (this.height < 0) {
            this.height *= -1;
            this.bottomUp = false;
        }
        const coloShift = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
        this.shiftRed = coloShift.shiftRed;
        this.shiftGreen = coloShift.shiftGreen;
        this.shiftBlue = coloShift.shiftBlue;
        this.shiftAlpha = coloShift.shiftAlpha;
    }
    parseRGBA() {
        this.data = Buffer.alloc(this.width * this.height * 4);
        switch (this.bitPP) {
            case 1:
                this.bit1();
                break;
            case 4:
                this.bit4();
                break;
            case 8:
                this.bit8();
                break;
            case 16:
                this.bit16();
                break;
            case 24:
                this.bit24();
                break;
            default:
                this.bit32();
        }
    }
    bit1() {
        const xLen = Math.ceil(this.width / 8);
        const mode = xLen % 4;
        const padding = mode !== 0 ? 4 - mode : 0;
        this.scanImage(padding, xLen, (x, line) => {
            const b = this.buffer.readUInt8(this.pos++);
            const location = line * this.width * 4 + x * 8 * 4;
            for (let i = 0; i < 8; i++) {
                if (x * 8 + i < this.width) {
                    const rgb = this.palette[(b >> (7 - i)) & 0x1];
                    this.data[location + i * this.locAlpha] = 0;
                    this.data[location + i * 4 + this.locBlue] = rgb.blue;
                    this.data[location + i * 4 + this.locGreen] = rgb.green;
                    this.data[location + i * 4 + this.locRed] = rgb.red;
                }
                else {
                    break;
                }
            }
        });
    }
    bit4() {
        if (this.compression === BmpCompression.BI_RLE4) {
            this.data.fill(0);
            let lowNibble = false; //for all count of pixel
            let lines = this.bottomUp ? this.height - 1 : 0;
            let location = 0;
            while (location < this.data.length) {
                const a = this.buffer.readUInt8(this.pos++);
                const b = this.buffer.readUInt8(this.pos++);
                //absolute mode
                if (a === 0) {
                    if (b === 0) {
                        //line end
                        lines += this.bottomUp ? -1 : 1;
                        location = lines * this.width * 4;
                        lowNibble = false;
                        continue;
                    }
                    if (b === 1) {
                        // image end
                        break;
                    }
                    if (b === 2) {
                        // offset x, y
                        const x = this.buffer.readUInt8(this.pos++);
                        const y = this.buffer.readUInt8(this.pos++);
                        lines += this.bottomUp ? -y : y;
                        location += y * this.width * 4 + x * 4;
                    }
                    else {
                        let c = this.buffer.readUInt8(this.pos++);
                        for (let i = 0; i < b; i++) {
                            location = this.setPixelData(location, lowNibble ? c & 0x0f : (c & 0xf0) >> 4);
                            if (i & 1 && i + 1 < b) {
                                c = this.buffer.readUInt8(this.pos++);
                            }
                            lowNibble = !lowNibble;
                        }
                        if ((((b + 1) >> 1) & 1) === 1) {
                            this.pos++;
                        }
                    }
                }
                else {
                    //encoded mode
                    for (let i = 0; i < a; i++) {
                        location = this.setPixelData(location, lowNibble ? b & 0x0f : (b & 0xf0) >> 4);
                        lowNibble = !lowNibble;
                    }
                }
            }
        }
        else {
            const xLen = Math.ceil(this.width / 2);
            const mode = xLen % 4;
            const padding = mode !== 0 ? 4 - mode : 0;
            this.scanImage(padding, xLen, (x, line) => {
                const b = this.buffer.readUInt8(this.pos++);
                const location = line * this.width * 4 + x * 2 * 4;
                const first4 = b >> 4;
                let rgb = this.palette[first4];
                this.data[location] = 0;
                this.data[location + 1] = rgb.blue;
                this.data[location + 2] = rgb.green;
                this.data[location + 3] = rgb.red;
                if (x * 2 + 1 >= this.width) {
                    // throw new Error('Something');
                    return false;
                }
                const last4 = b & 0x0f;
                rgb = this.palette[last4];
                this.data[location + 4] = 0;
                this.data[location + 4 + 1] = rgb.blue;
                this.data[location + 4 + 2] = rgb.green;
                this.data[location + 4 + 3] = rgb.red;
            });
        }
    }
    bit8() {
        if (this.compression === BmpCompression.BI_RLE8) {
            this.data.fill(0);
            let lines = this.bottomUp ? this.height - 1 : 0;
            let location = 0;
            while (location < this.data.length) {
                const a = this.buffer.readUInt8(this.pos++);
                const b = this.buffer.readUInt8(this.pos++);
                //absolute mode
                if (a === 0) {
                    if (b === 0) {
                        //line end
                        lines += this.bottomUp ? -1 : 1;
                        location = lines * this.width * 4;
                        continue;
                    }
                    if (b === 1) {
                        //image end
                        break;
                    }
                    if (b === 2) {
                        //offset x,y
                        const x = this.buffer.readUInt8(this.pos++);
                        const y = this.buffer.readUInt8(this.pos++);
                        lines += this.bottomUp ? -y : y;
                        location += y * this.width * 4 + x * 4;
                    }
                    else {
                        for (let i = 0; i < b; i++) {
                            const c = this.buffer.readUInt8(this.pos++);
                            location = this.setPixelData(location, c);
                        }
                        // @ts-ignore
                        const shouldIncrement = b & (1 === 1);
                        if (shouldIncrement) {
                            this.pos++;
                        }
                    }
                }
                else {
                    //encoded mode
                    for (let i = 0; i < a; i++) {
                        location = this.setPixelData(location, b);
                    }
                }
            }
        }
        else {
            const mode = this.width % 4;
            const padding = mode !== 0 ? 4 - mode : 0;
            this.scanImage(padding, this.width, (x, line) => {
                const b = this.buffer.readUInt8(this.pos++);
                const location = line * this.width * 4 + x * 4;
                if (b < this.palette.length) {
                    const rgb = this.palette[b];
                    this.data[location] = 0;
                    this.data[location + 1] = rgb.blue;
                    this.data[location + 2] = rgb.green;
                    this.data[location + 3] = rgb.red;
                }
                else {
                    this.data[location] = 0;
                    this.data[location + 1] = 0xff;
                    this.data[location + 2] = 0xff;
                    this.data[location + 3] = 0xff;
                }
            });
        }
    }
    bit16() {
        const padding = (this.width % 2) * 2;
        this.scanImage(padding, this.width, (x, line) => {
            const loc = line * this.width * 4 + x * 4;
            const px = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            this.data[loc + this.locRed] = this.shiftRed(px);
            this.data[loc + this.locGreen] = this.shiftGreen(px);
            this.data[loc + this.locBlue] = this.shiftBlue(px);
            this.data[loc + this.locAlpha] = this.shiftAlpha(px);
        });
    }
    bit24() {
        const padding = this.width % 4;
        this.scanImage(padding, this.width, (x, line) => {
            const loc = line * this.width * 4 + x * 4;
            const blue = this.buffer.readUInt8(this.pos++);
            const green = this.buffer.readUInt8(this.pos++);
            const red = this.buffer.readUInt8(this.pos++);
            this.data[loc + this.locRed] = red;
            this.data[loc + this.locGreen] = green;
            this.data[loc + this.locBlue] = blue;
            this.data[loc + this.locAlpha] = 0;
        });
    }
    bit32() {
        this.scanImage(0, this.width, (x, line) => {
            const loc = line * this.width * 4 + x * 4;
            const px = this.readUInt32LE();
            this.data[loc + this.locRed] = this.shiftRed(px);
            this.data[loc + this.locGreen] = this.shiftGreen(px);
            this.data[loc + this.locBlue] = this.shiftBlue(px);
            this.data[loc + this.locAlpha] = this.shiftAlpha(px);
        });
    }
    scanImage(padding = 0, width = this.width, processPixel) {
        for (let y = this.height - 1; y >= 0; y--) {
            const line = this.bottomUp ? y : this.height - 1 - y;
            for (let x = 0; x < width; x++) {
                const result = processPixel.call(this, x, line);
                if (result === false) {
                    return;
                }
            }
            this.pos += padding;
        }
    }
    readUInt32LE() {
        const value = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        return value;
    }
    setPixelData(location, rgbIndex) {
        const { blue, green, red } = this.palette[rgbIndex];
        this.data[location + this.locAlpha] = 0;
        this.data[location + 1 + this.locBlue] = blue;
        this.data[location + 2 + this.locGreen] = green;
        this.data[location + 3 + this.locRed] = red;
        return location + 4;
    }
}

function createInteger(numbers) {
    return numbers.reduce((final, n) => (final << 1) | n, 0);
}
function createColor(color) {
    return ((color.quad << 24) | (color.red << 16) | (color.green << 8) | color.blue);
}
class BmpEncoder {
    fileSize;
    reserved1;
    reserved2;
    offset;
    width;
    flag;
    height;
    planes;
    bitPP;
    compress;
    hr;
    vr;
    colors;
    importantColors;
    rawSize;
    headerSize;
    data;
    palette;
    extraBytes;
    buffer;
    bytesInColor;
    pos;
    constructor(imgData) {
        this.buffer = imgData.data;
        this.width = imgData.width;
        this.height = imgData.height;
        this.headerSize = HeaderTypes.BITMAP_INFO_HEADER;
        // Header
        this.flag = 'BM';
        this.bitPP = imgData.bitPP || 24;
        this.offset = 54;
        this.reserved1 = imgData.reserved1 || 0;
        this.reserved2 = imgData.reserved2 || 0;
        this.planes = 1;
        this.compress = 0;
        this.hr = imgData.hr || 0;
        this.vr = imgData.vr || 0;
        this.importantColors = imgData.importantColors || 0;
        this.colors = Math.min(2 ** (this.bitPP - 1 || 1), imgData.colors || Infinity);
        this.palette = imgData.palette || [];
        if (this.colors && this.bitPP < 16) {
            this.offset += this.colors * 4;
        }
        else {
            this.colors = 0;
        }
        switch (this.bitPP) {
            case 32:
                this.bytesInColor = 4;
                break;
            case 16:
                this.bytesInColor = 2;
                break;
            case 8:
                this.bytesInColor = 1;
                break;
            case 4:
                this.bytesInColor = 1 / 2;
                break;
            case 1:
                this.bytesInColor = 1 / 8;
                break;
            default:
                this.bytesInColor = 3;
                this.bitPP = 24;
        }
        const rowWidth = (this.width * this.bitPP) / 32;
        const rowBytes = Math.ceil(rowWidth);
        this.extraBytes = (rowBytes - rowWidth) * 4;
        // Why 2?
        this.rawSize = this.height * rowBytes * 4 + 2;
        this.fileSize = this.rawSize + this.offset;
        this.data = Buffer.alloc(this.fileSize, 0x1);
        this.pos = 0;
        this.encode();
    }
    encode() {
        this.pos = 0;
        this.writeHeader();
        switch (this.bitPP) {
            case 32:
                this.bit32();
                break;
            case 16:
                this.bit16();
                break;
            case 8:
                this.bit8();
                break;
            case 4:
                this.bit4();
                break;
            case 1:
                this.bit1();
                break;
            default:
                this.bit24();
        }
    }
    writeHeader() {
        this.data.write(this.flag, this.pos, 2);
        this.pos += 2;
        this.writeUInt32LE(this.fileSize);
        // Writing 2 UInt16LE resulted in a weird bug
        this.writeUInt32LE((this.reserved1 << 16) | this.reserved2);
        this.writeUInt32LE(this.offset);
        this.writeUInt32LE(this.headerSize);
        this.writeUInt32LE(this.width);
        this.writeUInt32LE(this.height);
        this.data.writeUInt16LE(this.planes, this.pos);
        this.pos += 2;
        this.data.writeUInt16LE(this.bitPP, this.pos);
        this.pos += 2;
        this.writeUInt32LE(this.compress);
        this.writeUInt32LE(this.rawSize);
        this.writeUInt32LE(this.hr);
        this.writeUInt32LE(this.vr);
        this.writeUInt32LE(this.colors);
        this.writeUInt32LE(this.importantColors);
    }
    bit1() {
        if (this.palette.length && this.colors === 2) {
            this.initColors(1);
        }
        else {
            this.writeUInt32LE(0x00ffffff); // Black
            this.writeUInt32LE(0x00000000); // White
        }
        this.pos += 1; // ?
        let lineArr = [];
        this.writeImage((p, index, x) => {
            let i = index;
            i++;
            const b = this.buffer[i++];
            const g = this.buffer[i++];
            const r = this.buffer[i++];
            const brightness = r * 0.2126 + g * 0.7152 + b * 0.0722;
            lineArr.push(brightness > 127 ? 0 : 1);
            if ((x + 1) % 8 === 0) {
                this.data[p - 1] = createInteger(lineArr);
                lineArr = [];
            }
            else if (x === this.width - 1 && lineArr.length > 0) {
                this.data[p - 1] = createInteger(lineArr) << 4;
                lineArr = [];
            }
            return i;
        });
    }
    bit4() {
        const colors = this.initColors(4);
        let integerPair = [];
        this.writeImage((p, index, x) => {
            let i = index;
            const colorInt = createColor({
                quad: this.buffer[i++],
                blue: this.buffer[i++],
                green: this.buffer[i++],
                red: this.buffer[i++],
            });
            const colorExists = colors.findIndex((c) => c === colorInt);
            if (colorExists !== -1) {
                integerPair.push(colorExists);
            }
            else {
                integerPair.push(0);
            }
            if ((x + 1) % 2 === 0) {
                this.data[p] = (integerPair[0] << 4) | integerPair[1];
                integerPair = [];
            }
            return i;
        });
    }
    bit8() {
        const colors = this.initColors(8);
        this.writeImage((p, index) => {
            let i = index;
            const colorInt = createColor({
                quad: this.buffer[i++],
                blue: this.buffer[i++],
                green: this.buffer[i++],
                red: this.buffer[i++],
            });
            const colorExists = colors.findIndex((c) => c === colorInt);
            if (colorExists !== -1) {
                this.data[p] = colorExists;
            }
            else {
                this.data[p] = 0;
            }
            return i;
        });
    }
    bit16() {
        this.writeImage((p, index) => {
            let i = index + 1;
            const b = this.buffer[i++] / 8; // b
            const g = this.buffer[i++] / 8; // g
            const r = this.buffer[i++] / 8; // r
            const color = (r << 10) | (g << 5) | b;
            this.data[p] = color & 0x00ff;
            this.data[p + 1] = (color & 0xff00) >> 8;
            return i;
        });
    }
    bit24() {
        this.writeImage((p, index) => {
            let i = index + 1;
            this.data[p] = this.buffer[i++]; //b
            this.data[p + 1] = this.buffer[i++]; //g
            this.data[p + 2] = this.buffer[i++]; //r
            return i;
        });
    }
    bit32() {
        this.writeImage((p, index) => {
            let i = index;
            this.data[p + 3] = this.buffer[i++]; // a
            this.data[p] = this.buffer[i++]; // b
            this.data[p + 1] = this.buffer[i++]; // g
            this.data[p + 2] = this.buffer[i++]; // r
            return i;
        });
    }
    writeImage(writePixel) {
        const rowBytes = this.extraBytes + this.width * this.bytesInColor;
        let i = 0;
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const p = Math.floor(this.pos + (this.height - 1 - y) * rowBytes + x * this.bytesInColor);
                i = writePixel.call(this, p, i, x, y);
            }
        }
    }
    initColors(bit) {
        const colors = [];
        if (this.palette.length) {
            for (let i = 0; i < this.colors; i++) {
                const rootColor = createColor(this.palette[i]);
                this.writeUInt32LE(rootColor);
                colors.push(rootColor);
            }
        }
        else {
            throw new Error(`To encode ${bit}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
        }
        return colors;
    }
    writeUInt32LE(value) {
        this.data.writeUInt32LE(value, this.pos);
        this.pos += 4;
    }
}

function decode$1(bmpData, options) {
    return new BmpDecoder(bmpData, options);
}
function encode$1(imgData) {
    return new BmpEncoder(imgData);
}

// This file is autogenerated. It's used to publish ESM to npm.
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};

  // If input is already a tinycolor, return itself
  if (color instanceof tinycolor) {
    return color;
  }
  // If we are called as a function, call using new instead
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;

  // Don't let the range of [0,255] come back in [0,1].
  // Potentially lose a little bit of precision here, but will fix issues where
  // .5 gets interpreted as half of the total, instead of half of 1
  // If it was supposed to be 128, this was already taken care of by `inputToRgb`
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    //http://www.w3.org/TR/AERT#color-contrast
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  },
  getLuminance: function getLuminance() {
    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360),
      s = Math.round(hsv.s * 100),
      v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360),
      s = Math.round(hsl.s * 100),
      l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      // Special case for "transparent", all other non-alpha formats
      // will return rgba when there is transparency.
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function (color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a
  };
}

// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    l: l
  };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    v: v
  };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h),
    f = h - i,
    p = v * (1 - s),
    q = v * (1 - f * s),
    t = v * (1 - (1 - f) * s),
    mod = i % 6,
    r = [v, q, p, p, t, v][mod],
    g = [t, v, v, q, p, p][mod],
    b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];

  // Return a 3 character hex if possible
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];

  // Return a 4 character hex if possible
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function () {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};

// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h,
    s = hsv.s,
    v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h,
      s: s,
      v: v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function (color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};

// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function (color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function (color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function (baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level: level,
    size: size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};

// Big List of Colors
// ------------------
// <https://www.w3.org/TR/css-color-4/#named-colors>
var names$1 = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names$1);

// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));

  // Automatically convert percentage into number
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }

  // Handle floating point rounding errors
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }

  // Convert into [0, 1] range if it isn't already
  return n % max / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
  return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function () {
  // <http://www.w3.org/TR/css3-values/#integers>
  var CSS_INTEGER = "[-\\+]?\\d+%?";

  // <http://www.w3.org/TR/css3-values/#number-value>
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

  // Actual matching.
  // Parentheses and commas are optional, but not required.
  // Whitespace can take the place of commas or opening paren
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names$1[color]) {
    color = names$1[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }

  // Try to match string input using regular expressions.
  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
  // Just return an object and let the conversion functions handle that.
  // This way the result will be the same whether the tinycolor is initialized with string or object.
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  // return valid WCAG2 parms for isReadable.
  // If input parms are invalid, return {"level":"AA", "size":"small"}
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level: level,
    size: size
  };
}

function clone(image) {
    const newBitmap = {
        width: image.bitmap.width,
        height: image.bitmap.height,
        data: Buffer.from(image.bitmap.data),
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new image.constructor(newBitmap);
}
function scan(image, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
xArg, yArg, wArg, hArg, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
cbArg) {
    let x;
    let y;
    let w;
    let h;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let cb;
    if (typeof xArg === "function") {
        cb = xArg;
        x = 0;
        y = 0;
        w = image.bitmap.width;
        h = image.bitmap.height;
    }
    else {
        x = xArg;
        if (typeof yArg !== "number")
            throw new Error("y must be a number");
        y = yArg;
        if (typeof wArg !== "number")
            throw new Error("w must be a number");
        w = wArg;
        if (typeof hArg !== "number")
            throw new Error("h must be a number");
        h = hArg;
        if (typeof cbArg !== "function")
            throw new Error("cb must be a function");
        cb = cbArg;
    }
    // round input
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    const bound = cb.bind(image);
    for (let _y = y; _y < y + h; _y++) {
        for (let _x = x; _x < x + w; _x++) {
            const idx = (image.bitmap.width * _y + _x) << 2;
            // Bind the images so this.bitmap works
            bound(_x, _y, idx);
        }
    }
    return image;
}
function* scanIterator(image, x, y, w, h) {
    // round input
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    for (let _y = y; _y < y + h; _y++) {
        for (let _x = x; _x < x + w; _x++) {
            const idx = (image.bitmap.width * _y + _x) << 2;
            yield { x: _x, y: _y, idx, image };
        }
    }
}
/**
 * A helper method that converts RGBA values to a single integer value
 * @param i A single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)
 * @returns An object with the properties r, g, b and a representing RGBA values
 * @example
 * ```ts
 * import { intToRGBA } from "@jimp/utils";
 *
 * intToRGBA(0xFF0000FF); // { r: 255, g: 0, b: 0, a:255 }
 * ```
 */
function intToRGBA$1(i) {
    if (typeof i !== "number") {
        throw new Error("i must be a number");
    }
    const rgba = {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
    };
    rgba.r = Math.floor(i / Math.pow(256, 3));
    rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
    rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /
        Math.pow(256, 1));
    rgba.a = Math.floor((i -
        rgba.r * Math.pow(256, 3) -
        rgba.g * Math.pow(256, 2) -
        rgba.b * Math.pow(256, 1)) /
        Math.pow(256, 0));
    return rgba;
}
/**
 * Compute color difference
 * 0 means no difference, 1 means maximum difference.
 * Both parameters must be an color object `{ r:val, g:val, b:val, a:val }`
 * Where `a` is optional and `val` is an integer between 0 and 255.
 * @param rgba1 first color to compare.
 * @param rgba2 second color to compare.
 * @returns float between 0 and 1.
 * @example
 * ```ts
 * import { colorDiff } from "@jimp/utils";
 *
 * colorDiff(
 *  { r: 255, g: 0, b: 0, a: 0 },
 *  { r: 0, g: 255, b: 0, a: 0 },
 * ); // 0.5
 *
 * colorDiff(
 *  { r: 0, g: 0, b: 0, },
 *  { r: 255, g: 255, b: 255, }
 * ); // 0.7
 * ```
 */
function colorDiff(rgba1, rgba2) {
    const sq = (n) => Math.pow(n, 2);
    const { max } = Math;
    const maxVal = 255 * 255 * 3;
    const rgba1A = "a" in rgba1 ? rgba1.a : 255;
    const rgba2A = "a" in rgba2 ? rgba2.a : 255;
    return ((max(sq(rgba1.r - rgba2.r), sq(rgba1.r - rgba2.r - rgba1A + rgba2A)) +
        max(sq(rgba1.g - rgba2.g), sq(rgba1.g - rgba2.g - rgba1A + rgba2A)) +
        max(sq(rgba1.b - rgba2.b), sq(rgba1.b - rgba2.b - rgba1A + rgba2A))) /
        maxVal);
}
/**
 * Limits a number to between 0 or 255
 * @example
 * ```ts
 * import { limit255 } from "@jimp/utils";
 *
 * limit255(256); // 255
 * limit255(-1); // 0
 * ```
 */
function limit255(n) {
    n = Math.max(n, 0);
    n = Math.min(n, 255);
    return n;
}
/**
 * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number
 * @returns A hex number representing a color
 * @example
 * ```ts
 * import { cssColorToHex } from "@jimp/utils";
 *
 * cssColorToHex("rgba(255, 0, 0, 0.5)"); // "ff000080"
 * ```
 */
function cssColorToHex(cssColor) {
    if (typeof cssColor === "number") {
        return cssColor;
    }
    return parseInt(tinycolor(cssColor).toHex8(), 16);
}

function encode(image, options = {}) {
    scan({ bitmap: image }, 0, 0, image.width, image.height, function (_, __, index) {
        const red = image.data[index + 0];
        const green = image.data[index + 1];
        const blue = image.data[index + 2];
        const alpha = image.data[index + 3];
        image.data[index + 0] = alpha;
        image.data[index + 1] = blue;
        image.data[index + 2] = green;
        image.data[index + 3] = red;
    });
    return encode$1({ ...image, ...options }).data;
}
function decode(data, options) {
    const result = decode$1(data, options);
    scan({ bitmap: result }, 0, 0, result.width, result.height, function (_, __, index) {
        // const alpha = result.data[index + 0]!;
        const blue = result.data[index + 1];
        const green = result.data[index + 2];
        const red = result.data[index + 3];
        result.data[index + 0] = red;
        result.data[index + 1] = green;
        result.data[index + 2] = blue;
        result.data[index + 3] = 0xff;
    });
    return result;
}
function msBmp() {
    return {
        mime: "image/x-ms-bmp",
        encode,
        decode,
    };
}
function bmp() {
    return {
        mime: "image/bmp",
        encode,
        decode,
    };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var omggif = {};

var hasRequiredOmggif;

function requireOmggif () {
	if (hasRequiredOmggif) return omggif;
	hasRequiredOmggif = 1;

	function GifWriter(buf, width, height, gopts) {
	  var p = 0;

	  var gopts = gopts === undefined ? { } : gopts;
	  var loop_count = gopts.loop === undefined ? null : gopts.loop;
	  var global_palette = gopts.palette === undefined ? null : gopts.palette;

	  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
	    throw new Error("Width/Height invalid.");

	  function check_palette_and_num_colors(palette) {
	    var num_colors = palette.length;
	    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
	      throw new Error(
	          "Invalid code/color length, must be power of 2 and 2 .. 256.");
	    }
	    return num_colors;
	  }

	  // - Header.
	  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
	  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

	  // Handling of Global Color Table (palette) and background index.
	  var gp_num_colors_pow2 = 0;
	  var background = 0;
	  if (global_palette !== null) {
	    var gp_num_colors = check_palette_and_num_colors(global_palette);
	    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
	    gp_num_colors = 1 << gp_num_colors_pow2;
	    --gp_num_colors_pow2;
	    if (gopts.background !== undefined) {
	      background = gopts.background;
	      if (background >= gp_num_colors)
	        throw new Error("Background index out of range.");
	      // The GIF spec states that a background index of 0 should be ignored, so
	      // this is probably a mistake and you really want to set it to another
	      // slot in the palette.  But actually in the end most browsers, etc end
	      // up ignoring this almost completely (including for dispose background).
	      if (background === 0)
	        throw new Error("Background index explicitly passed as 0.");
	    }
	  }

	  // - Logical Screen Descriptor.
	  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
	  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
	  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
	  // NOTE: Indicates 0-bpp original color resolution (unused?).
	  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
	             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
	  buf[p++] = background;  // Background Color Index.
	  buf[p++] = 0;  // Pixel aspect ratio (unused?).

	  // - Global Color Table
	  if (global_palette !== null) {
	    for (var i = 0, il = global_palette.length; i < il; ++i) {
	      var rgb = global_palette[i];
	      buf[p++] = rgb >> 16 & 0xff;
	      buf[p++] = rgb >> 8 & 0xff;
	      buf[p++] = rgb & 0xff;
	    }
	  }

	  if (loop_count !== null) {  // Netscape block for looping.
	    if (loop_count < 0 || loop_count > 65535)
	      throw new Error("Loop count invalid.")
	    // Extension code, label, and length.
	    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
	    // NETSCAPE2.0
	    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
	    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
	    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
	    // Sub-block
	    buf[p++] = 0x03; buf[p++] = 0x01;
	    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
	    buf[p++] = 0x00;  // Terminator.
	  }


	  var ended = false;

	  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
	    if (ended === true) { --p; ended = false; }  // Un-end.

	    opts = opts === undefined ? { } : opts;

	    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
	    // canvas width/height, I imagine?
	    if (x < 0 || y < 0 || x > 65535 || y > 65535)
	      throw new Error("x/y invalid.")

	    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
	      throw new Error("Width/Height invalid.")

	    if (indexed_pixels.length < w * h)
	      throw new Error("Not enough pixels for the frame size.");

	    var using_local_palette = true;
	    var palette = opts.palette;
	    if (palette === undefined || palette === null) {
	      using_local_palette = false;
	      palette = global_palette;
	    }

	    if (palette === undefined || palette === null)
	      throw new Error("Must supply either a local or global palette.");

	    var num_colors = check_palette_and_num_colors(palette);

	    // Compute the min_code_size (power of 2), destroying num_colors.
	    var min_code_size = 0;
	    while (num_colors >>= 1) ++min_code_size;
	    num_colors = 1 << min_code_size;  // Now we can easily get it back.

	    var delay = opts.delay === undefined ? 0 : opts.delay;

	    // From the spec:
	    //     0 -   No disposal specified. The decoder is
	    //           not required to take any action.
	    //     1 -   Do not dispose. The graphic is to be left
	    //           in place.
	    //     2 -   Restore to background color. The area used by the
	    //           graphic must be restored to the background color.
	    //     3 -   Restore to previous. The decoder is required to
	    //           restore the area overwritten by the graphic with
	    //           what was there prior to rendering the graphic.
	    //  4-7 -    To be defined.
	    // NOTE(deanm): Dispose background doesn't really work, apparently most
	    // browsers ignore the background palette index and clear to transparency.
	    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
	    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
	      throw new Error("Disposal out of range.");

	    var use_transparency = false;
	    var transparent_index = 0;
	    if (opts.transparent !== undefined && opts.transparent !== null) {
	      use_transparency = true;
	      transparent_index = opts.transparent;
	      if (transparent_index < 0 || transparent_index >= num_colors)
	        throw new Error("Transparent color index.");
	    }

	    if (disposal !== 0 || use_transparency || delay !== 0) {
	      // - Graphics Control Extension
	      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
	      buf[p++] = 4;  // Byte size.

	      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
	      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
	      buf[p++] = transparent_index;  // Transparent color index.
	      buf[p++] = 0;  // Block Terminator.
	    }

	    // - Image Descriptor
	    buf[p++] = 0x2c;  // Image Seperator.
	    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
	    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
	    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
	    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
	    // NOTE: No sort flag (unused?).
	    // TODO(deanm): Support interlace.
	    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

	    // - Local Color Table
	    if (using_local_palette === true) {
	      for (var i = 0, il = palette.length; i < il; ++i) {
	        var rgb = palette[i];
	        buf[p++] = rgb >> 16 & 0xff;
	        buf[p++] = rgb >> 8 & 0xff;
	        buf[p++] = rgb & 0xff;
	      }
	    }

	    p = GifWriterOutputLZWCodeStream(
	            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

	    return p;
	  };

	  this.end = function() {
	    if (ended === false) {
	      buf[p++] = 0x3b;  // Trailer.
	      ended = true;
	    }
	    return p;
	  };

	  this.getOutputBuffer = function() { return buf; };
	  this.setOutputBuffer = function(v) { buf = v; };
	  this.getOutputBufferPosition = function() { return p; };
	  this.setOutputBufferPosition = function(v) { p = v; };
	}

	// Main compression routine, palette indexes -> LZW code stream.
	// |index_stream| must have at least one entry.
	function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
	  buf[p++] = min_code_size;
	  var cur_subblock = p++;  // Pointing at the length field.

	  var clear_code = 1 << min_code_size;
	  var code_mask = clear_code - 1;
	  var eoi_code = clear_code + 1;
	  var next_code = eoi_code + 1;

	  var cur_code_size = min_code_size + 1;  // Number of bits per code.
	  var cur_shift = 0;
	  // We have at most 12-bit codes, so we should have to hold a max of 19
	  // bits here (and then we would write out).
	  var cur = 0;

	  function emit_bytes_to_buffer(bit_block_size) {
	    while (cur_shift >= bit_block_size) {
	      buf[p++] = cur & 0xff;
	      cur >>= 8; cur_shift -= 8;
	      if (p === cur_subblock + 256) {  // Finished a subblock.
	        buf[cur_subblock] = 255;
	        cur_subblock = p++;
	      }
	    }
	  }

	  function emit_code(c) {
	    cur |= c << cur_shift;
	    cur_shift += cur_code_size;
	    emit_bytes_to_buffer(8);
	  }

	  // I am not an expert on the topic, and I don't want to write a thesis.
	  // However, it is good to outline here the basic algorithm and the few data
	  // structures and optimizations here that make this implementation fast.
	  // The basic idea behind LZW is to build a table of previously seen runs
	  // addressed by a short id (herein called output code).  All data is
	  // referenced by a code, which represents one or more values from the
	  // original input stream.  All input bytes can be referenced as the same
	  // value as an output code.  So if you didn't want any compression, you
	  // could more or less just output the original bytes as codes (there are
	  // some details to this, but it is the idea).  In order to achieve
	  // compression, values greater then the input range (codes can be up to
	  // 12-bit while input only 8-bit) represent a sequence of previously seen
	  // inputs.  The decompressor is able to build the same mapping while
	  // decoding, so there is always a shared common knowledge between the
	  // encoding and decoder, which is also important for "timing" aspects like
	  // how to handle variable bit width code encoding.
	  //
	  // One obvious but very important consequence of the table system is there
	  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
	  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
	  // can be used for an effecient lookup strategy for the code mapping.  We
	  // need to know if a run has been seen before, and be able to map that run
	  // to the output code.  Since we start with known unique ids (input bytes),
	  // and then from those build more unique ids (table entries), we can
	  // continue this chain (almost like a linked list) to always have small
	  // integer values that represent the current byte chains in the encoder.
	  // This means instead of tracking the input bytes (AAAABCD) to know our
	  // current state, we can track the table entry for AAAABC (it is guaranteed
	  // to exist by the nature of the algorithm) and the next character D.
	  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
	  // unique.  This allows us to create a simple lookup key for mapping input
	  // sequences to codes (table indices) without having to store or search
	  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
	  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
	  // key.  This leads to a integer value at most 20-bits, which can always
	  // fit in an SMI value and be used as a fast sparse array / object key.

	  // Output code for the current contents of the index buffer.
	  var ib_code = index_stream[0] & code_mask;  // Load first input index.
	  var code_table = { };  // Key'd on our 20-bit "tuple".

	  emit_code(clear_code);  // Spec says first code should be a clear code.

	  // First index already loaded, process the rest of the stream.
	  for (var i = 1, il = index_stream.length; i < il; ++i) {
	    var k = index_stream[i] & code_mask;
	    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
	    var cur_code = code_table[cur_key];  // buffer + k.

	    // Check if we have to create a new code table entry.
	    if (cur_code === undefined) {  // We don't have buffer + k.
	      // Emit index buffer (without k).
	      // This is an inline version of emit_code, because this is the core
	      // writing routine of the compressor (and V8 cannot inline emit_code
	      // because it is a closure here in a different context).  Additionally
	      // we can call emit_byte_to_buffer less often, because we can have
	      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
	      // be 12-bits, so can safely have 18-bits there without overflow.
	      // emit_code(ib_code);
	      cur |= ib_code << cur_shift;
	      cur_shift += cur_code_size;
	      while (cur_shift >= 8) {
	        buf[p++] = cur & 0xff;
	        cur >>= 8; cur_shift -= 8;
	        if (p === cur_subblock + 256) {  // Finished a subblock.
	          buf[cur_subblock] = 255;
	          cur_subblock = p++;
	        }
	      }

	      if (next_code === 4096) {  // Table full, need a clear.
	        emit_code(clear_code);
	        next_code = eoi_code + 1;
	        cur_code_size = min_code_size + 1;
	        code_table = { };
	      } else {  // Table not full, insert a new entry.
	        // Increase our variable bit code sizes if necessary.  This is a bit
	        // tricky as it is based on "timing" between the encoding and
	        // decoder.  From the encoders perspective this should happen after
	        // we've already emitted the index buffer and are about to create the
	        // first table entry that would overflow our current code bit size.
	        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
	        code_table[cur_key] = next_code++;  // Insert into code table.
	      }

	      ib_code = k;  // Index buffer to single input k.
	    } else {
	      ib_code = cur_code;  // Index buffer to sequence in code table.
	    }
	  }

	  emit_code(ib_code);  // There will still be something in the index buffer.
	  emit_code(eoi_code);  // End Of Information.

	  // Flush / finalize the sub-blocks stream to the buffer.
	  emit_bytes_to_buffer(1);

	  // Finish the sub-blocks, writing out any unfinished lengths and
	  // terminating with a sub-block of length 0.  If we have already started
	  // but not yet used a sub-block it can just become the terminator.
	  if (cur_subblock + 1 === p) {  // Started but unused.
	    buf[cur_subblock] = 0;
	  } else {  // Started and used, write length and additional terminator block.
	    buf[cur_subblock] = p - cur_subblock - 1;
	    buf[p++] = 0;
	  }
	  return p;
	}

	function GifReader(buf) {
	  var p = 0;

	  // - Header (GIF87a or GIF89a).
	  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
	      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
	    throw new Error("Invalid GIF 87a/89a header.");
	  }

	  // - Logical Screen Descriptor.
	  var width = buf[p++] | buf[p++] << 8;
	  var height = buf[p++] | buf[p++] << 8;
	  var pf0 = buf[p++];  // <Packed Fields>.
	  var global_palette_flag = pf0 >> 7;
	  var num_global_colors_pow2 = pf0 & 0x7;
	  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
	  buf[p++];
	  buf[p++];  // Pixel aspect ratio (unused?).

	  var global_palette_offset = null;
	  var global_palette_size   = null;

	  if (global_palette_flag) {
	    global_palette_offset = p;
	    global_palette_size = num_global_colors;
	    p += num_global_colors * 3;  // Seek past palette.
	  }

	  var no_eof = true;

	  var frames = [ ];

	  var delay = 0;
	  var transparent_index = null;
	  var disposal = 0;  // 0 - No disposal specified.
	  var loop_count = null;

	  this.width = width;
	  this.height = height;

	  while (no_eof && p < buf.length) {
	    switch (buf[p++]) {
	      case 0x21:  // Graphics Control Extension Block
	        switch (buf[p++]) {
	          case 0xff:  // Application specific block
	            // Try if it's a Netscape block (with animation loop counter).
	            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
	                // NETSCAPE2.0
	                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
	                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
	                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
	                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
	                // Sub-block
	                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
	              p += 14;
	              loop_count = buf[p++] | buf[p++] << 8;
	              p++;  // Skip terminator.
	            } else {  // We don't know what it is, just try to get past it.
	              p += 12;
	              while (true) {  // Seek through subblocks.
	                var block_size = buf[p++];
	                // Bad block size (ex: undefined from an out of bounds read).
	                if (!(block_size >= 0)) throw Error("Invalid block size");
	                if (block_size === 0) break;  // 0 size is terminator
	                p += block_size;
	              }
	            }
	            break;

	          case 0xf9:  // Graphics Control Extension
	            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
	              throw new Error("Invalid graphics extension block.");
	            var pf1 = buf[p++];
	            delay = buf[p++] | buf[p++] << 8;
	            transparent_index = buf[p++];
	            if ((pf1 & 1) === 0) transparent_index = null;
	            disposal = pf1 >> 2 & 0x7;
	            p++;  // Skip terminator.
	            break;

	          case 0xfe:  // Comment Extension.
	            while (true) {  // Seek through subblocks.
	              var block_size = buf[p++];
	              // Bad block size (ex: undefined from an out of bounds read).
	              if (!(block_size >= 0)) throw Error("Invalid block size");
	              if (block_size === 0) break;  // 0 size is terminator
	              // console.log(buf.slice(p, p+block_size).toString('ascii'));
	              p += block_size;
	            }
	            break;

	          default:
	            throw new Error(
	                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
	        }
	        break;

	      case 0x2c:  // Image Descriptor.
	        var x = buf[p++] | buf[p++] << 8;
	        var y = buf[p++] | buf[p++] << 8;
	        var w = buf[p++] | buf[p++] << 8;
	        var h = buf[p++] | buf[p++] << 8;
	        var pf2 = buf[p++];
	        var local_palette_flag = pf2 >> 7;
	        var interlace_flag = pf2 >> 6 & 1;
	        var num_local_colors_pow2 = pf2 & 0x7;
	        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
	        var palette_offset = global_palette_offset;
	        var palette_size = global_palette_size;
	        var has_local_palette = false;
	        if (local_palette_flag) {
	          var has_local_palette = true;
	          palette_offset = p;  // Override with local palette.
	          palette_size = num_local_colors;
	          p += num_local_colors * 3;  // Seek past palette.
	        }

	        var data_offset = p;

	        p++;  // codesize
	        while (true) {
	          var block_size = buf[p++];
	          // Bad block size (ex: undefined from an out of bounds read).
	          if (!(block_size >= 0)) throw Error("Invalid block size");
	          if (block_size === 0) break;  // 0 size is terminator
	          p += block_size;
	        }

	        frames.push({x: x, y: y, width: w, height: h,
	                     has_local_palette: has_local_palette,
	                     palette_offset: palette_offset,
	                     palette_size: palette_size,
	                     data_offset: data_offset,
	                     data_length: p - data_offset,
	                     transparent_index: transparent_index,
	                     interlaced: !!interlace_flag,
	                     delay: delay,
	                     disposal: disposal});
	        break;

	      case 0x3b:  // Trailer Marker (end of file).
	        no_eof = false;
	        break;

	      default:
	        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
	    }
	  }

	  this.numFrames = function() {
	    return frames.length;
	  };

	  this.loopCount = function() {
	    return loop_count;
	  };

	  this.frameInfo = function(frame_num) {
	    if (frame_num < 0 || frame_num >= frames.length)
	      throw new Error("Frame index out of range.");
	    return frames[frame_num];
	  };

	  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
	    var frame = this.frameInfo(frame_num);
	    var num_pixels = frame.width * frame.height;
	    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
	    GifReaderLZWOutputIndexStream(
	        buf, frame.data_offset, index_stream, num_pixels);
	    var palette_offset = frame.palette_offset;

	    // NOTE(deanm): It seems to be much faster to compare index to 256 than
	    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
	    // the profile, not sure if it's related to using a Uint8Array.
	    var trans = frame.transparent_index;
	    if (trans === null) trans = 256;

	    // We are possibly just blitting to a portion of the entire frame.
	    // That is a subrect within the framerect, so the additional pixels
	    // must be skipped over after we finished a scanline.
	    var framewidth  = frame.width;
	    var framestride = width - framewidth;
	    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

	    // Output indicies of the top left and bottom right corners of the subrect.
	    var opbeg = ((frame.y * width) + frame.x) * 4;
	    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
	    var op    = opbeg;

	    var scanstride = framestride * 4;

	    // Use scanstride to skip past the rows when interlacing.  This is skipping
	    // 7 rows for the first two passes, then 3 then 1.
	    if (frame.interlaced === true) {
	      scanstride += width * 4 * 7;  // Pass 1.
	    }

	    var interlaceskip = 8;  // Tracking the row interval in the current pass.

	    for (var i = 0, il = index_stream.length; i < il; ++i) {
	      var index = index_stream[i];

	      if (xleft === 0) {  // Beginning of new scan line
	        op += scanstride;
	        xleft = framewidth;
	        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
	          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
	          // interlaceskip / 2 * 4 is interlaceskip << 1.
	          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
	          interlaceskip >>= 1;
	        }
	      }

	      if (index === trans) {
	        op += 4;
	      } else {
	        var r = buf[palette_offset + index * 3];
	        var g = buf[palette_offset + index * 3 + 1];
	        var b = buf[palette_offset + index * 3 + 2];
	        pixels[op++] = b;
	        pixels[op++] = g;
	        pixels[op++] = r;
	        pixels[op++] = 255;
	      }
	      --xleft;
	    }
	  };

	  // I will go to copy and paste hell one day...
	  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
	    var frame = this.frameInfo(frame_num);
	    var num_pixels = frame.width * frame.height;
	    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
	    GifReaderLZWOutputIndexStream(
	        buf, frame.data_offset, index_stream, num_pixels);
	    var palette_offset = frame.palette_offset;

	    // NOTE(deanm): It seems to be much faster to compare index to 256 than
	    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
	    // the profile, not sure if it's related to using a Uint8Array.
	    var trans = frame.transparent_index;
	    if (trans === null) trans = 256;

	    // We are possibly just blitting to a portion of the entire frame.
	    // That is a subrect within the framerect, so the additional pixels
	    // must be skipped over after we finished a scanline.
	    var framewidth  = frame.width;
	    var framestride = width - framewidth;
	    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

	    // Output indicies of the top left and bottom right corners of the subrect.
	    var opbeg = ((frame.y * width) + frame.x) * 4;
	    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
	    var op    = opbeg;

	    var scanstride = framestride * 4;

	    // Use scanstride to skip past the rows when interlacing.  This is skipping
	    // 7 rows for the first two passes, then 3 then 1.
	    if (frame.interlaced === true) {
	      scanstride += width * 4 * 7;  // Pass 1.
	    }

	    var interlaceskip = 8;  // Tracking the row interval in the current pass.

	    for (var i = 0, il = index_stream.length; i < il; ++i) {
	      var index = index_stream[i];

	      if (xleft === 0) {  // Beginning of new scan line
	        op += scanstride;
	        xleft = framewidth;
	        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
	          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
	          // interlaceskip / 2 * 4 is interlaceskip << 1.
	          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
	          interlaceskip >>= 1;
	        }
	      }

	      if (index === trans) {
	        op += 4;
	      } else {
	        var r = buf[palette_offset + index * 3];
	        var g = buf[palette_offset + index * 3 + 1];
	        var b = buf[palette_offset + index * 3 + 2];
	        pixels[op++] = r;
	        pixels[op++] = g;
	        pixels[op++] = b;
	        pixels[op++] = 255;
	      }
	      --xleft;
	    }
	  };
	}

	function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
	  var min_code_size = code_stream[p++];

	  var clear_code = 1 << min_code_size;
	  var eoi_code = clear_code + 1;
	  var next_code = eoi_code + 1;

	  var cur_code_size = min_code_size + 1;  // Number of bits per code.
	  // NOTE: This shares the same name as the encoder, but has a different
	  // meaning here.  Here this masks each code coming from the code stream.
	  var code_mask = (1 << cur_code_size) - 1;
	  var cur_shift = 0;
	  var cur = 0;

	  var op = 0;  // Output pointer.

	  var subblock_size = code_stream[p++];

	  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
	  // solve the fast mode / backing store uncertainty.
	  // var code_table = Array(4096);
	  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

	  var prev_code = null;  // Track code-1.

	  while (true) {
	    // Read up to two bytes, making sure we always 12-bits for max sized code.
	    while (cur_shift < 16) {
	      if (subblock_size === 0) break;  // No more data to be read.

	      cur |= code_stream[p++] << cur_shift;
	      cur_shift += 8;

	      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
	        subblock_size = code_stream[p++];  // Next subblock.
	      } else {
	        --subblock_size;
	      }
	    }

	    // TODO(deanm): We should never really get here, we should have received
	    // and EOI.
	    if (cur_shift < cur_code_size)
	      break;

	    var code = cur & code_mask;
	    cur >>= cur_code_size;
	    cur_shift -= cur_code_size;

	    // TODO(deanm): Maybe should check that the first code was a clear code,
	    // at least this is what you're supposed to do.  But actually our encoder
	    // now doesn't emit a clear code first anyway.
	    if (code === clear_code) {
	      // We don't actually have to clear the table.  This could be a good idea
	      // for greater error checking, but we don't really do any anyway.  We
	      // will just track it with next_code and overwrite old entries.

	      next_code = eoi_code + 1;
	      cur_code_size = min_code_size + 1;
	      code_mask = (1 << cur_code_size) - 1;

	      // Don't update prev_code ?
	      prev_code = null;
	      continue;
	    } else if (code === eoi_code) {
	      break;
	    }

	    // We have a similar situation as the decoder, where we want to store
	    // variable length entries (code table entries), but we want to do in a
	    // faster manner than an array of arrays.  The code below stores sort of a
	    // linked list within the code table, and then "chases" through it to
	    // construct the dictionary entries.  When a new entry is created, just the
	    // last byte is stored, and the rest (prefix) of the entry is only
	    // referenced by its table entry.  Then the code chases through the
	    // prefixes until it reaches a single byte code.  We have to chase twice,
	    // first to compute the length, and then to actually copy the data to the
	    // output (backwards, since we know the length).  The alternative would be
	    // storing something in an intermediate stack, but that doesn't make any
	    // more sense.  I implemented an approach where it also stored the length
	    // in the code table, although it's a bit tricky because you run out of
	    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
	    // entries are generally not the long).  Even when I created benchmarks for
	    // very long table entries the complexity did not seem worth it.
	    // The code table stores the prefix entry in 12 bits and then the suffix
	    // byte in 8 bits, so each entry is 20 bits.

	    var chase_code = code < next_code ? code : prev_code;

	    // Chase what we will output, either {CODE} or {CODE-1}.
	    var chase_length = 0;
	    var chase = chase_code;
	    while (chase > clear_code) {
	      chase = code_table[chase] >> 8;
	      ++chase_length;
	    }

	    var k = chase;

	    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
	    if (op_end > output_length) {
	      console.log("Warning, gif stream longer than expected.");
	      return;
	    }

	    // Already have the first byte from the chase, might as well write it fast.
	    output[op++] = k;

	    op += chase_length;
	    var b = op;  // Track pointer, writing backwards.

	    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
	      output[op++] = k;

	    chase = chase_code;
	    while (chase_length--) {
	      chase = code_table[chase];
	      output[--b] = chase & 0xff;  // Write backwards.
	      chase >>= 8;  // Pull down to the prefix code.
	    }

	    if (prev_code !== null && next_code < 4096) {
	      code_table[next_code++] = prev_code << 8 | k;
	      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
	      // have an feeling that it should just happen somewhere else, for now it
	      // is awkward between when we grow past the max and then hit a clear code.
	      // For now just check if we hit the max 12-bits (then a clear code should
	      // follow, also of course encoded in 12-bits).
	      if (next_code >= code_mask+1 && cur_code_size < 12) {
	        ++cur_code_size;
	        code_mask = code_mask << 1 | 1;
	      }
	    }

	    prev_code = code;
	  }

	  if (op !== output_length) {
	    console.log("Warning, gif stream shorter than expected.");
	  }

	  return output;
	}

	// CommonJS.
	try { omggif.GifWriter = GifWriter; omggif.GifReader = GifReader; } catch(e) {}
	return omggif;
}

var omggifExports = requireOmggif();
var GIF = /*@__PURE__*/getDefaultExportFromCjs(omggifExports);

var bitmapimage;
var hasRequiredBitmapimage;

function requireBitmapimage () {
	if (hasRequiredBitmapimage) return bitmapimage;
	hasRequiredBitmapimage = 1;

	/** @class BitmapImage */

	class BitmapImage {

	    /**
	     * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
	     * 
	     * Property | Description
	     * --- | ---
	     * bitmap.width | width of image in pixels
	     * bitmap.height | height of image in pixels
	     * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
	     *
	     * Its constructor supports the following signatures:
	     *
	     * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
	     * * new BitmapImage(bitmapImage: BitmapImage)
	     * * new BitmapImage(width: number, height: number, buffer: Buffer)
	     * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
	     * 
	     * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
	     *
	     * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
	     */

	    constructor(...args) {
	        // don't confirm the number of args, because a subclass may have
	        // additional args and pass them all to the superclass
	        if (args.length === 0) {
	            throw new Error("constructor requires parameters");
	        }
	        const firstArg = args[0];
	        if (firstArg !== null && typeof firstArg === 'object') {
	            if (firstArg instanceof BitmapImage) {
	                // copy a provided BitmapImage
	                const sourceBitmap = firstArg.bitmap;
	                this.bitmap = {
	                    width: sourceBitmap.width,
	                    height: sourceBitmap.height,
	                    data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
	                };
	                sourceBitmap.data.copy(this.bitmap.data);
	            }
	            else if (firstArg.width && firstArg.height && firstArg.data) {
	                // share a provided bitmap
	                this.bitmap = firstArg;
	            }
	            else {
	                throw new Error("unrecognized constructor parameters");
	            }
	        }
	        else if (typeof firstArg === 'number' && typeof args[1] === 'number')
	        {
	            const width = firstArg;
	            const height = args[1];
	            const thirdArg = args[2];
	            this.bitmap = { width, height };

	            if (Buffer.isBuffer(thirdArg)) {
	                this.bitmap.data = thirdArg;
	            }
	            else {
	                this.bitmap.data = new Buffer(width * height * 4);
	                if (typeof thirdArg === 'number') {
	                    this.fillRGBA(thirdArg);
	                }
	            }
	        }
	        else {
	            throw new Error("unrecognized constructor parameters");
	        }
	    }

	    /**
	     * Copy a square portion of this image into another image. 
	     * 
	     * @param {BitmapImage} toImage Image into which to copy the square
	     * @param {number} toX x-coord in toImage of upper-left corner of receiving square
	     * @param {number} toY y-coord in toImage of upper-left corner of receiving square
	     * @param {number} fromX x-coord in this image of upper-left corner of source square
	     * @param {number} fromY y-coord in this image of upper-left corner of source square
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
	        if (fromX + fromWidth > this.bitmap.width) {
	            throw new Error("copy exceeds width of source bitmap");
	        }
	        if (toX + fromWidth > toImage.bitmap.width) {
	            throw new Error("copy exceeds width of target bitmap");
	        }
	        if (fromY + fromHeight > this.bitmap.height) {
	            throw new Error("copy exceeds height of source bitmap");
	        }
	        if (toY + fromHeight > toImage.bitmap.height) {
	            throw new Erro("copy exceeds height of target bitmap");
	        }
	        
	        const sourceBuf = this.bitmap.data;
	        const targetBuf = toImage.bitmap.data;
	        const sourceByteWidth = this.bitmap.width * 4;
	        const targetByteWidth = toImage.bitmap.width * 4;
	        const copyByteWidth = fromWidth * 4;
	        let si = fromY * sourceByteWidth + fromX * 4;
	        let ti = toY * targetByteWidth + toX * 4;

	        while (--fromHeight >= 0) {
	            sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
	            si += sourceByteWidth;
	            ti += targetByteWidth;
	        }
	        return this;
	    }

	    /**
	     * Fills the image with a single color.
	     * 
	     * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    fillRGBA(rgba) {
	        const buf = this.bitmap.data;
	        const bufByteWidth = this.bitmap.height * 4;
	        
	        let bi = 0;
	        while (bi < bufByteWidth) {
	            buf.writeUInt32BE(rgba, bi);
	            bi += 4;
	        }
	        while (bi < buf.length) {
	            buf.copy(buf, bi, 0, bufByteWidth);
	            bi += bufByteWidth;
	        }
	        return this;
	    }

	    /**
	     * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
	     * 
	     * @param {number} x x-coord of pixel
	     * @param {number} y y-coord of pixel
	     * @return {number} RGBA of pixel in 0xRRGGBBAA form
	     */

	    getRGBA(x, y) {
	        const bi = (y * this.bitmap.width + x) * 4;
	        return this.bitmap.data.readUInt32BE(bi);
	    }

	    /**
	     * Gets a set of all RGBA colors found within the image.
	     * 
	     * @return {Set} Set of all RGBA colors that the image contains.
	     */

	    getRGBASet() {
	        const rgbaSet = new Set();
	        const buf = this.bitmap.data;
	        for (let bi = 0; bi < buf.length; bi += 4) {
	            rgbaSet.add(buf.readUInt32BE(bi, true));
	        }
	        return rgbaSet;
	    }

	    /**
	     * Converts the image to greyscale using inferred Adobe metrics.
	     * 
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    greyscale() {
	        const buf = this.bitmap.data;
	        this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
	            const grey = Math.round(
	                0.299 * buf[idx] +
	                0.587 * buf[idx + 1] +
	                0.114 * buf[idx + 2]
	            );
	            buf[idx] = grey;
	            buf[idx + 1] = grey;
	            buf[idx + 2] = grey;
	        });
	        return this;
	    }

	    /**
	     * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
	     * 
	     * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
	     * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
	     * @param {number} width The width of the new image after reframing
	     * @param {number} height The height of the new image after reframing
	     * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    reframe(xOffset, yOffset, width, height, fillRGBA) {
	        const cropX = (xOffset < 0 ? 0 : xOffset);
	        const cropY = (yOffset < 0 ? 0 : yOffset);
	        const cropWidth = (width + cropX > this.bitmap.width ?
	                this.bitmap.width - cropX : width);
	        const cropHeight = (height + cropY > this.bitmap.height ?
	                this.bitmap.height - cropY : height);
	        const newX = (xOffset < 0 ? -xOffset : 0);
	        const newY = (yOffset < 0 ? -yOffset : 0);

	        let image;
	        if (fillRGBA === undefined) {
	            if (cropX !== xOffset || cropY != yOffset ||
	                    cropWidth !== width || cropHeight !== height)
	            {
	                throw new GifError(`fillRGBA required for this reframing`);
	            }
	            image = new BitmapImage(width, height);
	        }
	        else {
	            image = new BitmapImage(width, height, fillRGBA);
	        }
	        this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);
	        this.bitmap = image.bitmap;
	        return this;
	    }

	    /**
	     * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
	     * 
	     * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
	     * @return {BitmapImage} The present image to allow for chaining.
	     */

	    scale(factor) {
	        if (factor === 1) {
	            return;
	        }
	        if (!Number.isInteger(factor) || factor < 1) {
	            throw new Error("the scale must be an integer >= 1");
	        }
	        const sourceWidth = this.bitmap.width;
	        const sourceHeight = this.bitmap.height;
	        const destByteWidth = sourceWidth * factor * 4;
	        const sourceBuf = this.bitmap.data;
	        const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
	        let sourceIndex = 0;
	        let priorDestRowIndex;
	        let destIndex = 0;
	        for (let y = 0; y < sourceHeight; ++y) {
	            priorDestRowIndex = destIndex;
	            for (let x = 0; x < sourceWidth; ++x) {
	                const color = sourceBuf.readUInt32BE(sourceIndex, true);
	                for (let cx = 0; cx < factor; ++cx) {
	                    destBuf.writeUInt32BE(color, destIndex);
	                    destIndex += 4;
	                }
	                sourceIndex += 4;
	            }
	            for (let cy = 1; cy < factor; ++cy) {
	                destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
	                destIndex += destByteWidth;
	                priorDestRowIndex += destByteWidth;
	            }
	        }
	        this.bitmap = {
	            width: sourceWidth * factor,
	            height: sourceHeight * factor,
	            data: destBuf
	        };
	        return this;
	    }

	    /**
	     * Scans all coordinates of the image, handing each in turn to the provided handler function.
	     *
	     * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
	     * @see scanAllIndexes
	     */

	    scanAllCoords(scanHandler) {
	        const width = this.bitmap.width;
	        const bufferLength = this.bitmap.data.length;
	        let x = 0;
	        let y = 0;

	        for (let bi = 0; bi < bufferLength; bi += 4) {
	            scanHandler(x, y, bi);
	            if (++x === width) {
	                x = 0;
	                ++y;
	            }
	        }
	    }

	    /**
	     * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
	     *
	     * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
	     * @see scanAllCoords
	     */

	    scanAllIndexes(scanHandler) {
	        const bufferLength = this.bitmap.data.length;
	        for (let bi = 0; bi < bufferLength; bi += 4) {
	            scanHandler(bi);
	        }
	    }
	}

	bitmapimage = BitmapImage;
	return bitmapimage;
}

var gif$1 = {};

var hasRequiredGif;

function requireGif () {
	if (hasRequiredGif) return gif$1;
	hasRequiredGif = 1;

	/** @class Gif */

	class Gif {

	    // width - width of GIF in pixels
	    // height - height of GIF in pixels
	    // loops - 0 = unending; (n > 0) = iterate n times
	    // usesTransparency - whether any frames have transparent pixels
	    // colorScope - scope of color tables in GIF
	    // frames - array of frames
	    // buffer - GIF-formatted data

	    /**
	     * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
	     * 
	     * Property | Description
	     * --- | ---
	     * width | width of the GIF at its widest
	     * height | height of the GIF at its highest
	     * loops | the number of times the GIF should loop before stopping; 0 => loop indefinitely
	     * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
	     * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
	     * frames | a array of GifFrame instances, one for each frame of the GIF
	     * buffer | a Buffer holding the encoding's byte data
	     * 
	     * Its constructor should only ever be called by the GIF encoder or decoder.
	     *
	     * @param {Buffer} buffer A Buffer containing the encoded bytes
	     * @param {GifFrame[]} frames Array of frames found in the encoding
	     * @param {object} spec Properties of the encoding as listed above
	     */

	    constructor(buffer, frames, spec) {
	        this.width = spec.width;
	        this.height = spec.height;
	        this.loops = spec.loops;
	        this.usesTransparency = spec.usesTransparency;
	        this.colorScope = spec.colorScope;
	        this.frames = frames;
	        this.buffer = buffer;
	    }
	}

	Gif.GlobalColorsPreferred = 0;
	Gif.GlobalColorsOnly = 1;
	Gif.LocalColorsOnly = 2;

	/** @class GifError */

	class GifError extends Error {

	    /**
	     * GifError is a class representing a GIF-related error
	     * 
	     * @param {string|Error} messageOrError
	     */

	    constructor(messageOrError) {
	        super(messageOrError);
	        if (messageOrError instanceof Error) {
	            this.stack = 'Gif' + messageOrError.stack;
	        }
	    }
	}

	gif$1.Gif = Gif;
	gif$1.GifError = GifError;
	return gif$1;
}

var gifcodec = {};

var gifutil = {};

var imageQ;
var hasRequiredImageQ;

function requireImageQ () {
	if (hasRequiredImageQ) return imageQ;
	hasRequiredImageQ = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
	var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
	var __export = (target, all) => {
	  for (var name in all)
	    __defProp(target, name, { get: all[name], enumerable: true });
	};
	var __reExport = (target, module2, copyDefault, desc) => {
	  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
	    for (let key of __getOwnPropNames(module2))
	      if (!__hasOwnProp.call(target, key) && (copyDefault))
	        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
	  }
	  return target;
	};
	var __toCommonJS = /* @__PURE__ */ ((cache) => {
	  return (module2, temp) => {
	    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
	  };
	})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
	var __publicField = (obj, key, value) => {
	  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
	  return value;
	};

	// src/index.ts
	var src_exports = {};
	__export(src_exports, {
	  applyPalette: () => applyPalette,
	  applyPaletteSync: () => applyPaletteSync,
	  buildPalette: () => buildPalette,
	  buildPaletteSync: () => buildPaletteSync,
	  constants: () => constants_exports,
	  conversion: () => conversion_exports,
	  distance: () => distance_exports,
	  image: () => image_exports,
	  palette: () => palette_exports,
	  quality: () => quality_exports,
	  utils: () => utils_exports
	});

	// src/constants/index.ts
	var constants_exports = {};
	__export(constants_exports, {
	  bt709: () => bt709_exports
	});

	// src/constants/bt709.ts
	var bt709_exports = {};
	__export(bt709_exports, {
	  Y: () => Y,
	  x: () => x,
	  y: () => y
	});
	var Y = /* @__PURE__ */ ((Y2) => {
	  Y2[Y2["RED"] = 0.2126] = "RED";
	  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
	  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
	  Y2[Y2["WHITE"] = 1] = "WHITE";
	  return Y2;
	})(Y || {});
	var x = /* @__PURE__ */ ((x2) => {
	  x2[x2["RED"] = 0.64] = "RED";
	  x2[x2["GREEN"] = 0.3] = "GREEN";
	  x2[x2["BLUE"] = 0.15] = "BLUE";
	  x2[x2["WHITE"] = 0.3127] = "WHITE";
	  return x2;
	})(x || {});
	var y = /* @__PURE__ */ ((y2) => {
	  y2[y2["RED"] = 0.33] = "RED";
	  y2[y2["GREEN"] = 0.6] = "GREEN";
	  y2[y2["BLUE"] = 0.06] = "BLUE";
	  y2[y2["WHITE"] = 0.329] = "WHITE";
	  return y2;
	})(y || {});

	// src/conversion/index.ts
	var conversion_exports = {};
	__export(conversion_exports, {
	  lab2rgb: () => lab2rgb,
	  lab2xyz: () => lab2xyz,
	  rgb2hsl: () => rgb2hsl,
	  rgb2lab: () => rgb2lab,
	  rgb2xyz: () => rgb2xyz,
	  xyz2lab: () => xyz2lab,
	  xyz2rgb: () => xyz2rgb
	});

	// src/conversion/rgb2xyz.ts
	function correctGamma(n) {
	  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
	}
	function rgb2xyz(r, g, b) {
	  r = correctGamma(r / 255);
	  g = correctGamma(g / 255);
	  b = correctGamma(b / 255);
	  return {
	    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
	    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
	    z: r * 0.0193 + g * 0.1192 + b * 0.9505
	  };
	}

	// src/utils/arithmetic.ts
	var arithmetic_exports = {};
	__export(arithmetic_exports, {
	  degrees2radians: () => degrees2radians,
	  inRange0to255: () => inRange0to255,
	  inRange0to255Rounded: () => inRange0to255Rounded,
	  intInRange: () => intInRange,
	  max3: () => max3,
	  min3: () => min3,
	  stableSort: () => stableSort
	});
	function degrees2radians(n) {
	  return n * (Math.PI / 180);
	}
	function max3(a, b, c) {
	  let m = a;
	  if (m < b)
	    m = b;
	  if (m < c)
	    m = c;
	  return m;
	}
	function min3(a, b, c) {
	  let m = a;
	  if (m > b)
	    m = b;
	  if (m > c)
	    m = c;
	  return m;
	}
	function intInRange(value, low, high) {
	  if (value > high)
	    value = high;
	  if (value < low)
	    value = low;
	  return value | 0;
	}
	function inRange0to255Rounded(n) {
	  n = Math.round(n);
	  if (n > 255)
	    n = 255;
	  else if (n < 0)
	    n = 0;
	  return n;
	}
	function inRange0to255(n) {
	  if (n > 255)
	    n = 255;
	  else if (n < 0)
	    n = 0;
	  return n;
	}
	function stableSort(arrayToSort, callback) {
	  const type = typeof arrayToSort[0];
	  let sorted;
	  if (type === "number" || type === "string") {
	    const ord = /* @__PURE__ */ Object.create(null);
	    for (let i = 0, l = arrayToSort.length; i < l; i++) {
	      const val = arrayToSort[i];
	      if (ord[val] || ord[val] === 0)
	        continue;
	      ord[val] = i;
	    }
	    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
	  } else {
	    const ord2 = arrayToSort.slice(0);
	    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
	  }
	  return sorted;
	}

	// src/conversion/rgb2hsl.ts
	function rgb2hsl(r, g, b) {
	  const min = min3(r, g, b);
	  const max = max3(r, g, b);
	  const delta = max - min;
	  const l = (min + max) / 510;
	  let s = 0;
	  if (l > 0 && l < 1)
	    s = delta / (l < 0.5 ? max + min : 510 - max - min);
	  let h = 0;
	  if (delta > 0) {
	    if (max === r) {
	      h = (g - b) / delta;
	    } else if (max === g) {
	      h = 2 + (b - r) / delta;
	    } else {
	      h = 4 + (r - g) / delta;
	    }
	    h *= 60;
	    if (h < 0)
	      h += 360;
	  }
	  return { h, s, l };
	}

	// src/conversion/xyz2lab.ts
	var refX = 0.95047;
	var refY = 1;
	var refZ = 1.08883;
	function pivot(n) {
	  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
	}
	function xyz2lab(x2, y2, z) {
	  x2 = pivot(x2 / refX);
	  y2 = pivot(y2 / refY);
	  z = pivot(z / refZ);
	  if (116 * y2 - 16 < 0)
	    throw new Error("xxx");
	  return {
	    L: Math.max(0, 116 * y2 - 16),
	    a: 500 * (x2 - y2),
	    b: 200 * (y2 - z)
	  };
	}

	// src/conversion/rgb2lab.ts
	function rgb2lab(r, g, b) {
	  const xyz = rgb2xyz(r, g, b);
	  return xyz2lab(xyz.x, xyz.y, xyz.z);
	}

	// src/conversion/lab2xyz.ts
	var refX2 = 0.95047;
	var refY2 = 1;
	var refZ2 = 1.08883;
	function pivot2(n) {
	  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
	}
	function lab2xyz(L, a, b) {
	  const y2 = (L + 16) / 116;
	  const x2 = a / 500 + y2;
	  const z = y2 - b / 200;
	  return {
	    x: refX2 * pivot2(x2),
	    y: refY2 * pivot2(y2),
	    z: refZ2 * pivot2(z)
	  };
	}

	// src/conversion/xyz2rgb.ts
	function correctGamma2(n) {
	  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
	}
	function xyz2rgb(x2, y2, z) {
	  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
	  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
	  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
	  return {
	    r: inRange0to255Rounded(r * 255),
	    g: inRange0to255Rounded(g * 255),
	    b: inRange0to255Rounded(b * 255)
	  };
	}

	// src/conversion/lab2rgb.ts
	function lab2rgb(L, a, b) {
	  const xyz = lab2xyz(L, a, b);
	  return xyz2rgb(xyz.x, xyz.y, xyz.z);
	}

	// src/distance/index.ts
	var distance_exports = {};
	__export(distance_exports, {
	  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
	  AbstractEuclidean: () => AbstractEuclidean,
	  AbstractManhattan: () => AbstractManhattan,
	  CIE94GraphicArts: () => CIE94GraphicArts,
	  CIE94Textiles: () => CIE94Textiles,
	  CIEDE2000: () => CIEDE2000,
	  CMetric: () => CMetric,
	  Euclidean: () => Euclidean,
	  EuclideanBT709: () => EuclideanBT709,
	  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
	  Manhattan: () => Manhattan,
	  ManhattanBT709: () => ManhattanBT709,
	  ManhattanNommyde: () => ManhattanNommyde,
	  PNGQuant: () => PNGQuant
	});

	// src/distance/distanceCalculator.ts
	var AbstractDistanceCalculator = class {
	  constructor() {
	    __publicField(this, "_maxDistance");
	    __publicField(this, "_whitePoint");
	    this._setDefaults();
	    this.setWhitePoint(255, 255, 255, 255);
	  }
	  setWhitePoint(r, g, b, a) {
	    this._whitePoint = {
	      r: r > 0 ? 255 / r : 0,
	      g: g > 0 ? 255 / g : 0,
	      b: b > 0 ? 255 / b : 0,
	      a: a > 0 ? 255 / a : 0
	    };
	    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
	  }
	  calculateNormalized(colorA, colorB) {
	    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
	  }
	};

	// src/distance/cie94.ts
	var AbstractCIE94 = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
	    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
	    const dL = lab1.L - lab2.L;
	    const dA = lab1.a - lab2.a;
	    const dB = lab1.b - lab2.b;
	    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
	    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
	    const dC = c1 - c2;
	    let deltaH = dA * dA + dB * dB - dC * dC;
	    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
	    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
	    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
	  }
	};
	var CIE94Textiles = class extends AbstractCIE94 {
	  _setDefaults() {
	    this._Kl = 2;
	    this._K1 = 0.048;
	    this._K2 = 0.014;
	    this._kA = 0.25 * 50 / 255;
	  }
	};
	var CIE94GraphicArts = class extends AbstractCIE94 {
	  _setDefaults() {
	    this._Kl = 1;
	    this._K1 = 0.045;
	    this._K2 = 0.015;
	    this._kA = 0.25 * 100 / 255;
	  }
	};

	// src/distance/ciede2000.ts
	var _CIEDE2000 = class extends AbstractDistanceCalculator {
	  _setDefaults() {
	  }
	  static _calculatehp(b, ap) {
	    const hp = Math.atan2(b, ap);
	    if (hp >= 0)
	      return hp;
	    return hp + _CIEDE2000._deg360InRad;
	  }
	  static _calculateRT(ahp, aCp) {
	    const aCp_to_7 = aCp ** 7;
	    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
	    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
	    return -Math.sin(2 * delta_theta) * R_C;
	  }
	  static _calculateT(ahp) {
	    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
	  }
	  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
	    const hpSum = h1p + h2p;
	    if (C1pC2p === 0)
	      return hpSum;
	    if (h_bar <= _CIEDE2000._deg180InRad)
	      return hpSum / 2;
	    if (hpSum < _CIEDE2000._deg360InRad) {
	      return (hpSum + _CIEDE2000._deg360InRad) / 2;
	    }
	    return (hpSum - _CIEDE2000._deg360InRad) / 2;
	  }
	  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
	    let dhp;
	    if (C1pC2p === 0) {
	      dhp = 0;
	    } else if (h_bar <= _CIEDE2000._deg180InRad) {
	      dhp = h2p - h1p;
	    } else if (h2p <= h1p) {
	      dhp = h2p - h1p + _CIEDE2000._deg360InRad;
	    } else {
	      dhp = h2p - h1p - _CIEDE2000._deg360InRad;
	    }
	    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
	  }
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
	    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
	    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
	    const dE2 = this.calculateRawInLab(lab1, lab2);
	    return Math.sqrt(dE2 + dA * dA);
	  }
	  calculateRawInLab(Lab1, Lab2) {
	    const L1 = Lab1.L;
	    const a1 = Lab1.a;
	    const b1 = Lab1.b;
	    const L2 = Lab2.L;
	    const a2 = Lab2.a;
	    const b2 = Lab2.b;
	    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
	    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
	    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
	    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
	    const a1p = (1 + G) * a1;
	    const a2p = (1 + G) * a2;
	    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
	    const C2p = Math.sqrt(a2p * a2p + b2 * b2);
	    const C1pC2p = C1p * C2p;
	    const h1p = _CIEDE2000._calculatehp(b1, a1p);
	    const h2p = _CIEDE2000._calculatehp(b2, a2p);
	    const h_bar = Math.abs(h1p - h2p);
	    const dLp = L2 - L1;
	    const dCp = C2p - C1p;
	    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
	    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
	    const T = _CIEDE2000._calculateT(ahp);
	    const aCp = (C1p + C2p) / 2;
	    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
	    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
	    const S_C = 1 + 0.045 * aCp;
	    const S_H = 1 + 0.015 * T * aCp;
	    const R_T = _CIEDE2000._calculateRT(ahp, aCp);
	    const dLpSL = dLp / S_L;
	    const dCpSC = dCp / S_C;
	    const dHpSH = dHp / S_H;
	    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
	  }
	};
	var CIEDE2000 = _CIEDE2000;
	__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
	__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
	__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
	__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
	__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
	__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
	__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
	__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
	__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));

	// src/distance/cmetric.ts
	var CMetric = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const rmean = (r1 + r2) / 2 * this._whitePoint.r;
	    const r = (r1 - r2) * this._whitePoint.r;
	    const g = (g1 - g2) * this._whitePoint.g;
	    const b = (b1 - b2) * this._whitePoint.b;
	    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
	    const dA = (a2 - a1) * this._whitePoint.a;
	    return Math.sqrt(dE + dA * dA);
	  }
	  _setDefaults() {
	  }
	};

	// src/distance/euclidean.ts
	var AbstractEuclidean = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const dR = r2 - r1;
	    const dG = g2 - g1;
	    const dB = b2 - b1;
	    const dA = a2 - a1;
	    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
	  }
	};
	var Euclidean = class extends AbstractEuclidean {
	  _setDefaults() {
	    this._kR = 1;
	    this._kG = 1;
	    this._kB = 1;
	    this._kA = 1;
	  }
	};
	var EuclideanBT709 = class extends AbstractEuclidean {
	  _setDefaults() {
	    this._kR = 0.2126 /* RED */;
	    this._kG = 0.7152 /* GREEN */;
	    this._kB = 0.0722 /* BLUE */;
	    this._kA = 1;
	  }
	};
	var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
	  _setDefaults() {
	    this._kR = 0.2126 /* RED */;
	    this._kG = 0.7152 /* GREEN */;
	    this._kB = 0.0722 /* BLUE */;
	    this._kA = 0;
	  }
	};

	// src/distance/manhattan.ts
	var AbstractManhattan = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    let dR = r2 - r1;
	    let dG = g2 - g1;
	    let dB = b2 - b1;
	    let dA = a2 - a1;
	    if (dR < 0)
	      dR = 0 - dR;
	    if (dG < 0)
	      dG = 0 - dG;
	    if (dB < 0)
	      dB = 0 - dB;
	    if (dA < 0)
	      dA = 0 - dA;
	    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
	  }
	};
	var Manhattan = class extends AbstractManhattan {
	  _setDefaults() {
	    this._kR = 1;
	    this._kG = 1;
	    this._kB = 1;
	    this._kA = 1;
	  }
	};
	var ManhattanNommyde = class extends AbstractManhattan {
	  _setDefaults() {
	    this._kR = 0.4984;
	    this._kG = 0.8625;
	    this._kB = 0.2979;
	    this._kA = 1;
	  }
	};
	var ManhattanBT709 = class extends AbstractManhattan {
	  _setDefaults() {
	    this._kR = 0.2126 /* RED */;
	    this._kG = 0.7152 /* GREEN */;
	    this._kB = 0.0722 /* BLUE */;
	    this._kA = 1;
	  }
	};

	// src/distance/pngQuant.ts
	var PNGQuant = class extends AbstractDistanceCalculator {
	  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
	    const alphas = (a2 - a1) * this._whitePoint.a;
	    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
	  }
	  _colordifferenceCh(x2, y2, alphas) {
	    const black = x2 - y2;
	    const white = black + alphas;
	    return black * black + white * white;
	  }
	  _setDefaults() {
	  }
	};

	// src/palette/index.ts
	var palette_exports = {};
	__export(palette_exports, {
	  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
	  ColorHistogram: () => ColorHistogram,
	  NeuQuant: () => NeuQuant,
	  NeuQuantFloat: () => NeuQuantFloat,
	  RGBQuant: () => RGBQuant,
	  WuColorCube: () => WuColorCube,
	  WuQuant: () => WuQuant
	});

	// src/palette/paletteQuantizer.ts
	var AbstractPaletteQuantizer = class {
	  quantizeSync() {
	    for (const value of this.quantize()) {
	      if (value.palette) {
	        return value.palette;
	      }
	    }
	    throw new Error("unreachable");
	  }
	};

	// src/utils/point.ts
	var Point = class {
	  constructor() {
	    __publicField(this, "r");
	    __publicField(this, "g");
	    __publicField(this, "b");
	    __publicField(this, "a");
	    __publicField(this, "uint32");
	    __publicField(this, "rgba");
	    this.uint32 = -1 >>> 0;
	    this.r = this.g = this.b = this.a = 0;
	    this.rgba = new Array(4);
	    this.rgba[0] = 0;
	    this.rgba[1] = 0;
	    this.rgba[2] = 0;
	    this.rgba[3] = 0;
	  }
	  static createByQuadruplet(quadruplet) {
	    const point = new Point();
	    point.r = quadruplet[0] | 0;
	    point.g = quadruplet[1] | 0;
	    point.b = quadruplet[2] | 0;
	    point.a = quadruplet[3] | 0;
	    point._loadUINT32();
	    point._loadQuadruplet();
	    return point;
	  }
	  static createByRGBA(red, green, blue, alpha) {
	    const point = new Point();
	    point.r = red | 0;
	    point.g = green | 0;
	    point.b = blue | 0;
	    point.a = alpha | 0;
	    point._loadUINT32();
	    point._loadQuadruplet();
	    return point;
	  }
	  static createByUint32(uint32) {
	    const point = new Point();
	    point.uint32 = uint32 >>> 0;
	    point._loadRGBA();
	    point._loadQuadruplet();
	    return point;
	  }
	  from(point) {
	    this.r = point.r;
	    this.g = point.g;
	    this.b = point.b;
	    this.a = point.a;
	    this.uint32 = point.uint32;
	    this.rgba[0] = point.r;
	    this.rgba[1] = point.g;
	    this.rgba[2] = point.b;
	    this.rgba[3] = point.a;
	  }
	  getLuminosity(useAlphaChannel) {
	    let r = this.r;
	    let g = this.g;
	    let b = this.b;
	    if (useAlphaChannel) {
	      r = Math.min(255, 255 - this.a + this.a * r / 255);
	      g = Math.min(255, 255 - this.a + this.a * g / 255);
	      b = Math.min(255, 255 - this.a + this.a * b / 255);
	    }
	    return r * 0.2126 /* RED */ + g * 0.7152 /* GREEN */ + b * 0.0722 /* BLUE */;
	  }
	  _loadUINT32() {
	    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
	  }
	  _loadRGBA() {
	    this.r = this.uint32 & 255;
	    this.g = this.uint32 >>> 8 & 255;
	    this.b = this.uint32 >>> 16 & 255;
	    this.a = this.uint32 >>> 24 & 255;
	  }
	  _loadQuadruplet() {
	    this.rgba[0] = this.r;
	    this.rgba[1] = this.g;
	    this.rgba[2] = this.b;
	    this.rgba[3] = this.a;
	  }
	};

	// src/utils/pointContainer.ts
	var PointContainer = class {
	  constructor() {
	    __publicField(this, "_pointArray");
	    __publicField(this, "_width");
	    __publicField(this, "_height");
	    this._width = 0;
	    this._height = 0;
	    this._pointArray = [];
	  }
	  getWidth() {
	    return this._width;
	  }
	  getHeight() {
	    return this._height;
	  }
	  setWidth(width) {
	    this._width = width;
	  }
	  setHeight(height) {
	    this._height = height;
	  }
	  getPointArray() {
	    return this._pointArray;
	  }
	  clone() {
	    const clone = new PointContainer();
	    clone._width = this._width;
	    clone._height = this._height;
	    for (let i = 0, l = this._pointArray.length; i < l; i++) {
	      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);
	    }
	    return clone;
	  }
	  toUint32Array() {
	    const l = this._pointArray.length;
	    const uint32Array = new Uint32Array(l);
	    for (let i = 0; i < l; i++) {
	      uint32Array[i] = this._pointArray[i].uint32;
	    }
	    return uint32Array;
	  }
	  toUint8Array() {
	    return new Uint8Array(this.toUint32Array().buffer);
	  }
	  static fromHTMLImageElement(img) {
	    const width = img.naturalWidth;
	    const height = img.naturalHeight;
	    const canvas = document.createElement("canvas");
	    canvas.width = width;
	    canvas.height = height;
	    const ctx = canvas.getContext("2d");
	    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
	    return PointContainer.fromHTMLCanvasElement(canvas);
	  }
	  static fromHTMLCanvasElement(canvas) {
	    const width = canvas.width;
	    const height = canvas.height;
	    const ctx = canvas.getContext("2d");
	    const imgData = ctx.getImageData(0, 0, width, height);
	    return PointContainer.fromImageData(imgData);
	  }
	  static fromImageData(imageData) {
	    const width = imageData.width;
	    const height = imageData.height;
	    return PointContainer.fromUint8Array(imageData.data, width, height);
	  }
	  static fromUint8Array(uint8Array, width, height) {
	    switch (Object.prototype.toString.call(uint8Array)) {
	      case "[object Uint8ClampedArray]":
	      case "[object Uint8Array]":
	        break;
	      default:
	        uint8Array = new Uint8Array(uint8Array);
	    }
	    const uint32Array = new Uint32Array(uint8Array.buffer);
	    return PointContainer.fromUint32Array(uint32Array, width, height);
	  }
	  static fromUint32Array(uint32Array, width, height) {
	    const container = new PointContainer();
	    container._width = width;
	    container._height = height;
	    for (let i = 0, l = uint32Array.length; i < l; i++) {
	      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);
	    }
	    return container;
	  }
	  static fromBuffer(buffer, width, height) {
	    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
	    return PointContainer.fromUint32Array(uint32Array, width, height);
	  }
	};

	// src/utils/palette.ts
	var hueGroups = 10;
	function hueGroup(hue, segmentsNumber) {
	  const maxHue = 360;
	  const seg = maxHue / segmentsNumber;
	  const half = seg / 2;
	  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
	    if (hue >= mid && hue < mid + seg)
	      return i;
	  }
	  return 0;
	}
	var Palette = class {
	  constructor() {
	    __publicField(this, "_pointContainer");
	    __publicField(this, "_pointArray", []);
	    __publicField(this, "_i32idx", {});
	    this._pointContainer = new PointContainer();
	    this._pointContainer.setHeight(1);
	    this._pointArray = this._pointContainer.getPointArray();
	  }
	  add(color) {
	    this._pointArray.push(color);
	    this._pointContainer.setWidth(this._pointArray.length);
	  }
	  has(color) {
	    for (let i = this._pointArray.length - 1; i >= 0; i--) {
	      if (color.uint32 === this._pointArray[i].uint32)
	        return true;
	    }
	    return false;
	  }
	  getNearestColor(colorDistanceCalculator, color) {
	    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
	  }
	  getPointContainer() {
	    return this._pointContainer;
	  }
	  _nearestPointFromCache(key) {
	    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
	  }
	  _getNearestIndex(colorDistanceCalculator, point) {
	    let idx = this._nearestPointFromCache("" + point.uint32);
	    if (idx >= 0)
	      return idx;
	    let minimalDistance = Number.MAX_VALUE;
	    idx = 0;
	    for (let i = 0, l = this._pointArray.length; i < l; i++) {
	      const p = this._pointArray[i];
	      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
	      if (distance < minimalDistance) {
	        minimalDistance = distance;
	        idx = i;
	      }
	    }
	    this._i32idx[point.uint32] = idx;
	    return idx;
	  }
	  sort() {
	    this._i32idx = {};
	    this._pointArray.sort((a, b) => {
	      const hslA = rgb2hsl(a.r, a.g, a.b);
	      const hslB = rgb2hsl(b.r, b.g, b.b);
	      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
	      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
	      const hueDiff = hueB - hueA;
	      if (hueDiff)
	        return -hueDiff;
	      const lA = a.getLuminosity(true);
	      const lB = b.getLuminosity(true);
	      if (lB - lA !== 0)
	        return lB - lA;
	      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
	      if (satDiff)
	        return -satDiff;
	      return 0;
	    });
	  }
	};

	// src/utils/index.ts
	var utils_exports = {};
	__export(utils_exports, {
	  HueStatistics: () => HueStatistics,
	  Palette: () => Palette,
	  Point: () => Point,
	  PointContainer: () => PointContainer,
	  ProgressTracker: () => ProgressTracker,
	  arithmetic: () => arithmetic_exports
	});

	// src/utils/hueStatistics.ts
	var HueGroup = class {
	  constructor() {
	    __publicField(this, "num", 0);
	    __publicField(this, "cols", []);
	  }
	};
	var HueStatistics = class {
	  constructor(numGroups, minCols) {
	    __publicField(this, "_numGroups");
	    __publicField(this, "_minCols");
	    __publicField(this, "_stats");
	    __publicField(this, "_groupsFull");
	    this._numGroups = numGroups;
	    this._minCols = minCols;
	    this._stats = [];
	    for (let i = 0; i <= numGroups; i++) {
	      this._stats[i] = new HueGroup();
	    }
	    this._groupsFull = 0;
	  }
	  check(i32) {
	    if (this._groupsFull === this._numGroups + 1) {
	      this.check = () => {
	      };
	    }
	    const r = i32 & 255;
	    const g = i32 >>> 8 & 255;
	    const b = i32 >>> 16 & 255;
	    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
	    const gr = this._stats[hg];
	    const min = this._minCols;
	    gr.num++;
	    if (gr.num > min) {
	      return;
	    }
	    if (gr.num === min) {
	      this._groupsFull++;
	    }
	    if (gr.num <= min) {
	      this._stats[hg].cols.push(i32);
	    }
	  }
	  injectIntoDictionary(histG) {
	    for (let i = 0; i <= this._numGroups; i++) {
	      if (this._stats[i].num <= this._minCols) {
	        this._stats[i].cols.forEach((col) => {
	          if (!histG[col]) {
	            histG[col] = 1;
	          } else {
	            histG[col]++;
	          }
	        });
	      }
	    }
	  }
	  injectIntoArray(histG) {
	    for (let i = 0; i <= this._numGroups; i++) {
	      if (this._stats[i].num <= this._minCols) {
	        this._stats[i].cols.forEach((col) => {
	          if (histG.indexOf(col) === -1) {
	            histG.push(col);
	          }
	        });
	      }
	    }
	  }
	};

	// src/utils/progressTracker.ts
	var _ProgressTracker = class {
	  constructor(valueRange, progressRange) {
	    __publicField(this, "progress");
	    __publicField(this, "_step");
	    __publicField(this, "_range");
	    __publicField(this, "_last");
	    __publicField(this, "_progressRange");
	    this._range = valueRange;
	    this._progressRange = progressRange;
	    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
	    this._last = -this._step;
	    this.progress = 0;
	  }
	  shouldNotify(current) {
	    if (current - this._last >= this._step) {
	      this._last = current;
	      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
	      return true;
	    }
	    return false;
	  }
	};
	var ProgressTracker = _ProgressTracker;
	__publicField(ProgressTracker, "steps", 100);

	// src/palette/neuquant/neuquant.ts
	var networkBiasShift = 3;
	var Neuron = class {
	  constructor(defaultValue) {
	    __publicField(this, "r");
	    __publicField(this, "g");
	    __publicField(this, "b");
	    __publicField(this, "a");
	    this.r = this.g = this.b = this.a = defaultValue;
	  }
	  toPoint() {
	    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
	  }
	  subtract(r, g, b, a) {
	    this.r -= r | 0;
	    this.g -= g | 0;
	    this.b -= b | 0;
	    this.a -= a | 0;
	  }
	};
	var _NeuQuant = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256) {
	    super();
	    __publicField(this, "_pointArray");
	    __publicField(this, "_networkSize");
	    __publicField(this, "_network");
	    __publicField(this, "_sampleFactor");
	    __publicField(this, "_radPower");
	    __publicField(this, "_freq");
	    __publicField(this, "_bias");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._pointArray = [];
	    this._sampleFactor = 1;
	    this._networkSize = colors;
	    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
	  }
	  sample(pointContainer) {
	    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
	  }
	  *quantize() {
	    this._init();
	    yield* this._learn();
	    yield {
	      palette: this._buildPalette(),
	      progress: 100
	    };
	  }
	  _init() {
	    this._freq = [];
	    this._bias = [];
	    this._radPower = [];
	    this._network = [];
	    for (let i = 0; i < this._networkSize; i++) {
	      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
	      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;
	      this._bias[i] = 0;
	    }
	  }
	  *_learn() {
	    let sampleFactor = this._sampleFactor;
	    const pointsNumber = this._pointArray.length;
	    if (pointsNumber < _NeuQuant._minpicturebytes)
	      sampleFactor = 1;
	    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
	    const pointsToSample = pointsNumber / sampleFactor | 0;
	    let delta = pointsToSample / _NeuQuant._nCycles | 0;
	    let alpha = _NeuQuant._initAlpha;
	    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
	    let rad = radius >> _NeuQuant._radiusBiasShift;
	    if (rad <= 1)
	      rad = 0;
	    for (let i = 0; i < rad; i++) {
	      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
	    }
	    let step;
	    if (pointsNumber < _NeuQuant._minpicturebytes) {
	      step = 1;
	    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
	      step = _NeuQuant._prime1;
	    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
	      step = _NeuQuant._prime2;
	    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
	      step = _NeuQuant._prime3;
	    } else {
	      step = _NeuQuant._prime4;
	    }
	    const tracker = new ProgressTracker(pointsToSample, 99);
	    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
	      if (tracker.shouldNotify(i)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      const point = this._pointArray[pointIndex];
	      const b = point.b << networkBiasShift;
	      const g = point.g << networkBiasShift;
	      const r = point.r << networkBiasShift;
	      const a = point.a << networkBiasShift;
	      const neuronIndex = this._contest(b, g, r, a);
	      this._alterSingle(alpha, neuronIndex, b, g, r, a);
	      if (rad !== 0)
	        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
	      pointIndex += step;
	      if (pointIndex >= pointsNumber)
	        pointIndex -= pointsNumber;
	      i++;
	      if (delta === 0)
	        delta = 1;
	      if (i % delta === 0) {
	        alpha -= alpha / alphadec | 0;
	        radius -= radius / _NeuQuant._radiusDecrease | 0;
	        rad = radius >> _NeuQuant._radiusBiasShift;
	        if (rad <= 1)
	          rad = 0;
	        for (let j = 0; j < rad; j++) {
	          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
	        }
	      }
	    }
	  }
	  _buildPalette() {
	    const palette = new Palette();
	    this._network.forEach((neuron) => {
	      palette.add(neuron.toPoint());
	    });
	    palette.sort();
	    return palette;
	  }
	  _alterNeighbour(rad, i, b, g, r, al) {
	    let lo = i - rad;
	    if (lo < -1)
	      lo = -1;
	    let hi = i + rad;
	    if (hi > this._networkSize)
	      hi = this._networkSize;
	    let j = i + 1;
	    let k = i - 1;
	    let m = 1;
	    while (j < hi || k > lo) {
	      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
	      if (j < hi) {
	        const p = this._network[j++];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	      if (k > lo) {
	        const p = this._network[k--];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	    }
	  }
	  _alterSingle(alpha, i, b, g, r, a) {
	    alpha /= _NeuQuant._initAlpha;
	    const n = this._network[i];
	    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
	  }
	  _contest(b, g, r, a) {
	    const multiplier = 255 * 4 << networkBiasShift;
	    let bestd = 2147483647;
	    let bestbiasd = bestd;
	    let bestpos = -1;
	    let bestbiaspos = bestpos;
	    for (let i = 0; i < this._networkSize; i++) {
	      const n = this._network[i];
	      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
	      if (dist < bestd) {
	        bestd = dist;
	        bestpos = i;
	      }
	      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);
	      if (biasdist < bestbiasd) {
	        bestbiasd = biasdist;
	        bestbiaspos = i;
	      }
	      const betafreq = this._freq[i] >> _NeuQuant._betaShift;
	      this._freq[i] -= betafreq;
	      this._bias[i] += betafreq << _NeuQuant._gammaShift;
	    }
	    this._freq[bestpos] += _NeuQuant._beta;
	    this._bias[bestpos] -= _NeuQuant._betaGamma;
	    return bestbiaspos;
	  }
	};
	var NeuQuant = _NeuQuant;
	__publicField(NeuQuant, "_prime1", 499);
	__publicField(NeuQuant, "_prime2", 491);
	__publicField(NeuQuant, "_prime3", 487);
	__publicField(NeuQuant, "_prime4", 503);
	__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
	__publicField(NeuQuant, "_nCycles", 100);
	__publicField(NeuQuant, "_initialBiasShift", 16);
	__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
	__publicField(NeuQuant, "_gammaShift", 10);
	__publicField(NeuQuant, "_betaShift", 10);
	__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
	__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
	__publicField(NeuQuant, "_radiusBiasShift", 6);
	__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
	__publicField(NeuQuant, "_radiusDecrease", 30);
	__publicField(NeuQuant, "_alphaBiasShift", 10);
	__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
	__publicField(NeuQuant, "_radBiasShift", 8);
	__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
	__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
	__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);

	// src/palette/neuquant/neuquantFloat.ts
	var networkBiasShift2 = 3;
	var NeuronFloat = class {
	  constructor(defaultValue) {
	    __publicField(this, "r");
	    __publicField(this, "g");
	    __publicField(this, "b");
	    __publicField(this, "a");
	    this.r = this.g = this.b = this.a = defaultValue;
	  }
	  toPoint() {
	    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
	  }
	  subtract(r, g, b, a) {
	    this.r -= r;
	    this.g -= g;
	    this.b -= b;
	    this.a -= a;
	  }
	};
	var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256) {
	    super();
	    __publicField(this, "_pointArray");
	    __publicField(this, "_networkSize");
	    __publicField(this, "_network");
	    __publicField(this, "_sampleFactor");
	    __publicField(this, "_radPower");
	    __publicField(this, "_freq");
	    __publicField(this, "_bias");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._pointArray = [];
	    this._sampleFactor = 1;
	    this._networkSize = colors;
	    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
	  }
	  sample(pointContainer) {
	    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
	  }
	  *quantize() {
	    this._init();
	    yield* this._learn();
	    yield {
	      palette: this._buildPalette(),
	      progress: 100
	    };
	  }
	  _init() {
	    this._freq = [];
	    this._bias = [];
	    this._radPower = [];
	    this._network = [];
	    for (let i = 0; i < this._networkSize; i++) {
	      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);
	      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;
	      this._bias[i] = 0;
	    }
	  }
	  *_learn() {
	    let sampleFactor = this._sampleFactor;
	    const pointsNumber = this._pointArray.length;
	    if (pointsNumber < _NeuQuantFloat._minpicturebytes)
	      sampleFactor = 1;
	    const alphadec = 30 + (sampleFactor - 1) / 3;
	    const pointsToSample = pointsNumber / sampleFactor;
	    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
	    let alpha = _NeuQuantFloat._initAlpha;
	    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
	    let rad = radius >> _NeuQuantFloat._radiusBiasShift;
	    if (rad <= 1)
	      rad = 0;
	    for (let i = 0; i < rad; i++) {
	      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
	    }
	    let step;
	    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
	      step = 1;
	    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
	      step = _NeuQuantFloat._prime1;
	    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
	      step = _NeuQuantFloat._prime2;
	    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
	      step = _NeuQuantFloat._prime3;
	    } else {
	      step = _NeuQuantFloat._prime4;
	    }
	    const tracker = new ProgressTracker(pointsToSample, 99);
	    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
	      if (tracker.shouldNotify(i)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      const point = this._pointArray[pointIndex];
	      const b = point.b << networkBiasShift2;
	      const g = point.g << networkBiasShift2;
	      const r = point.r << networkBiasShift2;
	      const a = point.a << networkBiasShift2;
	      const neuronIndex = this._contest(b, g, r, a);
	      this._alterSingle(alpha, neuronIndex, b, g, r, a);
	      if (rad !== 0)
	        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
	      pointIndex += step;
	      if (pointIndex >= pointsNumber)
	        pointIndex -= pointsNumber;
	      i++;
	      if (delta === 0)
	        delta = 1;
	      if (i % delta === 0) {
	        alpha -= alpha / alphadec;
	        radius -= radius / _NeuQuantFloat._radiusDecrease;
	        rad = radius >> _NeuQuantFloat._radiusBiasShift;
	        if (rad <= 1)
	          rad = 0;
	        for (let j = 0; j < rad; j++) {
	          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
	        }
	      }
	    }
	  }
	  _buildPalette() {
	    const palette = new Palette();
	    this._network.forEach((neuron) => {
	      palette.add(neuron.toPoint());
	    });
	    palette.sort();
	    return palette;
	  }
	  _alterNeighbour(rad, i, b, g, r, al) {
	    let lo = i - rad;
	    if (lo < -1)
	      lo = -1;
	    let hi = i + rad;
	    if (hi > this._networkSize)
	      hi = this._networkSize;
	    let j = i + 1;
	    let k = i - 1;
	    let m = 1;
	    while (j < hi || k > lo) {
	      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
	      if (j < hi) {
	        const p = this._network[j++];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	      if (k > lo) {
	        const p = this._network[k--];
	        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
	      }
	    }
	  }
	  _alterSingle(alpha, i, b, g, r, a) {
	    alpha /= _NeuQuantFloat._initAlpha;
	    const n = this._network[i];
	    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
	  }
	  _contest(b, g, r, al) {
	    const multiplier = 255 * 4 << networkBiasShift2;
	    let bestd = 2147483647;
	    let bestbiasd = bestd;
	    let bestpos = -1;
	    let bestbiaspos = bestpos;
	    for (let i = 0; i < this._networkSize; i++) {
	      const n = this._network[i];
	      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
	      if (dist < bestd) {
	        bestd = dist;
	        bestpos = i;
	      }
	      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
	      if (biasdist < bestbiasd) {
	        bestbiasd = biasdist;
	        bestbiaspos = i;
	      }
	      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
	      this._freq[i] -= betafreq;
	      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
	    }
	    this._freq[bestpos] += _NeuQuantFloat._beta;
	    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
	    return bestbiaspos;
	  }
	};
	var NeuQuantFloat = _NeuQuantFloat;
	__publicField(NeuQuantFloat, "_prime1", 499);
	__publicField(NeuQuantFloat, "_prime2", 491);
	__publicField(NeuQuantFloat, "_prime3", 487);
	__publicField(NeuQuantFloat, "_prime4", 503);
	__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
	__publicField(NeuQuantFloat, "_nCycles", 100);
	__publicField(NeuQuantFloat, "_initialBiasShift", 16);
	__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
	__publicField(NeuQuantFloat, "_gammaShift", 10);
	__publicField(NeuQuantFloat, "_betaShift", 10);
	__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
	__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
	__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
	__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
	__publicField(NeuQuantFloat, "_radiusDecrease", 30);
	__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
	__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
	__publicField(NeuQuantFloat, "_radBiasShift", 8);
	__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
	__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
	__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);

	// src/palette/rgbquant/colorHistogram.ts
	var _ColorHistogram = class {
	  constructor(method, colors) {
	    __publicField(this, "_method");
	    __publicField(this, "_hueStats");
	    __publicField(this, "_histogram");
	    __publicField(this, "_initColors");
	    __publicField(this, "_minHueCols");
	    this._method = method;
	    this._minHueCols = colors << 2;
	    this._initColors = colors << 2;
	    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
	    this._histogram = /* @__PURE__ */ Object.create(null);
	  }
	  sample(pointContainer) {
	    switch (this._method) {
	      case 1:
	        this._colorStats1D(pointContainer);
	        break;
	      case 2:
	        this._colorStats2D(pointContainer);
	        break;
	    }
	  }
	  getImportanceSortedColorsIDXI32() {
	    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
	    if (sorted.length === 0) {
	      return [];
	    }
	    let idxi32;
	    switch (this._method) {
	      case 1:
	        const initialColorsLimit = Math.min(sorted.length, this._initColors);
	        const last = sorted[initialColorsLimit - 1];
	        const freq = this._histogram[last];
	        idxi32 = sorted.slice(0, initialColorsLimit);
	        let pos = initialColorsLimit;
	        const len = sorted.length;
	        while (pos < len && this._histogram[sorted[pos]] === freq) {
	          idxi32.push(sorted[pos++]);
	        }
	        this._hueStats.injectIntoArray(idxi32);
	        break;
	      case 2:
	        idxi32 = sorted;
	        break;
	      default:
	        throw new Error("Incorrect method");
	    }
	    return idxi32.map((v) => +v);
	  }
	  _colorStats1D(pointContainer) {
	    const histG = this._histogram;
	    const pointArray = pointContainer.getPointArray();
	    const len = pointArray.length;
	    for (let i = 0; i < len; i++) {
	      const col = pointArray[i].uint32;
	      this._hueStats.check(col);
	      if (col in histG) {
	        histG[col]++;
	      } else {
	        histG[col] = 1;
	      }
	    }
	  }
	  _colorStats2D(pointContainer) {
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const pointArray = pointContainer.getPointArray();
	    const boxW = _ColorHistogram._boxSize[0];
	    const boxH = _ColorHistogram._boxSize[1];
	    const area = boxW * boxH;
	    const boxes = this._makeBoxes(width, height, boxW, boxH);
	    const histG = this._histogram;
	    boxes.forEach((box) => {
	      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
	      if (effc < 2)
	        effc = 2;
	      const histL = {};
	      this._iterateBox(box, width, (i) => {
	        const col = pointArray[i].uint32;
	        this._hueStats.check(col);
	        if (col in histG) {
	          histG[col]++;
	        } else if (col in histL) {
	          if (++histL[col] >= effc) {
	            histG[col] = histL[col];
	          }
	        } else {
	          histL[col] = 1;
	        }
	      });
	    });
	    this._hueStats.injectIntoDictionary(histG);
	  }
	  _iterateBox(bbox, wid, fn) {
	    const b = bbox;
	    const i0 = b.y * wid + b.x;
	    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
	    const incr = wid - b.w + 1;
	    let cnt = 0;
	    let i = i0;
	    do {
	      fn.call(this, i);
	      i += ++cnt % b.w === 0 ? incr : 1;
	    } while (i <= i1);
	  }
	  _makeBoxes(width, height, stepX, stepY) {
	    const wrem = width % stepX;
	    const hrem = height % stepY;
	    const xend = width - wrem;
	    const yend = height - hrem;
	    const boxesArray = [];
	    for (let y2 = 0; y2 < height; y2 += stepY) {
	      for (let x2 = 0; x2 < width; x2 += stepX) {
	        boxesArray.push({
	          x: x2,
	          y: y2,
	          w: x2 === xend ? wrem : stepX,
	          h: y2 === yend ? hrem : stepY
	        });
	      }
	    }
	    return boxesArray;
	  }
	};
	var ColorHistogram = _ColorHistogram;
	__publicField(ColorHistogram, "_boxSize", [64, 64]);
	__publicField(ColorHistogram, "_boxPixels", 2);
	__publicField(ColorHistogram, "_hueGroups", 10);

	// src/palette/rgbquant/rgbquant.ts
	var RemovedColor = class {
	  constructor(index, color, distance) {
	    __publicField(this, "index");
	    __publicField(this, "color");
	    __publicField(this, "distance");
	    this.index = index;
	    this.color = color;
	    this.distance = distance;
	  }
	};
	var RGBQuant = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256, method = 2) {
	    super();
	    __publicField(this, "_colors");
	    __publicField(this, "_initialDistance");
	    __publicField(this, "_distanceIncrement");
	    __publicField(this, "_histogram");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._colors = colors;
	    this._histogram = new ColorHistogram(method, colors);
	    this._initialDistance = 0.01;
	    this._distanceIncrement = 5e-3;
	  }
	  sample(image) {
	    this._histogram.sample(image);
	  }
	  *quantize() {
	    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
	    if (idxi32.length === 0) {
	      throw new Error("No colors in image");
	    }
	    yield* this._buildPalette(idxi32);
	  }
	  *_buildPalette(idxi32) {
	    const palette = new Palette();
	    const colorArray = palette.getPointContainer().getPointArray();
	    const usageArray = new Array(idxi32.length);
	    for (let i = 0; i < idxi32.length; i++) {
	      colorArray.push(Point.createByUint32(idxi32[i]));
	      usageArray[i] = 1;
	    }
	    const len = colorArray.length;
	    const memDist = [];
	    let palLen = len;
	    let thold = this._initialDistance;
	    const tracker = new ProgressTracker(palLen - this._colors, 99);
	    while (palLen > this._colors) {
	      memDist.length = 0;
	      for (let i = 0; i < len; i++) {
	        if (tracker.shouldNotify(len - palLen)) {
	          yield {
	            progress: tracker.progress
	          };
	        }
	        if (usageArray[i] === 0)
	          continue;
	        const pxi = colorArray[i];
	        for (let j = i + 1; j < len; j++) {
	          if (usageArray[j] === 0)
	            continue;
	          const pxj = colorArray[j];
	          const dist = this._distance.calculateNormalized(pxi, pxj);
	          if (dist < thold) {
	            memDist.push(new RemovedColor(j, pxj, dist));
	            usageArray[j] = 0;
	            palLen--;
	          }
	        }
	      }
	      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
	    }
	    if (palLen < this._colors) {
	      stableSort(memDist, (a, b) => b.distance - a.distance);
	      let k = 0;
	      while (palLen < this._colors && k < memDist.length) {
	        const removedColor = memDist[k];
	        usageArray[removedColor.index] = 1;
	        palLen++;
	        k++;
	      }
	    }
	    let colors = colorArray.length;
	    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
	      if (usageArray[colorIndex] === 0) {
	        if (colorIndex !== colors - 1) {
	          colorArray[colorIndex] = colorArray[colors - 1];
	        }
	        --colors;
	      }
	    }
	    colorArray.length = colors;
	    palette.sort();
	    yield {
	      palette,
	      progress: 100
	    };
	  }
	};

	// src/palette/wu/wuQuant.ts
	function createArray1D(dimension1) {
	  const a = [];
	  for (let k = 0; k < dimension1; k++) {
	    a[k] = 0;
	  }
	  return a;
	}
	function createArray4D(dimension1, dimension2, dimension3, dimension4) {
	  const a = new Array(dimension1);
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = new Array(dimension2);
	    for (let j = 0; j < dimension2; j++) {
	      a[i][j] = new Array(dimension3);
	      for (let k = 0; k < dimension3; k++) {
	        a[i][j][k] = new Array(dimension4);
	        for (let l = 0; l < dimension4; l++) {
	          a[i][j][k][l] = 0;
	        }
	      }
	    }
	  }
	  return a;
	}
	function createArray3D(dimension1, dimension2, dimension3) {
	  const a = new Array(dimension1);
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = new Array(dimension2);
	    for (let j = 0; j < dimension2; j++) {
	      a[i][j] = new Array(dimension3);
	      for (let k = 0; k < dimension3; k++) {
	        a[i][j][k] = 0;
	      }
	    }
	  }
	  return a;
	}
	function fillArray3D(a, dimension1, dimension2, dimension3, value) {
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = [];
	    for (let j = 0; j < dimension2; j++) {
	      a[i][j] = [];
	      for (let k = 0; k < dimension3; k++) {
	        a[i][j][k] = value;
	      }
	    }
	  }
	}
	function fillArray1D(a, dimension1, value) {
	  for (let i = 0; i < dimension1; i++) {
	    a[i] = value;
	  }
	}
	var WuColorCube = class {
	  constructor() {
	    __publicField(this, "redMinimum");
	    __publicField(this, "redMaximum");
	    __publicField(this, "greenMinimum");
	    __publicField(this, "greenMaximum");
	    __publicField(this, "blueMinimum");
	    __publicField(this, "blueMaximum");
	    __publicField(this, "volume");
	    __publicField(this, "alphaMinimum");
	    __publicField(this, "alphaMaximum");
	  }
	};
	var _WuQuant = class extends AbstractPaletteQuantizer {
	  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
	    super();
	    __publicField(this, "_reds");
	    __publicField(this, "_greens");
	    __publicField(this, "_blues");
	    __publicField(this, "_alphas");
	    __publicField(this, "_sums");
	    __publicField(this, "_weights");
	    __publicField(this, "_momentsRed");
	    __publicField(this, "_momentsGreen");
	    __publicField(this, "_momentsBlue");
	    __publicField(this, "_momentsAlpha");
	    __publicField(this, "_moments");
	    __publicField(this, "_table");
	    __publicField(this, "_pixels");
	    __publicField(this, "_cubes");
	    __publicField(this, "_colors");
	    __publicField(this, "_significantBitsPerChannel");
	    __publicField(this, "_maxSideIndex");
	    __publicField(this, "_alphaMaxSideIndex");
	    __publicField(this, "_sideSize");
	    __publicField(this, "_alphaSideSize");
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	    this._setQuality(significantBitsPerChannel);
	    this._initialize(colors);
	  }
	  sample(image) {
	    const pointArray = image.getPointArray();
	    for (let i = 0, l = pointArray.length; i < l; i++) {
	      this._addColor(pointArray[i]);
	    }
	    this._pixels = this._pixels.concat(pointArray);
	  }
	  *quantize() {
	    yield* this._preparePalette();
	    const palette = new Palette();
	    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
	      if (this._sums[paletteIndex] > 0) {
	        const sum = this._sums[paletteIndex];
	        const r = this._reds[paletteIndex] / sum;
	        const g = this._greens[paletteIndex] / sum;
	        const b = this._blues[paletteIndex] / sum;
	        const a = this._alphas[paletteIndex] / sum;
	        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
	        palette.add(color);
	      }
	    }
	    palette.sort();
	    yield {
	      palette,
	      progress: 100
	    };
	  }
	  *_preparePalette() {
	    yield* this._calculateMoments();
	    let next = 0;
	    const volumeVariance = createArray1D(this._colors);
	    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
	      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
	        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
	        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
	      } else {
	        volumeVariance[next] = 0;
	        cubeIndex--;
	      }
	      next = 0;
	      let temp = volumeVariance[0];
	      for (let index = 1; index <= cubeIndex; ++index) {
	        if (volumeVariance[index] > temp) {
	          temp = volumeVariance[index];
	          next = index;
	        }
	      }
	      if (temp <= 0) {
	        this._colors = cubeIndex + 1;
	        break;
	      }
	    }
	    const lookupRed = [];
	    const lookupGreen = [];
	    const lookupBlue = [];
	    const lookupAlpha = [];
	    for (let k = 0; k < this._colors; ++k) {
	      const weight = _WuQuant._volume(this._cubes[k], this._weights);
	      if (weight > 0) {
	        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
	        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
	        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
	        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
	      } else {
	        lookupRed[k] = 0;
	        lookupGreen[k] = 0;
	        lookupBlue[k] = 0;
	        lookupAlpha[k] = 0;
	      }
	    }
	    this._reds = createArray1D(this._colors + 1);
	    this._greens = createArray1D(this._colors + 1);
	    this._blues = createArray1D(this._colors + 1);
	    this._alphas = createArray1D(this._colors + 1);
	    this._sums = createArray1D(this._colors + 1);
	    for (let index = 0, l = this._pixels.length; index < l; index++) {
	      const color = this._pixels[index];
	      const match = -1;
	      let bestMatch = match;
	      let bestDistance = Number.MAX_VALUE;
	      for (let lookup = 0; lookup < this._colors; lookup++) {
	        const foundRed = lookupRed[lookup];
	        const foundGreen = lookupGreen[lookup];
	        const foundBlue = lookupBlue[lookup];
	        const foundAlpha = lookupAlpha[lookup];
	        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
	        if (distance < bestDistance) {
	          bestDistance = distance;
	          bestMatch = lookup;
	        }
	      }
	      this._reds[bestMatch] += color.r;
	      this._greens[bestMatch] += color.g;
	      this._blues[bestMatch] += color.b;
	      this._alphas[bestMatch] += color.a;
	      this._sums[bestMatch]++;
	    }
	  }
	  _addColor(color) {
	    const bitsToRemove = 8 - this._significantBitsPerChannel;
	    const indexRed = (color.r >> bitsToRemove) + 1;
	    const indexGreen = (color.g >> bitsToRemove) + 1;
	    const indexBlue = (color.b >> bitsToRemove) + 1;
	    const indexAlpha = (color.a >> bitsToRemove) + 1;
	    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
	    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
	    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
	    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
	    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
	    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
	  }
	  *_calculateMoments() {
	    const area = [];
	    const areaRed = [];
	    const areaGreen = [];
	    const areaBlue = [];
	    const areaAlpha = [];
	    const area2 = [];
	    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
	    let trackerProgress = 0;
	    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
	    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
	      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
	      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
	      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
	        if (tracker.shouldNotify(trackerProgress)) {
	          yield {
	            progress: tracker.progress
	          };
	        }
	        fillArray1D(area, this._sideSize, 0);
	        fillArray1D(areaRed, this._sideSize, 0);
	        fillArray1D(areaGreen, this._sideSize, 0);
	        fillArray1D(areaBlue, this._sideSize, 0);
	        fillArray1D(areaAlpha, this._sideSize, 0);
	        fillArray1D(area2, this._sideSize, 0);
	        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
	          let line = 0;
	          let lineRed = 0;
	          let lineGreen = 0;
	          let lineBlue = 0;
	          let lineAlpha = 0;
	          let line2 = 0;
	          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
	            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
	            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
	            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
	            area[blueIndex] += line;
	            areaRed[blueIndex] += lineRed;
	            areaGreen[blueIndex] += lineGreen;
	            areaBlue[blueIndex] += lineBlue;
	            areaAlpha[blueIndex] += lineAlpha;
	            area2[blueIndex] += line2;
	            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
	            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
	            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
	            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
	            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
	            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
	            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
	            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
	            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
	            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
	            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
	            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
	          }
	        }
	      }
	    }
	  }
	  static _volumeFloat(cube, moment) {
	    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	  }
	  static _volume(cube, moment) {
	    return _WuQuant._volumeFloat(cube, moment) | 0;
	  }
	  static _top(cube, direction, position, moment) {
	    let result;
	    switch (direction) {
	      case _WuQuant._alpha:
	        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	        break;
	      case _WuQuant._red:
	        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
	        break;
	      case _WuQuant._green:
	        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
	        break;
	      case _WuQuant._blue:
	        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
	        break;
	      default:
	        throw new Error("impossible");
	    }
	    return result | 0;
	  }
	  static _bottom(cube, direction, moment) {
	    switch (direction) {
	      case _WuQuant._alpha:
	        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      case _WuQuant._red:
	        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      case _WuQuant._green:
	        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      case _WuQuant._blue:
	        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
	      default:
	        return 0;
	    }
	  }
	  _calculateVariance(cube) {
	    const volumeRed = _WuQuant._volume(cube, this._momentsRed);
	    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
	    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
	    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
	    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
	    const volumeWeight = _WuQuant._volume(cube, this._weights);
	    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
	    return volumeMoment - distance / volumeWeight;
	  }
	  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
	    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
	    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
	    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
	    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
	    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
	    let result = 0;
	    let cutPosition = -1;
	    for (let position = first; position < last; ++position) {
	      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
	      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
	      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
	      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
	      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
	      if (halfWeight !== 0) {
	        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
	        let temp = halfDistance / halfWeight;
	        halfRed = wholeRed - halfRed;
	        halfGreen = wholeGreen - halfGreen;
	        halfBlue = wholeBlue - halfBlue;
	        halfAlpha = wholeAlpha - halfAlpha;
	        halfWeight = wholeWeight - halfWeight;
	        if (halfWeight !== 0) {
	          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
	          temp += halfDistance / halfWeight;
	          if (temp > result) {
	            result = temp;
	            cutPosition = position;
	          }
	        }
	      }
	    }
	    return { max: result, position: cutPosition };
	  }
	  _cut(first, second) {
	    let direction;
	    const wholeRed = _WuQuant._volume(first, this._momentsRed);
	    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
	    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
	    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
	    const wholeWeight = _WuQuant._volume(first, this._weights);
	    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
	    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
	      direction = _WuQuant._alpha;
	      if (alpha.position < 0)
	        return false;
	    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
	      direction = _WuQuant._red;
	    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
	      direction = _WuQuant._green;
	    } else {
	      direction = _WuQuant._blue;
	    }
	    second.redMaximum = first.redMaximum;
	    second.greenMaximum = first.greenMaximum;
	    second.blueMaximum = first.blueMaximum;
	    second.alphaMaximum = first.alphaMaximum;
	    switch (direction) {
	      case _WuQuant._red:
	        second.redMinimum = first.redMaximum = red.position;
	        second.greenMinimum = first.greenMinimum;
	        second.blueMinimum = first.blueMinimum;
	        second.alphaMinimum = first.alphaMinimum;
	        break;
	      case _WuQuant._green:
	        second.greenMinimum = first.greenMaximum = green.position;
	        second.redMinimum = first.redMinimum;
	        second.blueMinimum = first.blueMinimum;
	        second.alphaMinimum = first.alphaMinimum;
	        break;
	      case _WuQuant._blue:
	        second.blueMinimum = first.blueMaximum = blue.position;
	        second.redMinimum = first.redMinimum;
	        second.greenMinimum = first.greenMinimum;
	        second.alphaMinimum = first.alphaMinimum;
	        break;
	      case _WuQuant._alpha:
	        second.alphaMinimum = first.alphaMaximum = alpha.position;
	        second.blueMinimum = first.blueMinimum;
	        second.redMinimum = first.redMinimum;
	        second.greenMinimum = first.greenMinimum;
	        break;
	    }
	    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
	    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
	    return true;
	  }
	  _initialize(colors) {
	    this._colors = colors;
	    this._cubes = [];
	    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
	      this._cubes[cubeIndex] = new WuColorCube();
	    }
	    this._cubes[0].redMinimum = 0;
	    this._cubes[0].greenMinimum = 0;
	    this._cubes[0].blueMinimum = 0;
	    this._cubes[0].alphaMinimum = 0;
	    this._cubes[0].redMaximum = this._maxSideIndex;
	    this._cubes[0].greenMaximum = this._maxSideIndex;
	    this._cubes[0].blueMaximum = this._maxSideIndex;
	    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
	    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
	    this._table = [];
	    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
	      this._table[tableIndex] = tableIndex * tableIndex;
	    }
	    this._pixels = [];
	  }
	  _setQuality(significantBitsPerChannel = 5) {
	    this._significantBitsPerChannel = significantBitsPerChannel;
	    this._maxSideIndex = 1 << this._significantBitsPerChannel;
	    this._alphaMaxSideIndex = this._maxSideIndex;
	    this._sideSize = this._maxSideIndex + 1;
	    this._alphaSideSize = this._alphaMaxSideIndex + 1;
	  }
	};
	var WuQuant = _WuQuant;
	__publicField(WuQuant, "_alpha", 3);
	__publicField(WuQuant, "_red", 2);
	__publicField(WuQuant, "_green", 1);
	__publicField(WuQuant, "_blue", 0);

	// src/image/index.ts
	var image_exports = {};
	__export(image_exports, {
	  AbstractImageQuantizer: () => AbstractImageQuantizer,
	  ErrorDiffusionArray: () => ErrorDiffusionArray,
	  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
	  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
	  NearestColor: () => NearestColor
	});

	// src/image/imageQuantizer.ts
	var AbstractImageQuantizer = class {
	  quantizeSync(pointContainer, palette) {
	    for (const value of this.quantize(pointContainer, palette)) {
	      if (value.pointContainer) {
	        return value.pointContainer;
	      }
	    }
	    throw new Error("unreachable");
	  }
	};

	// src/image/nearestColor.ts
	var NearestColor = class extends AbstractImageQuantizer {
	  constructor(colorDistanceCalculator) {
	    super();
	    __publicField(this, "_distance");
	    this._distance = colorDistanceCalculator;
	  }
	  *quantize(pointContainer, palette) {
	    const pointArray = pointContainer.getPointArray();
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const tracker = new ProgressTracker(height, 99);
	    for (let y2 = 0; y2 < height; y2++) {
	      if (tracker.shouldNotify(y2)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
	        const point = pointArray[idx];
	        point.from(palette.getNearestColor(this._distance, point));
	      }
	    }
	    yield {
	      pointContainer,
	      progress: 100
	    };
	  }
	};

	// src/image/array.ts
	var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
	  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
	  return ErrorDiffusionArrayKernel2;
	})(ErrorDiffusionArrayKernel || {});
	var ErrorDiffusionArray = class extends AbstractImageQuantizer {
	  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
	    super();
	    __publicField(this, "_minColorDistance");
	    __publicField(this, "_serpentine");
	    __publicField(this, "_kernel");
	    __publicField(this, "_calculateErrorLikeGIMP");
	    __publicField(this, "_distance");
	    this._setKernel(kernel);
	    this._distance = colorDistanceCalculator;
	    this._minColorDistance = minimumColorDistanceToDither;
	    this._serpentine = serpentine;
	    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
	  }
	  *quantize(pointContainer, palette) {
	    const pointArray = pointContainer.getPointArray();
	    const originalPoint = new Point();
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const errorLines = [];
	    let dir = 1;
	    let maxErrorLines = 1;
	    for (const kernel of this._kernel) {
	      const kernelErrorLines = kernel[2] + 1;
	      if (maxErrorLines < kernelErrorLines)
	        maxErrorLines = kernelErrorLines;
	    }
	    for (let i = 0; i < maxErrorLines; i++) {
	      this._fillErrorLine(errorLines[i] = [], width);
	    }
	    const tracker = new ProgressTracker(height, 99);
	    for (let y2 = 0; y2 < height; y2++) {
	      if (tracker.shouldNotify(y2)) {
	        yield {
	          progress: tracker.progress
	        };
	      }
	      if (this._serpentine)
	        dir *= -1;
	      const lni = y2 * width;
	      const xStart = dir === 1 ? 0 : width - 1;
	      const xEnd = dir === 1 ? width : -1;
	      this._fillErrorLine(errorLines[0], width);
	      errorLines.push(errorLines.shift());
	      const errorLine = errorLines[0];
	      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
	        const point = pointArray[idx];
	        const error = errorLine[x2];
	        originalPoint.from(point);
	        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
	        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);
	        point.from(palettePoint);
	        if (this._minColorDistance) {
	          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
	          if (dist < this._minColorDistance)
	            continue;
	        }
	        let er;
	        let eg;
	        let eb;
	        let ea;
	        if (this._calculateErrorLikeGIMP) {
	          er = correctedPoint.r - palettePoint.r;
	          eg = correctedPoint.g - palettePoint.g;
	          eb = correctedPoint.b - palettePoint.b;
	          ea = correctedPoint.a - palettePoint.a;
	        } else {
	          er = originalPoint.r - palettePoint.r;
	          eg = originalPoint.g - palettePoint.g;
	          eb = originalPoint.b - palettePoint.b;
	          ea = originalPoint.a - palettePoint.a;
	        }
	        const dStart = dir === 1 ? 0 : this._kernel.length - 1;
	        const dEnd = dir === 1 ? this._kernel.length : -1;
	        for (let i = dStart; i !== dEnd; i += dir) {
	          const x1 = this._kernel[i][1] * dir;
	          const y1 = this._kernel[i][2];
	          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
	            const d = this._kernel[i][0];
	            const e = errorLines[y1][x1 + x2];
	            e[0] += er * d;
	            e[1] += eg * d;
	            e[2] += eb * d;
	            e[3] += ea * d;
	          }
	        }
	      }
	    }
	    yield {
	      pointContainer,
	      progress: 100
	    };
	  }
	  _fillErrorLine(errorLine, width) {
	    if (errorLine.length > width) {
	      errorLine.length = width;
	    }
	    const l = errorLine.length;
	    for (let i = 0; i < l; i++) {
	      const error = errorLine[i];
	      error[0] = error[1] = error[2] = error[3] = 0;
	    }
	    for (let i = l; i < width; i++) {
	      errorLine[i] = [0, 0, 0, 0];
	    }
	  }
	  _setKernel(kernel) {
	    switch (kernel) {
	      case 0 /* FloydSteinberg */:
	        this._kernel = [
	          [7 / 16, 1, 0],
	          [3 / 16, -1, 1],
	          [5 / 16, 0, 1],
	          [1 / 16, 1, 1]
	        ];
	        break;
	      case 1 /* FalseFloydSteinberg */:
	        this._kernel = [
	          [3 / 8, 1, 0],
	          [3 / 8, 0, 1],
	          [2 / 8, 1, 1]
	        ];
	        break;
	      case 2 /* Stucki */:
	        this._kernel = [
	          [8 / 42, 1, 0],
	          [4 / 42, 2, 0],
	          [2 / 42, -2, 1],
	          [4 / 42, -1, 1],
	          [8 / 42, 0, 1],
	          [4 / 42, 1, 1],
	          [2 / 42, 2, 1],
	          [1 / 42, -2, 2],
	          [2 / 42, -1, 2],
	          [4 / 42, 0, 2],
	          [2 / 42, 1, 2],
	          [1 / 42, 2, 2]
	        ];
	        break;
	      case 3 /* Atkinson */:
	        this._kernel = [
	          [1 / 8, 1, 0],
	          [1 / 8, 2, 0],
	          [1 / 8, -1, 1],
	          [1 / 8, 0, 1],
	          [1 / 8, 1, 1],
	          [1 / 8, 0, 2]
	        ];
	        break;
	      case 4 /* Jarvis */:
	        this._kernel = [
	          [7 / 48, 1, 0],
	          [5 / 48, 2, 0],
	          [3 / 48, -2, 1],
	          [5 / 48, -1, 1],
	          [7 / 48, 0, 1],
	          [5 / 48, 1, 1],
	          [3 / 48, 2, 1],
	          [1 / 48, -2, 2],
	          [3 / 48, -1, 2],
	          [5 / 48, 0, 2],
	          [3 / 48, 1, 2],
	          [1 / 48, 2, 2]
	        ];
	        break;
	      case 5 /* Burkes */:
	        this._kernel = [
	          [8 / 32, 1, 0],
	          [4 / 32, 2, 0],
	          [2 / 32, -2, 1],
	          [4 / 32, -1, 1],
	          [8 / 32, 0, 1],
	          [4 / 32, 1, 1],
	          [2 / 32, 2, 1]
	        ];
	        break;
	      case 6 /* Sierra */:
	        this._kernel = [
	          [5 / 32, 1, 0],
	          [3 / 32, 2, 0],
	          [2 / 32, -2, 1],
	          [4 / 32, -1, 1],
	          [5 / 32, 0, 1],
	          [4 / 32, 1, 1],
	          [2 / 32, 2, 1],
	          [2 / 32, -1, 2],
	          [3 / 32, 0, 2],
	          [2 / 32, 1, 2]
	        ];
	        break;
	      case 7 /* TwoSierra */:
	        this._kernel = [
	          [4 / 16, 1, 0],
	          [3 / 16, 2, 0],
	          [1 / 16, -2, 1],
	          [2 / 16, -1, 1],
	          [3 / 16, 0, 1],
	          [2 / 16, 1, 1],
	          [1 / 16, 2, 1]
	        ];
	        break;
	      case 8 /* SierraLite */:
	        this._kernel = [
	          [2 / 4, 1, 0],
	          [1 / 4, -1, 1],
	          [1 / 4, 0, 1]
	        ];
	        break;
	      default:
	        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
	    }
	  }
	};

	// src/image/spaceFillingCurves/hilbertCurve.ts
	function* hilbertCurve(width, height, callback) {
	  const maxBound = Math.max(width, height);
	  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
	  const tracker = new ProgressTracker(width * height, 99);
	  const data = {
	    width,
	    height,
	    level,
	    callback,
	    tracker,
	    index: 0,
	    x: 0,
	    y: 0
	  };
	  yield* walkHilbert(data, 1 /* UP */);
	  visit(data, 0 /* NONE */);
	}
	function* walkHilbert(data, direction) {
	  if (data.level < 1)
	    return;
	  if (data.tracker.shouldNotify(data.index)) {
	    yield { progress: data.tracker.progress };
	  }
	  data.level--;
	  switch (direction) {
	    case 2 /* LEFT */:
	      yield* walkHilbert(data, 1 /* UP */);
	      visit(data, 3 /* RIGHT */);
	      yield* walkHilbert(data, 2 /* LEFT */);
	      visit(data, 4 /* DOWN */);
	      yield* walkHilbert(data, 2 /* LEFT */);
	      visit(data, 2 /* LEFT */);
	      yield* walkHilbert(data, 4 /* DOWN */);
	      break;
	    case 3 /* RIGHT */:
	      yield* walkHilbert(data, 4 /* DOWN */);
	      visit(data, 2 /* LEFT */);
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      visit(data, 1 /* UP */);
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      visit(data, 3 /* RIGHT */);
	      yield* walkHilbert(data, 1 /* UP */);
	      break;
	    case 1 /* UP */:
	      yield* walkHilbert(data, 2 /* LEFT */);
	      visit(data, 4 /* DOWN */);
	      yield* walkHilbert(data, 1 /* UP */);
	      visit(data, 3 /* RIGHT */);
	      yield* walkHilbert(data, 1 /* UP */);
	      visit(data, 1 /* UP */);
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      break;
	    case 4 /* DOWN */:
	      yield* walkHilbert(data, 3 /* RIGHT */);
	      visit(data, 1 /* UP */);
	      yield* walkHilbert(data, 4 /* DOWN */);
	      visit(data, 2 /* LEFT */);
	      yield* walkHilbert(data, 4 /* DOWN */);
	      visit(data, 4 /* DOWN */);
	      yield* walkHilbert(data, 2 /* LEFT */);
	      break;
	  }
	  data.level++;
	}
	function visit(data, direction) {
	  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
	    data.callback(data.x, data.y);
	    data.index++;
	  }
	  switch (direction) {
	    case 2 /* LEFT */:
	      data.x--;
	      break;
	    case 3 /* RIGHT */:
	      data.x++;
	      break;
	    case 1 /* UP */:
	      data.y--;
	      break;
	    case 4 /* DOWN */:
	      data.y++;
	      break;
	  }
	}

	// src/image/riemersma.ts
	var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
	  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
	    super();
	    __publicField(this, "_distance");
	    __publicField(this, "_weights");
	    __publicField(this, "_errorQueueSize");
	    this._distance = colorDistanceCalculator;
	    this._errorQueueSize = errorQueueSize;
	    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
	  }
	  *quantize(pointContainer, palette) {
	    const pointArray = pointContainer.getPointArray();
	    const width = pointContainer.getWidth();
	    const height = pointContainer.getHeight();
	    const errorQueue = [];
	    let head = 0;
	    for (let i = 0; i < this._errorQueueSize; i++) {
	      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
	    }
	    yield* hilbertCurve(width, height, (x2, y2) => {
	      const p = pointArray[x2 + y2 * width];
	      let { r, g, b, a } = p;
	      for (let i = 0; i < this._errorQueueSize; i++) {
	        const weight = this._weights[i];
	        const e = errorQueue[(i + head) % this._errorQueueSize];
	        r += e.r * weight;
	        g += e.g * weight;
	        b += e.b * weight;
	        a += e.a * weight;
	      }
	      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
	      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
	      head = (head + 1) % this._errorQueueSize;
	      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
	      errorQueue[tail].r = p.r - quantizedPoint.r;
	      errorQueue[tail].g = p.g - quantizedPoint.g;
	      errorQueue[tail].b = p.b - quantizedPoint.b;
	      errorQueue[tail].a = p.a - quantizedPoint.a;
	      p.from(quantizedPoint);
	    });
	    yield {
	      pointContainer,
	      progress: 100
	    };
	  }
	  static _createWeights(errorPropagation, errorQueueSize) {
	    const weights = [];
	    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
	    for (let i = 0, next = 1; i < errorQueueSize; i++) {
	      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
	      next *= multiplier;
	    }
	    return weights;
	  }
	};

	// src/quality/index.ts
	var quality_exports = {};
	__export(quality_exports, {
	  ssim: () => ssim
	});

	// src/quality/ssim.ts
	var K1 = 0.01;
	var K2 = 0.03;
	function ssim(image1, image2) {
	  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
	    throw new Error("Images have different sizes!");
	  }
	  const bitsPerComponent = 8;
	  const L = (1 << bitsPerComponent) - 1;
	  const c1 = (K1 * L) ** 2;
	  const c2 = (K2 * L) ** 2;
	  let numWindows = 0;
	  let mssim = 0;
	  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
	    let sigxy = 0;
	    let sigsqx = 0;
	    let sigsqy = 0;
	    for (let i = 0; i < lumaValues1.length; i++) {
	      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;
	      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;
	      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
	    }
	    const numPixelsInWin = lumaValues1.length - 1;
	    sigsqx /= numPixelsInWin;
	    sigsqy /= numPixelsInWin;
	    sigxy /= numPixelsInWin;
	    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
	    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
	    const ssim2 = numerator / denominator;
	    mssim += ssim2;
	    numWindows++;
	  });
	  return mssim / numWindows;
	}
	function iterate(image1, image2, callback) {
	  const windowSize = 8;
	  const width = image1.getWidth();
	  const height = image1.getHeight();
	  for (let y2 = 0; y2 < height; y2 += windowSize) {
	    for (let x2 = 0; x2 < width; x2 += windowSize) {
	      const windowWidth = Math.min(windowSize, width - x2);
	      const windowHeight = Math.min(windowSize, height - y2);
	      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
	      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
	      const averageLuma1 = calculateAverageLuma(lumaValues1);
	      const averageLuma2 = calculateAverageLuma(lumaValues2);
	      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
	    }
	  }
	}
	function calculateLumaValuesForWindow(image, x2, y2, width, height) {
	  const pointArray = image.getPointArray();
	  const lumaValues = [];
	  let counter = 0;
	  for (let j = y2; j < y2 + height; j++) {
	    const offset = j * image.getWidth();
	    for (let i = x2; i < x2 + width; i++) {
	      const point = pointArray[offset + i];
	      lumaValues[counter] = point.r * 0.2126 /* RED */ + point.g * 0.7152 /* GREEN */ + point.b * 0.0722 /* BLUE */;
	      counter++;
	    }
	  }
	  return lumaValues;
	}
	function calculateAverageLuma(lumaValues) {
	  let sumLuma = 0;
	  for (const luma of lumaValues) {
	    sumLuma += luma;
	  }
	  return sumLuma / lumaValues.length;
	}

	// src/basicAPI.ts
	var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? void 0 : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
	function buildPaletteSync(images, {
	  colorDistanceFormula,
	  paletteQuantization,
	  colors
	} = {}) {
	  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
	  images.forEach((image) => paletteQuantizer.sample(image));
	  return paletteQuantizer.quantizeSync();
	}
	async function buildPalette(images, {
	  colorDistanceFormula,
	  paletteQuantization,
	  colors,
	  onProgress
	} = {}) {
	  return new Promise((resolve, reject) => {
	    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
	    images.forEach((image) => paletteQuantizer.sample(image));
	    let palette;
	    const iterator = paletteQuantizer.quantize();
	    const next = () => {
	      try {
	        const result = iterator.next();
	        if (result.done) {
	          resolve(palette);
	        } else {
	          if (result.value.palette)
	            palette = result.value.palette;
	          if (onProgress)
	            onProgress(result.value.progress);
	          setImmediateImpl(next);
	        }
	      } catch (error) {
	        reject(error);
	      }
	    };
	    setImmediateImpl(next);
	  });
	}
	function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
	  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
	  return imageQuantizer.quantizeSync(image, palette);
	}
	async function applyPalette(image, palette, {
	  colorDistanceFormula,
	  imageQuantization,
	  onProgress
	} = {}) {
	  return new Promise((resolve, reject) => {
	    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
	    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
	    let outPointContainer;
	    const iterator = imageQuantizer.quantize(image, palette);
	    const next = () => {
	      try {
	        const result = iterator.next();
	        if (result.done) {
	          resolve(outPointContainer);
	        } else {
	          if (result.value.pointContainer) {
	            outPointContainer = result.value.pointContainer;
	          }
	          if (onProgress)
	            onProgress(result.value.progress);
	          setImmediateImpl(next);
	        }
	      } catch (error) {
	        reject(error);
	      }
	    };
	    setImmediateImpl(next);
	  });
	}
	function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
	  switch (colorDistanceFormula) {
	    case "cie94-graphic-arts":
	      return new CIE94GraphicArts();
	    case "cie94-textiles":
	      return new CIE94Textiles();
	    case "ciede2000":
	      return new CIEDE2000();
	    case "color-metric":
	      return new CMetric();
	    case "euclidean":
	      return new Euclidean();
	    case "euclidean-bt709":
	      return new EuclideanBT709();
	    case "euclidean-bt709-noalpha":
	      return new EuclideanBT709NoAlpha();
	    case "manhattan":
	      return new Manhattan();
	    case "manhattan-bt709":
	      return new ManhattanBT709();
	    case "manhattan-nommyde":
	      return new ManhattanNommyde();
	    case "pngquant":
	      return new PNGQuant();
	    default:
	      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
	  }
	}
	function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
	  switch (imageQuantization) {
	    case "nearest":
	      return new NearestColor(distanceCalculator);
	    case "riemersma":
	      return new ErrorDiffusionRiemersma(distanceCalculator);
	    case "floyd-steinberg":
	      return new ErrorDiffusionArray(distanceCalculator, 0 /* FloydSteinberg */);
	    case "false-floyd-steinberg":
	      return new ErrorDiffusionArray(distanceCalculator, 1 /* FalseFloydSteinberg */);
	    case "stucki":
	      return new ErrorDiffusionArray(distanceCalculator, 2 /* Stucki */);
	    case "atkinson":
	      return new ErrorDiffusionArray(distanceCalculator, 3 /* Atkinson */);
	    case "jarvis":
	      return new ErrorDiffusionArray(distanceCalculator, 4 /* Jarvis */);
	    case "burkes":
	      return new ErrorDiffusionArray(distanceCalculator, 5 /* Burkes */);
	    case "sierra":
	      return new ErrorDiffusionArray(distanceCalculator, 6 /* Sierra */);
	    case "two-sierra":
	      return new ErrorDiffusionArray(distanceCalculator, 7 /* TwoSierra */);
	    case "sierra-lite":
	      return new ErrorDiffusionArray(distanceCalculator, 8 /* SierraLite */);
	    default:
	      throw new Error(`Unknown imageQuantization ${imageQuantization}`);
	  }
	}
	function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
	  switch (paletteQuantization) {
	    case "neuquant":
	      return new NeuQuant(distanceCalculator, colors);
	    case "rgbquant":
	      return new RGBQuant(distanceCalculator, colors);
	    case "wuquant":
	      return new WuQuant(distanceCalculator, colors);
	    case "neuquant-float":
	      return new NeuQuantFloat(distanceCalculator, colors);
	    default:
	      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
	  }
	}
	imageQ = __toCommonJS(src_exports);
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * cie94.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ciede2000.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * cmetric.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * common.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * constants.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * euclidean.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * helper.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * hueStatistics.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * lab2rgb.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * lab2xyz.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * manhattanNeuQuant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * nearestColor.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * palette.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * pngQuant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * point.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * pointContainer.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2hsl.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2lab.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2xyz.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ssim.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * wuQuant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * xyz2lab.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * xyz2rgb.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve
	 * MIT License
	 *
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 *
	 * riemersma.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve TypeScript port:
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * colorHistogram.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve TypeScript port:
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * neuquant.ts - part of Image Quantization Library
	 */
	/**
	 * @preserve TypeScript port:
	 * Copyright 2015-2018 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgbquant.ts - part of Image Quantization Library
	 */
	
	return imageQ;
}

var gifframe = {};

var hasRequiredGifframe;

function requireGifframe () {
	if (hasRequiredGifframe) return gifframe;
	hasRequiredGifframe = 1;

	const BitmapImage = requireBitmapimage();
	const { GifError } = requireGif();

	/** @class GifFrame */

	class GifFrame extends BitmapImage {

	    // xOffset - x offset of bitmap on GIF (defaults to 0)
	    // yOffset - y offset of bitmap on GIF (defaults to 0)
	    // disposalMethod - pixel disposal method when handling partial images
	    // delayCentisecs - duration of frame in hundredths of a second
	    // interlaced - whether the image is interlaced (defaults to false)

	    /**
	     * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
	     * 
	     * Property | Description
	     * --- | ---
	     * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
	     * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
	     * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
	     * delayCentisecs | duration of the frame in hundreths of a second
	     * interlaced | boolean indicating whether the frame renders interlaced
	     * 
	     * Its constructor supports the following signatures:
	     * 
	     * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
	     * * new GifFrame(bitmapImage: BitmapImage, options?)
	     * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
	     * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
	     * * new GifFrame(frame: GifFrame)
	     * 
	     * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
	     * 
	     * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
	     */

	    constructor(...args) {
	        super(...args);
	        if (args[0] instanceof GifFrame) {
	            // copy a provided GifFrame
	            const source = args[0];
	            this.xOffset = source.xOffset;
	            this.yOffset = source.yOffset;
	            this.disposalMethod = source.disposalMethod;
	            this.delayCentisecs = source.delayCentisecs;
	            this.interlaced = source.interlaced;
	        }
	        else {
	            const lastArg = args[args.length - 1];
	            let options = {};
	            if (typeof lastArg === 'object' && !(lastArg instanceof BitmapImage)) {
	                options = lastArg;
	            }
	            this.xOffset = options.xOffset || 0;
	            this.yOffset = options.yOffset || 0;
	            this.disposalMethod = (options.disposalMethod !== undefined ?
	                    options.disposalMethod : GifFrame.DisposeToBackgroundColor);
	            this.delayCentisecs = options.delayCentisecs || 8;
	            this.interlaced = options.interlaced || false;
	        }
	    }

	    /**
	     * Get a summary of the colors found within the frame. The return value is an object of the following form:
	     * 
	     * Property | Description
	     * --- | ---
	     * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
	     * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
	     * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
	     * 
	     * @return {object} An object representing a color palette as described above.
	     */

	    getPalette() {
	        // returns with colors sorted low to high
	        const colorSet = new Set();
	        const buf = this.bitmap.data;
	        let i = 0;
	        let usesTransparency = false;
	        while (i < buf.length) {
	            if (buf[i + 3] === 0) {
	                usesTransparency = true;
	            }
	            else {
	                // can eliminate the bitshift by starting one byte prior
	                const color = (buf.readUInt32BE(i, true) >> 8) & 0xFFFFFF;
	                colorSet.add(color);
	            }
	            i += 4; // skip alpha
	        }
	        const colors = new Array(colorSet.size);
	        const iter = colorSet.values();
	        for (i = 0; i < colors.length; ++i) {
	            colors[i] = iter.next().value;
	        }
	        colors.sort((a, b) => (a - b));
	        let indexCount = colors.length;
	        if (usesTransparency) {
	            ++indexCount;
	        }
	        return { colors, usesTransparency, indexCount };
	    }
	}

	GifFrame.DisposeToAnything = 0;
	GifFrame.DisposeNothing = 1;
	GifFrame.DisposeToBackgroundColor = 2;
	GifFrame.DisposeToPrevious = 3;

	gifframe.GifFrame = GifFrame;
	return gifframe;
}

var hasRequiredGifutil;

function requireGifutil () {
	if (hasRequiredGifutil) return gifutil;
	hasRequiredGifutil = 1;
	(function (exports) {

		/** @namespace GifUtil */

		const fs = require$$0;
		const ImageQ = requireImageQ();

		const BitmapImage = requireBitmapimage();
		const { GifFrame } = requireGifframe();
		const { GifError } = requireGif();
		const { GifCodec } = requireGifcodec();

		const INVALID_SUFFIXES = ['.jpg', '.jpeg', '.png', '.bmp'];

		const defaultCodec = new GifCodec();

		/**
		 * cloneFrames() clones provided frames. It's a utility method for cloning an entire array of frames at once.
		 * 
		 * @function cloneFrames
		 * @memberof GifUtil
		 * @param {GifFrame[]} frames An array of GifFrame instances to clone
		 * @return {GifFrame[]} An array of GifFrame clones of the provided frames.
		 */

		exports.cloneFrames = function (frames) {
		    let clones = [];
		    frames.forEach(frame => {

		        clones.push(new GifFrame(frame));
		    });
		    return clones;
		};

		/**
		 * getColorInfo() gets information about the colors used in the provided frames. The method is able to return an array of all colors found across all frames.
		 * 
		 * `maxGlobalIndex` controls whether the computation short-circuits to avoid doing work that the caller doesn't need. The method only returns `colors` and `indexCount` for the colors across all frames when the number of indexes required to store the colors and transparency in a GIF (which is the value of `indexCount`) is less than or equal to `maxGlobalIndex`. Such short-circuiting is useful when the caller just needs to determine whether any frame includes transparency.
		 * 
		 * @function getColorInfo
		 * @memberof GifUtil
		 * @param {GifFrame[]} frames Frames to examine for color and transparency.
		 * @param {number} maxGlobalIndex Maximum number of color indexes (including one for transparency) allowed among the returned compilation of colors. `colors` and `indexCount` are not returned if the number of color indexes required to accommodate  all frames exceeds this number. Returns `colors` and `indexCount` by default.
		 * @returns {object} Object containing at least `palettes` and `usesTransparency`. `palettes` is an array of all the palettes returned by GifFrame#getPalette(). `usesTransparency` indicates whether at least one frame uses transparency. If `maxGlobalIndex` is not exceeded, the object also contains `colors`, an array of all colors (RGB) found across all palettes, sorted by increasing value, and `indexCount` indicating the number of indexes required to store the colors and the transparency in a GIF.
		 * @throws {GifError} When any frame requires more than 256 color indexes.
		 */

		exports.getColorInfo = function (frames, maxGlobalIndex) {
		    let usesTransparency = false;
		    const palettes = [];
		    for (let i = 0; i < frames.length; ++i) {
		        let palette = frames[i].getPalette();
		        if (palette.usesTransparency) {
		            usesTransparency = true;
		        }
		        if (palette.indexCount > 256) {
		            throw new GifError(`Frame ${i} uses more than 256 color indexes`);
		        }
		        palettes.push(palette);
		    }
		    if (maxGlobalIndex === 0) {
		        return { usesTransparency, palettes };
		    }

		    const globalColorSet = new Set();
		    palettes.forEach(palette => {

		        palette.colors.forEach(color => {

		            globalColorSet.add(color);
		        });
		    });
		    let indexCount = globalColorSet.size;
		    if (usesTransparency) {
		        // odd that GIF requires a color table entry at transparent index
		        ++indexCount;
		    }
		    if (maxGlobalIndex && indexCount > maxGlobalIndex) {
		        return { usesTransparency, palettes };
		    }
		    
		    const colors = new Array(globalColorSet.size);
		    const iter = globalColorSet.values();
		    for (let i = 0; i < colors.length; ++i) {
		        colors[i] = iter.next().value;
		    }
		    colors.sort((a, b) => (a - b));
		    return { colors, indexCount, usesTransparency, palettes };
		};

		/**
		 * copyAsJimp() returns a Jimp that contains a copy of the provided bitmap image (which may be either a BitmapImage or a GifFrame). Modifying the Jimp does not affect the provided bitmap image. This method serves as a macro for simplifying working with Jimp.
		 *
		 * @function copyAsJimp
		 * @memberof GifUtil
		 * @param {object} Reference to the Jimp package, keeping this library from being dependent on Jimp.
		 * @param {bitmapImageToCopy} Instance of BitmapImage (may be a GifUtil) with which to source the Jimp.
		 * @return {object} An new instance of Jimp containing a copy of the image in bitmapImageToCopy.
		 */
		 
		exports.copyAsJimp = function (jimp, bitmapImageToCopy) {
		    return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
		};

		/**
		 * getMaxDimensions() returns the pixel width and height required to accommodate all of the provided frames, according to the offsets and dimensions of each frame.
		 * 
		 * @function getMaxDimensions
		 * @memberof GifUtil
		 * @param {GifFrame[]} frames Frames to measure for their aggregate maximum dimensions.
		 * @return {object} An object of the form {maxWidth, maxHeight} indicating the maximum width and height required to accommodate all frames.
		 */

		exports.getMaxDimensions = function (frames) {
		    let maxWidth = 0, maxHeight = 0;
		    frames.forEach(frame => {
		        const width = frame.xOffset + frame.bitmap.width;
		        if (width > maxWidth) {
		            maxWidth = width;
		        }
		        const height = frame.yOffset + frame.bitmap.height;
		        if (height > maxHeight) {
		            maxHeight = height;
		        }
		    });
		    return { maxWidth, maxHeight };
		};

		/**
		 * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Anthony Dekker.
		 * 
		 * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.
		 * 
		 * The method may increase the number of colors if there are fewer than the provided maximum.
		 * 
		 * @function quantizeDekker
		 * @memberof GifUtil
		 * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.
		 * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.
		 * @param {object} dither (optional) An object configuring the dithering to apply. The properties are as followings, imported from the [`image-q` package](https://github.com/ibezkrovnyi/image-quantization) without explanation: { `ditherAlgorithm`: One of 'FloydSteinberg', 'FalseFloydSteinberg', 'Stucki', 'Atkinson', 'Jarvis', 'Burkes', 'Sierra', 'TwoSierra', 'SierraLite'; `minimumColorDistanceToDither`: (optional) A number defaulting to 0; `serpentine`: (optional) A boolean defaulting to true; `calculateErrorLikeGIMP`: (optional) A boolean defaulting to false. }
		 */

		exports.quantizeDekker = function (imageOrImages, maxColorIndexes, dither) {
		    maxColorIndexes = maxColorIndexes || 256;
		    _quantize(imageOrImages, 'NeuQuantFloat', maxColorIndexes, 0, dither);
		};

		/**
		 * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Leon Sorokin. This quantization method differs from the other two by likely never increasing the number of colors, should there be fewer than the provided maximum.
		 * 
		 * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.
		 * 
		 * @function quantizeSorokin
		 * @memberof GifUtil
		 * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.
		 * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.
		 * @param {string} histogram (optional) Histogram method: 'top-pop' for global top-population, 'min-pop' for minimum-population threshhold within subregions. Defaults to 'min-pop'.
		 * @param {object} dither (optional) An object configuring the dithering to apply, as explained for `quantizeDekker()`.
		 */

		exports.quantizeSorokin = function (imageOrImages, maxColorIndexes, histogram, dither) {
		    maxColorIndexes = maxColorIndexes || 256;
		    histogram = histogram || 'min-pop';
		    let histogramID;
		    switch (histogram) {
		        case 'min-pop':
		        histogramID = 2;
		        break;

		        case 'top-pop':
		        histogramID = 1;
		        break

		        default:
		        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
		    }
		    _quantize(imageOrImages, 'RGBQuant', maxColorIndexes, histogramID, dither);
		};

		/**
		 * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Xiaolin Wu.
		 * 
		 * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.
		 * 
		 * The method may increase the number of colors if there are fewer than the provided maximum.
		 * 
		 * @function quantizeWu
		 * @memberof GifUtil
		 * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.
		 * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.
		 * @param {number} significantBits (optional) This is the number of significant high bits in each RGB color channel. Takes integer values from 1 through 8. Higher values correspond to higher quality. Defaults to 5.
		 * @param {object} dither (optional) An object configuring the dithering to apply, as explained for `quantizeDekker()`.
		 */

		exports.quantizeWu = function (imageOrImages, maxColorIndexes, significantBits, dither) {
		    maxColorIndexes = maxColorIndexes || 256;
		    significantBits = significantBits || 5;
		    if (significantBits < 1 || significantBits > 8) {
		        throw new Error("Invalid quantization quality");
		    }
		    _quantize(imageOrImages, 'WuQuant', maxColorIndexes, significantBits, dither);
		};

		/**
		 * read() decodes an encoded GIF, whether provided as a filename or as a byte buffer.
		 * 
		 * @function read
		 * @memberof GifUtil
		 * @param {string|Buffer} source Source to decode. When a string, it's the GIF filename to load and parse. When a Buffer, it's an encoded GIF to parse.
		 * @param {object} decoder An optional GIF decoder object implementing the `decode` method of class GifCodec. When provided, the method decodes the GIF using this decoder. When not provided, the method uses GifCodec.
		 * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the decoded GIF.
		 */

		exports.read = function (source, decoder) {
		    decoder = decoder || defaultCodec;
		    if (Buffer.isBuffer(source)) {
		        return decoder.decodeGif(source);
		    }
		    return _readBinary(source)
		    .then(buffer => {

		        return decoder.decodeGif(buffer);
		    });
		};

		/**
		 * shareAsJimp() returns a Jimp that shares a bitmap with the provided bitmap image (which may be either a BitmapImage or a GifFrame). Modifying the image in either the Jimp or the BitmapImage affects the other objects. This method serves as a macro for simplifying working with Jimp.
		 *
		 * @function shareAsJimp
		 * @memberof GifUtil
		 * @param {object} Reference to the Jimp package, keeping this library from being dependent on Jimp.
		 * @param {bitmapImageToShare} Instance of BitmapImage (may be a GifUtil) with which to source the Jimp.
		 * @return {object} An new instance of Jimp that shares the image in bitmapImageToShare.
		 */
		 
		exports.shareAsJimp = function (jimp, bitmapImageToShare) {
		    const jimpImage = new jimp(bitmapImageToShare.bitmap.width,
		            bitmapImageToShare.bitmap.height, 0);
		    jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
		    return jimpImage;
		};

		/**
		 * write() encodes a GIF and saves it as a file.
		 * 
		 * @function write
		 * @memberof GifUtil
		 * @param {string} path Filename to write GIF out as. Will overwrite an existing file.
		 * @param {GifFrame[]} frames Array of frames to be written into GIF.
		 * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.
		 * @param {object} encoder An optional GIF encoder object implementing the `encode` method of class GifCodec. When provided, the method encodes the GIF using this encoder. When not provided, the method uses GifCodec.
		 * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
		 */

		exports.write = function (path, frames, spec, encoder) {
		    encoder = encoder || defaultCodec;
		    const matches = path.match(/\.[a-zA-Z]+$/); // prevent accidents
		    if (matches !== null &&
		            INVALID_SUFFIXES.includes(matches[0].toLowerCase()))
		    {
		        throw new Error(`GIF '${path}' has an unexpected suffix`);
		    }

		    return encoder.encodeGif(frames, spec)
		    .then(gif => {

		        return _writeBinary(path, gif.buffer)
		        .then(() => {

		            return gif;
		        });
		    });
		};

		function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
		    const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
		    const ditherAlgs = [
		        'FloydSteinberg',
		        'FalseFloydSteinberg',
		        'Stucki',
		        'Atkinson',
		        'Jarvis',
		        'Burkes',
		        'Sierra',
		        'TwoSierra',
		        'SierraLite'
		    ];

		    if (dither) {
		        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
		            throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
		        }
		        if (dither.serpentine === undefined) {
		            dither.serpentine = true;
		        }
		        if (dither.minimumColorDistanceToDither === undefined) {
		            dither.minimumColorDistanceToDither = 0;
		        }
		        if (dither.calculateErrorLikeGIMP === undefined) {
		            dither.calculateErrorLikeGIMP = false;
		        }
		    }

		    const distCalculator = new ImageQ.distance.Euclidean();
		    const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
		    let imageMaker;
		    if (dither) {
		        imageMaker = new ImageQ.image.ErrorDiffusionArray(
		            distCalculator,
		            ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm],
		            dither.serpentine,
		            dither.minimumColorDistanceToDither,
		            dither.calculateErrorLikeGIMP
		        );
		    }
		    else {
		        imageMaker = new ImageQ.image.NearestColor(distCalculator);
		    }

		    const inputContainers = [];
		    images.forEach(image => {

		        const imageBuf = image.bitmap.data;
		        const inputBuf = new ArrayBuffer(imageBuf.length);
		        const inputArray = new Uint32Array(inputBuf);
		        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
		            inputArray[ai] = imageBuf.readUInt32LE(bi, true);
		        }
		        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(
		                inputArray, image.bitmap.width, image.bitmap.height);
		        quantizer.sample(inputContainer);
		        inputContainers.push(inputContainer);
		    });
		    
		    const limitedPalette = quantizer.quantizeSync();

		    for (let i = 0; i < images.length; ++i) {
		        const imageBuf = images[i].bitmap.data;
		        const outputContainer = imageMaker.quantizeSync(inputContainers[i], limitedPalette);
		        const outputArray = outputContainer.toUint32Array();
		        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
		            imageBuf.writeUInt32LE(outputArray[ai], bi);
		        }
		    }
		}

		function _readBinary(path) {
		    // TBD: add support for URLs
		    return new Promise((resolve, reject) => {

		        fs.readFile(path, (err, buffer) => {

		            if (err) {
		                return reject(err);
		            }
		            return resolve(buffer);
		        });
		    });
		}

		function _writeBinary(path, buffer) {
		    // TBD: add support for URLs
		    return new Promise((resolve, reject) => {

		        fs.writeFile(path, buffer, err => {
		            
		            if (err) {
		                return reject(err);
		            }
		            return resolve();
		        });
		    });
		} 
	} (gifutil));
	return gifutil;
}

var hasRequiredGifcodec;

function requireGifcodec () {
	if (hasRequiredGifcodec) return gifcodec;
	hasRequiredGifcodec = 1;

	const Omggif = requireOmggif();
	const { Gif, GifError } = requireGif();

	// allow circular dependency with GifUtil
	function GifUtil() {
	    const data = requireGifutil();

	    GifUtil = function () {
	      return data;
	    };

	  return data;
	}

	const { GifFrame } = requireGifframe();

	const PER_GIF_OVERHEAD = 200; // these are guesses at upper limits
	const PER_FRAME_OVERHEAD = 100;

	// Note: I experimented with accepting a global color table when encoding and returning the global color table when decoding. Doing this properly greatly increased the complexity of the code and the amount of clock cycles required. The main issue is that each frame can specify any color of the global color table to be transparent within the frame, while this GIF library strives to hide GIF formatting details from its clients. E.g. it's possible to have 256 colors in the global color table and different transparencies in each frame, requiring clients to either provide per-frame transparency indexes, or for arcane reasons that won't be apparent to client developers, encode some GIFs with local color tables that previously decoded with global tables.

	/** @class GifCodec */

	class GifCodec
	{
	    // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest

	    /**
	     * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
	     * 
	     * Instances of this class are stateless and can be shared across multiple encodings and decodings.
	     * 
	     * Its constructor takes one option argument:
	     * 
	     * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
	     */

	    constructor(options = {}) {
	        this._transparentRGB = null; // 0x000000
	        if (typeof options.transparentRGB === 'number' &&
	                options.transparentRGB !== 0)
	        {
	            this._transparentRGBA = options.transparentRGB * 256;
	        }
	        this._testInitialBufferSize = 0; // assume no buffer scaling test
	    }

	    /**
	     * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
	     * 
	     * @param {Buffer} buffer Bytes of an encoded GIF to decode.
	     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
	     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
	     */

	    decodeGif(buffer) {
	        try {
	            let reader;
	            try {
	                reader = new Omggif.GifReader(buffer);
	            }
	            catch (err) {
	                throw new GifError(err);
	            }
	            const frameCount = reader.numFrames();
	            const frames = [];
	            const spec = {
	                width: reader.width,
	                height: reader.height,
	                loops: reader.loopCount()
	            };

	            spec.usesTransparency = false;
	            for (let i = 0; i < frameCount; ++i) {
	                const frameInfo =
	                        this._decodeFrame(reader, i, spec.usesTransparency);
	                frames.push(frameInfo.frame);
	                if (frameInfo.usesTransparency) {
	                    spec.usesTransparency = true;
	                }
	            }
	            return Promise.resolve(new Gif(buffer, frames, spec));
	        }
	        catch (err) {
	            return Promise.reject(err);
	        }
	    }

	    /**
	     * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
	     * 
	     * @param {GifFrame[]} frames Array of frames to encode
	     * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely. Set `loop` to null to disable looping, playing only once. `colorScope` defaults to Gif.GlobalColorsPreferred.
	     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
	     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
	     */

	    encodeGif(frames, spec = {}) {
	        try {
	            if (frames === null || frames.length === 0) {
	                throw new GifError("there are no frames");
	            }
	            const dims = GifUtil().getMaxDimensions(frames);

	            spec = Object.assign({}, spec); // don't munge caller's spec
	            spec.width = dims.maxWidth;
	            spec.height = dims.maxHeight;
	            if (spec.loops === undefined) {
	                spec.loops = 0;
	            }
	            spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;

	            return Promise.resolve(this._encodeGif(frames, spec));
	        }
	        catch (err) {
	            return Promise.reject(err);
	        }
	    }

	    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
	        let info, buffer;
	        try {
	            info = reader.frameInfo(frameIndex);
	            buffer = new Buffer(reader.width * reader.height * 4);
	            reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
	            if (info.width !== reader.width || info.height !== reader.height) {
	                if (info.y) {
	                    // skip unused rows
	                    buffer = buffer.slice(info.y * reader.width * 4);
	                }
	                if (reader.width > info.width) {
	                    // skip scanstride
	                    for (let ii = 0; ii < info.height; ++ii) {
	                        buffer.copy(buffer, ii * info.width * 4,
	                            (info.x + ii * reader.width) * 4,
	                            (info.x + ii * reader.width) * 4 + info.width * 4);
	                    }
	                }
	                // trim buffer to size
	                buffer = buffer.slice(0, info.width * info.height * 4);
	            }
	        }
	        catch (err) {
	            throw new GifError(err);
	        }

	        let usesTransparency = false;
	        if (this._transparentRGBA === null) {
	            if (!alreadyUsedTransparency) {
	                for (let i = 3; i < buffer.length; i += 4) {
	                    if (buffer[i] === 0) {
	                        usesTransparency = true;
	                        i = buffer.length;
	                    }
	                }
	            }
	        }
	        else {
	            for (let i = 3; i < buffer.length; i += 4) {
	                if (buffer[i] === 0) {
	                    buffer.writeUInt32BE(this._transparentRGBA, i - 3);
	                    usesTransparency = true; // GIF might encode unused index
	                }
	            }
	        }

	        const frame = new GifFrame(info.width, info.height, buffer, {
	            xOffset: info.x,
	            yOffset: info.y,
	            disposalMethod: info.disposal,
	            interlaced: info.interlaced,
	            delayCentisecs: info.delay
	        });
	        return { frame, usesTransparency };
	    }

	    _encodeGif(frames, spec) {
	        let colorInfo;
	        if (spec.colorScope === Gif.LocalColorsOnly) {
	            colorInfo = GifUtil().getColorInfo(frames, 0);
	        }
	        else {
	            colorInfo = GifUtil().getColorInfo(frames, 256);
	            if (!colorInfo.colors) { // if global palette impossible
	                if (spec.colorScope === Gif.GlobalColorsOnly) {
	                    throw new GifError(
	                            "Too many color indexes for global color table");
	                }
	                spec.colorScope = Gif.LocalColorsOnly;
	            }
	        }
	        spec.usesTransparency = colorInfo.usesTransparency;

	        const localPalettes = colorInfo.palettes;
	        if (spec.colorScope === Gif.LocalColorsOnly) {
	            const localSizeEst = 2000; //this._getSizeEstimateLocal(localPalettes, frames);
	            return _encodeLocal(frames, spec, localSizeEst, localPalettes);
	        }

	        const globalSizeEst = 2000; //this._getSizeEstimateGlobal(colorInfo, frames);
	        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
	    }

	    _getSizeEstimateGlobal(globalPalette, frames) {
	        if (this._testInitialBufferSize > 0) {
	            return this._testInitialBufferSize;
	        }
	        let sizeEst = PER_GIF_OVERHEAD + 3*256 /* max palette size*/;
	        const pixelBitWidth = _getPixelBitWidth(globalPalette);
	        frames.forEach(frame => {
	            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
	        });
	        return sizeEst; // should be the upper limit
	    }

	    _getSizeEstimateLocal(palettes, frames) {
	        if (this._testInitialBufferSize > 0) {
	            return this._testInitialBufferSize;
	        }
	        let sizeEst = PER_GIF_OVERHEAD;
	        for (let i = 0; i < frames.length; ++i ) {
	            const palette = palettes[i];
	            const pixelBitWidth = _getPixelBitWidth(palette);
	            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
	        }
	        return sizeEst; // should be the upper limit
	    }
	}
	gifcodec.GifCodec = GifCodec;

	function _colorLookupLinear(colors, color) {
	    const index = colors.indexOf(color);
	    return (index === -1 ? null : index);
	}

	function _colorLookupBinary(colors, color) {
	    // adapted from https://stackoverflow.com/a/10264318/650894
	    var lo = 0, hi = colors.length - 1, mid;
	    while (lo <= hi) {
	        mid = Math.floor((lo + hi)/2);
	        if (colors[mid] > color)
	            hi = mid - 1;
	        else if (colors[mid] < color)
	            lo = mid + 1;
	        else
	            return mid;
	    }
	    return null;
	}

	function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
	    // would be inefficient for frames to lookup colors in extended palette 
	    const extendedGlobalPalette = {
	        colors: globalPalette.colors.slice(),
	        usesTransparency: globalPalette.usesTransparency
	    };
	    _extendPaletteToPowerOf2(extendedGlobalPalette);
	    const options = {
	        palette: extendedGlobalPalette.colors,
	        loop: spec.loops
	    };
	    let buffer = new Buffer(bufferSizeEst);
	    let gifWriter;
	    try {
	        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,
	                            options);
	    }
	    catch (err) {
	        throw new GifError(err);
	    }
	    for (let i = 0; i < frames.length; ++i) {
	        buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
	    }
	    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
	}

	function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
	    const options = {
	        loop: spec.loops
	    };
	    let buffer = new Buffer(bufferSizeEst);
	    let gifWriter;
	    try {
	        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,
	                            options);
	    }                            
	    catch (err) {
	        throw new GifError(err);
	    }
	    for (let i = 0; i < frames.length; ++i) {
	        buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
	    }
	    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
	}

	function _extendPaletteToPowerOf2(palette) {
	    const colors = palette.colors;
	    if (palette.usesTransparency) {
	        colors.push(0);
	    }
	    const colorCount = colors.length;
	    let powerOf2 = 2;
	    while (colorCount > powerOf2) {
	        powerOf2 <<= 1;
	    }
	    colors.length = powerOf2;
	    colors.fill(0, colorCount);
	}

	function _getFrameSizeEst(frame, pixelBitWidth) {
	    let byteLength = frame.bitmap.width * frame.bitmap.height;
	    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
	    byteLength += Math.ceil(byteLength / 255); // add block size bytes
	    // assume maximum palete size because it might get extended for power of 2
	    return (PER_FRAME_OVERHEAD + byteLength + 3 * 256 /* largest palette */);
	}

	function _getIndexedImage(frameIndex, frame, palette) {
	    const colors = palette.colors;
	    const colorToIndexFunc = (colors.length <= 8 ? // guess at the break-even
	            _colorLookupLinear : _colorLookupBinary);
	    const colorBuffer = frame.bitmap.data;
	    const indexBuffer = new Buffer(colorBuffer.length/4);
	    let transparentIndex = colors.length;
	    let i = 0, j = 0;

	    while (i < colorBuffer.length) {
	        if (colorBuffer[i + 3] !== 0) {
	            const color = (colorBuffer.readUInt32BE(i, true) >> 8) & 0xFFFFFF;
	            // caller guarantees that the color will be in the palette
	            indexBuffer[j] = colorToIndexFunc(colors, color);
	        }
	        else {
	            indexBuffer[j] = transparentIndex;
	        }
	        i += 4; // skip alpha
	        ++j;
	    }

	    if (palette.usesTransparency) {
	        if (transparentIndex === 256) {
	            throw new GifError(`Frame ${frameIndex} already has 256 colors` +
	                    `and so can't use transparency`);
	        }
	    }
	    else {
	        transparentIndex = null;
	    }

	    return { buffer: indexBuffer, transparentIndex };
	}

	function _getPixelBitWidth(palette) {
	    let indexCount = palette.indexCount;
	    let pixelBitWidth = 0;
	    --indexCount; // start at maximum index
	    while (indexCount) {
	        ++pixelBitWidth;
	        indexCount >>= 1;
	    }
	    return (pixelBitWidth > 0 ? pixelBitWidth : 1);
	}

	function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
	    if (frame.interlaced) {
	        throw new GifError("writing interlaced GIFs is not supported");
	    }
	    const frameInfo = _getIndexedImage(frameIndex, frame, palette);
	    const options = {
	        delay: frame.delayCentisecs,
	        disposal: frame.disposalMethod,
	        transparent: frameInfo.transparentIndex
	    };
	    if (isLocalPalette) {
	        _extendPaletteToPowerOf2(palette); // ok 'cause palette never used again
	        options.palette = palette.colors;
	    }
	    try {
	        let buffer = gifWriter.getOutputBuffer();
	        let startOfFrame = gifWriter.getOutputBufferPosition();
	        let endOfFrame;
	        let tryAgain = true;

	        while (tryAgain) {
	            endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset,
	                    frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);
	            tryAgain = false;
	            if (endOfFrame >= buffer.length - 1) {
	                const biggerBuffer = new Buffer(buffer.length * 1.5);
	                buffer.copy(biggerBuffer);
	                gifWriter.setOutputBuffer(biggerBuffer);
	                gifWriter.setOutputBufferPosition(startOfFrame);
	                buffer = biggerBuffer;
	                tryAgain = true;
	            }
	        }
	        return buffer;
	    }
	    catch (err) {
	        throw new GifError(err);
	    }
	}
	return gifcodec;
}

var src;
var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;

	const BitmapImage = requireBitmapimage();
	const { Gif, GifError } = requireGif();
	const { GifCodec } = requireGifcodec();
	const { GifFrame } = requireGifframe();
	const GifUtil = requireGifutil();

	src = {
	    BitmapImage,
	    Gif,
	    GifCodec,
	    GifFrame,
	    GifUtil,
	    GifError
	};
	return src;
}

var srcExports = requireSrc();

function gif() {
    return {
        mime: "image/gif",
        encode: async (bitmap) => {
            const gif = new srcExports.BitmapImage(bitmap);
            srcExports.GifUtil.quantizeDekker(gif, 256);
            const newFrame = new srcExports.GifFrame(bitmap);
            const gifCodec = new srcExports.GifCodec();
            const newGif = await gifCodec.encodeGif([newFrame], {});
            return newGif.buffer;
        },
        decode: (data) => {
            const gifObj = new GIF.GifReader(data);
            const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
            gifObj.decodeAndBlitFrameRGBA(0, gifData);
            return {
                data: gifData,
                width: gifObj.width,
                height: gifObj.height,
            };
        },
    };
}

var encoder = {exports: {}};

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder.exports;
	hasRequiredEncoder = 1;
	(function (module) {

		function JPEGEncoder(quality) {
			var ffloor = Math.floor;
			var YTable = new Array(64);
			var UVTable = new Array(64);
			var fdtbl_Y = new Array(64);
			var fdtbl_UV = new Array(64);
			var YDC_HT;
			var UVDC_HT;
			var YAC_HT;
			var UVAC_HT;
			
			var bitcode = new Array(65535);
			var category = new Array(65535);
			var outputfDCTQuant = new Array(64);
			var DU = new Array(64);
			var byteout = [];
			var bytenew = 0;
			var bytepos = 7;
			
			var YDU = new Array(64);
			var UDU = new Array(64);
			var VDU = new Array(64);
			var clt = new Array(256);
			var RGB_YUV_TABLE = new Array(2048);
			var currentQuality;
			
			var ZigZag = [
					 0, 1, 5, 6,14,15,27,28,
					 2, 4, 7,13,16,26,29,42,
					 3, 8,12,17,25,30,41,43,
					 9,11,18,24,31,40,44,53,
					10,19,23,32,39,45,52,54,
					20,22,33,38,46,51,55,60,
					21,34,37,47,50,56,59,61,
					35,36,48,49,57,58,62,63
				];
			
			var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
			var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
			var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
			var std_ac_luminance_values = [
					0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
					0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
					0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
					0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
					0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
					0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
					0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
					0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
					0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
					0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
					0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
					0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
					0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
					0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
					0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
					0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
					0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
					0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
					0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
					0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
					0xf9,0xfa
				];
			
			var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
			var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
			var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
			var std_ac_chrominance_values = [
					0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
					0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
					0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
					0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
					0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
					0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
					0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
					0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
					0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
					0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
					0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
					0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
					0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
					0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
					0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
					0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
					0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
					0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
					0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
					0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
					0xf9,0xfa
				];
			
			function initQuantTables(sf){
					var YQT = [
						16, 11, 10, 16, 24, 40, 51, 61,
						12, 12, 14, 19, 26, 58, 60, 55,
						14, 13, 16, 24, 40, 57, 69, 56,
						14, 17, 22, 29, 51, 87, 80, 62,
						18, 22, 37, 56, 68,109,103, 77,
						24, 35, 55, 64, 81,104,113, 92,
						49, 64, 78, 87,103,121,120,101,
						72, 92, 95, 98,112,100,103, 99
					];
					
					for (var i = 0; i < 64; i++) {
						var t = ffloor((YQT[i]*sf+50)/100);
						if (t < 1) {
							t = 1;
						} else if (t > 255) {
							t = 255;
						}
						YTable[ZigZag[i]] = t;
					}
					var UVQT = [
						17, 18, 24, 47, 99, 99, 99, 99,
						18, 21, 26, 66, 99, 99, 99, 99,
						24, 26, 56, 99, 99, 99, 99, 99,
						47, 66, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99,
						99, 99, 99, 99, 99, 99, 99, 99
					];
					for (var j = 0; j < 64; j++) {
						var u = ffloor((UVQT[j]*sf+50)/100);
						if (u < 1) {
							u = 1;
						} else if (u > 255) {
							u = 255;
						}
						UVTable[ZigZag[j]] = u;
					}
					var aasf = [
						1.0, 1.387039845, 1.306562965, 1.175875602,
						1.0, 0.785694958, 0.541196100, 0.275899379
					];
					var k = 0;
					for (var row = 0; row < 8; row++)
					{
						for (var col = 0; col < 8; col++)
						{
							fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
							fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
							k++;
						}
					}
				}
				
				function computeHuffmanTbl(nrcodes, std_table){
					var codevalue = 0;
					var pos_in_table = 0;
					var HT = new Array();
					for (var k = 1; k <= 16; k++) {
						for (var j = 1; j <= nrcodes[k]; j++) {
							HT[std_table[pos_in_table]] = [];
							HT[std_table[pos_in_table]][0] = codevalue;
							HT[std_table[pos_in_table]][1] = k;
							pos_in_table++;
							codevalue++;
						}
						codevalue*=2;
					}
					return HT;
				}
				
				function initHuffmanTbl()
				{
					YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
					UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
					YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
					UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
				}
			
				function initCategoryNumber()
				{
					var nrlower = 1;
					var nrupper = 2;
					for (var cat = 1; cat <= 15; cat++) {
						//Positive numbers
						for (var nr = nrlower; nr<nrupper; nr++) {
							category[32767+nr] = cat;
							bitcode[32767+nr] = [];
							bitcode[32767+nr][1] = cat;
							bitcode[32767+nr][0] = nr;
						}
						//Negative numbers
						for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
							category[32767+nrneg] = cat;
							bitcode[32767+nrneg] = [];
							bitcode[32767+nrneg][1] = cat;
							bitcode[32767+nrneg][0] = nrupper-1+nrneg;
						}
						nrlower <<= 1;
						nrupper <<= 1;
					}
				}
				
				function initRGBYUVTable() {
					for(var i = 0; i < 256;i++) {
						RGB_YUV_TABLE[i]      		=  19595 * i;
						RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
						RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
						RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
						RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
						RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
						RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
						RGB_YUV_TABLE[(i+1792)>>0] 	= -5329 * i;
					}
				}
				
				// IO functions
				function writeBits(bs)
				{
					var value = bs[0];
					var posval = bs[1]-1;
					while ( posval >= 0 ) {
						if (value & (1 << posval) ) {
							bytenew |= (1 << bytepos);
						}
						posval--;
						bytepos--;
						if (bytepos < 0) {
							if (bytenew == 0xFF) {
								writeByte(0xFF);
								writeByte(0);
							}
							else {
								writeByte(bytenew);
							}
							bytepos=7;
							bytenew=0;
						}
					}
				}
			
				function writeByte(value)
				{
					//byteout.push(clt[value]); // write char directly instead of converting later
		      byteout.push(value);
				}
			
				function writeWord(value)
				{
					writeByte((value>>8)&0xFF);
					writeByte((value   )&0xFF);
				}
				
				// DCT & quantization core
				function fDCTQuant(data, fdtbl)
				{
					var d0, d1, d2, d3, d4, d5, d6, d7;
					/* Pass 1: process rows. */
					var dataOff=0;
					var i;
					var I8 = 8;
					var I64 = 64;
					for (i=0; i<I8; ++i)
					{
						d0 = data[dataOff];
						d1 = data[dataOff+1];
						d2 = data[dataOff+2];
						d3 = data[dataOff+3];
						d4 = data[dataOff+4];
						d5 = data[dataOff+5];
						d6 = data[dataOff+6];
						d7 = data[dataOff+7];
						
						var tmp0 = d0 + d7;
						var tmp7 = d0 - d7;
						var tmp1 = d1 + d6;
						var tmp6 = d1 - d6;
						var tmp2 = d2 + d5;
						var tmp5 = d2 - d5;
						var tmp3 = d3 + d4;
						var tmp4 = d3 - d4;
			
						/* Even part */
						var tmp10 = tmp0 + tmp3;	/* phase 2 */
						var tmp13 = tmp0 - tmp3;
						var tmp11 = tmp1 + tmp2;
						var tmp12 = tmp1 - tmp2;
			
						data[dataOff] = tmp10 + tmp11; /* phase 3 */
						data[dataOff+4] = tmp10 - tmp11;
			
						var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
						data[dataOff+2] = tmp13 + z1; /* phase 5 */
						data[dataOff+6] = tmp13 - z1;
			
						/* Odd part */
						tmp10 = tmp4 + tmp5; /* phase 2 */
						tmp11 = tmp5 + tmp6;
						tmp12 = tmp6 + tmp7;
			
						/* The rotator is modified from fig 4-8 to avoid extra negations. */
						var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
						var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
						var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
						var z3 = tmp11 * 0.707106781; /* c4 */
			
						var z11 = tmp7 + z3;	/* phase 5 */
						var z13 = tmp7 - z3;
			
						data[dataOff+5] = z13 + z2;	/* phase 6 */
						data[dataOff+3] = z13 - z2;
						data[dataOff+1] = z11 + z4;
						data[dataOff+7] = z11 - z4;
			
						dataOff += 8; /* advance pointer to next row */
					}
			
					/* Pass 2: process columns. */
					dataOff = 0;
					for (i=0; i<I8; ++i)
					{
						d0 = data[dataOff];
						d1 = data[dataOff + 8];
						d2 = data[dataOff + 16];
						d3 = data[dataOff + 24];
						d4 = data[dataOff + 32];
						d5 = data[dataOff + 40];
						d6 = data[dataOff + 48];
						d7 = data[dataOff + 56];
						
						var tmp0p2 = d0 + d7;
						var tmp7p2 = d0 - d7;
						var tmp1p2 = d1 + d6;
						var tmp6p2 = d1 - d6;
						var tmp2p2 = d2 + d5;
						var tmp5p2 = d2 - d5;
						var tmp3p2 = d3 + d4;
						var tmp4p2 = d3 - d4;
			
						/* Even part */
						var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
						var tmp13p2 = tmp0p2 - tmp3p2;
						var tmp11p2 = tmp1p2 + tmp2p2;
						var tmp12p2 = tmp1p2 - tmp2p2;
			
						data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
						data[dataOff+32] = tmp10p2 - tmp11p2;
			
						var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
						data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
						data[dataOff+48] = tmp13p2 - z1p2;
			
						/* Odd part */
						tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
						tmp11p2 = tmp5p2 + tmp6p2;
						tmp12p2 = tmp6p2 + tmp7p2;
			
						/* The rotator is modified from fig 4-8 to avoid extra negations. */
						var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
						var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
						var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
						var z3p2 = tmp11p2 * 0.707106781; /* c4 */
			
						var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
						var z13p2 = tmp7p2 - z3p2;
			
						data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
						data[dataOff+24] = z13p2 - z2p2;
						data[dataOff+ 8] = z11p2 + z4p2;
						data[dataOff+56] = z11p2 - z4p2;
			
						dataOff++; /* advance pointer to next column */
					}
			
					// Quantize/descale the coefficients
					var fDCTQuant;
					for (i=0; i<I64; ++i)
					{
						// Apply the quantization and scaling factor & Round to nearest integer
						fDCTQuant = data[i]*fdtbl[i];
						outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
						//outputfDCTQuant[i] = fround(fDCTQuant);

					}
					return outputfDCTQuant;
				}
				
				function writeAPP0()
				{
					writeWord(0xFFE0); // marker
					writeWord(16); // length
					writeByte(0x4A); // J
					writeByte(0x46); // F
					writeByte(0x49); // I
					writeByte(0x46); // F
					writeByte(0); // = "JFIF",'\0'
					writeByte(1); // versionhi
					writeByte(1); // versionlo
					writeByte(0); // xyunits
					writeWord(1); // xdensity
					writeWord(1); // ydensity
					writeByte(0); // thumbnwidth
					writeByte(0); // thumbnheight
				}

				function writeAPP1(exifBuffer) {
					if (!exifBuffer) return;

					writeWord(0xFFE1); // APP1 marker

					if (exifBuffer[0] === 0x45 &&
							exifBuffer[1] === 0x78 &&
							exifBuffer[2] === 0x69 &&
							exifBuffer[3] === 0x66) {
						// Buffer already starts with EXIF, just use it directly
						writeWord(exifBuffer.length + 2); // length is buffer + length itself!
					} else {
						// Buffer doesn't start with EXIF, write it for them
						writeWord(exifBuffer.length + 5 + 2); // length is buffer + EXIF\0 + length itself!
						writeByte(0x45); // E
						writeByte(0x78); // X
						writeByte(0x69); // I
						writeByte(0x66); // F
						writeByte(0); // = "EXIF",'\0'
					}

					for (var i = 0; i < exifBuffer.length; i++) {
						writeByte(exifBuffer[i]);
					}
				}

				function writeSOF0(width, height)
				{
					writeWord(0xFFC0); // marker
					writeWord(17);   // length, truecolor YUV JPG
					writeByte(8);    // precision
					writeWord(height);
					writeWord(width);
					writeByte(3);    // nrofcomponents
					writeByte(1);    // IdY
					writeByte(0x11); // HVY
					writeByte(0);    // QTY
					writeByte(2);    // IdU
					writeByte(0x11); // HVU
					writeByte(1);    // QTU
					writeByte(3);    // IdV
					writeByte(0x11); // HVV
					writeByte(1);    // QTV
				}
			
				function writeDQT()
				{
					writeWord(0xFFDB); // marker
					writeWord(132);	   // length
					writeByte(0);
					for (var i=0; i<64; i++) {
						writeByte(YTable[i]);
					}
					writeByte(1);
					for (var j=0; j<64; j++) {
						writeByte(UVTable[j]);
					}
				}
			
				function writeDHT()
				{
					writeWord(0xFFC4); // marker
					writeWord(0x01A2); // length
			
					writeByte(0); // HTYDCinfo
					for (var i=0; i<16; i++) {
						writeByte(std_dc_luminance_nrcodes[i+1]);
					}
					for (var j=0; j<=11; j++) {
						writeByte(std_dc_luminance_values[j]);
					}
			
					writeByte(0x10); // HTYACinfo
					for (var k=0; k<16; k++) {
						writeByte(std_ac_luminance_nrcodes[k+1]);
					}
					for (var l=0; l<=161; l++) {
						writeByte(std_ac_luminance_values[l]);
					}
			
					writeByte(1); // HTUDCinfo
					for (var m=0; m<16; m++) {
						writeByte(std_dc_chrominance_nrcodes[m+1]);
					}
					for (var n=0; n<=11; n++) {
						writeByte(std_dc_chrominance_values[n]);
					}
			
					writeByte(0x11); // HTUACinfo
					for (var o=0; o<16; o++) {
						writeByte(std_ac_chrominance_nrcodes[o+1]);
					}
					for (var p=0; p<=161; p++) {
						writeByte(std_ac_chrominance_values[p]);
					}
				}
				
				function writeCOM(comments)
				{
					if (typeof comments === "undefined" || comments.constructor !== Array) return;
					comments.forEach(e => {
						if (typeof e !== "string") return;
						writeWord(0xFFFE); // marker
						var l = e.length;
						writeWord(l + 2); // length itself as well
						var i;
						for (i = 0; i < l; i++)
							writeByte(e.charCodeAt(i));
					});
				}
			
				function writeSOS()
				{
					writeWord(0xFFDA); // marker
					writeWord(12); // length
					writeByte(3); // nrofcomponents
					writeByte(1); // IdY
					writeByte(0); // HTY
					writeByte(2); // IdU
					writeByte(0x11); // HTU
					writeByte(3); // IdV
					writeByte(0x11); // HTV
					writeByte(0); // Ss
					writeByte(0x3f); // Se
					writeByte(0); // Bf
				}
				
				function processDU(CDU, fdtbl, DC, HTDC, HTAC){
					var EOB = HTAC[0x00];
					var M16zeroes = HTAC[0xF0];
					var pos;
					var I16 = 16;
					var I63 = 63;
					var I64 = 64;
					var DU_DCT = fDCTQuant(CDU, fdtbl);
					//ZigZag reorder
					for (var j=0;j<I64;++j) {
						DU[ZigZag[j]]=DU_DCT[j];
					}
					var Diff = DU[0] - DC; DC = DU[0];
					//Encode DC
					if (Diff==0) {
						writeBits(HTDC[0]); // Diff might be 0
					} else {
						pos = 32767+Diff;
						writeBits(HTDC[category[pos]]);
						writeBits(bitcode[pos]);
					}
					//Encode ACs
					var end0pos = 63; // was const... which is crazy
					for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {}					//end0pos = first element in reverse order !=0
					if ( end0pos == 0) {
						writeBits(EOB);
						return DC;
					}
					var i = 1;
					var lng;
					while ( i <= end0pos ) {
						var startpos = i;
						for (; (DU[i]==0) && (i<=end0pos); ++i) {}
						var nrzeroes = i-startpos;
						if ( nrzeroes >= I16 ) {
							lng = nrzeroes>>4;
							for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
								writeBits(M16zeroes);
							nrzeroes = nrzeroes&0xF;
						}
						pos = 32767+DU[i];
						writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
						writeBits(bitcode[pos]);
						i++;
					}
					if ( end0pos != I63 ) {
						writeBits(EOB);
					}
					return DC;
				}

				function initCharLookupTable(){
					var sfcc = String.fromCharCode;
					for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
						clt[i] = sfcc(i);
					}
				}
				
				this.encode = function(image,quality) // image data object
				{
					new Date().getTime();
					
					if(quality) setQuality(quality);
					
					// Initialize bit writer
					byteout = new Array();
					bytenew=0;
					bytepos=7;
			
					// Add JPEG headers
					writeWord(0xFFD8); // SOI
					writeAPP0();
					writeCOM(image.comments);
					writeAPP1(image.exifBuffer);
					writeDQT();
					writeSOF0(image.width,image.height);
					writeDHT();
					writeSOS();

			
					// Encode 8x8 macroblocks
					var DCY=0;
					var DCU=0;
					var DCV=0;
					
					bytenew=0;
					bytepos=7;
					
					
					this.encode.displayName = "_encode_";

					var imageData = image.data;
					var width = image.width;
					var height = image.height;

					var quadWidth = width*4;
					
					var x, y = 0;
					var r, g, b;
					var start,p, col,row,pos;
					while(y < height){
						x = 0;
						while(x < quadWidth){
						start = quadWidth * y + x;
						p = start;
						col = -1;
						row = 0;
						
						for(pos=0; pos < 64; pos++){
							row = pos >> 3;// /8
							col = ( pos & 7 ) * 4; // %8
							p = start + ( row * quadWidth ) + col;		
							
							if(y+row >= height){ // padding bottom
								p-= (quadWidth*(y+1+row-height));
							}

							if(x+col >= quadWidth){ // padding right	
								p-= ((x+col) - quadWidth +4);
							}
							
							r = imageData[ p++ ];
							g = imageData[ p++ ];
							b = imageData[ p++ ];
							
							
							/* // calculate YUV values dynamically
							YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
							UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
							VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
							*/
							
							// use lookup table (slightly faster)
							YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
							UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
							VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

						}
						
						DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
						DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
						DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
						x+=32;
						}
						y+=8;
					}
					
					
					////////////////////////////////////////////////////////////////
			
					// Do the bit alignment of the EOI marker
					if ( bytepos >= 0 ) {
						var fillbits = [];
						fillbits[1] = bytepos+1;
						fillbits[0] = (1<<(bytepos+1))-1;
						writeBits(fillbits);
					}
			
					writeWord(0xFFD9); //EOI
		      return Buffer.from(byteout);
			};
			
			function setQuality(quality){
				if (quality <= 0) {
					quality = 1;
				}
				if (quality > 100) {
					quality = 100;
				}
				
				if(currentQuality == quality) return // don't recalc if unchanged
				
				var sf = 0;
				if (quality < 50) {
					sf = Math.floor(5000 / quality);
				} else {
					sf = Math.floor(200 - quality*2);
				}
				
				initQuantTables(sf);
				currentQuality = quality;
				//console.log('Quality set to: '+quality +'%');
			}
			
			function init(){
				var time_start = new Date().getTime();
				if(!quality) quality = 50;
				// Create tables
				initCharLookupTable();
				initHuffmanTbl();
				initCategoryNumber();
				initRGBYUVTable();
				
				setQuality(quality);
				new Date().getTime() - time_start;
		    	//console.log('Initialization '+ duration + 'ms');
			}
			
			init();
			
		}
		{
			module.exports = encode;
		}

		function encode(imgData, qu) {
		  if (typeof qu === 'undefined') qu = 50;
		  var encoder = new JPEGEncoder(qu);
			var data = encoder.encode(imgData, qu);
		  return {
		    data: data,
		    width: imgData.width,
		    height: imgData.height,
		  };
		}
	} (encoder));
	return encoder.exports;
}

var decoder = {exports: {}};

/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

var hasRequiredDecoder$1;

function requireDecoder$1 () {
	if (hasRequiredDecoder$1) return decoder.exports;
	hasRequiredDecoder$1 = 1;
	(function (module) {
		/*
		   Copyright 2011 notmasteryet

		   Licensed under the Apache License, Version 2.0 (the "License");
		   you may not use this file except in compliance with the License.
		   You may obtain a copy of the License at

		       http://www.apache.org/licenses/LICENSE-2.0

		   Unless required by applicable law or agreed to in writing, software
		   distributed under the License is distributed on an "AS IS" BASIS,
		   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		   See the License for the specific language governing permissions and
		   limitations under the License.
		*/

		// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
		//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
		// - The JFIF specification can be found in the JPEG File Interchange Format
		//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
		// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
		//   in PostScript Level 2, Technical Note #5116
		//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

		var JpegImage = (function jpegImage() {
		  var dctZigZag = new Int32Array([
		     0,
		     1,  8,
		    16,  9,  2,
		     3, 10, 17, 24,
		    32, 25, 18, 11, 4,
		     5, 12, 19, 26, 33, 40,
		    48, 41, 34, 27, 20, 13,  6,
		     7, 14, 21, 28, 35, 42, 49, 56,
		    57, 50, 43, 36, 29, 22, 15,
		    23, 30, 37, 44, 51, 58,
		    59, 52, 45, 38, 31,
		    39, 46, 53, 60,
		    61, 54, 47,
		    55, 62,
		    63
		  ]);

		  var dctCos1  =  4017;   // cos(pi/16)
		  var dctSin1  =   799;   // sin(pi/16)
		  var dctCos3  =  3406;   // cos(3*pi/16)
		  var dctSin3  =  2276;   // sin(3*pi/16)
		  var dctCos6  =  1567;   // cos(6*pi/16)
		  var dctSin6  =  3784;   // sin(6*pi/16)
		  var dctSqrt2 =  5793;   // sqrt(2)
		  var dctSqrt1d2 = 2896;  // sqrt(2) / 2

		  function constructor() {
		  }

		  function buildHuffmanTable(codeLengths, values) {
		    var k = 0, code = [], i, j, length = 16;
		    while (length > 0 && !codeLengths[length - 1])
		      length--;
		    code.push({children: [], index: 0});
		    var p = code[0], q;
		    for (i = 0; i < length; i++) {
		      for (j = 0; j < codeLengths[i]; j++) {
		        p = code.pop();
		        p.children[p.index] = values[k];
		        while (p.index > 0) {
		          if (code.length === 0)
		            throw new Error('Could not recreate Huffman Table');
		          p = code.pop();
		        }
		        p.index++;
		        code.push(p);
		        while (code.length <= i) {
		          code.push(q = {children: [], index: 0});
		          p.children[p.index] = q.children;
		          p = q;
		        }
		        k++;
		      }
		      if (i + 1 < length) {
		        // p here points to last code
		        code.push(q = {children: [], index: 0});
		        p.children[p.index] = q.children;
		        p = q;
		      }
		    }
		    return code[0].children;
		  }

		  function decodeScan(data, offset,
		                      frame, components, resetInterval,
		                      spectralStart, spectralEnd,
		                      successivePrev, successive, opts) {
		    frame.precision;
		    frame.samplesPerLine;
		    frame.scanLines;
		    var mcusPerLine = frame.mcusPerLine;
		    var progressive = frame.progressive;
		    frame.maxH; frame.maxV;

		    var startOffset = offset, bitsData = 0, bitsCount = 0;
		    function readBit() {
		      if (bitsCount > 0) {
		        bitsCount--;
		        return (bitsData >> bitsCount) & 1;
		      }
		      bitsData = data[offset++];
		      if (bitsData == 0xFF) {
		        var nextByte = data[offset++];
		        if (nextByte) {
		          throw new Error("unexpected marker: " + ((bitsData << 8) | nextByte).toString(16));
		        }
		        // unstuff 0
		      }
		      bitsCount = 7;
		      return bitsData >>> 7;
		    }
		    function decodeHuffman(tree) {
		      var node = tree, bit;
		      while ((bit = readBit()) !== null) {
		        node = node[bit];
		        if (typeof node === 'number')
		          return node;
		        if (typeof node !== 'object')
		          throw new Error("invalid huffman sequence");
		      }
		      return null;
		    }
		    function receive(length) {
		      var n = 0;
		      while (length > 0) {
		        var bit = readBit();
		        if (bit === null) return;
		        n = (n << 1) | bit;
		        length--;
		      }
		      return n;
		    }
		    function receiveAndExtend(length) {
		      var n = receive(length);
		      if (n >= 1 << (length - 1))
		        return n;
		      return n + (-1 << length) + 1;
		    }
		    function decodeBaseline(component, zz) {
		      var t = decodeHuffman(component.huffmanTableDC);
		      var diff = t === 0 ? 0 : receiveAndExtend(t);
		      zz[0]= (component.pred += diff);
		      var k = 1;
		      while (k < 64) {
		        var rs = decodeHuffman(component.huffmanTableAC);
		        var s = rs & 15, r = rs >> 4;
		        if (s === 0) {
		          if (r < 15)
		            break;
		          k += 16;
		          continue;
		        }
		        k += r;
		        var z = dctZigZag[k];
		        zz[z] = receiveAndExtend(s);
		        k++;
		      }
		    }
		    function decodeDCFirst(component, zz) {
		      var t = decodeHuffman(component.huffmanTableDC);
		      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
		      zz[0] = (component.pred += diff);
		    }
		    function decodeDCSuccessive(component, zz) {
		      zz[0] |= readBit() << successive;
		    }
		    var eobrun = 0;
		    function decodeACFirst(component, zz) {
		      if (eobrun > 0) {
		        eobrun--;
		        return;
		      }
		      var k = spectralStart, e = spectralEnd;
		      while (k <= e) {
		        var rs = decodeHuffman(component.huffmanTableAC);
		        var s = rs & 15, r = rs >> 4;
		        if (s === 0) {
		          if (r < 15) {
		            eobrun = receive(r) + (1 << r) - 1;
		            break;
		          }
		          k += 16;
		          continue;
		        }
		        k += r;
		        var z = dctZigZag[k];
		        zz[z] = receiveAndExtend(s) * (1 << successive);
		        k++;
		      }
		    }
		    var successiveACState = 0, successiveACNextValue;
		    function decodeACSuccessive(component, zz) {
		      var k = spectralStart, e = spectralEnd, r = 0;
		      while (k <= e) {
		        var z = dctZigZag[k];
		        var direction = zz[z] < 0 ? -1 : 1;
		        switch (successiveACState) {
		        case 0: // initial state
		          var rs = decodeHuffman(component.huffmanTableAC);
		          var s = rs & 15, r = rs >> 4;
		          if (s === 0) {
		            if (r < 15) {
		              eobrun = receive(r) + (1 << r);
		              successiveACState = 4;
		            } else {
		              r = 16;
		              successiveACState = 1;
		            }
		          } else {
		            if (s !== 1)
		              throw new Error("invalid ACn encoding");
		            successiveACNextValue = receiveAndExtend(s);
		            successiveACState = r ? 2 : 3;
		          }
		          continue;
		        case 1: // skipping r zero items
		        case 2:
		          if (zz[z])
		            zz[z] += (readBit() << successive) * direction;
		          else {
		            r--;
		            if (r === 0)
		              successiveACState = successiveACState == 2 ? 3 : 0;
		          }
		          break;
		        case 3: // set value for a zero item
		          if (zz[z])
		            zz[z] += (readBit() << successive) * direction;
		          else {
		            zz[z] = successiveACNextValue << successive;
		            successiveACState = 0;
		          }
		          break;
		        case 4: // eob
		          if (zz[z])
		            zz[z] += (readBit() << successive) * direction;
		          break;
		        }
		        k++;
		      }
		      if (successiveACState === 4) {
		        eobrun--;
		        if (eobrun === 0)
		          successiveACState = 0;
		      }
		    }
		    function decodeMcu(component, decode, mcu, row, col) {
		      var mcuRow = (mcu / mcusPerLine) | 0;
		      var mcuCol = mcu % mcusPerLine;
		      var blockRow = mcuRow * component.v + row;
		      var blockCol = mcuCol * component.h + col;
		      // If the block is missing and we're in tolerant mode, just skip it.
		      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
		        return;
		      decode(component, component.blocks[blockRow][blockCol]);
		    }
		    function decodeBlock(component, decode, mcu) {
		      var blockRow = (mcu / component.blocksPerLine) | 0;
		      var blockCol = mcu % component.blocksPerLine;
		      // If the block is missing and we're in tolerant mode, just skip it.
		      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
		        return;
		      decode(component, component.blocks[blockRow][blockCol]);
		    }

		    var componentsLength = components.length;
		    var component, i, j, k, n;
		    var decodeFn;
		    if (progressive) {
		      if (spectralStart === 0)
		        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
		      else
		        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
		    } else {
		      decodeFn = decodeBaseline;
		    }

		    var mcu = 0, marker;
		    var mcuExpected;
		    if (componentsLength == 1) {
		      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
		    } else {
		      mcuExpected = mcusPerLine * frame.mcusPerColumn;
		    }
		    if (!resetInterval) resetInterval = mcuExpected;

		    var h, v;
		    while (mcu < mcuExpected) {
		      // reset interval stuff
		      for (i = 0; i < componentsLength; i++)
		        components[i].pred = 0;
		      eobrun = 0;

		      if (componentsLength == 1) {
		        component = components[0];
		        for (n = 0; n < resetInterval; n++) {
		          decodeBlock(component, decodeFn, mcu);
		          mcu++;
		        }
		      } else {
		        for (n = 0; n < resetInterval; n++) {
		          for (i = 0; i < componentsLength; i++) {
		            component = components[i];
		            h = component.h;
		            v = component.v;
		            for (j = 0; j < v; j++) {
		              for (k = 0; k < h; k++) {
		                decodeMcu(component, decodeFn, mcu, j, k);
		              }
		            }
		          }
		          mcu++;

		          // If we've reached our expected MCU's, stop decoding
		          if (mcu === mcuExpected) break;
		        }
		      }

		      if (mcu === mcuExpected) {
		        // Skip trailing bytes at the end of the scan - until we reach the next marker
		        do {
		          if (data[offset] === 0xFF) {
		            if (data[offset + 1] !== 0x00) {
		              break;
		            }
		          }
		          offset += 1;
		        } while (offset < data.length - 2);
		      }

		      // find marker
		      bitsCount = 0;
		      marker = (data[offset] << 8) | data[offset + 1];
		      if (marker < 0xFF00) {
		        throw new Error("marker was not found");
		      }

		      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
		        offset += 2;
		      }
		      else
		        break;
		    }

		    return offset - startOffset;
		  }

		  function buildComponentData(frame, component) {
		    var lines = [];
		    var blocksPerLine = component.blocksPerLine;
		    var blocksPerColumn = component.blocksPerColumn;
		    var samplesPerLine = blocksPerLine << 3;
		    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.
		    var R = new Int32Array(64), r = new Uint8Array(64);

		    // A port of poppler's IDCT method which in turn is taken from:
		    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
		    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
		    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
		    //   988-991.
		    function quantizeAndInverse(zz, dataOut, dataIn) {
		      var qt = component.quantizationTable;
		      var v0, v1, v2, v3, v4, v5, v6, v7, t;
		      var p = dataIn;
		      var i;

		      // dequant
		      for (i = 0; i < 64; i++)
		        p[i] = zz[i] * qt[i];

		      // inverse DCT on rows
		      for (i = 0; i < 8; ++i) {
		        var row = 8 * i;

		        // check for all-zero AC coefficients
		        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
		            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
		            p[7 + row] == 0) {
		          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
		          p[0 + row] = t;
		          p[1 + row] = t;
		          p[2 + row] = t;
		          p[3 + row] = t;
		          p[4 + row] = t;
		          p[5 + row] = t;
		          p[6 + row] = t;
		          p[7 + row] = t;
		          continue;
		        }

		        // stage 4
		        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
		        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
		        v2 = p[2 + row];
		        v3 = p[6 + row];
		        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
		        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
		        v5 = p[3 + row] << 4;
		        v6 = p[5 + row] << 4;

		        // stage 3
		        t = (v0 - v1+ 1) >> 1;
		        v0 = (v0 + v1 + 1) >> 1;
		        v1 = t;
		        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
		        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
		        v3 = t;
		        t = (v4 - v6 + 1) >> 1;
		        v4 = (v4 + v6 + 1) >> 1;
		        v6 = t;
		        t = (v7 + v5 + 1) >> 1;
		        v5 = (v7 - v5 + 1) >> 1;
		        v7 = t;

		        // stage 2
		        t = (v0 - v3 + 1) >> 1;
		        v0 = (v0 + v3 + 1) >> 1;
		        v3 = t;
		        t = (v1 - v2 + 1) >> 1;
		        v1 = (v1 + v2 + 1) >> 1;
		        v2 = t;
		        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
		        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
		        v7 = t;
		        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
		        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
		        v6 = t;

		        // stage 1
		        p[0 + row] = v0 + v7;
		        p[7 + row] = v0 - v7;
		        p[1 + row] = v1 + v6;
		        p[6 + row] = v1 - v6;
		        p[2 + row] = v2 + v5;
		        p[5 + row] = v2 - v5;
		        p[3 + row] = v3 + v4;
		        p[4 + row] = v3 - v4;
		      }

		      // inverse DCT on columns
		      for (i = 0; i < 8; ++i) {
		        var col = i;

		        // check for all-zero AC coefficients
		        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
		            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
		            p[7*8 + col] == 0) {
		          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
		          p[0*8 + col] = t;
		          p[1*8 + col] = t;
		          p[2*8 + col] = t;
		          p[3*8 + col] = t;
		          p[4*8 + col] = t;
		          p[5*8 + col] = t;
		          p[6*8 + col] = t;
		          p[7*8 + col] = t;
		          continue;
		        }

		        // stage 4
		        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
		        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
		        v2 = p[2*8 + col];
		        v3 = p[6*8 + col];
		        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
		        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
		        v5 = p[3*8 + col];
		        v6 = p[5*8 + col];

		        // stage 3
		        t = (v0 - v1 + 1) >> 1;
		        v0 = (v0 + v1 + 1) >> 1;
		        v1 = t;
		        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
		        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
		        v3 = t;
		        t = (v4 - v6 + 1) >> 1;
		        v4 = (v4 + v6 + 1) >> 1;
		        v6 = t;
		        t = (v7 + v5 + 1) >> 1;
		        v5 = (v7 - v5 + 1) >> 1;
		        v7 = t;

		        // stage 2
		        t = (v0 - v3 + 1) >> 1;
		        v0 = (v0 + v3 + 1) >> 1;
		        v3 = t;
		        t = (v1 - v2 + 1) >> 1;
		        v1 = (v1 + v2 + 1) >> 1;
		        v2 = t;
		        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
		        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
		        v7 = t;
		        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
		        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
		        v6 = t;

		        // stage 1
		        p[0*8 + col] = v0 + v7;
		        p[7*8 + col] = v0 - v7;
		        p[1*8 + col] = v1 + v6;
		        p[6*8 + col] = v1 - v6;
		        p[2*8 + col] = v2 + v5;
		        p[5*8 + col] = v2 - v5;
		        p[3*8 + col] = v3 + v4;
		        p[4*8 + col] = v3 - v4;
		      }

		      // convert to 8-bit integers
		      for (i = 0; i < 64; ++i) {
		        var sample = 128 + ((p[i] + 8) >> 4);
		        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
		      }
		    }

		    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);

		    var i, j;
		    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
		      var scanLine = blockRow << 3;
		      for (i = 0; i < 8; i++)
		        lines.push(new Uint8Array(samplesPerLine));
		      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
		        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

		        var offset = 0, sample = blockCol << 3;
		        for (j = 0; j < 8; j++) {
		          var line = lines[scanLine + j];
		          for (i = 0; i < 8; i++)
		            line[sample + i] = r[offset++];
		        }
		      }
		    }
		    return lines;
		  }

		  function clampTo8bit(a) {
		    return a < 0 ? 0 : a > 255 ? 255 : a;
		  }

		  constructor.prototype = {
		    load: function load(path) {
		      var xhr = new XMLHttpRequest();
		      xhr.open("GET", path, true);
		      xhr.responseType = "arraybuffer";
		      xhr.onload = (function() {
		        // TODO catch parse error
		        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
		        this.parse(data);
		        if (this.onload)
		          this.onload();
		      }).bind(this);
		      xhr.send(null);
		    },
		    parse: function parse(data) {
		      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
		      var offset = 0; data.length;
		      function readUint16() {
		        var value = (data[offset] << 8) | data[offset + 1];
		        offset += 2;
		        return value;
		      }
		      function readDataBlock() {
		        var length = readUint16();
		        var array = data.subarray(offset, offset + length - 2);
		        offset += array.length;
		        return array;
		      }
		      function prepareComponents(frame) {
		        // According to the JPEG standard, the sampling factor must be between 1 and 4
		        // See https://github.com/libjpeg-turbo/libjpeg-turbo/blob/9abeff46d87bd201a952e276f3e4339556a403a3/libjpeg.txt#L1138-L1146
		        var maxH = 1, maxV = 1;
		        var component, componentId;
		        for (componentId in frame.components) {
		          if (frame.components.hasOwnProperty(componentId)) {
		            component = frame.components[componentId];
		            if (maxH < component.h) maxH = component.h;
		            if (maxV < component.v) maxV = component.v;
		          }
		        }
		        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
		        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
		        for (componentId in frame.components) {
		          if (frame.components.hasOwnProperty(componentId)) {
		            component = frame.components[componentId];
		            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
		            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
		            var blocksPerLineForMcu = mcusPerLine * component.h;
		            var blocksPerColumnForMcu = mcusPerColumn * component.v;
		            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
		            var blocks = [];

		            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)
		            requestMemoryAllocation(blocksToAllocate * 256);

		            for (var i = 0; i < blocksPerColumnForMcu; i++) {
		              var row = [];
		              for (var j = 0; j < blocksPerLineForMcu; j++)
		                row.push(new Int32Array(64));
		              blocks.push(row);
		            }
		            component.blocksPerLine = blocksPerLine;
		            component.blocksPerColumn = blocksPerColumn;
		            component.blocks = blocks;
		          }
		        }
		        frame.maxH = maxH;
		        frame.maxV = maxV;
		        frame.mcusPerLine = mcusPerLine;
		        frame.mcusPerColumn = mcusPerColumn;
		      }
		      var jfif = null;
		      var adobe = null;
		      var frame, resetInterval;
		      var quantizationTables = [], frames = [];
		      var huffmanTablesAC = [], huffmanTablesDC = [];
		      var fileMarker = readUint16();
		      var malformedDataOffset = -1;
		      this.comments = [];
		      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
		        throw new Error("SOI not found");
		      }

		      fileMarker = readUint16();
		      while (fileMarker != 0xFFD9) { // EOI (End of image)
		        var i, j;
		        switch(fileMarker) {
		          case 0xFF00: break;
		          case 0xFFE0: // APP0 (Application Specific)
		          case 0xFFE1: // APP1
		          case 0xFFE2: // APP2
		          case 0xFFE3: // APP3
		          case 0xFFE4: // APP4
		          case 0xFFE5: // APP5
		          case 0xFFE6: // APP6
		          case 0xFFE7: // APP7
		          case 0xFFE8: // APP8
		          case 0xFFE9: // APP9
		          case 0xFFEA: // APP10
		          case 0xFFEB: // APP11
		          case 0xFFEC: // APP12
		          case 0xFFED: // APP13
		          case 0xFFEE: // APP14
		          case 0xFFEF: // APP15
		          case 0xFFFE: // COM (Comment)
		            var appData = readDataBlock();

		            if (fileMarker === 0xFFFE) {
		              var comment = String.fromCharCode.apply(null, appData);
		              this.comments.push(comment);
		            }

		            if (fileMarker === 0xFFE0) {
		              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
		                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
		                jfif = {
		                  version: { major: appData[5], minor: appData[6] },
		                  densityUnits: appData[7],
		                  xDensity: (appData[8] << 8) | appData[9],
		                  yDensity: (appData[10] << 8) | appData[11],
		                  thumbWidth: appData[12],
		                  thumbHeight: appData[13],
		                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
		                };
		              }
		            }
		            // TODO APP1 - Exif
		            if (fileMarker === 0xFFE1) {
		              if (appData[0] === 0x45 &&
		                appData[1] === 0x78 &&
		                appData[2] === 0x69 &&
		                appData[3] === 0x66 &&
		                appData[4] === 0) { // 'EXIF\x00'
		                this.exifBuffer = appData.subarray(5, appData.length);
		              }
		            }

		            if (fileMarker === 0xFFEE) {
		              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
		                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
		                adobe = {
		                  version: appData[6],
		                  flags0: (appData[7] << 8) | appData[8],
		                  flags1: (appData[9] << 8) | appData[10],
		                  transformCode: appData[11]
		                };
		              }
		            }
		            break;

		          case 0xFFDB: // DQT (Define Quantization Tables)
		            var quantizationTablesLength = readUint16();
		            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
		            while (offset < quantizationTablesEnd) {
		              var quantizationTableSpec = data[offset++];
		              requestMemoryAllocation(64 * 4);
		              var tableData = new Int32Array(64);
		              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
		                for (j = 0; j < 64; j++) {
		                  var z = dctZigZag[j];
		                  tableData[z] = data[offset++];
		                }
		              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
		                for (j = 0; j < 64; j++) {
		                  var z = dctZigZag[j];
		                  tableData[z] = readUint16();
		                }
		              } else
		                throw new Error("DQT: invalid table spec");
		              quantizationTables[quantizationTableSpec & 15] = tableData;
		            }
		            break;

		          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
		          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
		          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
		            readUint16(); // skip data length
		            frame = {};
		            frame.extended = (fileMarker === 0xFFC1);
		            frame.progressive = (fileMarker === 0xFFC2);
		            frame.precision = data[offset++];
		            frame.scanLines = readUint16();
		            frame.samplesPerLine = readUint16();
		            frame.components = {};
		            frame.componentsOrder = [];

		            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
		            if (pixelsInFrame > maxResolutionInPixels) {
		              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
		              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
		            }

		            var componentsCount = data[offset++], componentId;
		            for (i = 0; i < componentsCount; i++) {
		              componentId = data[offset];
		              var h = data[offset + 1] >> 4;
		              var v = data[offset + 1] & 15;
		              var qId = data[offset + 2];

		              if ( h <= 0 || v <= 0 ) {
		                throw new Error('Invalid sampling factor, expected values above 0');
		              }

		              frame.componentsOrder.push(componentId);
		              frame.components[componentId] = {
		                h: h,
		                v: v,
		                quantizationIdx: qId
		              };
		              offset += 3;
		            }
		            prepareComponents(frame);
		            frames.push(frame);
		            break;

		          case 0xFFC4: // DHT (Define Huffman Tables)
		            var huffmanLength = readUint16();
		            for (i = 2; i < huffmanLength;) {
		              var huffmanTableSpec = data[offset++];
		              var codeLengths = new Uint8Array(16);
		              var codeLengthSum = 0;
		              for (j = 0; j < 16; j++, offset++) {
		                codeLengthSum += (codeLengths[j] = data[offset]);
		              }
		              requestMemoryAllocation(16 + codeLengthSum);
		              var huffmanValues = new Uint8Array(codeLengthSum);
		              for (j = 0; j < codeLengthSum; j++, offset++)
		                huffmanValues[j] = data[offset];
		              i += 17 + codeLengthSum;

		              ((huffmanTableSpec >> 4) === 0 ?
		                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
		                buildHuffmanTable(codeLengths, huffmanValues);
		            }
		            break;

		          case 0xFFDD: // DRI (Define Restart Interval)
		            readUint16(); // skip data length
		            resetInterval = readUint16();
		            break;

		          case 0xFFDC: // Number of Lines marker
		            readUint16(); // skip data length
		            readUint16(); // Ignore this data since it represents the image height
		            break;
		            
		          case 0xFFDA: // SOS (Start of Scan)
		            readUint16();
		            var selectorsCount = data[offset++];
		            var components = [], component;
		            for (i = 0; i < selectorsCount; i++) {
		              component = frame.components[data[offset++]];
		              var tableSpec = data[offset++];
		              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
		              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
		              components.push(component);
		            }
		            var spectralStart = data[offset++];
		            var spectralEnd = data[offset++];
		            var successiveApproximation = data[offset++];
		            var processed = decodeScan(data, offset,
		              frame, components, resetInterval,
		              spectralStart, spectralEnd,
		              successiveApproximation >> 4, successiveApproximation & 15, this.opts);
		            offset += processed;
		            break;

		          case 0xFFFF: // Fill bytes
		            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
		              offset--;
		            }
		            break;
		          default:
		            if (data[offset - 3] == 0xFF &&
		                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
		              // could be incorrect encoding -- last 0xFF byte of the previous
		              // block was eaten by the encoder
		              offset -= 3;
		              break;
		            }
		            else if (fileMarker === 0xE0 || fileMarker == 0xE1) {
		              // Recover from malformed APP1 markers popular in some phone models.
		              // See https://github.com/eugeneware/jpeg-js/issues/82
		              if (malformedDataOffset !== -1) {
		                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
		              }
		              malformedDataOffset = offset - 1;
		              const nextOffset = readUint16();
		              if (data[offset + nextOffset - 2] === 0xFF) {
		                offset += nextOffset - 2;
		                break;
		              }
		            }
		            throw new Error("unknown JPEG marker " + fileMarker.toString(16));
		        }
		        fileMarker = readUint16();
		      }
		      if (frames.length != 1)
		        throw new Error("only single frame JPEGs supported");

		      // set each frame's components quantization table
		      for (var i = 0; i < frames.length; i++) {
		        var cp = frames[i].components;
		        for (var j in cp) {
		          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
		          delete cp[j].quantizationIdx;
		        }
		      }

		      this.width = frame.samplesPerLine;
		      this.height = frame.scanLines;
		      this.jfif = jfif;
		      this.adobe = adobe;
		      this.components = [];
		      for (var i = 0; i < frame.componentsOrder.length; i++) {
		        var component = frame.components[frame.componentsOrder[i]];
		        this.components.push({
		          lines: buildComponentData(frame, component),
		          scaleX: component.h / frame.maxH,
		          scaleY: component.v / frame.maxV
		        });
		      }
		    },
		    getData: function getData(width, height) {
		      var scaleX = this.width / width, scaleY = this.height / height;

		      var component1, component2, component3, component4;
		      var component1Line, component2Line, component3Line, component4Line;
		      var x, y;
		      var offset = 0;
		      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
		      var colorTransform;
		      var dataLength = width * height * this.components.length;
		      requestMemoryAllocation(dataLength);
		      var data = new Uint8Array(dataLength);
		      switch (this.components.length) {
		        case 1:
		          component1 = this.components[0];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

		              data[offset++] = Y;
		            }
		          }
		          break;
		        case 2:
		          // PDF might compress two component data in custom colorspace
		          component1 = this.components[0];
		          component2 = this.components[1];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
		              data[offset++] = Y;
		              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
		              data[offset++] = Y;
		            }
		          }
		          break;
		        case 3:
		          // The default transform for three components is true
		          colorTransform = true;
		          // The adobe transform marker overrides any previous setting
		          if (this.adobe && this.adobe.transformCode)
		            colorTransform = true;
		          else if (typeof this.opts.colorTransform !== 'undefined')
		            colorTransform = !!this.opts.colorTransform;

		          component1 = this.components[0];
		          component2 = this.components[1];
		          component3 = this.components[2];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
		            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              if (!colorTransform) {
		                R = component1Line[0 | (x * component1.scaleX * scaleX)];
		                G = component2Line[0 | (x * component2.scaleX * scaleX)];
		                B = component3Line[0 | (x * component3.scaleX * scaleX)];
		              } else {
		                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
		                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
		                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

		                R = clampTo8bit(Y + 1.402 * (Cr - 128));
		                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
		                B = clampTo8bit(Y + 1.772 * (Cb - 128));
		              }

		              data[offset++] = R;
		              data[offset++] = G;
		              data[offset++] = B;
		            }
		          }
		          break;
		        case 4:
		          if (!this.adobe)
		            throw new Error('Unsupported color mode (4 components)');
		          // The default transform for four components is false
		          colorTransform = false;
		          // The adobe transform marker overrides any previous setting
		          if (this.adobe && this.adobe.transformCode)
		            colorTransform = true;
		          else if (typeof this.opts.colorTransform !== 'undefined')
		            colorTransform = !!this.opts.colorTransform;

		          component1 = this.components[0];
		          component2 = this.components[1];
		          component3 = this.components[2];
		          component4 = this.components[3];
		          for (y = 0; y < height; y++) {
		            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
		            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
		            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
		            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
		            for (x = 0; x < width; x++) {
		              if (!colorTransform) {
		                C = component1Line[0 | (x * component1.scaleX * scaleX)];
		                M = component2Line[0 | (x * component2.scaleX * scaleX)];
		                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
		                K = component4Line[0 | (x * component4.scaleX * scaleX)];
		              } else {
		                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
		                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
		                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
		                K = component4Line[0 | (x * component4.scaleX * scaleX)];

		                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
		                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
		                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
		              }
		              data[offset++] = 255-C;
		              data[offset++] = 255-M;
		              data[offset++] = 255-Ye;
		              data[offset++] = 255-K;
		            }
		          }
		          break;
		        default:
		          throw new Error('Unsupported color mode');
		      }
		      return data;
		    },
		    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
		      var width = imageData.width, height = imageData.height;
		      var imageDataArray = imageData.data;
		      var data = this.getData(width, height);
		      var i = 0, j = 0, x, y;
		      var Y, K, C, M, R, G, B;
		      switch (this.components.length) {
		        case 1:
		          for (y = 0; y < height; y++) {
		            for (x = 0; x < width; x++) {
		              Y = data[i++];

		              imageDataArray[j++] = Y;
		              imageDataArray[j++] = Y;
		              imageDataArray[j++] = Y;
		              if (formatAsRGBA) {
		                imageDataArray[j++] = 255;
		              }
		            }
		          }
		          break;
		        case 3:
		          for (y = 0; y < height; y++) {
		            for (x = 0; x < width; x++) {
		              R = data[i++];
		              G = data[i++];
		              B = data[i++];

		              imageDataArray[j++] = R;
		              imageDataArray[j++] = G;
		              imageDataArray[j++] = B;
		              if (formatAsRGBA) {
		                imageDataArray[j++] = 255;
		              }
		            }
		          }
		          break;
		        case 4:
		          for (y = 0; y < height; y++) {
		            for (x = 0; x < width; x++) {
		              C = data[i++];
		              M = data[i++];
		              Y = data[i++];
		              K = data[i++];

		              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
		              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
		              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

		              imageDataArray[j++] = R;
		              imageDataArray[j++] = G;
		              imageDataArray[j++] = B;
		              if (formatAsRGBA) {
		                imageDataArray[j++] = 255;
		              }
		            }
		          }
		          break;
		        default:
		          throw new Error('Unsupported color mode');
		      }
		    }
		  };


		  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.
		  var totalBytesAllocated = 0;
		  var maxMemoryUsageBytes = 0;
		  function requestMemoryAllocation(increaseAmount = 0) {
		    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
		    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
		      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
		      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
		    }

		    totalBytesAllocated = totalMemoryImpactBytes;
		  }

		  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {
		    totalBytesAllocated = 0;
		    maxMemoryUsageBytes = maxMemoryUsageBytes_;
		  };

		  constructor.getBytesAllocated = function () {
		    return totalBytesAllocated;
		  };

		  constructor.requestMemoryAllocation = requestMemoryAllocation;

		  return constructor;
		})();

		{
			module.exports = decode;
		}

		function decode(jpegData, userOpts = {}) {
		  var defaultOpts = {
		    // "undefined" means "Choose whether to transform colors based on the images color model."
		    colorTransform: undefined,
		    useTArray: false,
		    formatAsRGBA: true,
		    tolerantDecoding: true,
		    maxResolutionInMP: 100, // Don't decode more than 100 megapixels
		    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB
		  };

		  var opts = {...defaultOpts, ...userOpts};
		  var arr = new Uint8Array(jpegData);
		  var decoder = new JpegImage();
		  decoder.opts = opts;
		  // If this constructor ever supports async decoding this will need to be done differently.
		  // Until then, treating as singleton limit is fine.
		  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
		  decoder.parse(arr);

		  var channels = (opts.formatAsRGBA) ? 4 : 3;
		  var bytesNeeded = decoder.width * decoder.height * channels;
		  try {
		    JpegImage.requestMemoryAllocation(bytesNeeded);
		    var image = {
		      width: decoder.width,
		      height: decoder.height,
		      exifBuffer: decoder.exifBuffer,
		      data: opts.useTArray ?
		        new Uint8Array(bytesNeeded) :
		        Buffer.alloc(bytesNeeded)
		    };
		    if(decoder.comments.length > 0) {
		      image["comments"] = decoder.comments;
		    }
		  } catch (err) {
		    if (err instanceof RangeError) {
		      throw new Error("Could not allocate enough memory for the image. " +
		                      "Required: " + bytesNeeded);
		    } 
		    
		    if (err instanceof ReferenceError) {
		      if (err.message === "Buffer is not defined") {
		        throw new Error("Buffer is not globally defined in this environment. " +
		                        "Consider setting useTArray to true");
		      }
		    }
		    throw err;
		  }

		  decoder.copyToImageData(image, opts.formatAsRGBA);

		  return image;
		} 
	} (decoder));
	return decoder.exports;
}

var jpegJs;
var hasRequiredJpegJs;

function requireJpegJs () {
	if (hasRequiredJpegJs) return jpegJs;
	hasRequiredJpegJs = 1;
	var encode = requireEncoder(),
	    decode = requireDecoder$1();

	jpegJs = {
	  encode: encode,
	  decode: decode
	};
	return jpegJs;
}

var jpegJsExports = requireJpegJs();
var JPEG = /*@__PURE__*/getDefaultExportFromCjs(jpegJsExports);

function jpeg$1() {
    return {
        mime: "image/jpeg",
        encode: (bitmap, { quality = 100 } = {}) => JPEG.encode(bitmap, quality).data,
        decode: (data, options) => JPEG.decode(data, options),
    };
}

var png$1 = {};

var parserAsync = {exports: {}};

var chunkstream = {exports: {}};

var hasRequiredChunkstream;

function requireChunkstream () {
	if (hasRequiredChunkstream) return chunkstream.exports;
	hasRequiredChunkstream = 1;

	let util = require$$0$1;
	let Stream = require$$1;

	let ChunkStream = (chunkstream.exports = function () {
	  Stream.call(this);

	  this._buffers = [];
	  this._buffered = 0;

	  this._reads = [];
	  this._paused = false;

	  this._encoding = "utf8";
	  this.writable = true;
	});
	util.inherits(ChunkStream, Stream);

	ChunkStream.prototype.read = function (length, callback) {
	  this._reads.push({
	    length: Math.abs(length), // if length < 0 then at most this length
	    allowLess: length < 0,
	    func: callback,
	  });

	  process.nextTick(
	    function () {
	      this._process();

	      // its paused and there is not enought data then ask for more
	      if (this._paused && this._reads && this._reads.length > 0) {
	        this._paused = false;

	        this.emit("drain");
	      }
	    }.bind(this)
	  );
	};

	ChunkStream.prototype.write = function (data, encoding) {
	  if (!this.writable) {
	    this.emit("error", new Error("Stream not writable"));
	    return false;
	  }

	  let dataBuffer;
	  if (Buffer.isBuffer(data)) {
	    dataBuffer = data;
	  } else {
	    dataBuffer = Buffer.from(data, encoding || this._encoding);
	  }

	  this._buffers.push(dataBuffer);
	  this._buffered += dataBuffer.length;

	  this._process();

	  // ok if there are no more read requests
	  if (this._reads && this._reads.length === 0) {
	    this._paused = true;
	  }

	  return this.writable && !this._paused;
	};

	ChunkStream.prototype.end = function (data, encoding) {
	  if (data) {
	    this.write(data, encoding);
	  }

	  this.writable = false;

	  // already destroyed
	  if (!this._buffers) {
	    return;
	  }

	  // enqueue or handle end
	  if (this._buffers.length === 0) {
	    this._end();
	  } else {
	    this._buffers.push(null);
	    this._process();
	  }
	};

	ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;

	ChunkStream.prototype._end = function () {
	  if (this._reads.length > 0) {
	    this.emit("error", new Error("Unexpected end of input"));
	  }

	  this.destroy();
	};

	ChunkStream.prototype.destroy = function () {
	  if (!this._buffers) {
	    return;
	  }

	  this.writable = false;
	  this._reads = null;
	  this._buffers = null;

	  this.emit("close");
	};

	ChunkStream.prototype._processReadAllowingLess = function (read) {
	  // ok there is any data so that we can satisfy this request
	  this._reads.shift(); // == read

	  // first we need to peek into first buffer
	  let smallerBuf = this._buffers[0];

	  // ok there is more data than we need
	  if (smallerBuf.length > read.length) {
	    this._buffered -= read.length;
	    this._buffers[0] = smallerBuf.slice(read.length);

	    read.func.call(this, smallerBuf.slice(0, read.length));
	  } else {
	    // ok this is less than maximum length so use it all
	    this._buffered -= smallerBuf.length;
	    this._buffers.shift(); // == smallerBuf

	    read.func.call(this, smallerBuf);
	  }
	};

	ChunkStream.prototype._processRead = function (read) {
	  this._reads.shift(); // == read

	  let pos = 0;
	  let count = 0;
	  let data = Buffer.alloc(read.length);

	  // create buffer for all data
	  while (pos < read.length) {
	    let buf = this._buffers[count++];
	    let len = Math.min(buf.length, read.length - pos);

	    buf.copy(data, pos, 0, len);
	    pos += len;

	    // last buffer wasn't used all so just slice it and leave
	    if (len !== buf.length) {
	      this._buffers[--count] = buf.slice(len);
	    }
	  }

	  // remove all used buffers
	  if (count > 0) {
	    this._buffers.splice(0, count);
	  }

	  this._buffered -= read.length;

	  read.func.call(this, data);
	};

	ChunkStream.prototype._process = function () {
	  try {
	    // as long as there is any data and read requests
	    while (this._buffered > 0 && this._reads && this._reads.length > 0) {
	      let read = this._reads[0];

	      // read any data (but no more than length)
	      if (read.allowLess) {
	        this._processReadAllowingLess(read);
	      } else if (this._buffered >= read.length) {
	        // ok we can meet some expectations

	        this._processRead(read);
	      } else {
	        // not enought data to satisfy first request in queue
	        // so we need to wait for more
	        break;
	      }
	    }

	    if (this._buffers && !this.writable) {
	      this._end();
	    }
	  } catch (ex) {
	    this.emit("error", ex);
	  }
	};
	return chunkstream.exports;
}

var filterParseAsync = {exports: {}};

var filterParse = {exports: {}};

var interlace = {};

var hasRequiredInterlace;

function requireInterlace () {
	if (hasRequiredInterlace) return interlace;
	hasRequiredInterlace = 1;

	// Adam 7
	//   0 1 2 3 4 5 6 7
	// 0 x 6 4 6 x 6 4 6
	// 1 7 7 7 7 7 7 7 7
	// 2 5 6 5 6 5 6 5 6
	// 3 7 7 7 7 7 7 7 7
	// 4 3 6 4 6 3 6 4 6
	// 5 7 7 7 7 7 7 7 7
	// 6 5 6 5 6 5 6 5 6
	// 7 7 7 7 7 7 7 7 7

	let imagePasses = [
	  {
	    // pass 1 - 1px
	    x: [0],
	    y: [0],
	  },
	  {
	    // pass 2 - 1px
	    x: [4],
	    y: [0],
	  },
	  {
	    // pass 3 - 2px
	    x: [0, 4],
	    y: [4],
	  },
	  {
	    // pass 4 - 4px
	    x: [2, 6],
	    y: [0, 4],
	  },
	  {
	    // pass 5 - 8px
	    x: [0, 2, 4, 6],
	    y: [2, 6],
	  },
	  {
	    // pass 6 - 16px
	    x: [1, 3, 5, 7],
	    y: [0, 2, 4, 6],
	  },
	  {
	    // pass 7 - 32px
	    x: [0, 1, 2, 3, 4, 5, 6, 7],
	    y: [1, 3, 5, 7],
	  },
	];

	interlace.getImagePasses = function (width, height) {
	  let images = [];
	  let xLeftOver = width % 8;
	  let yLeftOver = height % 8;
	  let xRepeats = (width - xLeftOver) / 8;
	  let yRepeats = (height - yLeftOver) / 8;
	  for (let i = 0; i < imagePasses.length; i++) {
	    let pass = imagePasses[i];
	    let passWidth = xRepeats * pass.x.length;
	    let passHeight = yRepeats * pass.y.length;
	    for (let j = 0; j < pass.x.length; j++) {
	      if (pass.x[j] < xLeftOver) {
	        passWidth++;
	      } else {
	        break;
	      }
	    }
	    for (let j = 0; j < pass.y.length; j++) {
	      if (pass.y[j] < yLeftOver) {
	        passHeight++;
	      } else {
	        break;
	      }
	    }
	    if (passWidth > 0 && passHeight > 0) {
	      images.push({ width: passWidth, height: passHeight, index: i });
	    }
	  }
	  return images;
	};

	interlace.getInterlaceIterator = function (width) {
	  return function (x, y, pass) {
	    let outerXLeftOver = x % imagePasses[pass].x.length;
	    let outerX =
	      ((x - outerXLeftOver) / imagePasses[pass].x.length) * 8 +
	      imagePasses[pass].x[outerXLeftOver];
	    let outerYLeftOver = y % imagePasses[pass].y.length;
	    let outerY =
	      ((y - outerYLeftOver) / imagePasses[pass].y.length) * 8 +
	      imagePasses[pass].y[outerYLeftOver];
	    return outerX * 4 + outerY * width * 4;
	  };
	};
	return interlace;
}

var paethPredictor;
var hasRequiredPaethPredictor;

function requirePaethPredictor () {
	if (hasRequiredPaethPredictor) return paethPredictor;
	hasRequiredPaethPredictor = 1;

	paethPredictor = function paethPredictor(left, above, upLeft) {
	  let paeth = left + above - upLeft;
	  let pLeft = Math.abs(paeth - left);
	  let pAbove = Math.abs(paeth - above);
	  let pUpLeft = Math.abs(paeth - upLeft);

	  if (pLeft <= pAbove && pLeft <= pUpLeft) {
	    return left;
	  }
	  if (pAbove <= pUpLeft) {
	    return above;
	  }
	  return upLeft;
	};
	return paethPredictor;
}

var hasRequiredFilterParse;

function requireFilterParse () {
	if (hasRequiredFilterParse) return filterParse.exports;
	hasRequiredFilterParse = 1;

	let interlaceUtils = requireInterlace();
	let paethPredictor = requirePaethPredictor();

	function getByteWidth(width, bpp, depth) {
	  let byteWidth = width * bpp;
	  if (depth !== 8) {
	    byteWidth = Math.ceil(byteWidth / (8 / depth));
	  }
	  return byteWidth;
	}

	let Filter = (filterParse.exports = function (bitmapInfo, dependencies) {
	  let width = bitmapInfo.width;
	  let height = bitmapInfo.height;
	  let interlace = bitmapInfo.interlace;
	  let bpp = bitmapInfo.bpp;
	  let depth = bitmapInfo.depth;

	  this.read = dependencies.read;
	  this.write = dependencies.write;
	  this.complete = dependencies.complete;

	  this._imageIndex = 0;
	  this._images = [];
	  if (interlace) {
	    let passes = interlaceUtils.getImagePasses(width, height);
	    for (let i = 0; i < passes.length; i++) {
	      this._images.push({
	        byteWidth: getByteWidth(passes[i].width, bpp, depth),
	        height: passes[i].height,
	        lineIndex: 0,
	      });
	    }
	  } else {
	    this._images.push({
	      byteWidth: getByteWidth(width, bpp, depth),
	      height: height,
	      lineIndex: 0,
	    });
	  }

	  // when filtering the line we look at the pixel to the left
	  // the spec also says it is done on a byte level regardless of the number of pixels
	  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back
	  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.
	  if (depth === 8) {
	    this._xComparison = bpp;
	  } else if (depth === 16) {
	    this._xComparison = bpp * 2;
	  } else {
	    this._xComparison = 1;
	  }
	});

	Filter.prototype.start = function () {
	  this.read(
	    this._images[this._imageIndex].byteWidth + 1,
	    this._reverseFilterLine.bind(this)
	  );
	};

	Filter.prototype._unFilterType1 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let xComparison = this._xComparison;
	  let xBiggerThan = xComparison - 1;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
	    unfilteredLine[x] = rawByte + f1Left;
	  }
	};

	Filter.prototype._unFilterType2 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let lastLine = this._lastLine;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f2Up = lastLine ? lastLine[x] : 0;
	    unfilteredLine[x] = rawByte + f2Up;
	  }
	};

	Filter.prototype._unFilterType3 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let xComparison = this._xComparison;
	  let xBiggerThan = xComparison - 1;
	  let lastLine = this._lastLine;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f3Up = lastLine ? lastLine[x] : 0;
	    let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
	    let f3Add = Math.floor((f3Left + f3Up) / 2);
	    unfilteredLine[x] = rawByte + f3Add;
	  }
	};

	Filter.prototype._unFilterType4 = function (
	  rawData,
	  unfilteredLine,
	  byteWidth
	) {
	  let xComparison = this._xComparison;
	  let xBiggerThan = xComparison - 1;
	  let lastLine = this._lastLine;

	  for (let x = 0; x < byteWidth; x++) {
	    let rawByte = rawData[1 + x];
	    let f4Up = lastLine ? lastLine[x] : 0;
	    let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
	    let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
	    let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
	    unfilteredLine[x] = rawByte + f4Add;
	  }
	};

	Filter.prototype._reverseFilterLine = function (rawData) {
	  let filter = rawData[0];
	  let unfilteredLine;
	  let currentImage = this._images[this._imageIndex];
	  let byteWidth = currentImage.byteWidth;

	  if (filter === 0) {
	    unfilteredLine = rawData.slice(1, byteWidth + 1);
	  } else {
	    unfilteredLine = Buffer.alloc(byteWidth);

	    switch (filter) {
	      case 1:
	        this._unFilterType1(rawData, unfilteredLine, byteWidth);
	        break;
	      case 2:
	        this._unFilterType2(rawData, unfilteredLine, byteWidth);
	        break;
	      case 3:
	        this._unFilterType3(rawData, unfilteredLine, byteWidth);
	        break;
	      case 4:
	        this._unFilterType4(rawData, unfilteredLine, byteWidth);
	        break;
	      default:
	        throw new Error("Unrecognised filter type - " + filter);
	    }
	  }

	  this.write(unfilteredLine);

	  currentImage.lineIndex++;
	  if (currentImage.lineIndex >= currentImage.height) {
	    this._lastLine = null;
	    this._imageIndex++;
	    currentImage = this._images[this._imageIndex];
	  } else {
	    this._lastLine = unfilteredLine;
	  }

	  if (currentImage) {
	    // read, using the byte width that may be from the new current image
	    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
	  } else {
	    this._lastLine = null;
	    this.complete();
	  }
	};
	return filterParse.exports;
}

var hasRequiredFilterParseAsync;

function requireFilterParseAsync () {
	if (hasRequiredFilterParseAsync) return filterParseAsync.exports;
	hasRequiredFilterParseAsync = 1;

	let util = require$$0$1;
	let ChunkStream = requireChunkstream();
	let Filter = requireFilterParse();

	let FilterAsync = (filterParseAsync.exports = function (bitmapInfo) {
	  ChunkStream.call(this);

	  let buffers = [];
	  let that = this;
	  this._filter = new Filter(bitmapInfo, {
	    read: this.read.bind(this),
	    write: function (buffer) {
	      buffers.push(buffer);
	    },
	    complete: function () {
	      that.emit("complete", Buffer.concat(buffers));
	    },
	  });

	  this._filter.start();
	});
	util.inherits(FilterAsync, ChunkStream);
	return filterParseAsync.exports;
}

var parser$1 = {exports: {}};

var constants$6;
var hasRequiredConstants$6;

function requireConstants$6 () {
	if (hasRequiredConstants$6) return constants$6;
	hasRequiredConstants$6 = 1;

	constants$6 = {
	  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],

	  TYPE_IHDR: 0x49484452,
	  TYPE_IEND: 0x49454e44,
	  TYPE_IDAT: 0x49444154,
	  TYPE_PLTE: 0x504c5445,
	  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase
	  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase

	  // color-type bits
	  COLORTYPE_GRAYSCALE: 0,
	  COLORTYPE_PALETTE: 1,
	  COLORTYPE_COLOR: 2,
	  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha

	  // color-type combinations
	  COLORTYPE_PALETTE_COLOR: 3,
	  COLORTYPE_COLOR_ALPHA: 6,

	  COLORTYPE_TO_BPP_MAP: {
	    0: 1,
	    2: 3,
	    3: 1,
	    4: 2,
	    6: 4,
	  },

	  GAMMA_DIVISION: 100000,
	};
	return constants$6;
}

var crc = {exports: {}};

var hasRequiredCrc;

function requireCrc () {
	if (hasRequiredCrc) return crc.exports;
	hasRequiredCrc = 1;

	let crcTable = [];

	(function () {
	  for (let i = 0; i < 256; i++) {
	    let currentCrc = i;
	    for (let j = 0; j < 8; j++) {
	      if (currentCrc & 1) {
	        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);
	      } else {
	        currentCrc = currentCrc >>> 1;
	      }
	    }
	    crcTable[i] = currentCrc;
	  }
	})();

	let CrcCalculator = (crc.exports = function () {
	  this._crc = -1;
	});

	CrcCalculator.prototype.write = function (data) {
	  for (let i = 0; i < data.length; i++) {
	    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);
	  }
	  return true;
	};

	CrcCalculator.prototype.crc32 = function () {
	  return this._crc ^ -1;
	};

	CrcCalculator.crc32 = function (buf) {
	  let crc = -1;
	  for (let i = 0; i < buf.length; i++) {
	    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);
	  }
	  return crc ^ -1;
	};
	return crc.exports;
}

var hasRequiredParser$1;

function requireParser$1 () {
	if (hasRequiredParser$1) return parser$1.exports;
	hasRequiredParser$1 = 1;

	let constants = requireConstants$6();
	let CrcCalculator = requireCrc();

	let Parser = (parser$1.exports = function (options, dependencies) {
	  this._options = options;
	  options.checkCRC = options.checkCRC !== false;

	  this._hasIHDR = false;
	  this._hasIEND = false;
	  this._emittedHeadersFinished = false;

	  // input flags/metadata
	  this._palette = [];
	  this._colorType = 0;

	  this._chunks = {};
	  this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
	  this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
	  this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
	  this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
	  this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
	  this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);

	  this.read = dependencies.read;
	  this.error = dependencies.error;
	  this.metadata = dependencies.metadata;
	  this.gamma = dependencies.gamma;
	  this.transColor = dependencies.transColor;
	  this.palette = dependencies.palette;
	  this.parsed = dependencies.parsed;
	  this.inflateData = dependencies.inflateData;
	  this.finished = dependencies.finished;
	  this.simpleTransparency = dependencies.simpleTransparency;
	  this.headersFinished = dependencies.headersFinished || function () {};
	});

	Parser.prototype.start = function () {
	  this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
	};

	Parser.prototype._parseSignature = function (data) {
	  let signature = constants.PNG_SIGNATURE;

	  for (let i = 0; i < signature.length; i++) {
	    if (data[i] !== signature[i]) {
	      this.error(new Error("Invalid file signature"));
	      return;
	    }
	  }
	  this.read(8, this._parseChunkBegin.bind(this));
	};

	Parser.prototype._parseChunkBegin = function (data) {
	  // chunk content length
	  let length = data.readUInt32BE(0);

	  // chunk type
	  let type = data.readUInt32BE(4);
	  let name = "";
	  for (let i = 4; i < 8; i++) {
	    name += String.fromCharCode(data[i]);
	  }

	  //console.log('chunk ', name, length);

	  // chunk flags
	  let ancillary = Boolean(data[4] & 0x20); // or critical
	  //    priv = Boolean(data[5] & 0x20), // or public
	  //    safeToCopy = Boolean(data[7] & 0x20); // or unsafe

	  if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
	    this.error(new Error("Expected IHDR on beggining"));
	    return;
	  }

	  this._crc = new CrcCalculator();
	  this._crc.write(Buffer.from(name));

	  if (this._chunks[type]) {
	    return this._chunks[type](length);
	  }

	  if (!ancillary) {
	    this.error(new Error("Unsupported critical chunk type " + name));
	    return;
	  }

	  this.read(length + 4, this._skipChunk.bind(this));
	};

	Parser.prototype._skipChunk = function (/*data*/) {
	  this.read(8, this._parseChunkBegin.bind(this));
	};

	Parser.prototype._handleChunkEnd = function () {
	  this.read(4, this._parseChunkEnd.bind(this));
	};

	Parser.prototype._parseChunkEnd = function (data) {
	  let fileCrc = data.readInt32BE(0);
	  let calcCrc = this._crc.crc32();

	  // check CRC
	  if (this._options.checkCRC && calcCrc !== fileCrc) {
	    this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
	    return;
	  }

	  if (!this._hasIEND) {
	    this.read(8, this._parseChunkBegin.bind(this));
	  }
	};

	Parser.prototype._handleIHDR = function (length) {
	  this.read(length, this._parseIHDR.bind(this));
	};
	Parser.prototype._parseIHDR = function (data) {
	  this._crc.write(data);

	  let width = data.readUInt32BE(0);
	  let height = data.readUInt32BE(4);
	  let depth = data[8];
	  let colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
	  let compr = data[10];
	  let filter = data[11];
	  let interlace = data[12];

	  // console.log('    width', width, 'height', height,
	  //     'depth', depth, 'colorType', colorType,
	  //     'compr', compr, 'filter', filter, 'interlace', interlace
	  // );

	  if (
	    depth !== 8 &&
	    depth !== 4 &&
	    depth !== 2 &&
	    depth !== 1 &&
	    depth !== 16
	  ) {
	    this.error(new Error("Unsupported bit depth " + depth));
	    return;
	  }
	  if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
	    this.error(new Error("Unsupported color type"));
	    return;
	  }
	  if (compr !== 0) {
	    this.error(new Error("Unsupported compression method"));
	    return;
	  }
	  if (filter !== 0) {
	    this.error(new Error("Unsupported filter method"));
	    return;
	  }
	  if (interlace !== 0 && interlace !== 1) {
	    this.error(new Error("Unsupported interlace method"));
	    return;
	  }

	  this._colorType = colorType;

	  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];

	  this._hasIHDR = true;

	  this.metadata({
	    width: width,
	    height: height,
	    depth: depth,
	    interlace: Boolean(interlace),
	    palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
	    color: Boolean(colorType & constants.COLORTYPE_COLOR),
	    alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
	    bpp: bpp,
	    colorType: colorType,
	  });

	  this._handleChunkEnd();
	};

	Parser.prototype._handlePLTE = function (length) {
	  this.read(length, this._parsePLTE.bind(this));
	};
	Parser.prototype._parsePLTE = function (data) {
	  this._crc.write(data);

	  let entries = Math.floor(data.length / 3);
	  // console.log('Palette:', entries);

	  for (let i = 0; i < entries; i++) {
	    this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 0xff]);
	  }

	  this.palette(this._palette);

	  this._handleChunkEnd();
	};

	Parser.prototype._handleTRNS = function (length) {
	  this.simpleTransparency();
	  this.read(length, this._parseTRNS.bind(this));
	};
	Parser.prototype._parseTRNS = function (data) {
	  this._crc.write(data);

	  // palette
	  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
	    if (this._palette.length === 0) {
	      this.error(new Error("Transparency chunk must be after palette"));
	      return;
	    }
	    if (data.length > this._palette.length) {
	      this.error(new Error("More transparent colors than palette size"));
	      return;
	    }
	    for (let i = 0; i < data.length; i++) {
	      this._palette[i][3] = data[i];
	    }
	    this.palette(this._palette);
	  }

	  // for colorType 0 (grayscale) and 2 (rgb)
	  // there might be one gray/color defined as transparent
	  if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
	    // grey, 2 bytes
	    this.transColor([data.readUInt16BE(0)]);
	  }
	  if (this._colorType === constants.COLORTYPE_COLOR) {
	    this.transColor([
	      data.readUInt16BE(0),
	      data.readUInt16BE(2),
	      data.readUInt16BE(4),
	    ]);
	  }

	  this._handleChunkEnd();
	};

	Parser.prototype._handleGAMA = function (length) {
	  this.read(length, this._parseGAMA.bind(this));
	};
	Parser.prototype._parseGAMA = function (data) {
	  this._crc.write(data);
	  this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);

	  this._handleChunkEnd();
	};

	Parser.prototype._handleIDAT = function (length) {
	  if (!this._emittedHeadersFinished) {
	    this._emittedHeadersFinished = true;
	    this.headersFinished();
	  }
	  this.read(-length, this._parseIDAT.bind(this, length));
	};
	Parser.prototype._parseIDAT = function (length, data) {
	  this._crc.write(data);

	  if (
	    this._colorType === constants.COLORTYPE_PALETTE_COLOR &&
	    this._palette.length === 0
	  ) {
	    throw new Error("Expected palette not found");
	  }

	  this.inflateData(data);
	  let leftOverLength = length - data.length;

	  if (leftOverLength > 0) {
	    this._handleIDAT(leftOverLength);
	  } else {
	    this._handleChunkEnd();
	  }
	};

	Parser.prototype._handleIEND = function (length) {
	  this.read(length, this._parseIEND.bind(this));
	};
	Parser.prototype._parseIEND = function (data) {
	  this._crc.write(data);

	  this._hasIEND = true;
	  this._handleChunkEnd();

	  if (this.finished) {
	    this.finished();
	  }
	};
	return parser$1.exports;
}

var bitmapper = {};

var hasRequiredBitmapper;

function requireBitmapper () {
	if (hasRequiredBitmapper) return bitmapper;
	hasRequiredBitmapper = 1;

	let interlaceUtils = requireInterlace();

	let pixelBppMapper = [
	  // 0 - dummy entry
	  function () {},

	  // 1 - L
	  // 0: 0, 1: 0, 2: 0, 3: 0xff
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos === data.length) {
	      throw new Error("Ran out of data");
	    }

	    let pixel = data[rawPos];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = 0xff;
	  },

	  // 2 - LA
	  // 0: 0, 1: 0, 2: 0, 3: 1
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos + 1 >= data.length) {
	      throw new Error("Ran out of data");
	    }

	    let pixel = data[rawPos];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = data[rawPos + 1];
	  },

	  // 3 - RGB
	  // 0: 0, 1: 1, 2: 2, 3: 0xff
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos + 2 >= data.length) {
	      throw new Error("Ran out of data");
	    }

	    pxData[pxPos] = data[rawPos];
	    pxData[pxPos + 1] = data[rawPos + 1];
	    pxData[pxPos + 2] = data[rawPos + 2];
	    pxData[pxPos + 3] = 0xff;
	  },

	  // 4 - RGBA
	  // 0: 0, 1: 1, 2: 2, 3: 3
	  function (pxData, data, pxPos, rawPos) {
	    if (rawPos + 3 >= data.length) {
	      throw new Error("Ran out of data");
	    }

	    pxData[pxPos] = data[rawPos];
	    pxData[pxPos + 1] = data[rawPos + 1];
	    pxData[pxPos + 2] = data[rawPos + 2];
	    pxData[pxPos + 3] = data[rawPos + 3];
	  },
	];

	let pixelBppCustomMapper = [
	  // 0 - dummy entry
	  function () {},

	  // 1 - L
	  // 0: 0, 1: 0, 2: 0, 3: 0xff
	  function (pxData, pixelData, pxPos, maxBit) {
	    let pixel = pixelData[0];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = maxBit;
	  },

	  // 2 - LA
	  // 0: 0, 1: 0, 2: 0, 3: 1
	  function (pxData, pixelData, pxPos) {
	    let pixel = pixelData[0];
	    pxData[pxPos] = pixel;
	    pxData[pxPos + 1] = pixel;
	    pxData[pxPos + 2] = pixel;
	    pxData[pxPos + 3] = pixelData[1];
	  },

	  // 3 - RGB
	  // 0: 0, 1: 1, 2: 2, 3: 0xff
	  function (pxData, pixelData, pxPos, maxBit) {
	    pxData[pxPos] = pixelData[0];
	    pxData[pxPos + 1] = pixelData[1];
	    pxData[pxPos + 2] = pixelData[2];
	    pxData[pxPos + 3] = maxBit;
	  },

	  // 4 - RGBA
	  // 0: 0, 1: 1, 2: 2, 3: 3
	  function (pxData, pixelData, pxPos) {
	    pxData[pxPos] = pixelData[0];
	    pxData[pxPos + 1] = pixelData[1];
	    pxData[pxPos + 2] = pixelData[2];
	    pxData[pxPos + 3] = pixelData[3];
	  },
	];

	function bitRetriever(data, depth) {
	  let leftOver = [];
	  let i = 0;

	  function split() {
	    if (i === data.length) {
	      throw new Error("Ran out of data");
	    }
	    let byte = data[i];
	    i++;
	    let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
	    switch (depth) {
	      default:
	        throw new Error("unrecognised depth");
	      case 16:
	        byte2 = data[i];
	        i++;
	        leftOver.push((byte << 8) + byte2);
	        break;
	      case 4:
	        byte2 = byte & 0x0f;
	        byte1 = byte >> 4;
	        leftOver.push(byte1, byte2);
	        break;
	      case 2:
	        byte4 = byte & 3;
	        byte3 = (byte >> 2) & 3;
	        byte2 = (byte >> 4) & 3;
	        byte1 = (byte >> 6) & 3;
	        leftOver.push(byte1, byte2, byte3, byte4);
	        break;
	      case 1:
	        byte8 = byte & 1;
	        byte7 = (byte >> 1) & 1;
	        byte6 = (byte >> 2) & 1;
	        byte5 = (byte >> 3) & 1;
	        byte4 = (byte >> 4) & 1;
	        byte3 = (byte >> 5) & 1;
	        byte2 = (byte >> 6) & 1;
	        byte1 = (byte >> 7) & 1;
	        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
	        break;
	    }
	  }

	  return {
	    get: function (count) {
	      while (leftOver.length < count) {
	        split();
	      }
	      let returner = leftOver.slice(0, count);
	      leftOver = leftOver.slice(count);
	      return returner;
	    },
	    resetAfterLine: function () {
	      leftOver.length = 0;
	    },
	    end: function () {
	      if (i !== data.length) {
	        throw new Error("extra data found");
	      }
	    },
	  };
	}

	function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
	  // eslint-disable-line max-params
	  let imageWidth = image.width;
	  let imageHeight = image.height;
	  let imagePass = image.index;
	  for (let y = 0; y < imageHeight; y++) {
	    for (let x = 0; x < imageWidth; x++) {
	      let pxPos = getPxPos(x, y, imagePass);
	      pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
	      rawPos += bpp; //eslint-disable-line no-param-reassign
	    }
	  }
	  return rawPos;
	}

	function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
	  // eslint-disable-line max-params
	  let imageWidth = image.width;
	  let imageHeight = image.height;
	  let imagePass = image.index;
	  for (let y = 0; y < imageHeight; y++) {
	    for (let x = 0; x < imageWidth; x++) {
	      let pixelData = bits.get(bpp);
	      let pxPos = getPxPos(x, y, imagePass);
	      pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
	    }
	    bits.resetAfterLine();
	  }
	}

	bitmapper.dataToBitMap = function (data, bitmapInfo) {
	  let width = bitmapInfo.width;
	  let height = bitmapInfo.height;
	  let depth = bitmapInfo.depth;
	  let bpp = bitmapInfo.bpp;
	  let interlace = bitmapInfo.interlace;
	  let bits;

	  if (depth !== 8) {
	    bits = bitRetriever(data, depth);
	  }
	  let pxData;
	  if (depth <= 8) {
	    pxData = Buffer.alloc(width * height * 4);
	  } else {
	    pxData = new Uint16Array(width * height * 4);
	  }
	  let maxBit = Math.pow(2, depth) - 1;
	  let rawPos = 0;
	  let images;
	  let getPxPos;

	  if (interlace) {
	    images = interlaceUtils.getImagePasses(width, height);
	    getPxPos = interlaceUtils.getInterlaceIterator(width, height);
	  } else {
	    let nonInterlacedPxPos = 0;
	    getPxPos = function () {
	      let returner = nonInterlacedPxPos;
	      nonInterlacedPxPos += 4;
	      return returner;
	    };
	    images = [{ width: width, height: height }];
	  }

	  for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
	    if (depth === 8) {
	      rawPos = mapImage8Bit(
	        images[imageIndex],
	        pxData,
	        getPxPos,
	        bpp,
	        data,
	        rawPos
	      );
	    } else {
	      mapImageCustomBit(
	        images[imageIndex],
	        pxData,
	        getPxPos,
	        bpp,
	        bits,
	        maxBit
	      );
	    }
	  }
	  if (depth === 8) {
	    if (rawPos !== data.length) {
	      throw new Error("extra data found");
	    }
	  } else {
	    bits.end();
	  }

	  return pxData;
	};
	return bitmapper;
}

var formatNormaliser;
var hasRequiredFormatNormaliser;

function requireFormatNormaliser () {
	if (hasRequiredFormatNormaliser) return formatNormaliser;
	hasRequiredFormatNormaliser = 1;

	function dePalette(indata, outdata, width, height, palette) {
	  let pxPos = 0;
	  // use values from palette
	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      let color = palette[indata[pxPos]];

	      if (!color) {
	        throw new Error("index " + indata[pxPos] + " not in palette");
	      }

	      for (let i = 0; i < 4; i++) {
	        outdata[pxPos + i] = color[i];
	      }
	      pxPos += 4;
	    }
	  }
	}

	function replaceTransparentColor(indata, outdata, width, height, transColor) {
	  let pxPos = 0;
	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      let makeTrans = false;

	      if (transColor.length === 1) {
	        if (transColor[0] === indata[pxPos]) {
	          makeTrans = true;
	        }
	      } else if (
	        transColor[0] === indata[pxPos] &&
	        transColor[1] === indata[pxPos + 1] &&
	        transColor[2] === indata[pxPos + 2]
	      ) {
	        makeTrans = true;
	      }
	      if (makeTrans) {
	        for (let i = 0; i < 4; i++) {
	          outdata[pxPos + i] = 0;
	        }
	      }
	      pxPos += 4;
	    }
	  }
	}

	function scaleDepth(indata, outdata, width, height, depth) {
	  let maxOutSample = 255;
	  let maxInSample = Math.pow(2, depth) - 1;
	  let pxPos = 0;

	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      for (let i = 0; i < 4; i++) {
	        outdata[pxPos + i] = Math.floor(
	          (indata[pxPos + i] * maxOutSample) / maxInSample + 0.5
	        );
	      }
	      pxPos += 4;
	    }
	  }
	}

	formatNormaliser = function (indata, imageData, skipRescale = false) {
	  let depth = imageData.depth;
	  let width = imageData.width;
	  let height = imageData.height;
	  let colorType = imageData.colorType;
	  let transColor = imageData.transColor;
	  let palette = imageData.palette;

	  let outdata = indata; // only different for 16 bits

	  if (colorType === 3) {
	    // paletted
	    dePalette(indata, outdata, width, height, palette);
	  } else {
	    if (transColor) {
	      replaceTransparentColor(indata, outdata, width, height, transColor);
	    }
	    // if it needs scaling
	    if (depth !== 8 && !skipRescale) {
	      // if we need to change the buffer size
	      if (depth === 16) {
	        outdata = Buffer.alloc(width * height * 4);
	      }
	      scaleDepth(indata, outdata, width, height, depth);
	    }
	  }
	  return outdata;
	};
	return formatNormaliser;
}

var hasRequiredParserAsync;

function requireParserAsync () {
	if (hasRequiredParserAsync) return parserAsync.exports;
	hasRequiredParserAsync = 1;

	let util = require$$0$1;
	let zlib = require$$1$1;
	let ChunkStream = requireChunkstream();
	let FilterAsync = requireFilterParseAsync();
	let Parser = requireParser$1();
	let bitmapper = requireBitmapper();
	let formatNormaliser = requireFormatNormaliser();

	let ParserAsync = (parserAsync.exports = function (options) {
	  ChunkStream.call(this);

	  this._parser = new Parser(options, {
	    read: this.read.bind(this),
	    error: this._handleError.bind(this),
	    metadata: this._handleMetaData.bind(this),
	    gamma: this.emit.bind(this, "gamma"),
	    palette: this._handlePalette.bind(this),
	    transColor: this._handleTransColor.bind(this),
	    finished: this._finished.bind(this),
	    inflateData: this._inflateData.bind(this),
	    simpleTransparency: this._simpleTransparency.bind(this),
	    headersFinished: this._headersFinished.bind(this),
	  });
	  this._options = options;
	  this.writable = true;

	  this._parser.start();
	});
	util.inherits(ParserAsync, ChunkStream);

	ParserAsync.prototype._handleError = function (err) {
	  this.emit("error", err);

	  this.writable = false;

	  this.destroy();

	  if (this._inflate && this._inflate.destroy) {
	    this._inflate.destroy();
	  }

	  if (this._filter) {
	    this._filter.destroy();
	    // For backward compatibility with Node 7 and below.
	    // Suppress errors due to _inflate calling write() even after
	    // it's destroy()'ed.
	    this._filter.on("error", function () {});
	  }

	  this.errord = true;
	};

	ParserAsync.prototype._inflateData = function (data) {
	  if (!this._inflate) {
	    if (this._bitmapInfo.interlace) {
	      this._inflate = zlib.createInflate();

	      this._inflate.on("error", this.emit.bind(this, "error"));
	      this._filter.on("complete", this._complete.bind(this));

	      this._inflate.pipe(this._filter);
	    } else {
	      let rowSize =
	        ((this._bitmapInfo.width *
	          this._bitmapInfo.bpp *
	          this._bitmapInfo.depth +
	          7) >>
	          3) +
	        1;
	      let imageSize = rowSize * this._bitmapInfo.height;
	      let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);

	      this._inflate = zlib.createInflate({ chunkSize: chunkSize });
	      let leftToInflate = imageSize;

	      let emitError = this.emit.bind(this, "error");
	      this._inflate.on("error", function (err) {
	        if (!leftToInflate) {
	          return;
	        }

	        emitError(err);
	      });
	      this._filter.on("complete", this._complete.bind(this));

	      let filterWrite = this._filter.write.bind(this._filter);
	      this._inflate.on("data", function (chunk) {
	        if (!leftToInflate) {
	          return;
	        }

	        if (chunk.length > leftToInflate) {
	          chunk = chunk.slice(0, leftToInflate);
	        }

	        leftToInflate -= chunk.length;

	        filterWrite(chunk);
	      });

	      this._inflate.on("end", this._filter.end.bind(this._filter));
	    }
	  }
	  this._inflate.write(data);
	};

	ParserAsync.prototype._handleMetaData = function (metaData) {
	  this._metaData = metaData;
	  this._bitmapInfo = Object.create(metaData);

	  this._filter = new FilterAsync(this._bitmapInfo);
	};

	ParserAsync.prototype._handleTransColor = function (transColor) {
	  this._bitmapInfo.transColor = transColor;
	};

	ParserAsync.prototype._handlePalette = function (palette) {
	  this._bitmapInfo.palette = palette;
	};

	ParserAsync.prototype._simpleTransparency = function () {
	  this._metaData.alpha = true;
	};

	ParserAsync.prototype._headersFinished = function () {
	  // Up until this point, we don't know if we have a tRNS chunk (alpha)
	  // so we can't emit metadata any earlier
	  this.emit("metadata", this._metaData);
	};

	ParserAsync.prototype._finished = function () {
	  if (this.errord) {
	    return;
	  }

	  if (!this._inflate) {
	    this.emit("error", "No Inflate block");
	  } else {
	    // no more data to inflate
	    this._inflate.end();
	  }
	};

	ParserAsync.prototype._complete = function (filteredData) {
	  if (this.errord) {
	    return;
	  }

	  let normalisedBitmapData;

	  try {
	    let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);

	    normalisedBitmapData = formatNormaliser(
	      bitmapData,
	      this._bitmapInfo,
	      this._options.skipRescale
	    );
	    bitmapData = null;
	  } catch (ex) {
	    this._handleError(ex);
	    return;
	  }

	  this.emit("parsed", normalisedBitmapData);
	};
	return parserAsync.exports;
}

var packerAsync = {exports: {}};

var packer = {exports: {}};

var bitpacker;
var hasRequiredBitpacker;

function requireBitpacker () {
	if (hasRequiredBitpacker) return bitpacker;
	hasRequiredBitpacker = 1;

	let constants = requireConstants$6();

	bitpacker = function (dataIn, width, height, options) {
	  let outHasAlpha =
	    [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(
	      options.colorType
	    ) !== -1;
	  if (options.colorType === options.inputColorType) {
	    let bigEndian = (function () {
	      let buffer = new ArrayBuffer(2);
	      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
	      // Int16Array uses the platform's endianness.
	      return new Int16Array(buffer)[0] !== 256;
	    })();
	    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route
	    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {
	      return dataIn;
	    }
	  }

	  // map to a UInt16 array if data is 16bit, fix endianness below
	  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);

	  let maxValue = 255;
	  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
	  if (inBpp === 4 && !options.inputHasAlpha) {
	    inBpp = 3;
	  }
	  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
	  if (options.bitDepth === 16) {
	    maxValue = 65535;
	    outBpp *= 2;
	  }
	  let outData = Buffer.alloc(width * height * outBpp);

	  let inIndex = 0;
	  let outIndex = 0;

	  let bgColor = options.bgColor || {};
	  if (bgColor.red === undefined) {
	    bgColor.red = maxValue;
	  }
	  if (bgColor.green === undefined) {
	    bgColor.green = maxValue;
	  }
	  if (bgColor.blue === undefined) {
	    bgColor.blue = maxValue;
	  }

	  function getRGBA() {
	    let red;
	    let green;
	    let blue;
	    let alpha = maxValue;
	    switch (options.inputColorType) {
	      case constants.COLORTYPE_COLOR_ALPHA:
	        alpha = data[inIndex + 3];
	        red = data[inIndex];
	        green = data[inIndex + 1];
	        blue = data[inIndex + 2];
	        break;
	      case constants.COLORTYPE_COLOR:
	        red = data[inIndex];
	        green = data[inIndex + 1];
	        blue = data[inIndex + 2];
	        break;
	      case constants.COLORTYPE_ALPHA:
	        alpha = data[inIndex + 1];
	        red = data[inIndex];
	        green = red;
	        blue = red;
	        break;
	      case constants.COLORTYPE_GRAYSCALE:
	        red = data[inIndex];
	        green = red;
	        blue = red;
	        break;
	      default:
	        throw new Error(
	          "input color type:" +
	            options.inputColorType +
	            " is not supported at present"
	        );
	    }

	    if (options.inputHasAlpha) {
	      if (!outHasAlpha) {
	        alpha /= maxValue;
	        red = Math.min(
	          Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
	          maxValue
	        );
	        green = Math.min(
	          Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
	          maxValue
	        );
	        blue = Math.min(
	          Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
	          maxValue
	        );
	      }
	    }
	    return { red: red, green: green, blue: blue, alpha: alpha };
	  }

	  for (let y = 0; y < height; y++) {
	    for (let x = 0; x < width; x++) {
	      let rgba = getRGBA();

	      switch (options.colorType) {
	        case constants.COLORTYPE_COLOR_ALPHA:
	        case constants.COLORTYPE_COLOR:
	          if (options.bitDepth === 8) {
	            outData[outIndex] = rgba.red;
	            outData[outIndex + 1] = rgba.green;
	            outData[outIndex + 2] = rgba.blue;
	            if (outHasAlpha) {
	              outData[outIndex + 3] = rgba.alpha;
	            }
	          } else {
	            outData.writeUInt16BE(rgba.red, outIndex);
	            outData.writeUInt16BE(rgba.green, outIndex + 2);
	            outData.writeUInt16BE(rgba.blue, outIndex + 4);
	            if (outHasAlpha) {
	              outData.writeUInt16BE(rgba.alpha, outIndex + 6);
	            }
	          }
	          break;
	        case constants.COLORTYPE_ALPHA:
	        case constants.COLORTYPE_GRAYSCALE: {
	          // Convert to grayscale and alpha
	          let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
	          if (options.bitDepth === 8) {
	            outData[outIndex] = grayscale;
	            if (outHasAlpha) {
	              outData[outIndex + 1] = rgba.alpha;
	            }
	          } else {
	            outData.writeUInt16BE(grayscale, outIndex);
	            if (outHasAlpha) {
	              outData.writeUInt16BE(rgba.alpha, outIndex + 2);
	            }
	          }
	          break;
	        }
	        default:
	          throw new Error("unrecognised color Type " + options.colorType);
	      }

	      inIndex += inBpp;
	      outIndex += outBpp;
	    }
	  }

	  return outData;
	};
	return bitpacker;
}

var filterPack;
var hasRequiredFilterPack;

function requireFilterPack () {
	if (hasRequiredFilterPack) return filterPack;
	hasRequiredFilterPack = 1;

	let paethPredictor = requirePaethPredictor();

	function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
	  for (let x = 0; x < byteWidth; x++) {
	    rawData[rawPos + x] = pxData[pxPos + x];
	  }
	}

	function filterSumNone(pxData, pxPos, byteWidth) {
	  let sum = 0;
	  let length = pxPos + byteWidth;

	  for (let i = pxPos; i < length; i++) {
	    sum += Math.abs(pxData[i]);
	  }
	  return sum;
	}

	function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let val = pxData[pxPos + x] - left;

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumSub(pxData, pxPos, byteWidth, bpp) {
	  let sum = 0;
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let val = pxData[pxPos + x] - left;

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
	  for (let x = 0; x < byteWidth; x++) {
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let val = pxData[pxPos + x] - up;

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumUp(pxData, pxPos, byteWidth) {
	  let sum = 0;
	  let length = pxPos + byteWidth;
	  for (let x = pxPos; x < length; x++) {
	    let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
	    let val = pxData[x] - up;

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let val = pxData[pxPos + x] - ((left + up) >> 1);

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
	  let sum = 0;
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let val = pxData[pxPos + x] - ((left + up) >> 1);

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let upleft =
	      pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
	    let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

	    rawData[rawPos + x] = val;
	  }
	}

	function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
	  let sum = 0;
	  for (let x = 0; x < byteWidth; x++) {
	    let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
	    let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
	    let upleft =
	      pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
	    let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);

	    sum += Math.abs(val);
	  }

	  return sum;
	}

	let filters = {
	  0: filterNone,
	  1: filterSub,
	  2: filterUp,
	  3: filterAvg,
	  4: filterPaeth,
	};

	let filterSums = {
	  0: filterSumNone,
	  1: filterSumSub,
	  2: filterSumUp,
	  3: filterSumAvg,
	  4: filterSumPaeth,
	};

	filterPack = function (pxData, width, height, options, bpp) {
	  let filterTypes;
	  if (!("filterType" in options) || options.filterType === -1) {
	    filterTypes = [0, 1, 2, 3, 4];
	  } else if (typeof options.filterType === "number") {
	    filterTypes = [options.filterType];
	  } else {
	    throw new Error("unrecognised filter types");
	  }

	  if (options.bitDepth === 16) {
	    bpp *= 2;
	  }
	  let byteWidth = width * bpp;
	  let rawPos = 0;
	  let pxPos = 0;
	  let rawData = Buffer.alloc((byteWidth + 1) * height);

	  let sel = filterTypes[0];

	  for (let y = 0; y < height; y++) {
	    if (filterTypes.length > 1) {
	      // find best filter for this line (with lowest sum of values)
	      let min = Infinity;

	      for (let i = 0; i < filterTypes.length; i++) {
	        let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
	        if (sum < min) {
	          sel = filterTypes[i];
	          min = sum;
	        }
	      }
	    }

	    rawData[rawPos] = sel;
	    rawPos++;
	    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
	    rawPos += byteWidth;
	    pxPos += byteWidth;
	  }
	  return rawData;
	};
	return filterPack;
}

var hasRequiredPacker;

function requirePacker () {
	if (hasRequiredPacker) return packer.exports;
	hasRequiredPacker = 1;

	let constants = requireConstants$6();
	let CrcStream = requireCrc();
	let bitPacker = requireBitpacker();
	let filter = requireFilterPack();
	let zlib = require$$1$1;

	let Packer = (packer.exports = function (options) {
	  this._options = options;

	  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
	  options.deflateLevel =
	    options.deflateLevel != null ? options.deflateLevel : 9;
	  options.deflateStrategy =
	    options.deflateStrategy != null ? options.deflateStrategy : 3;
	  options.inputHasAlpha =
	    options.inputHasAlpha != null ? options.inputHasAlpha : true;
	  options.deflateFactory = options.deflateFactory || zlib.createDeflate;
	  options.bitDepth = options.bitDepth || 8;
	  // This is outputColorType
	  options.colorType =
	    typeof options.colorType === "number"
	      ? options.colorType
	      : constants.COLORTYPE_COLOR_ALPHA;
	  options.inputColorType =
	    typeof options.inputColorType === "number"
	      ? options.inputColorType
	      : constants.COLORTYPE_COLOR_ALPHA;

	  if (
	    [
	      constants.COLORTYPE_GRAYSCALE,
	      constants.COLORTYPE_COLOR,
	      constants.COLORTYPE_COLOR_ALPHA,
	      constants.COLORTYPE_ALPHA,
	    ].indexOf(options.colorType) === -1
	  ) {
	    throw new Error(
	      "option color type:" + options.colorType + " is not supported at present"
	    );
	  }
	  if (
	    [
	      constants.COLORTYPE_GRAYSCALE,
	      constants.COLORTYPE_COLOR,
	      constants.COLORTYPE_COLOR_ALPHA,
	      constants.COLORTYPE_ALPHA,
	    ].indexOf(options.inputColorType) === -1
	  ) {
	    throw new Error(
	      "option input color type:" +
	        options.inputColorType +
	        " is not supported at present"
	    );
	  }
	  if (options.bitDepth !== 8 && options.bitDepth !== 16) {
	    throw new Error(
	      "option bit depth:" + options.bitDepth + " is not supported at present"
	    );
	  }
	});

	Packer.prototype.getDeflateOptions = function () {
	  return {
	    chunkSize: this._options.deflateChunkSize,
	    level: this._options.deflateLevel,
	    strategy: this._options.deflateStrategy,
	  };
	};

	Packer.prototype.createDeflate = function () {
	  return this._options.deflateFactory(this.getDeflateOptions());
	};

	Packer.prototype.filterData = function (data, width, height) {
	  // convert to correct format for filtering (e.g. right bpp and bit depth)
	  let packedData = bitPacker(data, width, height, this._options);

	  // filter pixel data
	  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
	  let filteredData = filter(packedData, width, height, this._options, bpp);
	  return filteredData;
	};

	Packer.prototype._packChunk = function (type, data) {
	  let len = data ? data.length : 0;
	  let buf = Buffer.alloc(len + 12);

	  buf.writeUInt32BE(len, 0);
	  buf.writeUInt32BE(type, 4);

	  if (data) {
	    data.copy(buf, 8);
	  }

	  buf.writeInt32BE(
	    CrcStream.crc32(buf.slice(4, buf.length - 4)),
	    buf.length - 4
	  );
	  return buf;
	};

	Packer.prototype.packGAMA = function (gamma) {
	  let buf = Buffer.alloc(4);
	  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
	  return this._packChunk(constants.TYPE_gAMA, buf);
	};

	Packer.prototype.packIHDR = function (width, height) {
	  let buf = Buffer.alloc(13);
	  buf.writeUInt32BE(width, 0);
	  buf.writeUInt32BE(height, 4);
	  buf[8] = this._options.bitDepth; // Bit depth
	  buf[9] = this._options.colorType; // colorType
	  buf[10] = 0; // compression
	  buf[11] = 0; // filter
	  buf[12] = 0; // interlace

	  return this._packChunk(constants.TYPE_IHDR, buf);
	};

	Packer.prototype.packIDAT = function (data) {
	  return this._packChunk(constants.TYPE_IDAT, data);
	};

	Packer.prototype.packIEND = function () {
	  return this._packChunk(constants.TYPE_IEND, null);
	};
	return packer.exports;
}

var hasRequiredPackerAsync;

function requirePackerAsync () {
	if (hasRequiredPackerAsync) return packerAsync.exports;
	hasRequiredPackerAsync = 1;

	let util = require$$0$1;
	let Stream = require$$1;
	let constants = requireConstants$6();
	let Packer = requirePacker();

	let PackerAsync = (packerAsync.exports = function (opt) {
	  Stream.call(this);

	  let options = opt || {};

	  this._packer = new Packer(options);
	  this._deflate = this._packer.createDeflate();

	  this.readable = true;
	});
	util.inherits(PackerAsync, Stream);

	PackerAsync.prototype.pack = function (data, width, height, gamma) {
	  // Signature
	  this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
	  this.emit("data", this._packer.packIHDR(width, height));

	  if (gamma) {
	    this.emit("data", this._packer.packGAMA(gamma));
	  }

	  let filteredData = this._packer.filterData(data, width, height);

	  // compress it
	  this._deflate.on("error", this.emit.bind(this, "error"));

	  this._deflate.on(
	    "data",
	    function (compressedData) {
	      this.emit("data", this._packer.packIDAT(compressedData));
	    }.bind(this)
	  );

	  this._deflate.on(
	    "end",
	    function () {
	      this.emit("data", this._packer.packIEND());
	      this.emit("end");
	    }.bind(this)
	  );

	  this._deflate.end(filteredData);
	};
	return packerAsync.exports;
}

var pngSync = {};

var syncInflate = {exports: {}};

var hasRequiredSyncInflate;

function requireSyncInflate () {
	if (hasRequiredSyncInflate) return syncInflate.exports;
	hasRequiredSyncInflate = 1;
	(function (module, exports) {

		let assert = require$$0$2.ok;
		let zlib = require$$1$1;
		let util = require$$0$1;

		let kMaxLength = require$$7.kMaxLength;

		function Inflate(opts) {
		  if (!(this instanceof Inflate)) {
		    return new Inflate(opts);
		  }

		  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
		    opts.chunkSize = zlib.Z_MIN_CHUNK;
		  }

		  zlib.Inflate.call(this, opts);

		  // Node 8 --> 9 compatibility check
		  this._offset = this._offset === undefined ? this._outOffset : this._offset;
		  this._buffer = this._buffer || this._outBuffer;

		  if (opts && opts.maxLength != null) {
		    this._maxLength = opts.maxLength;
		  }
		}

		function createInflate(opts) {
		  return new Inflate(opts);
		}

		function _close(engine, callback) {

		  // Caller may invoke .close after a zlib error (which will null _handle).
		  if (!engine._handle) {
		    return;
		  }

		  engine._handle.close();
		  engine._handle = null;
		}

		Inflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {
		  if (typeof asyncCb === "function") {
		    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
		  }

		  let self = this;

		  let availInBefore = chunk && chunk.length;
		  let availOutBefore = this._chunkSize - this._offset;
		  let leftToInflate = this._maxLength;
		  let inOff = 0;

		  let buffers = [];
		  let nread = 0;

		  let error;
		  this.on("error", function (err) {
		    error = err;
		  });

		  function handleChunk(availInAfter, availOutAfter) {
		    if (self._hadError) {
		      return;
		    }

		    let have = availOutBefore - availOutAfter;
		    assert(have >= 0, "have should not go down");

		    if (have > 0) {
		      let out = self._buffer.slice(self._offset, self._offset + have);
		      self._offset += have;

		      if (out.length > leftToInflate) {
		        out = out.slice(0, leftToInflate);
		      }

		      buffers.push(out);
		      nread += out.length;
		      leftToInflate -= out.length;

		      if (leftToInflate === 0) {
		        return false;
		      }
		    }

		    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
		      availOutBefore = self._chunkSize;
		      self._offset = 0;
		      self._buffer = Buffer.allocUnsafe(self._chunkSize);
		    }

		    if (availOutAfter === 0) {
		      inOff += availInBefore - availInAfter;
		      availInBefore = availInAfter;

		      return true;
		    }

		    return false;
		  }

		  assert(this._handle, "zlib binding closed");
		  let res;
		  do {
		    res = this._handle.writeSync(
		      flushFlag,
		      chunk, // in
		      inOff, // in_off
		      availInBefore, // in_len
		      this._buffer, // out
		      this._offset, //out_off
		      availOutBefore
		    ); // out_len
		    // Node 8 --> 9 compatibility check
		    res = res || this._writeState;
		  } while (!this._hadError && handleChunk(res[0], res[1]));

		  if (this._hadError) {
		    throw error;
		  }

		  if (nread >= kMaxLength) {
		    _close(this);
		    throw new RangeError(
		      "Cannot create final Buffer. It would be larger than 0x" +
		        kMaxLength.toString(16) +
		        " bytes"
		    );
		  }

		  let buf = Buffer.concat(buffers, nread);
		  _close(this);

		  return buf;
		};

		util.inherits(Inflate, zlib.Inflate);

		function zlibBufferSync(engine, buffer) {
		  if (typeof buffer === "string") {
		    buffer = Buffer.from(buffer);
		  }
		  if (!(buffer instanceof Buffer)) {
		    throw new TypeError("Not a string or buffer");
		  }

		  let flushFlag = engine._finishFlushFlag;
		  if (flushFlag == null) {
		    flushFlag = zlib.Z_FINISH;
		  }

		  return engine._processChunk(buffer, flushFlag);
		}

		function inflateSync(buffer, opts) {
		  return zlibBufferSync(new Inflate(opts), buffer);
		}

		module.exports = exports = inflateSync;
		exports.Inflate = Inflate;
		exports.createInflate = createInflate;
		exports.inflateSync = inflateSync; 
	} (syncInflate, syncInflate.exports));
	return syncInflate.exports;
}

var syncReader = {exports: {}};

var hasRequiredSyncReader;

function requireSyncReader () {
	if (hasRequiredSyncReader) return syncReader.exports;
	hasRequiredSyncReader = 1;

	let SyncReader = (syncReader.exports = function (buffer) {
	  this._buffer = buffer;
	  this._reads = [];
	});

	SyncReader.prototype.read = function (length, callback) {
	  this._reads.push({
	    length: Math.abs(length), // if length < 0 then at most this length
	    allowLess: length < 0,
	    func: callback,
	  });
	};

	SyncReader.prototype.process = function () {
	  // as long as there is any data and read requests
	  while (this._reads.length > 0 && this._buffer.length) {
	    let read = this._reads[0];

	    if (
	      this._buffer.length &&
	      (this._buffer.length >= read.length || read.allowLess)
	    ) {
	      // ok there is any data so that we can satisfy this request
	      this._reads.shift(); // == read

	      let buf = this._buffer;

	      this._buffer = buf.slice(read.length);

	      read.func.call(this, buf.slice(0, read.length));
	    } else {
	      break;
	    }
	  }

	  if (this._reads.length > 0) {
	    throw new Error("There are some read requests waitng on finished stream");
	  }

	  if (this._buffer.length > 0) {
	    throw new Error("unrecognised content at end of stream");
	  }
	};
	return syncReader.exports;
}

var filterParseSync = {};

var hasRequiredFilterParseSync;

function requireFilterParseSync () {
	if (hasRequiredFilterParseSync) return filterParseSync;
	hasRequiredFilterParseSync = 1;

	let SyncReader = requireSyncReader();
	let Filter = requireFilterParse();

	filterParseSync.process = function (inBuffer, bitmapInfo) {
	  let outBuffers = [];
	  let reader = new SyncReader(inBuffer);
	  let filter = new Filter(bitmapInfo, {
	    read: reader.read.bind(reader),
	    write: function (bufferPart) {
	      outBuffers.push(bufferPart);
	    },
	    complete: function () {},
	  });

	  filter.start();
	  reader.process();

	  return Buffer.concat(outBuffers);
	};
	return filterParseSync;
}

var parserSync;
var hasRequiredParserSync;

function requireParserSync () {
	if (hasRequiredParserSync) return parserSync;
	hasRequiredParserSync = 1;

	let hasSyncZlib = true;
	let zlib = require$$1$1;
	let inflateSync = requireSyncInflate();
	if (!zlib.deflateSync) {
	  hasSyncZlib = false;
	}
	let SyncReader = requireSyncReader();
	let FilterSync = requireFilterParseSync();
	let Parser = requireParser$1();
	let bitmapper = requireBitmapper();
	let formatNormaliser = requireFormatNormaliser();

	parserSync = function (buffer, options) {
	  if (!hasSyncZlib) {
	    throw new Error(
	      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
	    );
	  }

	  let err;
	  function handleError(_err_) {
	    err = _err_;
	  }

	  let metaData;
	  function handleMetaData(_metaData_) {
	    metaData = _metaData_;
	  }

	  function handleTransColor(transColor) {
	    metaData.transColor = transColor;
	  }

	  function handlePalette(palette) {
	    metaData.palette = palette;
	  }

	  function handleSimpleTransparency() {
	    metaData.alpha = true;
	  }

	  let gamma;
	  function handleGamma(_gamma_) {
	    gamma = _gamma_;
	  }

	  let inflateDataList = [];
	  function handleInflateData(inflatedData) {
	    inflateDataList.push(inflatedData);
	  }

	  let reader = new SyncReader(buffer);

	  let parser = new Parser(options, {
	    read: reader.read.bind(reader),
	    error: handleError,
	    metadata: handleMetaData,
	    gamma: handleGamma,
	    palette: handlePalette,
	    transColor: handleTransColor,
	    inflateData: handleInflateData,
	    simpleTransparency: handleSimpleTransparency,
	  });

	  parser.start();
	  reader.process();

	  if (err) {
	    throw err;
	  }

	  //join together the inflate datas
	  let inflateData = Buffer.concat(inflateDataList);
	  inflateDataList.length = 0;

	  let inflatedData;
	  if (metaData.interlace) {
	    inflatedData = zlib.inflateSync(inflateData);
	  } else {
	    let rowSize =
	      ((metaData.width * metaData.bpp * metaData.depth + 7) >> 3) + 1;
	    let imageSize = rowSize * metaData.height;
	    inflatedData = inflateSync(inflateData, {
	      chunkSize: imageSize,
	      maxLength: imageSize,
	    });
	  }
	  inflateData = null;

	  if (!inflatedData || !inflatedData.length) {
	    throw new Error("bad png - invalid inflate data response");
	  }

	  let unfilteredData = FilterSync.process(inflatedData, metaData);
	  inflateData = null;

	  let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
	  unfilteredData = null;

	  let normalisedBitmapData = formatNormaliser(
	    bitmapData,
	    metaData,
	    options.skipRescale
	  );

	  metaData.data = normalisedBitmapData;
	  metaData.gamma = gamma || 0;

	  return metaData;
	};
	return parserSync;
}

var packerSync;
var hasRequiredPackerSync;

function requirePackerSync () {
	if (hasRequiredPackerSync) return packerSync;
	hasRequiredPackerSync = 1;

	let hasSyncZlib = true;
	let zlib = require$$1$1;
	if (!zlib.deflateSync) {
	  hasSyncZlib = false;
	}
	let constants = requireConstants$6();
	let Packer = requirePacker();

	packerSync = function (metaData, opt) {
	  if (!hasSyncZlib) {
	    throw new Error(
	      "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
	    );
	  }

	  let options = opt || {};

	  let packer = new Packer(options);

	  let chunks = [];

	  // Signature
	  chunks.push(Buffer.from(constants.PNG_SIGNATURE));

	  // Header
	  chunks.push(packer.packIHDR(metaData.width, metaData.height));

	  if (metaData.gamma) {
	    chunks.push(packer.packGAMA(metaData.gamma));
	  }

	  let filteredData = packer.filterData(
	    metaData.data,
	    metaData.width,
	    metaData.height
	  );

	  // compress it
	  let compressedData = zlib.deflateSync(
	    filteredData,
	    packer.getDeflateOptions()
	  );
	  filteredData = null;

	  if (!compressedData || !compressedData.length) {
	    throw new Error("bad png - invalid compressed data response");
	  }
	  chunks.push(packer.packIDAT(compressedData));

	  // End
	  chunks.push(packer.packIEND());

	  return Buffer.concat(chunks);
	};
	return packerSync;
}

var hasRequiredPngSync;

function requirePngSync () {
	if (hasRequiredPngSync) return pngSync;
	hasRequiredPngSync = 1;

	let parse = requireParserSync();
	let pack = requirePackerSync();

	pngSync.read = function (buffer, options) {
	  return parse(buffer, options || {});
	};

	pngSync.write = function (png, options) {
	  return pack(png, options);
	};
	return pngSync;
}

var hasRequiredPng;

function requirePng () {
	if (hasRequiredPng) return png$1;
	hasRequiredPng = 1;

	let util = require$$0$1;
	let Stream = require$$1;
	let Parser = requireParserAsync();
	let Packer = requirePackerAsync();
	let PNGSync = requirePngSync();

	let PNG = (png$1.PNG = function (options) {
	  Stream.call(this);

	  options = options || {}; // eslint-disable-line no-param-reassign

	  // coerce pixel dimensions to integers (also coerces undefined -> 0):
	  this.width = options.width | 0;
	  this.height = options.height | 0;

	  this.data =
	    this.width > 0 && this.height > 0
	      ? Buffer.alloc(4 * this.width * this.height)
	      : null;

	  if (options.fill && this.data) {
	    this.data.fill(0);
	  }

	  this.gamma = 0;
	  this.readable = this.writable = true;

	  this._parser = new Parser(options);

	  this._parser.on("error", this.emit.bind(this, "error"));
	  this._parser.on("close", this._handleClose.bind(this));
	  this._parser.on("metadata", this._metadata.bind(this));
	  this._parser.on("gamma", this._gamma.bind(this));
	  this._parser.on(
	    "parsed",
	    function (data) {
	      this.data = data;
	      this.emit("parsed", data);
	    }.bind(this)
	  );

	  this._packer = new Packer(options);
	  this._packer.on("data", this.emit.bind(this, "data"));
	  this._packer.on("end", this.emit.bind(this, "end"));
	  this._parser.on("close", this._handleClose.bind(this));
	  this._packer.on("error", this.emit.bind(this, "error"));
	});
	util.inherits(PNG, Stream);

	PNG.sync = PNGSync;

	PNG.prototype.pack = function () {
	  if (!this.data || !this.data.length) {
	    this.emit("error", "No data provided");
	    return this;
	  }

	  process.nextTick(
	    function () {
	      this._packer.pack(this.data, this.width, this.height, this.gamma);
	    }.bind(this)
	  );

	  return this;
	};

	PNG.prototype.parse = function (data, callback) {
	  if (callback) {
	    let onParsed, onError;

	    onParsed = function (parsedData) {
	      this.removeListener("error", onError);

	      this.data = parsedData;
	      callback(null, this);
	    }.bind(this);

	    onError = function (err) {
	      this.removeListener("parsed", onParsed);

	      callback(err, null);
	    }.bind(this);

	    this.once("parsed", onParsed);
	    this.once("error", onError);
	  }

	  this.end(data);
	  return this;
	};

	PNG.prototype.write = function (data) {
	  this._parser.write(data);
	  return true;
	};

	PNG.prototype.end = function (data) {
	  this._parser.end(data);
	};

	PNG.prototype._metadata = function (metadata) {
	  this.width = metadata.width;
	  this.height = metadata.height;

	  this.emit("metadata", metadata);
	};

	PNG.prototype._gamma = function (gamma) {
	  this.gamma = gamma;
	};

	PNG.prototype._handleClose = function () {
	  if (!this._parser.writable && !this._packer.readable) {
	    this.emit("close");
	  }
	};

	PNG.bitblt = function (src, dst, srcX, srcY, width, height, deltaX, deltaY) {
	  // eslint-disable-line max-params
	  // coerce pixel dimensions to integers (also coerces undefined -> 0):
	  /* eslint-disable no-param-reassign */
	  srcX |= 0;
	  srcY |= 0;
	  width |= 0;
	  height |= 0;
	  deltaX |= 0;
	  deltaY |= 0;
	  /* eslint-enable no-param-reassign */

	  if (
	    srcX > src.width ||
	    srcY > src.height ||
	    srcX + width > src.width ||
	    srcY + height > src.height
	  ) {
	    throw new Error("bitblt reading outside image");
	  }

	  if (
	    deltaX > dst.width ||
	    deltaY > dst.height ||
	    deltaX + width > dst.width ||
	    deltaY + height > dst.height
	  ) {
	    throw new Error("bitblt writing outside image");
	  }

	  for (let y = 0; y < height; y++) {
	    src.data.copy(
	      dst.data,
	      ((deltaY + y) * dst.width + deltaX) << 2,
	      ((srcY + y) * src.width + srcX) << 2,
	      ((srcY + y) * src.width + srcX + width) << 2
	    );
	  }
	};

	PNG.prototype.bitblt = function (
	  dst,
	  srcX,
	  srcY,
	  width,
	  height,
	  deltaX,
	  deltaY
	) {
	  // eslint-disable-line max-params

	  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
	  return this;
	};

	PNG.adjustGamma = function (src) {
	  if (src.gamma) {
	    for (let y = 0; y < src.height; y++) {
	      for (let x = 0; x < src.width; x++) {
	        let idx = (src.width * y + x) << 2;

	        for (let i = 0; i < 3; i++) {
	          let sample = src.data[idx + i] / 255;
	          sample = Math.pow(sample, 1 / 2.2 / src.gamma);
	          src.data[idx + i] = Math.round(sample * 255);
	        }
	      }
	    }
	    src.gamma = 0;
	  }
	};

	PNG.prototype.adjustGamma = function () {
	  PNG.adjustGamma(this);
	};
	return png$1;
}

var pngExports = requirePng();

/**
 * Filter method is a single-byte integer that indicates the preprocessing method applied to the image data before compression.
 */
var PNGFilterType;
(function (PNGFilterType) {
    PNGFilterType[PNGFilterType["AUTO"] = -1] = "AUTO";
    /** scanline is transmitted unmodified */
    PNGFilterType[PNGFilterType["NONE"] = 0] = "NONE";
    /** filter transmits the difference between each byte and the value of the corresponding byte of the prior pixel */
    PNGFilterType[PNGFilterType["SUB"] = 1] = "SUB";
    /** The Up() filter is just like the Sub() filter except that the pixel immediately above the current pixel, rather than just to its left, is used as the predictor. */
    PNGFilterType[PNGFilterType["UP"] = 2] = "UP";
    /** uses the average of the two neighboring pixels (left and above) to predict the value of a pixel */
    PNGFilterType[PNGFilterType["AVERAGE"] = 3] = "AVERAGE";
    /** computes a simple linear function of the three neighboring pixels (left, above, upper left), then chooses as predictor the neighboring pixel closest to the computed value. */
    PNGFilterType[PNGFilterType["PATH"] = 4] = "PATH";
})(PNGFilterType || (PNGFilterType = {}));
/**
 * Color type is a single-byte integer that describes the interpretation of the image data.
 * Color type codes represent sums of the following values:
 *
 * 1 (palette used), 2 (color used), and 4 (alpha channel used).
 */
var PNGColorType;
(function (PNGColorType) {
    PNGColorType[PNGColorType["GRAYSCALE"] = 0] = "GRAYSCALE";
    PNGColorType[PNGColorType["COLOR"] = 2] = "COLOR";
    PNGColorType[PNGColorType["GRAYSCALE_ALPHA"] = 4] = "GRAYSCALE_ALPHA";
    PNGColorType[PNGColorType["COLOR_ALPHA"] = 6] = "COLOR_ALPHA";
})(PNGColorType || (PNGColorType = {}));

function png() {
    return {
        mime: "image/png",
        hasAlpha: true,
        encode: (bitmap, { deflateLevel = 9, deflateStrategy = 3, filterType = PNGFilterType.AUTO, colorType, inputHasAlpha = true, ...options } = {}) => {
            const png = new pngExports.PNG({
                width: bitmap.width,
                height: bitmap.height,
            });
            png.data = bitmap.data;
            return pngExports.PNG.sync.write(png, {
                ...options,
                deflateLevel,
                deflateStrategy,
                filterType,
                colorType: typeof colorType !== "undefined"
                    ? colorType
                    : inputHasAlpha
                        ? PNGColorType.COLOR_ALPHA
                        : PNGColorType.COLOR,
                inputHasAlpha,
            });
        },
        decode: (data, options) => {
            const result = pngExports.PNG.sync.read(data, options);
            return {
                data: result.data,
                width: result.width,
                height: result.height,
            };
        },
    };
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var UTIF = {exports: {}};

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports) {


		var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
		                (typeof Uint16Array !== 'undefined') &&
		                (typeof Int32Array !== 'undefined');

		function _has(obj, key) {
		  return Object.prototype.hasOwnProperty.call(obj, key);
		}

		exports.assign = function (obj /*from1, from2, from3, ...*/) {
		  var sources = Array.prototype.slice.call(arguments, 1);
		  while (sources.length) {
		    var source = sources.shift();
		    if (!source) { continue; }

		    if (typeof source !== 'object') {
		      throw new TypeError(source + 'must be non-object');
		    }

		    for (var p in source) {
		      if (_has(source, p)) {
		        obj[p] = source[p];
		      }
		    }
		  }

		  return obj;
		};


		// reduce buffer size, avoiding mem copy
		exports.shrinkBuf = function (buf, size) {
		  if (buf.length === size) { return buf; }
		  if (buf.subarray) { return buf.subarray(0, size); }
		  buf.length = size;
		  return buf;
		};


		var fnTyped = {
		  arraySet: function (dest, src, src_offs, len, dest_offs) {
		    if (src.subarray && dest.subarray) {
		      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
		      return;
		    }
		    // Fallback to ordinary array
		    for (var i = 0; i < len; i++) {
		      dest[dest_offs + i] = src[src_offs + i];
		    }
		  },
		  // Join array of chunks to single array.
		  flattenChunks: function (chunks) {
		    var i, l, len, pos, chunk, result;

		    // calculate data length
		    len = 0;
		    for (i = 0, l = chunks.length; i < l; i++) {
		      len += chunks[i].length;
		    }

		    // join chunks
		    result = new Uint8Array(len);
		    pos = 0;
		    for (i = 0, l = chunks.length; i < l; i++) {
		      chunk = chunks[i];
		      result.set(chunk, pos);
		      pos += chunk.length;
		    }

		    return result;
		  }
		};

		var fnUntyped = {
		  arraySet: function (dest, src, src_offs, len, dest_offs) {
		    for (var i = 0; i < len; i++) {
		      dest[dest_offs + i] = src[src_offs + i];
		    }
		  },
		  // Join array of chunks to single array.
		  flattenChunks: function (chunks) {
		    return [].concat.apply([], chunks);
		  }
		};


		// Enable/Disable typed arrays use, for testing
		//
		exports.setTyped = function (on) {
		  if (on) {
		    exports.Buf8  = Uint8Array;
		    exports.Buf16 = Uint16Array;
		    exports.Buf32 = Int32Array;
		    exports.assign(exports, fnTyped);
		  } else {
		    exports.Buf8  = Array;
		    exports.Buf16 = Array;
		    exports.Buf32 = Array;
		    exports.assign(exports, fnUntyped);
		  }
		};

		exports.setTyped(TYPED_OK); 
	} (common));
	return common;
}

var deflate$1 = {};

var deflate = {};

var trees = {};

var hasRequiredTrees;

function requireTrees () {
	if (hasRequiredTrees) return trees;
	hasRequiredTrees = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	/* eslint-disable space-unary-ops */

	var utils = requireCommon();

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;

	/*============================================================================*/


	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */

	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS      = 256;
	/* number of literal bytes 0..255 */

	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES       = 30;
	/* number of distance codes */

	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */

	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */


	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK   = 256;
	/* end of block literal code */

	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* eslint-enable comma-spacing,array-bracket-spacing */

	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */


	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	}


	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;


	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	}



	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}


	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}


	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}


	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
	}


	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}


	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;

	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}


	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) { continue; } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
	        tree[m * 2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}


	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n * 2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}


	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1 << extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1 << extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }

	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1]/*.Len*/ = 5;
	    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

	  //static_init_done = true;
	}


	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

	  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}


	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */

	  {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}


	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;

	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");

	    } while (lx < s.last_lit);
	  }

	  send_code(s, END_BLOCK, ltree);
	}


	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;

	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;

	    } else {
	      tree[n * 2 + 1]/*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;

	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/

	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);

	  } while (s.heap_len >= 2);

	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}


	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;

	    } else if (curlen !== 0) {

	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

	    } else {
	      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;

	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);

	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);

	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}


	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1,   5);
	  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}


	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}


	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{

	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }

	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}


	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len); /* with header */
	}


	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}


	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {

	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
	    static_lenb = (s.static_len + 3 + 7) >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);

	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);

	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);

	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;

	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }

	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility

	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif

	  return (s.last_lit === s.lit_bufsize - 1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	trees._tr_init  = _tr_init;
	trees._tr_stored_block = _tr_stored_block;
	trees._tr_flush_block  = _tr_flush_block;
	trees._tr_tally = _tr_tally;
	trees._tr_align = _tr_align;
	return trees;
}

var adler32_1;
var hasRequiredAdler32;

function requireAdler32 () {
	if (hasRequiredAdler32) return adler32_1;
	hasRequiredAdler32 = 1;

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It isn't worth it to make additional optimizations as in original.
	// Small size is preferable.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	adler32_1 = adler32;
	return adler32_1;
}

var crc32_1;
var hasRequiredCrc32;

function requireCrc32 () {
	if (hasRequiredCrc32) return crc32_1;
	hasRequiredCrc32 = 1;

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc ^= -1;

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	crc32_1 = crc32;
	return crc32_1;
}

var messages;
var hasRequiredMessages;

function requireMessages () {
	if (hasRequiredMessages) return messages;
	hasRequiredMessages = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	messages = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};
	return messages;
}

var hasRequiredDeflate$1;

function requireDeflate$1 () {
	if (hasRequiredDeflate$1) return deflate;
	hasRequiredDeflate$1 = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils   = requireCommon();
	var trees   = requireTrees();
	var adler32 = requireAdler32();
	var crc32   = requireCrc32();
	var msg     = requireMessages();

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;


	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;


	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;


	/* The deflate compression method */
	var Z_DEFLATED  = 8;

	/*============================================================================*/


	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;


	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

	var PRESET_DICT = 0x20;

	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;

	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}

	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}

	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }

	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}


	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}


	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}


	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}


	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;

	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }

	  strm.avail_in -= len;

	  // zmemcpy(buf, strm->next_in, len);
	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }

	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }

	  strm.next_in += len;
	  strm.total_in += len;

	  return len;
	}


	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev  = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;

	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}


	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}


	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);

	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);

	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */

	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;

	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {

	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }

	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;

	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/


	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;

	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }

	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;

	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */

	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;

	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }

	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}


	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */

	  var _win = s.window;

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}

	var configuration_table;

	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];


	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;

	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}


	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */

	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null;   /* Heads of the hash chains or NIL. */

	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	              /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);

	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
	  zero(this.heap);

	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0;          /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0;      /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */


	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}


	function deflateResetKeep(strm) {
	  var s;

	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;

	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;

	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}


	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}


	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}


	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;

	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }

	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }

	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }


	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }


	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();

	  strm.state = s;
	  s.strm = strm;

	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;

	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;

	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);

	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;

	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;

	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;

	  return deflateReset(strm);
	}

	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}


	function deflate$1(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }

	  s = strm.state;

	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }

	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {

	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	        );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;

	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);

	      s.status = BUSY_STATE;
	      putShortMSB(s, header);

	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }

	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */

	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));

	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }

	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}

	function deflateEnd(strm) {
	  var status;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.state = null;

	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}


	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  s = strm.state;
	  wrap = s.wrap;

	  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
	    return Z_STREAM_ERROR;
	  }

	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
	  }

	  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {            /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new utils.Buf8(s.w_size);
	    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

	      s.prev[str & s.w_mask] = s.head[s.ins_h];

	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK;
	}


	deflate.deflateInit = deflateInit;
	deflate.deflateInit2 = deflateInit2;
	deflate.deflateReset = deflateReset;
	deflate.deflateResetKeep = deflateResetKeep;
	deflate.deflateSetHeader = deflateSetHeader;
	deflate.deflate = deflate$1;
	deflate.deflateEnd = deflateEnd;
	deflate.deflateSetDictionary = deflateSetDictionary;
	deflate.deflateInfo = 'pako deflate (from Nodeca project)';

	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/
	return deflate;
}

var strings = {};

var hasRequiredStrings;

function requireStrings () {
	if (hasRequiredStrings) return strings;
	hasRequiredStrings = 1;


	var utils = requireCommon();


	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safari
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;

	try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new utils.Buf8(256);
	for (var q = 0; q < 256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


	// convert string to array (typed, when possible)
	strings.string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }

	  // allocate buffer
	  buf = new utils.Buf8(buf_len);

	  // convert
	  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }

	  return buf;
	};

	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // On Chrome, the arguments in a function call that are allowed is `65534`.
	  // If the length of the buffer is smaller than that, we can use this optimization,
	  // otherwise we will take a slower path.
	  if (len < 65534) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	    }
	  }

	  var result = '';
	  for (var i = 0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}


	// Convert byte array to binary string
	strings.buf2binstring = function (buf) {
	  return buf2binstring(buf, buf.length);
	};


	// Convert binary string (typed, when possible)
	strings.binstring2buf = function (str) {
	  var buf = new utils.Buf8(str.length);
	  for (var i = 0, len = buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};


	// convert array to string
	strings.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;

	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len * 2);

	  for (out = 0, i = 0; i < len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }

	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }

	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }

	  return buf2binstring(utf16buf, out);
	};


	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	strings.utf8border = function (buf, max) {
	  var pos;

	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }

	  // go back from last position, until start of sequence found
	  pos = max - 1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

	  // Very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }

	  // If we came to start of buffer - that means buffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }

	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};
	return strings;
}

var zstream;
var hasRequiredZstream;

function requireZstream () {
	if (hasRequiredZstream) return zstream;
	hasRequiredZstream = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	zstream = ZStream;
	return zstream;
}

var hasRequiredDeflate;

function requireDeflate () {
	if (hasRequiredDeflate) return deflate$1;
	hasRequiredDeflate = 1;


	var zlib_deflate = requireDeflate$1();
	var utils        = requireCommon();
	var strings      = requireStrings();
	var msg          = requireMessages();
	var ZStream      = requireZstream();

	var toString = Object.prototype.toString;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/

	var Z_NO_FLUSH      = 0;
	var Z_FINISH        = 4;

	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_SYNC_FLUSH    = 2;

	var Z_DEFAULT_COMPRESSION = -1;

	var Z_DEFAULT_STRATEGY    = 0;

	var Z_DEFLATED  = 8;

	/* ===========================================================================*/


	/**
	 * class Deflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[deflate]],
	 * [[deflateRaw]] and [[gzip]].
	 **/

	/* internal
	 * Deflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Deflate#onData]] not overridden.
	 **/

	/**
	 * Deflate.result -> Uint8Array|Array
	 *
	 * Compressed result, generated by default [[Deflate#onData]]
	 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
	 * push a chunk with explicit flush (call [[Deflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Deflate.err -> Number
	 *
	 * Error code after deflate finished. 0 (Z_OK) on success.
	 * You will not need it in real life, because deflate errors
	 * are possible only on wrong options or bad `onData` / `onEnd`
	 * custom handlers.
	 **/

	/**
	 * Deflate.msg -> String
	 *
	 * Error message, if [[Deflate.err]] != 0
	 **/


	/**
	 * new Deflate(options)
	 * - options (Object): zlib deflate options.
	 *
	 * Creates new deflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `level`
	 * - `windowBits`
	 * - `memLevel`
	 * - `strategy`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw deflate
	 * - `gzip` (Boolean) - create gzip wrapper
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 * - `header` (Object) - custom header for gzip
	 *   - `text` (Boolean) - true if compressed data believed to be text
	 *   - `time` (Number) - modification time, unix timestamp
	 *   - `os` (Number) - operation system code
	 *   - `extra` (Array) - array of bytes with extra data (max 65536)
	 *   - `name` (String) - file name (binary string)
	 *   - `comment` (String) - comment (binary string)
	 *   - `hcrc` (Boolean) - true if header crc should be added
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var deflate = new pako.Deflate({ level: 3});
	 *
	 * deflate.push(chunk1, false);
	 * deflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (deflate.err) { throw new Error(deflate.err); }
	 *
	 * console.log(deflate.result);
	 * ```
	 **/
	function Deflate(options) {
	  if (!(this instanceof Deflate)) return new Deflate(options);

	  this.options = utils.assign({
	    level: Z_DEFAULT_COMPRESSION,
	    method: Z_DEFLATED,
	    chunkSize: 16384,
	    windowBits: 15,
	    memLevel: 8,
	    strategy: Z_DEFAULT_STRATEGY,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  if (opt.raw && (opt.windowBits > 0)) {
	    opt.windowBits = -opt.windowBits;
	  }

	  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
	    opt.windowBits += 16;
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm = new ZStream();
	  this.strm.avail_out = 0;

	  var status = zlib_deflate.deflateInit2(
	    this.strm,
	    opt.level,
	    opt.method,
	    opt.windowBits,
	    opt.memLevel,
	    opt.strategy
	  );

	  if (status !== Z_OK) {
	    throw new Error(msg[status]);
	  }

	  if (opt.header) {
	    zlib_deflate.deflateSetHeader(this.strm, opt.header);
	  }

	  if (opt.dictionary) {
	    var dict;
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      // If we need to compress text, change encoding to utf8.
	      dict = strings.string2buf(opt.dictionary);
	    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
	      dict = new Uint8Array(opt.dictionary);
	    } else {
	      dict = opt.dictionary;
	    }

	    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

	    if (status !== Z_OK) {
	      throw new Error(msg[status]);
	    }

	    this._dict_set = true;
	  }
	}

	/**
	 * Deflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
	 *   converted to utf8 byte sequence.
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
	 * new compressed chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the compression context.
	 *
	 * On fail call [[Deflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * array format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Deflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var status, _mode;

	  if (this.ended) { return false; }

	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // If we need to compress text, change encoding to utf8.
	    strm.input = strings.string2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }
	    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

	    if (status !== Z_STREAM_END && status !== Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }
	    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
	      if (this.options.to === 'string') {
	        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
	      } else {
	        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	      }
	    }
	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

	  // Finalize on the last chunk.
	  if (_mode === Z_FINISH) {
	    status = zlib_deflate.deflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === Z_SYNC_FLUSH) {
	    this.onEnd(Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Deflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Deflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Deflate#onEnd(status) -> Void
	 * - status (Number): deflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called once after you tell deflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Deflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === Z_OK) {
	    if (this.options.to === 'string') {
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * deflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * Compress `data` with deflate algorithm and `options`.
	 *
	 * Supported options are:
	 *
	 * - level
	 * - windowBits
	 * - memLevel
	 * - strategy
	 * - dictionary
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be "binary string"
	 *    (each char code [0..255])
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
	 *
	 * console.log(pako.deflate(data));
	 * ```
	 **/
	function deflate(input, options) {
	  var deflator = new Deflate(options);

	  deflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

	  return deflator.result;
	}


	/**
	 * deflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function deflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return deflate(input, options);
	}


	/**
	 * gzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to compress.
	 * - options (Object): zlib deflate options.
	 *
	 * The same as [[deflate]], but create gzip wrapper instead of
	 * deflate one.
	 **/
	function gzip(input, options) {
	  options = options || {};
	  options.gzip = true;
	  return deflate(input, options);
	}


	deflate$1.Deflate = Deflate;
	deflate$1.deflate = deflate;
	deflate$1.deflateRaw = deflateRaw;
	deflate$1.gzip = gzip;
	return deflate$1;
}

var inflate$1 = {};

var inflate = {};

var inffast;
var hasRequiredInffast;

function requireInffast () {
	if (hasRequiredInffast) return inffast;
	hasRequiredInffast = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	inffast = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};
	return inffast;
}

var inftrees;
var hasRequiredInftrees;

function requireInftrees () {
	if (hasRequiredInftrees) return inftrees;
	hasRequiredInftrees = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils = requireCommon();

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	inftrees = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  /* process all codes and make table entries */
	  for (;;) {
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};
	return inftrees;
}

var hasRequiredInflate$1;

function requireInflate$1 () {
	if (hasRequiredInflate$1) return inflate;
	hasRequiredInflate$1 = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils         = requireCommon();
	var adler32       = requireAdler32();
	var crc32         = requireCrc32();
	var inflate_fast  = requireInffast();
	var inflate_table = requireInftrees();

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;


	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate$1(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	      case HEAD:
	        if (state.wrap === 0) {
	          state.mode = TYPEDO;
	          break;
	        }
	        //=== NEEDBITS(16);
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//

	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          state.mode = FLAGS;
	          break;
	        }
	        state.flags = 0;           /* expect zlib header */
	        if (state.head) {
	          state.head.done = false;
	        }
	        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	          strm.msg = 'incorrect header check';
	          state.mode = BAD;
	          break;
	        }
	        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	        len = (hold & 0x0f)/*BITS(4)*/ + 8;
	        if (state.wbits === 0) {
	          state.wbits = len;
	        }
	        else if (len > state.wbits) {
	          strm.msg = 'invalid window size';
	          state.mode = BAD;
	          break;
	        }
	        state.dmax = 1 << len;
	        //Tracev((stderr, "inflate:   zlib header ok\n"));
	        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	        state.mode = hold & 0x200 ? DICTID : TYPE;
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        break;
	      case FLAGS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.flags = hold;
	        if ((state.flags & 0xff) !== Z_DEFLATED) {
	          strm.msg = 'unknown compression method';
	          state.mode = BAD;
	          break;
	        }
	        if (state.flags & 0xe000) {
	          strm.msg = 'unknown header flags set';
	          state.mode = BAD;
	          break;
	        }
	        if (state.head) {
	          state.head.text = ((hold >> 8) & 1);
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = TIME;
	        /* falls through */
	      case TIME:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.time = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC4(state.check, hold)
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          hbuf[2] = (hold >>> 16) & 0xff;
	          hbuf[3] = (hold >>> 24) & 0xff;
	          state.check = crc32(state.check, hbuf, 4, 0);
	          //===
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = OS;
	        /* falls through */
	      case OS:
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (state.head) {
	          state.head.xflags = (hold & 0xff);
	          state.head.os = (hold >> 8);
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = EXLEN;
	        /* falls through */
	      case EXLEN:
	        if (state.flags & 0x0400) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length = hold;
	          if (state.head) {
	            state.head.extra_len = hold;
	          }
	          if (state.flags & 0x0200) {
	            //=== CRC2(state.check, hold);
	            hbuf[0] = hold & 0xff;
	            hbuf[1] = (hold >>> 8) & 0xff;
	            state.check = crc32(state.check, hbuf, 2, 0);
	            //===//
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        else if (state.head) {
	          state.head.extra = null/*Z_NULL*/;
	        }
	        state.mode = EXTRA;
	        /* falls through */
	      case EXTRA:
	        if (state.flags & 0x0400) {
	          copy = state.length;
	          if (copy > have) { copy = have; }
	          if (copy) {
	            if (state.head) {
	              len = state.head.extra_len - state.length;
	              if (!state.head.extra) {
	                // Use untyped array for more convenient processing later
	                state.head.extra = new Array(state.head.extra_len);
	              }
	              utils.arraySet(
	                state.head.extra,
	                input,
	                next,
	                // extra field is limited to 65536 bytes
	                // - no need for additional size check
	                copy,
	                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	                len
	              );
	              //zmemcpy(state.head.extra + len, next,
	              //        len + copy > state.head.extra_max ?
	              //        state.head.extra_max - len : copy);
	            }
	            if (state.flags & 0x0200) {
	              state.check = crc32(state.check, input, copy, next);
	            }
	            have -= copy;
	            next += copy;
	            state.length -= copy;
	          }
	          if (state.length) { break inf_leave; }
	        }
	        state.length = 0;
	        state.mode = NAME;
	        /* falls through */
	      case NAME:
	        if (state.flags & 0x0800) {
	          if (have === 0) { break inf_leave; }
	          copy = 0;
	          do {
	            // TODO: 2 or 1 bytes?
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len &&
	                (state.length < 65536 /*state.head.name_max*/)) {
	              state.head.name += String.fromCharCode(len);
	            }
	          } while (len && copy < have);

	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) { break inf_leave; }
	        }
	        else if (state.head) {
	          state.head.name = null;
	        }
	        state.length = 0;
	        state.mode = COMMENT;
	        /* falls through */
	      case COMMENT:
	        if (state.flags & 0x1000) {
	          if (have === 0) { break inf_leave; }
	          copy = 0;
	          do {
	            len = input[next + copy++];
	            /* use constant limit because in js we should not preallocate memory */
	            if (state.head && len &&
	                (state.length < 65536 /*state.head.comm_max*/)) {
	              state.head.comment += String.fromCharCode(len);
	            }
	          } while (len && copy < have);
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          if (len) { break inf_leave; }
	        }
	        else if (state.head) {
	          state.head.comment = null;
	        }
	        state.mode = HCRC;
	        /* falls through */
	      case HCRC:
	        if (state.flags & 0x0200) {
	          //=== NEEDBITS(16); */
	          while (bits < 16) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.check & 0xffff)) {
	            strm.msg = 'header crc mismatch';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	        }
	        if (state.head) {
	          state.head.hcrc = ((state.flags >> 9) & 1);
	          state.head.done = true;
	        }
	        strm.adler = state.check = 0;
	        state.mode = TYPE;
	        break;
	      case DICTID:
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        strm.adler = state.check = zswap32(hold);
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = DICT;
	        /* falls through */
	      case DICT:
	        if (state.havedict === 0) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          return Z_NEED_DICT;
	        }
	        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	        state.mode = TYPE;
	        /* falls through */
	      case TYPE:
	        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case TYPEDO:
	        if (state.last) {
	          //--- BYTEBITS() ---//
	          hold >>>= bits & 7;
	          bits -= bits & 7;
	          //---//
	          state.mode = CHECK;
	          break;
	        }
	        //=== NEEDBITS(3); */
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.last = (hold & 0x01)/*BITS(1)*/;
	        //--- DROPBITS(1) ---//
	        hold >>>= 1;
	        bits -= 1;
	        //---//

	        switch ((hold & 0x03)/*BITS(2)*/) {
	          case 0:                             /* stored block */
	            //Tracev((stderr, "inflate:     stored block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = STORED;
	            break;
	          case 1:                             /* fixed block */
	            fixedtables(state);
	            //Tracev((stderr, "inflate:     fixed codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = LEN_;             /* decode codes */
	            if (flush === Z_TREES) {
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	              break inf_leave;
	            }
	            break;
	          case 2:                             /* dynamic block */
	            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	            //        state.last ? " (last)" : ""));
	            state.mode = TABLE;
	            break;
	          case 3:
	            strm.msg = 'invalid block type';
	            state.mode = BAD;
	        }
	        //--- DROPBITS(2) ---//
	        hold >>>= 2;
	        bits -= 2;
	        //---//
	        break;
	      case STORED:
	        //--- BYTEBITS() ---// /* go to byte boundary */
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        //=== NEEDBITS(32); */
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	          strm.msg = 'invalid stored block lengths';
	          state.mode = BAD;
	          break;
	        }
	        state.length = hold & 0xffff;
	        //Tracev((stderr, "inflate:       stored length %u\n",
	        //        state.length));
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = COPY_;
	        if (flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case COPY_:
	        state.mode = COPY;
	        /* falls through */
	      case COPY:
	        copy = state.length;
	        if (copy) {
	          if (copy > have) { copy = have; }
	          if (copy > left) { copy = left; }
	          if (copy === 0) { break inf_leave; }
	          //--- zmemcpy(put, next, copy); ---
	          utils.arraySet(output, input, next, copy, put);
	          //---//
	          have -= copy;
	          next += copy;
	          left -= copy;
	          put += copy;
	          state.length -= copy;
	          break;
	        }
	        //Tracev((stderr, "inflate:       stored end\n"));
	        state.mode = TYPE;
	        break;
	      case TABLE:
	        //=== NEEDBITS(14); */
	        while (bits < 14) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	        //--- DROPBITS(5) ---//
	        hold >>>= 5;
	        bits -= 5;
	        //---//
	        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	        //--- DROPBITS(4) ---//
	        hold >>>= 4;
	        bits -= 4;
	        //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	        if (state.nlen > 286 || state.ndist > 30) {
	          strm.msg = 'too many length or distance symbols';
	          state.mode = BAD;
	          break;
	        }
	//#endif
	        //Tracev((stderr, "inflate:       table sizes ok\n"));
	        state.have = 0;
	        state.mode = LENLENS;
	        /* falls through */
	      case LENLENS:
	        while (state.have < state.ncode) {
	          //=== NEEDBITS(3);
	          while (bits < 3) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	          //--- DROPBITS(3) ---//
	          hold >>>= 3;
	          bits -= 3;
	          //---//
	        }
	        while (state.have < 19) {
	          state.lens[order[state.have++]] = 0;
	        }
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        //state.next = state.codes;
	        //state.lencode = state.next;
	        // Switch to use dynamic table
	        state.lencode = state.lendyn;
	        state.lenbits = 7;

	        opts = { bits: state.lenbits };
	        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	        state.lenbits = opts.bits;

	        if (ret) {
	          strm.msg = 'invalid code lengths set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, "inflate:       code lengths ok\n"));
	        state.have = 0;
	        state.mode = CODELENS;
	        /* falls through */
	      case CODELENS:
	        while (state.have < state.nlen + state.ndist) {
	          for (;;) {
	            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          if (here_val < 16) {
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            state.lens[state.have++] = here_val;
	          }
	          else {
	            if (here_val === 16) {
	              //=== NEEDBITS(here.bits + 2);
	              n = here_bits + 2;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              if (state.have === 0) {
	                strm.msg = 'invalid bit length repeat';
	                state.mode = BAD;
	                break;
	              }
	              len = state.lens[state.have - 1];
	              copy = 3 + (hold & 0x03);//BITS(2);
	              //--- DROPBITS(2) ---//
	              hold >>>= 2;
	              bits -= 2;
	              //---//
	            }
	            else if (here_val === 17) {
	              //=== NEEDBITS(here.bits + 3);
	              n = here_bits + 3;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 3 + (hold & 0x07);//BITS(3);
	              //--- DROPBITS(3) ---//
	              hold >>>= 3;
	              bits -= 3;
	              //---//
	            }
	            else {
	              //=== NEEDBITS(here.bits + 7);
	              n = here_bits + 7;
	              while (bits < n) {
	                if (have === 0) { break inf_leave; }
	                have--;
	                hold += input[next++] << bits;
	                bits += 8;
	              }
	              //===//
	              //--- DROPBITS(here.bits) ---//
	              hold >>>= here_bits;
	              bits -= here_bits;
	              //---//
	              len = 0;
	              copy = 11 + (hold & 0x7f);//BITS(7);
	              //--- DROPBITS(7) ---//
	              hold >>>= 7;
	              bits -= 7;
	              //---//
	            }
	            if (state.have + copy > state.nlen + state.ndist) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            while (copy--) {
	              state.lens[state.have++] = len;
	            }
	          }
	        }

	        /* handle error breaks in while */
	        if (state.mode === BAD) { break; }

	        /* check for end-of-block code (better have one) */
	        if (state.lens[256] === 0) {
	          strm.msg = 'invalid code -- missing end-of-block';
	          state.mode = BAD;
	          break;
	        }

	        /* build code tables -- note: do not change the lenbits or distbits
	           values here (9 and 6) without reading the comments in inftrees.h
	           concerning the ENOUGH constants, which depend on those values */
	        state.lenbits = 9;

	        opts = { bits: state.lenbits };
	        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.lenbits = opts.bits;
	        // state.lencode = state.next;

	        if (ret) {
	          strm.msg = 'invalid literal/lengths set';
	          state.mode = BAD;
	          break;
	        }

	        state.distbits = 6;
	        //state.distcode.copy(state.codes);
	        // Switch to use dynamic table
	        state.distcode = state.distdyn;
	        opts = { bits: state.distbits };
	        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	        // We have separate tables & no pointers. 2 commented lines below not needed.
	        // state.next_index = opts.table_index;
	        state.distbits = opts.bits;
	        // state.distcode = state.next;

	        if (ret) {
	          strm.msg = 'invalid distances set';
	          state.mode = BAD;
	          break;
	        }
	        //Tracev((stderr, 'inflate:       codes ok\n'));
	        state.mode = LEN_;
	        if (flush === Z_TREES) { break inf_leave; }
	        /* falls through */
	      case LEN_:
	        state.mode = LEN;
	        /* falls through */
	      case LEN:
	        if (have >= 6 && left >= 258) {
	          //--- RESTORE() ---
	          strm.next_out = put;
	          strm.avail_out = left;
	          strm.next_in = next;
	          strm.avail_in = have;
	          state.hold = hold;
	          state.bits = bits;
	          //---
	          inflate_fast(strm, _out);
	          //--- LOAD() ---
	          put = strm.next_out;
	          output = strm.output;
	          left = strm.avail_out;
	          next = strm.next_in;
	          input = strm.input;
	          have = strm.avail_in;
	          hold = state.hold;
	          bits = state.bits;
	          //---

	          if (state.mode === TYPE) {
	            state.back = -1;
	          }
	          break;
	        }
	        state.back = 0;
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if (here_bits <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_op && (here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.lencode[last_val +
	                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((last_bits + here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        state.length = here_val;
	        if (here_op === 0) {
	          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	          //        "inflate:         literal '%c'\n" :
	          //        "inflate:         literal 0x%02x\n", here.val));
	          state.mode = LIT;
	          break;
	        }
	        if (here_op & 32) {
	          //Tracevv((stderr, "inflate:         end of block\n"));
	          state.back = -1;
	          state.mode = TYPE;
	          break;
	        }
	        if (here_op & 64) {
	          strm.msg = 'invalid literal/length code';
	          state.mode = BAD;
	          break;
	        }
	        state.extra = here_op & 15;
	        state.mode = LENEXT;
	        /* falls through */
	      case LENEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", state.length));
	        state.was = state.length;
	        state.mode = DIST;
	        /* falls through */
	      case DIST:
	        for (;;) {
	          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if ((here_op & 0xf0) === 0) {
	          last_bits = here_bits;
	          last_op = here_op;
	          last_val = here_val;
	          for (;;) {
	            here = state.distcode[last_val +
	                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	            here_bits = here >>> 24;
	            here_op = (here >>> 16) & 0xff;
	            here_val = here & 0xffff;

	            if ((last_bits + here_bits) <= bits) { break; }
	            //--- PULLBYTE() ---//
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	            //---//
	          }
	          //--- DROPBITS(last.bits) ---//
	          hold >>>= last_bits;
	          bits -= last_bits;
	          //---//
	          state.back += last_bits;
	        }
	        //--- DROPBITS(here.bits) ---//
	        hold >>>= here_bits;
	        bits -= here_bits;
	        //---//
	        state.back += here_bits;
	        if (here_op & 64) {
	          strm.msg = 'invalid distance code';
	          state.mode = BAD;
	          break;
	        }
	        state.offset = here_val;
	        state.extra = (here_op) & 15;
	        state.mode = DISTEXT;
	        /* falls through */
	      case DISTEXT:
	        if (state.extra) {
	          //=== NEEDBITS(state.extra);
	          n = state.extra;
	          while (bits < n) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	          //--- DROPBITS(state.extra) ---//
	          hold >>>= state.extra;
	          bits -= state.extra;
	          //---//
	          state.back += state.extra;
	        }
	//#ifdef INFLATE_STRICT
	        if (state.offset > state.dmax) {
	          strm.msg = 'invalid distance too far back';
	          state.mode = BAD;
	          break;
	        }
	//#endif
	        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	        state.mode = MATCH;
	        /* falls through */
	      case MATCH:
	        if (left === 0) { break inf_leave; }
	        copy = _out - left;
	        if (state.offset > copy) {         /* copy from window */
	          copy = state.offset - copy;
	          if (copy > state.whave) {
	            if (state.sane) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break;
	            }
	// (!) This block is disabled in zlib defaults,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	          }
	          if (copy > state.wnext) {
	            copy -= state.wnext;
	            from = state.wsize - copy;
	          }
	          else {
	            from = state.wnext - copy;
	          }
	          if (copy > state.length) { copy = state.length; }
	          from_source = state.window;
	        }
	        else {                              /* copy from output */
	          from_source = output;
	          from = put - state.offset;
	          copy = state.length;
	        }
	        if (copy > left) { copy = left; }
	        left -= copy;
	        state.length -= copy;
	        do {
	          output[put++] = from_source[from++];
	        } while (--copy);
	        if (state.length === 0) { state.mode = LEN; }
	        break;
	      case LIT:
	        if (left === 0) { break inf_leave; }
	        output[put++] = state.length;
	        left--;
	        state.mode = LEN;
	        break;
	      case CHECK:
	        if (state.wrap) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            // Use '|' instead of '+' to make sure that result is signed
	            hold |= input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          _out -= left;
	          strm.total_out += _out;
	          state.total += _out;
	          if (_out) {
	            strm.adler = state.check =
	                /*UPDATE(state.check, put - _out, _out);*/
	                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

	          }
	          _out = left;
	          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	            strm.msg = 'incorrect data check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   check matches trailer\n"));
	        }
	        state.mode = LENGTH;
	        /* falls through */
	      case LENGTH:
	        if (state.wrap && state.flags) {
	          //=== NEEDBITS(32);
	          while (bits < 32) {
	            if (have === 0) { break inf_leave; }
	            have--;
	            hold += input[next++] << bits;
	            bits += 8;
	          }
	          //===//
	          if (hold !== (state.total & 0xffffffff)) {
	            strm.msg = 'incorrect length check';
	            state.mode = BAD;
	            break;
	          }
	          //=== INITBITS();
	          hold = 0;
	          bits = 0;
	          //===//
	          //Tracev((stderr, "inflate:   length matches trailer\n"));
	        }
	        state.mode = DONE;
	        /* falls through */
	      case DONE:
	        ret = Z_STREAM_END;
	        break inf_leave;
	      case BAD:
	        ret = Z_DATA_ERROR;
	        break inf_leave;
	      case MEM:
	        return Z_MEM_ERROR;
	      case SYNC:
	        /* falls through */
	      default:
	        return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}

	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var state;
	  var dictid;
	  var ret;

	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }

	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}

	inflate.inflateReset = inflateReset;
	inflate.inflateReset2 = inflateReset2;
	inflate.inflateResetKeep = inflateResetKeep;
	inflate.inflateInit = inflateInit;
	inflate.inflateInit2 = inflateInit2;
	inflate.inflate = inflate$1;
	inflate.inflateEnd = inflateEnd;
	inflate.inflateGetHeader = inflateGetHeader;
	inflate.inflateSetDictionary = inflateSetDictionary;
	inflate.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/
	return inflate;
}

var constants$5;
var hasRequiredConstants$5;

function requireConstants$5 () {
	if (hasRequiredConstants$5) return constants$5;
	hasRequiredConstants$5 = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	constants$5 = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};
	return constants$5;
}

var gzheader;
var hasRequiredGzheader;

function requireGzheader () {
	if (hasRequiredGzheader) return gzheader;
	hasRequiredGzheader = 1;

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function GZheader() {
	  /* true if compressed data believed to be text */
	  this.text       = 0;
	  /* modification time */
	  this.time       = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags     = 0;
	  /* operating system */
	  this.os         = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra      = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len  = 0; // Actually, we don't need it in JS,
	                       // but leave for few code modifications

	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //

	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name       = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment    = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc       = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done       = false;
	}

	gzheader = GZheader;
	return gzheader;
}

var hasRequiredInflate;

function requireInflate () {
	if (hasRequiredInflate) return inflate$1;
	hasRequiredInflate = 1;


	var zlib_inflate = requireInflate$1();
	var utils        = requireCommon();
	var strings      = requireStrings();
	var c            = requireConstants$5();
	var msg          = requireMessages();
	var ZStream      = requireZstream();
	var GZheader     = requireGzheader();

	var toString = Object.prototype.toString;

	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/

	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overridden.
	 **/

	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/

	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/


	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	function Inflate(options) {
	  if (!(this instanceof Inflate)) return new Inflate(options);

	  this.options = utils.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) { opt.windowBits = -15; }
	  }

	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
	      !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }

	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm   = new ZStream();
	  this.strm.avail_out = 0;

	  var status  = zlib_inflate.inflateInit2(
	    this.strm,
	    opt.windowBits
	  );

	  if (status !== c.Z_OK) {
	    throw new Error(msg[status]);
	  }

	  this.header = new GZheader();

	  zlib_inflate.inflateGetHeader(this.strm, this.header);

	  // Setup dictionary
	  if (opt.dictionary) {
	    // Convert data if needed
	    if (typeof opt.dictionary === 'string') {
	      opt.dictionary = strings.string2buf(opt.dictionary);
	    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
	      opt.dictionary = new Uint8Array(opt.dictionary);
	    }
	    if (opt.raw) { //In raw mode we need to set the dictionary early
	      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
	      if (status !== c.Z_OK) {
	        throw new Error(msg[status]);
	      }
	    }
	  }
	}

	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var dictionary = this.options.dictionary;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;

	  // Flag to properly process Z_BUF_ERROR on testing inflate call
	  // when we check that all output data was flushed.
	  var allowBufError = false;

	  if (this.ended) { return false; }
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }

	    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

	    if (status === c.Z_NEED_DICT && dictionary) {
	      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
	    }

	    if (status === c.Z_BUF_ERROR && allowBufError === true) {
	      status = c.Z_OK;
	      allowBufError = false;
	    }

	    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }

	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

	        if (this.options.to === 'string') {

	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);

	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

	          this.onData(utf8str);

	        } else {
	          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }

	    // When no more input data, we should check that internal inflate buffers
	    // are flushed. The only way to do it when avail_out = 0 - run one more
	    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
	    // Here we set flag to process this error properly.
	    //
	    // NOTE. Deflate does not return error in this case and does not needs such
	    // logic.
	    if (strm.avail_in === 0 && strm.avail_out === 0) {
	      allowBufError = true;
	    }

	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

	  if (status === c.Z_STREAM_END) {
	    _mode = c.Z_FINISH;
	  }

	  // Finalize on the last chunk.
	  if (_mode === c.Z_FINISH) {
	    status = zlib_inflate.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === c.Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === c.Z_SYNC_FLUSH) {
	    this.onEnd(c.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): output data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === c.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 aligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate(input, options) {
	  var inflator = new Inflate(options);

	  inflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

	  return inflator.result;
	}


	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate(input, options);
	}


	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/


	inflate$1.Inflate = Inflate;
	inflate$1.inflate = inflate;
	inflate$1.inflateRaw = inflateRaw;
	inflate$1.ungzip  = inflate;
	return inflate$1;
}

var pako_1;
var hasRequiredPako;

function requirePako () {
	if (hasRequiredPako) return pako_1;
	hasRequiredPako = 1;

	var assign    = requireCommon().assign;

	var deflate   = requireDeflate();
	var inflate   = requireInflate();
	var constants = requireConstants$5();

	var pako = {};

	assign(pako, deflate, inflate, constants);

	pako_1 = pako;
	return pako_1;
}

var hasRequiredUTIF;

function requireUTIF () {
	if (hasRequiredUTIF) return UTIF.exports;
	hasRequiredUTIF = 1;
	(function (module) {
(function(){
			var UTIF = {};
			
			// Make available for import by `require()`
			{module.exports = UTIF;}
			
			var pako = (typeof commonjsRequire === "function") ? requirePako() : self.pako;
			
			function log() { if (typeof process=="undefined" || process.env.NODE_ENV=="development") console.log.apply(console, arguments);  }
			
			(function(UTIF, pako){
				
			// Following lines add a JPEG decoder  to UTIF.JpegDecoder
			(function(){var W=function a1(){function W(p){this.message="JPEG error: "+p;}W.prototype=new Error;W.prototype.name="JpegError";W.constructor=W;return W}(),ak=function ag(){var p=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),t=4017,ac=799,ah=3406,ao=2276,ar=1567,ai=3784,s=5793,ad=2896;function ak(Q){if(Q==null)Q={};if(Q.w==null)Q.w=-1;this.V=Q.n;this.N=Q.w;}function a5(Q,h){var f=0,G=[],n,E,a=16,F;while(a>0&&!Q[a-1]){a--;}G.push({children:[],index:0});var C=G[0];for(n=0;n<a;n++)
			{for(E=0;E<Q[n];E++){C=G.pop();C.children[C.index]=h[f];while(C.index>0){C=G.pop();}C.index++;G.push(C);while(G.length<=n){G.push(F={children:[],index:0});C.children[C.index]=F.children;C=F;}f++;}if(n+1<a){G.push(F={children:[],index:0});C.children[C.index]=F.children;C=F;}}return G[0].children}function a2(Q,h,f){return 64*((Q.P+1)*h+f)}function a7(Q,h,f,G,n,E,a,C,F,d){if(d==null)d=false;var T=f.m,U=f.Z,z=h,J=0,V=0,r=0,D=0,a8,q=0,X,O,_,N,e,K,x=0,k,g,R,c;function Y(){if(V>0){V--;return J>>V&1}J=Q[h++];if(J===255){var I=Q[h++];if(I){if(I===220&&d){h+=2;var l=Z(Q,h);h+=2;if(l>0&&l!==f.s){throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data",l)}}else if(I===217){if(d){var M=q*8;
			if(M>0&&M<f.s/10){throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, "+"possibly caused by incorrect `scanLines` parameter",M)}}throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data")}throw new W("unexpected marker")}}V=7;return J>>>7}function u(I){var l=I;while(true){l=l[Y()];switch(typeof l){case "number":return l;case "object":continue}throw new W("invalid huffman sequence")}}function m(I){var e=0;while(I>0){e=e<<1|Y();I--;}return e}function j(I){if(I===1){return Y()===1?1:-1}var e=m(I);if(e>=1<<I-1){return e}return e+(-1<<I)+1}function v(X,I){var l=u(X.J),M=l===0?0:j(l),N=1;
			X.D[I]=X.Q+=M;while(N<64){var S=u(X.i),i=S&15,A=S>>4;if(i===0){if(A<15){break}N+=16;continue}N+=A;var o=p[N];X.D[I+o]=j(i);N++;}}function $(X,I){var l=u(X.J),M=l===0?0:j(l)<<F;X.D[I]=X.Q+=M;}function b(X,I){X.D[I]|=Y()<<F;}function P(X,I){if(r>0){r--;return}var N=E,l=a;while(N<=l){var M=u(X.i),S=M&15,i=M>>4;if(S===0){if(i<15){r=m(i)+(1<<i)-1;break}N+=16;continue}N+=i;var A=p[N];X.D[I+A]=j(S)*(1<<F);N++;}}function a4(X,I){var N=E,l=a,M=0,S,i;while(N<=l){var A=I+p[N],o=X.D[A]<0?-1:1;switch(D){case 0:i=u(X.i);S=i&15;M=i>>4;if(S===0){if(M<15){r=m(M)+(1<<M);D=4;}else {M=16;D=1;}}else {if(S!==1){throw new W("invalid ACn encoding")}a8=j(S);D=M?2:3;}continue;case 1:case 2:if(X.D[A]){X.D[A]+=o*(Y()<<F);}else {M--;if(M===0){D=D===2?3:0;}}break;case 3:if(X.D[A]){X.D[A]+=o*(Y()<<F);}else {X.D[A]=a8<<F;
			D=0;}break;case 4:if(X.D[A]){X.D[A]+=o*(Y()<<F);}break}N++;}if(D===4){r--;if(r===0){D=0;}}}function H(X,I,x,l,M){var S=x/T|0,i=x%T;q=S*X.A+l;var A=i*X.h+M,o=a2(X,q,A);I(X,o);}function w(X,I,x){q=x/X.P|0;var l=x%X.P,M=a2(X,q,l);I(X,M);}var y=G.length;if(U){if(E===0){K=C===0?$:b;}else {K=C===0?P:a4;}}else {K=v;}if(y===1){g=G[0].P*G[0].c;}else {g=T*f.R;}while(x<=g){var L=n?Math.min(g-x,n):g;if(L>0){for(O=0;O<y;O++){G[O].Q=0;}r=0;if(y===1){X=G[0];for(e=0;e<L;e++){w(X,K,x);x++;}}else {for(e=0;e<L;
			e++){for(O=0;O<y;O++){X=G[O];R=X.h;c=X.A;for(_=0;_<c;_++){for(N=0;N<R;N++){H(X,K,x,_,N);}}}x++;}}}V=0;k=an(Q,h);if(!k){break}if(k.u){h=k.offset;}if(k.M>=65488&&k.M<=65495){h+=2;}else {break}}return h-z}function al(Q,h,f){var G=Q.$,n=Q.D,E,a,C,F,d,T,U,z,J,V,Y,u,m,j,v,$,b;if(!G){throw new W("missing required Quantization Table.")}for(var r=0;r<64;r+=8){J=n[h+r];V=n[h+r+1];Y=n[h+r+2];u=n[h+r+3];m=n[h+r+4];j=n[h+r+5];v=n[h+r+6];$=n[h+r+7];J*=G[r];if((V|Y|u|m|j|v|$)===0){b=s*J+512>>10;f[r]=b;f[r+1]=b;f[r+2]=b;f[r+3]=b;f[r+4]=b;f[r+5]=b;f[r+6]=b;f[r+7]=b;continue}V*=G[r+1];Y*=G[r+2];u*=G[r+3];m*=G[r+4];j*=G[r+5];v*=G[r+6];$*=G[r+7];E=s*J+128>>8;a=s*m+128>>8;C=Y;F=v;d=ad*(V-$)+128>>8;z=ad*(V+$)+128>>8;
			T=u<<4;U=j<<4;E=E+a+1>>1;a=E-a;b=C*ai+F*ar+128>>8;C=C*ar-F*ai+128>>8;F=b;d=d+U+1>>1;U=d-U;z=z+T+1>>1;T=z-T;E=E+F+1>>1;F=E-F;a=a+C+1>>1;C=a-C;b=d*ao+z*ah+2048>>12;d=d*ah-z*ao+2048>>12;z=b;b=T*ac+U*t+2048>>12;T=T*t-U*ac+2048>>12;U=b;f[r]=E+z;f[r+7]=E-z;f[r+1]=a+U;f[r+6]=a-U;f[r+2]=C+T;f[r+5]=C-T;f[r+3]=F+d;f[r+4]=F-d;}for(var P=0;P<8;++P){J=f[P];V=f[P+8];Y=f[P+16];u=f[P+24];m=f[P+32];j=f[P+40];v=f[P+48];$=f[P+56];if((V|Y|u|m|j|v|$)===0){b=s*J+8192>>14;if(b<-2040){b=0;}else if(b>=2024){b=255;}else {b=b+2056>>4;}n[h+P]=b;n[h+P+8]=b;n[h+P+16]=b;n[h+P+24]=b;n[h+P+32]=b;n[h+P+40]=b;n[h+P+48]=b;n[h+P+56]=b;continue}E=s*J+2048>>12;a=s*m+2048>>12;C=Y;F=v;d=ad*(V-$)+2048>>12;z=ad*(V+$)+2048>>12;T=u;U=j;E=(E+a+1>>1)+4112;a=E-a;b=C*ai+F*ar+2048>>12;C=C*ar-F*ai+2048>>12;F=b;d=d+U+1>>1;U=d-U;z=z+T+1>>1;T=z-T;E=E+F+1>>1;F=E-F;a=a+C+1>>1;C=a-C;b=d*ao+z*ah+2048>>12;d=d*ah-z*ao+2048>>12;z=b;
			b=T*ac+U*t+2048>>12;T=T*t-U*ac+2048>>12;U=b;J=E+z;$=E-z;V=a+U;v=a-U;Y=C+T;j=C-T;u=F+d;m=F-d;if(J<16){J=0;}else if(J>=4080){J=255;}else {J>>=4;}if(V<16){V=0;}else if(V>=4080){V=255;}else {V>>=4;}if(Y<16){Y=0;}else if(Y>=4080){Y=255;}else {Y>>=4;}if(u<16){u=0;}else if(u>=4080){u=255;}else {u>>=4;}if(m<16){m=0;}else if(m>=4080){m=255;}else {m>>=4;}if(j<16){j=0;}else if(j>=4080){j=255;}else {j>>=4;}if(v<16){v=0;}else if(v>=4080){v=255;}else {v>>=4;}if($<16){$=0;}else if($>=4080){$=255;}else {$>>=4;}n[h+P]=J;
			n[h+P+8]=V;n[h+P+16]=Y;n[h+P+24]=u;n[h+P+32]=m;n[h+P+40]=j;n[h+P+48]=v;n[h+P+56]=$;}}function a0(Q,h){var f=h.P,G=h.c,n=new Int16Array(64);for(var E=0;E<G;E++){for(var a=0;a<f;a++){var C=a2(h,E,a);al(h,C,n);}}return h.D}function an(Q,h,f){if(f==null)f=h;var G=Q.length-1,n=f<h?f:h;if(h>=G){return null}var E=Z(Q,h);if(E>=65472&&E<=65534){return {u:null,M:E,offset:h}}var a=Z(Q,n);while(!(a>=65472&&a<=65534)){if(++n>=G){return null}a=Z(Q,n);}return {u:E.toString(16),M:a,offset:n}}ak.prototype={parse(Q,h){if(h==null)h={};
			var f=h.F,E=0,a=null,C=null,F,d,T=0;function G(){var o=Z(Q,E);E+=2;var B=E+o-2,V=an(Q,B,E);if(V&&V.u){B=V.offset;}var ab=Q.subarray(E,B);E+=ab.length;return ab}function n(F){var o=Math.ceil(F.o/8/F.X),B=Math.ceil(F.s/8/F.B);for(var Y=0;Y<F.W.length;Y++){R=F.W[Y];var ab=Math.ceil(Math.ceil(F.o/8)*R.h/F.X),af=Math.ceil(Math.ceil(F.s/8)*R.A/F.B),ap=o*R.h,aq=B*R.A,ae=64*aq*(ap+1);R.D=new Int16Array(ae);R.P=ab;R.c=af;}F.m=o;F.R=B;}var U=[],z=[],J=[],V=Z(Q,E);E+=2;if(V!==65496){throw new W("SOI not found")}V=Z(Q,E);
			E+=2;markerLoop:while(V!==65497){var Y,u,m;switch(V){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var j=G();if(V===65504){if(j[0]===74&&j[1]===70&&j[2]===73&&j[3]===70&&j[4]===0){a={version:{d:j[5],T:j[6]},K:j[7],j:j[8]<<8|j[9],H:j[10]<<8|j[11],S:j[12],I:j[13],C:j.subarray(14,14+3*j[12]*j[13])};}}if(V===65518){if(j[0]===65&&j[1]===100&&j[2]===111&&j[3]===98&&j[4]===101){C={version:j[5]<<8|j[6],k:j[7]<<8|j[8],q:j[9]<<8|j[10],a:j[11]};}}break;
			case 65499:var v=Z(Q,E),b;E+=2;var $=v+E-2;while(E<$){var r=Q[E++],P=new Uint16Array(64);if(r>>4===0){for(u=0;u<64;u++){b=p[u];P[b]=Q[E++];}}else if(r>>4===1){for(u=0;u<64;u++){b=p[u];P[b]=Z(Q,E);E+=2;}}else {throw new W("DQT - invalid table spec")}U[r&15]=P;}break;case 65472:case 65473:case 65474:if(F){throw new W("Only single frame JPEGs supported")}E+=2;F={};F.G=V===65473;F.Z=V===65474;F.precision=Q[E++];var D=Z(Q,E),a4,q=0,H=0;E+=2;F.s=f||D;F.o=Z(Q,E);E+=2;F.W=[];F._={};var a8=Q[E++];for(Y=0;Y<a8;Y++){a4=Q[E];var w=Q[E+1]>>4,y=Q[E+1]&15;if(q<w){q=w;}if(H<y){H=y;}var X=Q[E+2];m=F.W.push({h:w,A:y,L:X,$:null});F._[a4]=m-1;E+=3;}F.X=q;F.B=H;n(F);break;case 65476:var O=Z(Q,E);E+=2;
			for(Y=2;Y<O;){var _=Q[E++],N=new Uint8Array(16),e=0;for(u=0;u<16;u++,E++){e+=N[u]=Q[E];}var K=new Uint8Array(e);for(u=0;u<e;u++,E++){K[u]=Q[E];}Y+=17+e;(_>>4===0?J:z)[_&15]=a5(N,K);}break;case 65501:E+=2;d=Z(Q,E);E+=2;break;case 65498:var x=++T===1&&!f,R;E+=2;var k=Q[E++],g=[];for(Y=0;Y<k;Y++){var c=Q[E++],L=F._[c];R=F.W[L];R.index=c;var a6=Q[E++];R.J=J[a6>>4];R.i=z[a6&15];g.push(R);}var I=Q[E++],l=Q[E++],M=Q[E++];try{var S=a7(Q,E,F,g,d,I,l,M>>4,M&15,x);E+=S;}catch(ex){if(ex instanceof DNLMarkerError){return this.parse(Q,{F:ex.s})}else if(ex instanceof EOIMarkerError){break markerLoop}throw ex}break;case 65500:E+=4;break;case 65535:if(Q[E]!==255){E--;}break;default:var i=an(Q,E-2,E-3);if(i&&i.u){E=i.offset;break}if(E>=Q.length-1){break markerLoop}throw new W("JpegImage.parse - unknown marker: "+V.toString(16))}V=Z(Q,E);E+=2;}this.width=F.o;this.height=F.s;this.g=a;this.b=C;this.W=[];for(Y=0;Y<F.W.length;Y++){R=F.W[Y];
			var A=U[R.L];if(A){R.$=A;}this.W.push({index:R.index,e:a0(F,R),l:R.h/F.X,t:R.A/F.B,P:R.P,c:R.c});}this.p=this.W.length;return undefined},Y(Q,h,f){if(f==null)f=false;var G=this.width/Q,n=this.height/h,E,a,C,F,d,T,U,z,J,V,Y=0,u,m=this.W.length,j=Q*h*m,v=new Uint8ClampedArray(j),$=new Uint32Array(Q),b=4294967288,r;for(U=0;U<m;U++){E=this.W[U];a=E.l*G;C=E.t*n;Y=U;u=E.e;F=E.P+1<<3;if(a!==r){for(d=0;d<Q;d++){z=0|d*a;$[d]=(z&b)<<3|z&7;}r=a;}for(T=0;T<h;T++){z=0|T*C;V=F*(z&b)|(z&7)<<3;for(d=0;d<Q;d++){v[Y]=u[V+$[d]];Y+=m;}}}var P=this.V;if(!f&&m===4&&!P){P=new Int32Array([-256,255,-256,255,-256,255,-256,255]);}if(P){for(U=0;U<j;){for(z=0,J=0;z<m;z++,U++,J+=2){v[U]=(v[U]*P[J]>>8)+P[J+1];}}}return v},get f(){if(this.b){return !!this.b.a}if(this.p===3){if(this.N===0){return  false}else if(this.W[0].index===82&&this.W[1].index===71&&this.W[2].index===66){return  false}return  true}if(this.N===1){return  true}return  false},z:function aj(Q){var h,f,G;
			for(var n=0,E=Q.length;n<E;n+=3){h=Q[n];f=Q[n+1];G=Q[n+2];Q[n]=h-179.456+1.402*G;Q[n+1]=h+135.459-.344*f-.714*G;Q[n+2]=h-226.816+1.772*f;}return Q},O:function aa(Q){var h,f,G,n,E=0;for(var a=0,C=Q.length;a<C;a+=4){h=Q[a];f=Q[a+1];G=Q[a+2];n=Q[a+3];Q[E++]=-122.67195406894+f*(-660635669420364e-19*f+.000437130475926232*G-54080610064599e-18*h+.00048449797120281*n-.154362151871126)+G*(-957964378445773e-18*G+.000817076911346625*h-.00477271405408747*n+1.53380253221734)+h*(.000961250184130688*h-.00266257332283933*n+.48357088451265)+n*(-336197177618394e-18*n+.484791561490776);
			Q[E++]=107.268039397724+f*(219927104525741e-19*f-.000640992018297945*G+.000659397001245577*h+.000426105652938837*n-.176491792462875)+G*(-778269941513683e-18*G+.00130872261408275*h+.000770482631801132*n-.151051492775562)+h*(.00126935368114843*h-.00265090189010898*n+.25802910206845)+n*(-318913117588328e-18*n-.213742400323665);Q[E++]=-20.810012546947+f*(-570115196973677e-18*f-263409051004589e-19*G+.0020741088115012*h-.00288260236853442*n+.814272968359295)+G*(-153496057440975e-19*G-.000132689043961446*h+.000560833691242812*n-.195152027534049)+h*(.00174418132927582*h-.00255243321439347*n+.116935020465145)+n*(-343531996510555e-18*n+.24165260232407);}return Q.subarray(0,E)},r:function a3(Q){var h,f,G;
			for(var n=0,E=Q.length;n<E;n+=4){h=Q[n];f=Q[n+1];G=Q[n+2];Q[n]=434.456-h-1.402*G;Q[n+1]=119.541-h+.344*f+.714*G;Q[n+2]=481.816-h-1.772*f;}return Q},U:function as(Q){var h,f,G,n,E=0;for(var a=0,C=Q.length;a<C;a+=4){h=Q[a];f=Q[a+1];G=Q[a+2];n=Q[a+3];Q[E++]=255+h*(-6747147073602441e-20*h+.0008379262121013727*f+.0002894718188643294*G+.003264231057537806*n-1.1185611867203937)+f*(26374107616089404e-21*f-8626949158638572e-20*G-.0002748769067499491*n-.02155688794978967)+G*(-3878099212869363e-20*G-.0003267808279485286*n+.0686742238595345)-n*(.0003361971776183937*n+.7430659151342254);
			Q[E++]=255+h*(.00013596372813588848*h+.000924537132573585*f+.00010567359618683593*G+.0004791864687436512*n-.3109689587515875)+f*(-23545346108370344e-20*f+.0002702845253534714*G+.0020200308977307156*n-.7488052167015494)+G*(6834815998235662e-20*G+.00015168452363460973*n-.09751927774728933)-n*(.0003189131175883281*n+.7364883807733168);Q[E++]=255+h*(13598650411385308e-21*h+.00012423956175490851*f+.0004751985097583589*G-36729317476630424e-22*n-.05562186980264034)+f*(.00016141380598724676*f+.0009692239130725186*G+.0007782692450036253*n-.44015232367526463)+G*(5.068882914068769e-7*G+.0017778369011375071*n-.7591454649749609)-n*(.0003435319965105553*n+.7063770186160144);}return Q.subarray(0,E)},getData:function(Q){var h=Q.width,f=Q.height,G=Q.forceRGB,n=Q.isSourcePDF;
			if(this.p>4){throw new W("Unsupported color mode")}var E=this.Y(h,f,n);if(this.p===1&&G){var a=E.length,C=new Uint8ClampedArray(a*3),F=0;for(var d=0;d<a;d++){var T=E[d];C[F++]=T;C[F++]=T;C[F++]=T;}return C}else if(this.p===3&&this.f){return this.z(E)}else if(this.p===4){if(this.f){if(G){return this.O(E)}return this.r(E)}else if(G){return this.U(E)}}return E}};return ak}();function Z(p,t){return p[t]<<8|p[t+1]}UTIF.JpegDecoder=ak;}());
			
			//UTIF.JpegDecoder = PDFJS.JpegImage;
			
			
			UTIF.encodeImage = function(rgba, w, h, metadata)
			{
				var idf = { "t256":[w], "t257":[h], "t258":[8,8,8,8], "t259":[1], "t262":[2], "t273":[1000], // strips offset
							"t277":[4], "t278":[h], /* rows per strip */          "t279":[w*h*4], // strip byte counts
							"t282":[[72,1]], "t283":[[72,1]], "t284":[1], "t286":[[0,1]], "t287":[[0,1]], "t296":[1], "t305": ["Photopea (UTIF.js)"], "t338":[1]
					};
				if (metadata) for (var i in metadata) idf[i] = metadata[i];
				
				var prfx = new Uint8Array(UTIF.encode([idf]));
				var img = new Uint8Array(rgba);
				var data = new Uint8Array(1000+w*h*4);
				for(var i=0; i<prfx.length; i++) data[i] = prfx[i];
				for(var i=0; i<img .length; i++) data[1000+i] = img[i];
				return data.buffer;
			};
			
			UTIF.encode = function(ifds)
			{
				var data = new Uint8Array(20000), offset = 4, bin = UTIF._binBE;
				data[0]=data[1]=77;  bin.writeUshort(data,2,42);
			
				var ifdo = 8;
				bin.writeUint(data, offset, ifdo);  offset+=4;
				for(var i=0; i<ifds.length; i++)
				{
					var noffs = UTIF._writeIFD(bin, UTIF._types.basic, data, ifdo, ifds[i]);
					ifdo = noffs[1];
					if(i<ifds.length-1) {
						if((ifdo&3)!=0) ifdo+=(4-(ifdo&3));  // make each IFD start at multiple of 4
						bin.writeUint(data, noffs[0], ifdo);
					}
				}
				return data.slice(0, ifdo).buffer;
			};
			
			UTIF.decode = function(buff, prm)
			{
				if(prm==null) prm = {parseMN:true, debug:false};  // read MakerNote, debug
				var data = new Uint8Array(buff), offset = 0;
			
				var id = UTIF._binBE.readASCII(data, offset, 2);  offset+=2;
				var bin = id=="II" ? UTIF._binLE : UTIF._binBE;
				bin.readUshort(data, offset);  offset+=2;
			
				var ifdo = bin.readUint(data, offset);  offset+=4;
				var ifds = [];
				while(true) {
					var cnt = bin.readUshort(data,ifdo), typ = bin.readUshort(data,ifdo+4);  if(cnt!=0) if(typ<1 || 13<typ) {  log("error in TIFF");  break  }					UTIF._readIFD(bin, data, ifdo, ifds, 0, prm);
					
					ifdo = bin.readUint(data, ifdo+2+cnt*12);
					if(ifdo==0) break;
				}
				return ifds;
			};
			
			UTIF.decodeImage = function(buff, img, ifds)
			{
				if(img.data) return;
				var data = new Uint8Array(buff);
				var id = UTIF._binBE.readASCII(data, 0, 2);
			
				if(img["t256"]==null) return;	// No width => probably not an image
				img.isLE = id=="II";
				img.width  = img["t256"][0];  //delete img["t256"];
				img.height = img["t257"][0];  //delete img["t257"];
			
				var cmpr = img["t259"] ? img["t259"][0] : 1;  //delete img["t259"];
				var fo   = img["t266"] ? img["t266"][0] : 1;  //delete img["t266"];
				if(img["t284"] && img["t284"][0]==2) log("PlanarConfiguration 2 should not be used!");
				if(cmpr==7 && img["t258"] && img["t258"].length>3)  img["t258"]=img["t258"].slice(0,3);
			
				var spp = img["t277"]?img["t277"][0]:1;
				var bps = img["t258"]?img["t258"][0]:1;
				var bipp = bps*spp;  // bits per pixel
				/*
				var bipp;  // bits per pixel
				if(img["t258"]) bipp = Math.min(32,img["t258"][0])*img["t258"].length;
				else            bipp = (img["t277"]?img["t277"][0]:1);  
				*/
				// Some .NEF files have t258==14, even though they use 16 bits per pixel
				if(cmpr==1 && img["t279"]!=null && img["t278"] && img["t262"][0]==32803)  {
					bipp = Math.round((img["t279"][0]*8)/(img.width*img["t278"][0]));
				}
				if(img["t50885"] && img["t50885"][0]==4) bipp = img["t258"][0]*3;  // RAW_CANON_40D_SRAW_V103.CR2
				var bipl = Math.ceil(img.width*bipp/8)*8;
				var soff = img["t273"];  if(soff==null || img["t322"]) soff = img["t324"];
				var bcnt = img["t279"];  if(cmpr==1 && soff.length==1) bcnt = [img.height*(bipl>>>3)];  if(bcnt==null || img["t322"]) bcnt = img["t325"];
				//bcnt[0] = Math.min(bcnt[0], data.length);  // Hasselblad, "RAW_HASSELBLAD_H3D39II.3FR"
				var bytes = new Uint8Array(img.height*(bipl>>>3)), bilen = 0;
			
				if(img["t322"]!=null) // tiled
				{
					var tw = img["t322"][0], th = img["t323"][0];
					var tx = Math.floor((img.width  + tw - 1) / tw);
					var ty = Math.floor((img.height + th - 1) / th);
					var tbuff = new Uint8Array(Math.ceil(tw*th*bipp/8)|0);
					console.log("====", tx,ty);
					for(var y=0; y<ty; y++)
						for(var x=0; x<tx; x++)
						{
							var i = y*tx+x;  tbuff.fill(0);
							UTIF.decode._decompress(img,ifds, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo,tw,th);
							// Might be required for 7 too. Need to check
							if (cmpr==6) bytes = tbuff;
							else UTIF._copyTile(tbuff, Math.ceil(tw*bipp/8)|0, th, bytes, Math.ceil(img.width*bipp/8)|0, img.height, Math.ceil(x*tw*bipp/8)|0, y*th);
						}
					bilen = bytes.length*8;
				}
				else	// stripped
				{
					if(soff==null) return;
					var rps = img["t278"] ? img["t278"][0] : img.height;   rps = Math.min(rps, img.height);
					//console.log("====", img.width, rps);
					for(var i=0; i<soff.length; i++)
					{
						UTIF.decode._decompress(img,ifds, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen/8)|0, fo,img.width,rps);
						bilen += bipl * rps;
					}
					bilen = Math.min(bilen, bytes.length*8);
				}
				img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen/8)|0);
			};
			
			UTIF.decode._decompress = function(img,ifds, data, off, len, cmpr, tgt, toff, fo, w, h)  // fill order
			{
				if(img["t271"] && img["t271"][0]=="Panasonic" && img["t45"] && img["t45"][0]==6) cmpr = 34316;
				//console.log("compression", cmpr);
				//var time = Date.now();
				if(cmpr==1/* || (len==tgt.length && cmpr!=32767)*/) for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
				else if(cmpr==2) UTIF.decode._decodeG2 (data, off, len, tgt, toff, w, fo);
				else if(cmpr==3) UTIF.decode._decodeG3 (data, off, len, tgt, toff, w, fo, img["t292"]?((img["t292"][0]&1)==1):false);
				else if(cmpr==4) UTIF.decode._decodeG4 (data, off, len, tgt, toff, w, fo);
				else if(cmpr==5) UTIF.decode._decodeLZW(data, off, len, tgt, toff,8);
				else if(cmpr==6) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
				else if(cmpr==7 || cmpr==34892) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
				else if(cmpr==8 || cmpr==32946) {  var src = new Uint8Array(data.buffer,off+2,len-6);  var bin = pako["inflateRaw"](src);  if(toff+bin.length<=tgt.length) tgt.set(bin,toff);  }
				else if(cmpr==9) UTIF.decode._decodeVC5(data,off,len,tgt,toff,img["t33422"]);
				else if(cmpr==32767) UTIF.decode._decodeARW(img, data, off, len, tgt, toff);
				else if(cmpr==32773) UTIF.decode._decodePackBits(data, off, len, tgt, toff);
				else if(cmpr==32809) UTIF.decode._decodeThunder (data, off, len, tgt, toff);
				else if(cmpr==34316) UTIF.decode._decodePanasonic(img,data,off, len, tgt, toff);
				else if(cmpr==34713) //for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];
					UTIF.decode._decodeNikon   (img,ifds, data, off, len, tgt, toff);
				else if(cmpr==34676) UTIF.decode._decodeLogLuv32(img,data, off, len, tgt, toff);  
				else log("Unknown compression", cmpr);
				
				//console.log(Date.now()-time);
				
				var bps = (img["t258"]?Math.min(32,img["t258"][0]):1);
				var noc = (img["t277"]?img["t277"][0]:1), bpp=(bps*noc)>>>3, bpl = Math.ceil(bps*noc*w/8);
				
				// convert to Little Endian  /*
				if(bps==16 && !img.isLE && img["t33422"]==null)  // not DNG
					for(var y=0; y<h; y++) {
						//console.log("fixing endianity");
						var roff = toff+y*bpl;
						for(var x=1; x<bpl; x+=2) {  var t=tgt[roff+x];  tgt[roff+x]=tgt[roff+x-1];  tgt[roff+x-1]=t;  }
					}  //*/
			
				if(img["t317"] && img["t317"][0]==2)
				{
					for(var y=0; y<h; y++)
					{
						var ntoff = toff+y*bpl;
						if(bps==16) for(var j=bpp; j<bpl; j+=2) {
							var nv = ((tgt[ntoff+j+1]<<8)|tgt[ntoff+j])  +  ((tgt[ntoff+j-bpp+1]<<8)|tgt[ntoff+j-bpp]);
							tgt[ntoff+j] = nv&255;  tgt[ntoff+j+1] = (nv>>>8)&255;  
						}
						else if(noc==3) for(var j=  3; j<bpl; j+=3)
						{
							tgt[ntoff+j  ] = (tgt[ntoff+j  ] + tgt[ntoff+j-3])&255;
							tgt[ntoff+j+1] = (tgt[ntoff+j+1] + tgt[ntoff+j-2])&255;
							tgt[ntoff+j+2] = (tgt[ntoff+j+2] + tgt[ntoff+j-1])&255;
						}
						else for(var j=bpp; j<bpl; j++) tgt[ntoff+j] = (tgt[ntoff+j] + tgt[ntoff+j-bpp])&255;
					}
				}
			};
			
					UTIF.decode._decodePanasonic = function(img, data, off, len, tgt, toff) {
			
							var img_buffer = data.buffer;
				
							var rawWidth = img["t2"][0];
							var rawHeight = img["t3"][0];
							var bitsPerSample = img["t10"][0];
							var RW2_Format =  img["t45"][0];
				
							var bidx = 0;
							var imageIndex = 0;
							var vpos = 0;
							var byte = 0;
							var bytes = (RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16));
							var i, j, sh, pred=[0,0], nonz=[0,0], isOdd, idx = 0, pixel_base;
							var row, col, crow;
							var buffer = new Uint8Array(0x4000);
							var result = new Uint16Array(tgt.buffer);
			
							function getDataRaw(bits){
								if (vpos == 0) {
									var arr_a = new Uint8Array(img_buffer, off+imageIndex + 0x1ff8, 0x4000-0x1ff8);
									var arr_b = new Uint8Array(img_buffer, off+imageIndex, 0x1ff8);
									buffer.set(arr_a);  
									buffer.set(arr_b, arr_a.length);
									imageIndex += 0x4000;
								}
								if(RW2_Format == 5) {
									for (i = 0; i < 16; i++){
										bytes[i] = buffer[vpos++];
										vpos &= 0x3FFF;
									}
								} else {
									vpos = (vpos - bits) & 0x1ffff;
									byte = vpos >> 3 ^ 0x3ff0;
									return (buffer[byte] | buffer[byte + 1] << 8) >> (vpos & 7) & ~((-1) << bits);
								}
							}
							// Raw Format 6
							function getBufferDataRW6(i) {
								return buffer[vpos + 15 - i];
							}
							function readPageRW6() {
								bytes[0] = (getBufferDataRW6(0) << 6) | (getBufferDataRW6(1) >> 2); // 14 bit
								bytes[1] = (((getBufferDataRW6(1) & 0x3) << 12) | (getBufferDataRW6(2) << 4) | (getBufferDataRW6(3) >> 4)) & 0x3fff;
								bytes[2] = (getBufferDataRW6(3) >> 2) & 0x3;
								bytes[3] = ((getBufferDataRW6(3) & 0x3) << 8) | getBufferDataRW6(4);
								bytes[4] = (getBufferDataRW6(5) << 2) | (getBufferDataRW6(6) >> 6);
								bytes[5] = ((getBufferDataRW6(6) & 0x3f) << 4) | (getBufferDataRW6(7) >> 4);
								bytes[6] = (getBufferDataRW6(7) >> 2) & 0x3;
								bytes[7] = ((getBufferDataRW6(7) & 0x3) << 8) | getBufferDataRW6(8);
								bytes[8] = ((getBufferDataRW6(9) << 2) & 0x3fc) | (getBufferDataRW6(10) >> 6);
								bytes[9] = ((getBufferDataRW6(10) << 4) | (getBufferDataRW6(11) >> 4)) & 0x3ff;
								bytes[10] = (getBufferDataRW6(11) >> 2) & 0x3;
								bytes[11] = ((getBufferDataRW6(11) & 0x3) << 8) | getBufferDataRW6(12);
								bytes[12] = (((getBufferDataRW6(13) << 2) & 0x3fc) | getBufferDataRW6(14) >> 6) & 0x3ff;
								bytes[13] = ((getBufferDataRW6(14) << 4) | (getBufferDataRW6(15) >> 4)) & 0x3ff;
								vpos += 16;
								byte = 0;
							}
							function readPageRw6_bps12() {
								bytes[0] = (getBufferDataRW6(0) << 4) | (getBufferDataRW6(1) >> 4);
								bytes[1] = (((getBufferDataRW6(1) & 0xf) << 8) | (getBufferDataRW6(2))) & 0xfff;
								bytes[2] = (getBufferDataRW6(3) >> 6) & 0x3;
								bytes[3] = ((getBufferDataRW6(3) & 0x3f) << 2) | (getBufferDataRW6(4) >> 6);
								bytes[4] = ((getBufferDataRW6(4) & 0x3f) << 2) | (getBufferDataRW6(5) >> 6);
								bytes[5] = ((getBufferDataRW6(5) & 0x3f) << 2) | (getBufferDataRW6(6) >> 6);
								bytes[6] = (getBufferDataRW6(6) >> 4) & 0x3;
								bytes[7] = ((getBufferDataRW6(6) & 0xf) << 4) | (getBufferDataRW6(7) >> 4);
								bytes[8] = ((getBufferDataRW6(7) & 0xf) << 4) | (getBufferDataRW6(8) >> 4);
								bytes[9] = ((getBufferDataRW6(8) & 0xf) << 4) | (getBufferDataRW6(9) >> 4);
								bytes[10] = (getBufferDataRW6(9) >> 2) & 0x3;
								bytes[11] = ((getBufferDataRW6(9) & 0x3) << 6) | (getBufferDataRW6(10) >> 2);
								bytes[12] = ((getBufferDataRW6(10) & 0x3) << 6) | (getBufferDataRW6(11) >> 2);
								bytes[13] = ((getBufferDataRW6(11) & 0x3) << 6) | (getBufferDataRW6(12) >> 2);
								bytes[14] = getBufferDataRW6(12) & 0x3;
								bytes[15] = getBufferDataRW6(13);
								bytes[16] = getBufferDataRW6(14);
								bytes[17] = getBufferDataRW6(15);
			
								vpos += 16;
								byte = 0;                    
							}
							// Main loop
							function resetPredNonzeros(){
								pred[0]=0; pred[1]=0;
								nonz[0]=0; nonz[1]=0;
							}
							if (RW2_Format == 7) {
								throw RW2_Format;
			
								// Skatch of version 7 
								/*
								var pixels_per_block = bitsPerSample == 14 ? 9 : 10;
									rowbytes = 0|(rawWidth / pixels_per_block * 16);
								for (row = 0; row < rawHeight - 15; row += 16) {
									var rowstoread = Math.min(16, rawHeight - row);
									var readlen = rowbytes*rowstoread;
									buffer = new Uint8Array(image.slice(bidx, bidx+readlen));
									vpos = 0;
									bidx += readlen; 
									i = 0;
									for (crow = 0; crow < rowstoread; crow++) {
										idx = (row + crow) * rawWidth;
										for (col = 0; col <= rawWidth - pixels_per_block; col += pixels_per_block) {
											for(j=0; j < pixels_per_block; j++) bytes[j] = buffer[i++];
											if (bitsPerSample == 12) {
												result[idx ] = ((bytes[1] & 0xF) << 8) + bytes[0];
												result[idx + 1] = 16 * bytes[2] + (bytes[1] >> 4);
												result[idx + 2] = ((bytes[4] & 0xF) << 8) + bytes[3];
												result[idx + 3] = 16 * bytes[5] + (bytes[4] >> 4);
												result[idx + 4] = ((bytes[7] & 0xF) << 8) + bytes[6];
												result[idx + 5] = 16 * bytes[8] + (bytes[7] >> 4);
												result[idx + 6] = ((bytes[10] & 0xF) << 8) + bytes[9];
												result[idx + 7] = 16 * bytes[11] + (bytes[10] >> 4);
												result[idx + 8] = ((bytes[13] & 0xF) << 8) + bytes[12];
												result[idx + 9] = 16 * bytes[14] + (bytes[13] >> 4);
											} else if (bitsPerSample == 14) {
												result[idx] = bytes[0] + ((bytes[1] & 0x3F) << 8);
												result[idx + 1] = (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);
												result[idx + 2] = (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);
												result[idx + 3] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);
												result[idx + 4] = bytes[7] + ((bytes[8] & 0x3F) << 8);
												result[idx + 5] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);
												result[idx + 6] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
												result[idx + 7] = ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);
												result[idx + 8] = bytes[14] + ((bytes[15] & 0x3F) << 8);
											}
										}
									}
								}
								*/
							} 
							else if(RW2_Format == 6) {
								var is12bit = bitsPerSample == 12,
									readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6,
									pixelsPerBlock = is12bit ? 14 : 11,
									pixelbase0 = is12bit ? 0x80 : 0x200,
									pixelbase_compare = is12bit ? 0x800 : 0x2000,
									spix_compare = is12bit ? 0x3fff : 0xffff,
									pixel_mask = is12bit ? 0xfff : 0x3fff,
									blocksperrow = rawWidth / pixelsPerBlock, 
									rowbytes = blocksperrow * 16,
									bufferSize = is12bit ? 18 : 14;
			
								for (row = 0; row < rawHeight - 15; row += 16) {
									var rowstoread = Math.min(16, rawHeight - row);
									var readlen = rowbytes*rowstoread;
									buffer = new Uint8Array(img_buffer, off+bidx, readlen);//new Uint8Array(image.slice(bidx, bidx+readlen));
									vpos = 0;
									bidx += readlen; 
									for (crow = 0, col = 0; crow < rowstoread; crow++, col = 0) {
										idx = (row + crow) * rawWidth;
										for (var rblock = 0; rblock < blocksperrow; rblock++) {
											readPageRw6Fn();
											resetPredNonzeros();
											sh=0; pixel_base=0;
											for (i = 0; i < pixelsPerBlock; i++){
												isOdd = i & 1;
												if (i % 3 == 2) {
													var base = byte < bufferSize ? bytes[byte++] : 0;
													if (base == 3) base = 4;
													pixel_base = pixelbase0 << base;
													sh = 1 << base;
												}
												var epixel = byte < bufferSize ? bytes[byte++] : 0;
												if (pred[isOdd]) {
													epixel *= sh;
													if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base)
														epixel += nonz[isOdd] - pixel_base;
													nonz[isOdd] = epixel;
												} else {
													pred[isOdd] = epixel;
													if (epixel)
														nonz[isOdd] = epixel;
													else
														epixel = nonz[isOdd];
												}
												result[idx + col++] = (epixel - 0xf) <= spix_compare ? (epixel - 0xf) & spix_compare : ((epixel + 0x7ffffff1) >> 0x1f) & pixel_mask;
											}
										}
									}
								}
							} 
							else if (RW2_Format == 5) { 
								var blockSize = bitsPerSample == 12 ? 10 : 9;
								for (row = 0; row < rawHeight; row++) {
									for (col = 0; col < rawWidth; col+=blockSize) {
										getDataRaw(0);
										// Tuhle podminku pouziva i RW2_Format 7 
										if (bitsPerSample == 12) {
											result[idx++] = ((bytes[1] & 0xF) << 8) + bytes[0];
											result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);
											result[idx++] = ((bytes[4] & 0xF) << 8) + bytes[3];
											result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);
											result[idx++] = ((bytes[7] & 0xF) << 8) + bytes[6];
											result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);
											result[idx++] = ((bytes[10] & 0xF) << 8) + bytes[9];
											result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);
											result[idx++] = ((bytes[13] & 0xF) << 8) + bytes[12];
											result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);
										} else if (bitsPerSample == 14) {
											result[idx++] = bytes[0] + ((bytes[1] & 0x3F) << 8);
											result[idx++] = (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);
											result[idx++] = (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);
											result[idx++] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);
											result[idx++] = bytes[7] + ((bytes[8] & 0x3F) << 8);
											result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);
											result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
											result[idx++] = ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);
											result[idx++] = bytes[14] + ((bytes[15] & 0x3F) << 8);
										}
									}
								}
								//console.log(result[1000000 - 1])
							} else if(RW2_Format == 4) {
								for (row = 0; row < rawHeight; row++){
									for(col = 0; col < rawWidth; col++){
										i = col % 14;
										isOdd = i & 1;
										if (i==0) resetPredNonzeros();
										if (i%3 == 2) 
											sh = 4 >> (3 - getDataRaw(2));
										if (nonz[isOdd]) {
											j = getDataRaw(8);
											if(j != 0){
												pred[isOdd] -= 0x80 << sh;
												if (pred[isOdd] < 0 || sh == 4) 
													pred[isOdd] &= ~((-1) << sh);
												pred[isOdd] += j << sh;
											}
										} else {
											nonz[isOdd] = getDataRaw(8);
											if(nonz[isOdd] || i > 11)
												pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);
										}
										result[idx++] = pred[col & 1];
									}
								}
							} 
							else throw RW2_Format;
						};
			
			
			UTIF.decode._decodeVC5 = function(){var x=[1,0,1,0,2,2,1,1,3,7,1,2,5,25,1,3,6,48,1,4,6,54,1,5,7,111,1,8,7,99,1,6,7,105,12,0,7,107,1,7,8,209,20,0,8,212,1,9,8,220,1,10,9,393,1,11,9,394,32,0,9,416,1,12,9,427,1,13,10,887,1,18,10,784,1,14,10,790,1,15,10,835,60,0,10,852,1,16,10,885,1,17,11,1571,1,19,11,1668,1,20,11,1669,100,0,11,1707,1,21,11,1772,1,22,12,3547,1,29,12,3164,1,24,12,3166,1,25,12,3140,1,23,12,3413,1,26,12,3537,1,27,12,3539,1,28,13,7093,1,35,13,6283,1,30,13,6331,1,31,13,6335,180,0,13,6824,1,32,13,7072,1,33,13,7077,320,0,13,7076,1,34,14,12565,1,36,14,12661,1,37,14,12669,1,38,14,13651,1,39,14,14184,1,40,15,28295,1,46,15,28371,1,47,15,25320,1,42,15,25336,1,43,15,25128,1,41,15,27300,1,44,15,28293,1,45,16,50259,1,48,16,50643,1,49,16,50675,1,50,16,56740,1,53,16,56584,1,51,16,56588,1,52,17,113483,1,61,17,113482,1,60,17,101285,1,55,17,101349,1,56,17,109205,1,57,17,109207,1,58,17,100516,1,54,17,113171,1,59,18,202568,1,62,18,202696,1,63,18,218408,1,64,18,218412,1,65,18,226340,1,66,18,226356,1,67,18,226358,1,68,19,402068,1,69,19,405138,1,70,19,405394,1,71,19,436818,1,72,19,436826,1,73,19,452714,1,75,19,452718,1,76,19,452682,1,74,20,804138,1,77,20,810279,1,78,20,810790,1,79,20,873638,1,80,20,873654,1,81,20,905366,1,82,20,905430,1,83,20,905438,1,84,21,1608278,1,85,21,1620557,1,86,21,1621582,1,87,21,1621583,1,88,21,1747310,1,89,21,1810734,1,90,21,1810735,1,91,21,1810863,1,92,21,1810879,1,93,22,3621725,1,99,22,3621757,1,100,22,3241112,1,94,22,3494556,1,95,22,3494557,1,96,22,3494622,1,97,22,3494623,1,98,23,6482227,1,102,23,6433117,1,101,23,6989117,1,103,23,6989119,1,105,23,6989118,1,104,23,7243449,1,106,23,7243512,1,107,24,13978233,1,111,24,12964453,1,109,24,12866232,1,108,24,14486897,1,113,24,13978232,1,110,24,14486896,1,112,24,14487026,1,114,24,14487027,1,115,25,25732598,1,225,25,25732597,1,189,25,25732596,1,188,25,25732595,1,203,25,25732594,1,202,25,25732593,1,197,25,25732592,1,207,25,25732591,1,169,25,25732590,1,223,25,25732589,1,159,25,25732522,1,235,25,25732579,1,152,25,25732575,1,192,25,25732489,1,179,25,25732573,1,201,25,25732472,1,172,25,25732576,1,149,25,25732488,1,178,25,25732566,1,120,25,25732571,1,219,25,25732577,1,150,25,25732487,1,127,25,25732506,1,211,25,25732548,1,125,25,25732588,1,158,25,25732486,1,247,25,25732467,1,238,25,25732508,1,163,25,25732552,1,228,25,25732603,1,183,25,25732513,1,217,25,25732587,1,168,25,25732520,1,122,25,25732484,1,128,25,25732562,1,249,25,25732505,1,187,25,25732504,1,186,25,25732483,1,136,25,25928905,1,181,25,25732560,1,255,25,25732500,1,230,25,25732482,1,135,25,25732555,1,233,25,25732568,1,222,25,25732583,1,145,25,25732481,1,134,25,25732586,1,167,25,25732521,1,248,25,25732518,1,209,25,25732480,1,243,25,25732512,1,216,25,25732509,1,164,25,25732547,1,140,25,25732479,1,157,25,25732544,1,239,25,25732574,1,191,25,25732564,1,251,25,25732478,1,156,25,25732546,1,139,25,25732498,1,242,25,25732557,1,133,25,25732477,1,162,25,25732515,1,213,25,25732584,1,165,25,25732514,1,212,25,25732476,1,227,25,25732494,1,198,25,25732531,1,236,25,25732530,1,234,25,25732529,1,117,25,25732528,1,215,25,25732527,1,124,25,25732526,1,123,25,25732525,1,254,25,25732524,1,253,25,25732523,1,148,25,25732570,1,218,25,25732580,1,146,25,25732581,1,147,25,25732569,1,224,25,25732533,1,143,25,25732540,1,184,25,25732541,1,185,25,25732585,1,166,25,25732556,1,132,25,25732485,1,129,25,25732563,1,250,25,25732578,1,151,25,25732501,1,119,25,25732502,1,193,25,25732536,1,176,25,25732496,1,245,25,25732553,1,229,25,25732516,1,206,25,25732582,1,144,25,25732517,1,208,25,25732558,1,137,25,25732543,1,241,25,25732466,1,237,25,25732507,1,190,25,25732542,1,240,25,25732551,1,131,25,25732554,1,232,25,25732565,1,252,25,25732475,1,171,25,25732493,1,205,25,25732492,1,204,25,25732491,1,118,25,25732490,1,214,25,25928904,1,180,25,25732549,1,126,25,25732602,1,182,25,25732539,1,175,25,25732545,1,141,25,25732559,1,138,25,25732537,1,177,25,25732534,1,153,25,25732503,1,194,25,25732606,1,160,25,25732567,1,121,25,25732538,1,174,25,25732497,1,246,25,25732550,1,130,25,25732572,1,200,25,25732474,1,170,25,25732511,1,221,25,25732601,1,196,25,25732532,1,142,25,25732519,1,210,25,25732495,1,199,25,25732605,1,155,25,25732535,1,154,25,25732499,1,244,25,25732510,1,220,25,25732600,1,195,25,25732607,1,161,25,25732604,1,231,25,25732473,1,173,25,25732599,1,226,26,51465122,1,116,26,51465123,0,1],o,C,k,P=[3,3,3,3,2,2,2,1,1,1],V=24576,ar=16384,H=8192,az=ar|H;
			function d(t){var E=t[1],h=t[0][E>>>3]>>>7-(E&7)&1;t[1]++;return h}function ag(t,E){if(o==null){o={};
			for(var h=0;h<x.length;h+=4)o[x[h+1]]=x.slice(h,h+4);}var L=d(t),g=o[L];while(g==null){L=L<<1|d(t);g=o[L];}var n=g[3];
			if(n!=0)n=d(t)==0?n:-n;E[0]=g[2];E[1]=n;}function m(t,E){for(var h=0;h<E;h++){if((t&1)==1)t++;t=t>>>1;}return t}function A(t,E){return t>>E}function O(t,E,h,L,g,n){E[h]=A(A(11*t[g]-4*t[g+n]+t[g+n+n]+4,3)+t[L],1);
			E[h+n]=A(A(5*t[g]+4*t[g+n]-t[g+n+n]+4,3)-t[L],1);}function J(t,E,h,L,g,n){var W=t[g-n]-t[g+n],j=t[g],$=t[L];
			E[h]=A(A(W+4,3)+j+$,1);E[h+n]=A(A(-W+4,3)+j-$,1);}function y(t,E,h,L,g,n){E[h]=A(A(5*t[g]+4*t[g-n]-t[g-n-n]+4,3)+t[L],1);
			E[h+n]=A(A(11*t[g]-4*t[g-n]+t[g-n-n]+4,3)-t[L],1);}function q(t){t=t<0?0:t>4095?4095:t;t=k[t]>>>2;return t}function av(t,E,h,L,g,n){L=new Uint16Array(L.buffer);
			var W=Date.now(),j=UTIF._binBE,$=E+h,r,u,X,I,ax,R,aa,i,T,B;E+=4;var a5=n[0]==1;
			while(E<$){var S=j.readShort(t,E),s=j.readUshort(t,E+2);E+=4;if(S==12)r=s;else if(S==20)u=s;else if(S==21)X=s;
			else if(S==48)I=s;else if(S==53)ax=s;else if(S==35);else if(S==62)R=s;else if(S==101);else if(S==109)aa=s;
			else if(S==84);else if(S==106);else if(S==107);else if(S==108);else if(S==102);else if(S==104)i=s;
			else if(S==105);else {var F=S<0?-S:S,D=F&65280,_=0;if(F&az){if(F&H){_=s&65535;_+=(F&255)<<16;}else {_=s&65535;}}if((F&V)==V){if(T==null){T=[];
			for(var M=0;M<4;M++)T[M]=new Int16Array((u>>>1)*(X>>>1));B=new Int16Array((u>>>1)*(X>>>1));C=new Int16Array(1024);
			for(var M=0;M<1024;M++){var aG=M-512,p=Math.abs(aG),r=Math.floor(768*p*p*p/(255*255*255))+p;C[M]=Math.sign(aG)*r;}k=new Uint16Array(4096);
			var aA=(1<<16)-1;for(var M=0;M<4096;M++){var at=M,a1=aA*(Math.pow(113,at/4095)-1)/112;k[M]=Math.min(a1,aA);}}var w=T[R],v=m(u,1+P[I]),N=m(X,1+P[I]);
			if(I==0){for(var b=0;b<N;b++)for(var G=0;G<v;G++){var c=E+(b*v+G)*2;w[b*(u>>>1)+G]=t[c]<<8|t[c+1];}}else {var a7=[t,E*8],a4=[],ay=0,aw=v*N,f=[0,0],Q=0,s=0;
			while(ay<aw){ag(a7,f);Q=f[0];s=f[1];while(Q>0){a4[ay++]=s;Q--;}}var l=(I-1)%3,aF=l!=1?v:0,a2=l!=0?N:0;
			for(var b=0;b<N;b++){var af=(b+a2)*(u>>>1)+aF,au=b*v;for(var G=0;G<v;G++)w[af+G]=C[a4[au+G]+512]*ax;}if(l==2){var i=u>>>1,an=v*2,a9=N*2;
			for(var b=0;b<N;b++){for(var G=0;G<an;G++){var M=b*2*i+G,a=b*i+G,e=N*i+a;if(b==0)O(w,B,M,e,a,i);else if(b==N-1)y(w,B,M,e,a,i);
			else J(w,B,M,e,a,i);}}var Z=w;w=B;B=Z;for(var b=0;b<a9;b++){for(var G=0;G<v;G++){var M=b*i+2*G,a=b*i+G,e=v+a;
			if(G==0)O(w,B,M,e,a,1);else if(G==v-1)y(w,B,M,e,a,1);else J(w,B,M,e,a,1);}}var Z=w;w=B;B=Z;var aC=[],aB=2-~~((I-1)/3);
			for(var K=0;K<3;K++)aC[K]=aa>>14-K*2&3;var a6=aC[aB];if(a6!=0)for(var b=0;b<a9;b++)for(var G=0;G<an;
			G++){var M=b*i+G;w[M]=w[M]<<a6;}}}if(I==9&&R==3){var a8=T[0],ab=T[1],aq=T[2],as=T[3];for(var b=0;b<X;
			b+=2)for(var G=0;G<u;G+=2){var U=b*u+G,c=(b>>>1)*(u>>>1)+(G>>>1),z=a8[c],ao=ab[c]-2048,ak=aq[c]-2048,ad=as[c]-2048,aj=(ao<<1)+z,a0=(ak<<1)+z,aH=z+ad,am=z-ad;
			if(a5){L[U]=q(aH);L[U+1]=q(a0);L[U+u]=q(aj);L[U+u+1]=q(am);}else {L[U]=q(aj);L[U+1]=q(aH);L[U+u]=q(am);
			L[U+u+1]=q(a0);}}}E+=_*4;}else if(F==16388){E+=_*4;}else if(D==8192||D==8448||D==9216);else throw F.toString(16)}}console.log(Date.now()-W);}return av}();
			
			
			
			UTIF.decode._decodeLogLuv32 = function(img, data, off, len, tgt, toff) {
				var w = img.width, qw=w*4;
				var io = 0, out = new Uint8Array(qw);
				
				while(io<len) {
					var oo=0;
					while(oo<qw) {
						var c = data[off+io]; io++;
						if(c<128) {       for(var j=0; j<c; j++) out[oo+j] = data[off+io+j];  oo+=c;  io+=c;  }
						else {  c=c-126;  for(var j=0; j<c; j++) out[oo+j] = data[off+io  ];  oo+=c;  io++ ;  }
					}
					
					for(var x=0; x<w; x++) {
						tgt[toff+0] = out[x];
						tgt[toff+1] = out[x+w];
						tgt[toff+2] = out[x+w*2];
						tgt[toff+4] = out[x+w*3];
						toff+=6;
					}
				}
			};
			
			UTIF.decode._ljpeg_diff = function(data, prm, huff) {
				var getbithuff   = UTIF.decode._getbithuff;
				var len, diff;
				len  = getbithuff(data, prm, huff[0], huff);
				diff = getbithuff(data, prm, len, 0);
				if ((diff & (1 << (len-1))) == 0)  diff -= (1 << len) - 1;
				return diff;
			};
			UTIF.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
				var raw_width = img["t256"][0], height=img["t257"][0], tiff_bps=img["t258"][0];
				var bin=(img.isLE ? UTIF._binLE : UTIF._binBE);
				//console.log(raw_width, height, tiff_bps, raw_width*height, src_length);
				var arw2 = (raw_width*height == src_length) || (raw_width*height*1.5 == src_length);
				//arw2 = true;
				//console.log("ARW2: ", arw2, raw_width*height, src_length, tgt.length);
				if(!arw2) {  //"sony_arw_load_raw"; // not arw2
					height+=8;
					var prm = [off,0,0,0];
					var huff = new Uint16Array(32770);
					var tab = [ 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,
						0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 ];
					var i, c, n, col, row, sum=0;
					var ljpeg_diff = UTIF.decode._ljpeg_diff;
			
					huff[0] = 15;
					for (n=i=0; i < 18; i++) {
						var lim = 32768 >>> (tab[i] >>> 8);
						for(var c=0; c<lim; c++) huff[++n] = tab[i];
					}
					for (col = raw_width; col--; )
						for (row=0; row < height+1; row+=2) {
							if (row == height) row = 1;
							sum += ljpeg_diff(inp, prm, huff);
							if (row < height) {
								var clr =  (sum)&4095;
								UTIF.decode._putsF(tgt, (row*raw_width+col)*tiff_bps, clr<<(16-tiff_bps));
							}
						}
					return;
				}
				if(raw_width*height*1.5==src_length) {
					//console.log("weird compression");
					for(var i=0; i<src_length; i+=3) {  var b0=inp[off+i+0], b1=inp[off+i+1], b2=inp[off+i+2];  
						tgt[toff+i]=(b1<<4)|(b0>>>4);  tgt[toff+i+1]=(b0<<4)|(b2>>>4);  tgt[toff+i+2]=(b2<<4)|(b1>>>4);  }
					return;
				}
				
				var pix = new Uint16Array(16);
				var row, col, val, max, min, imax, imin, sh, bit, i,    dp;
				
				var data = new Uint8Array(raw_width+1);
				for (row=0; row < height; row++) {
					//fread (data, 1, raw_width, ifp);
					for(var j=0; j<raw_width; j++) data[j]=inp[off++];
					for (dp=0, col=0; col < raw_width-30; dp+=16) {
						max  = 0x7ff & (val = bin.readUint(data,dp));
						min  = 0x7ff & (val >>> 11);
						imax = 0x0f & (val >>> 22);
						imin = 0x0f & (val >>> 26);
						for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);
						for (bit=30, i=0; i < 16; i++)
							if      (i == imax) pix[i] = max;
							else if (i == imin) pix[i] = min;
							else {
								pix[i] = ((bin.readUshort(data, dp+(bit >> 3)) >>> (bit & 7) & 0x7f) << sh) + min;
								if (pix[i] > 0x7ff) pix[i] = 0x7ff;
								bit += 7;
							}
						for (i=0; i < 16; i++, col+=2) {
							//RAW(row,col) = curve[pix[i] << 1] >> 2;
							var clr =  pix[i]<<1;   //clr = 0xffff;
							UTIF.decode._putsF(tgt, (row*raw_width+col)*tiff_bps, clr<<(16-tiff_bps));
						}
						col -= col & 1 ? 1:31;
					}
				}
			};
			
			UTIF.decode._decodeNikon = function(img,imgs, data, off, src_length, tgt, toff)
			{
				var nikon_tree = [
				[ 0, 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy */
				  5,4,3,6,2,7,1,0,8,9,11,10,12 ],
				[ 0, 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy after split */
				  0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 ],
				[ 0, 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */
				  5,4,6,3,7,2,8,1,9,0,10,11,12 ],
				[ 0, 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	/* 14-bit lossy */
				  5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 ],
				[ 0, 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	/* 14-bit lossy after split */
				  8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 ],
				[ 0, 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	/* 14-bit lossless */
				  7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 ] ];
				  
				var raw_width = img["t256"][0], height=img["t257"][0], tiff_bps=img["t258"][0];
				
				var tree = 0, split = 0;
				var make_decoder = UTIF.decode._make_decoder;
				var getbithuff   = UTIF.decode._getbithuff;
				
				var mn = imgs[0].exifIFD.makerNote, md = mn["t150"]?mn["t150"]:mn["t140"], mdo=0;  //console.log(mn,md);
				//console.log(md[0].toString(16), md[1].toString(16), tiff_bps);
				var ver0 = md[mdo++], ver1 = md[mdo++];
				if (ver0 == 0x49 || ver1 == 0x58)  mdo+=2110;
				if (ver0 == 0x46) tree = 2;
				if (tiff_bps == 14) tree += 3;
				
				var vpred = [[0,0],[0,0]], bin=(img.isLE ? UTIF._binLE : UTIF._binBE);
				for(var i=0; i<2; i++) for(var j=0; j<2; j++) {  vpred[i][j] = bin.readShort(md,mdo);  mdo+=2;   }  // not sure here ... [i][j] or [j][i]
				//console.log(vpred);
				
				
				var max = 1 << tiff_bps & 0x7fff, step=0;
				var csize = bin.readShort(md,mdo);  mdo+=2;
				if (csize > 1) step = Math.floor(max / (csize-1));
				if (ver0 == 0x44 && ver1 == 0x20 && step > 0)  split = bin.readShort(md,562);
				
				
				var i;
				var row, col;
				var len, shl, diff;
				var hpred = [0,0];
				var huff = make_decoder(nikon_tree[tree]);
				
				//var g_input_offset=0, bitbuf=0, vbits=0, reset=0;
				var prm = [off,0,0,0];
				//console.log(split);  split = 170;
				
				for (row=0; row < height; row++) {
					if (split && row == split) {
						//free (huff);
						huff = make_decoder (nikon_tree[tree+1]);
						//max_v += (min_v = 16) << 1;
					}
					for (col=0; col < raw_width; col++) {
						i = getbithuff(data,prm,huff[0],huff);
						len = i  & 15;
						shl = i >>> 4;
						diff = (((getbithuff(data,prm,len-shl,0) << 1) + 1) << shl) >>> 1;
						if ((diff & (1 << (len-1))) == 0)
							diff -= (1 << len) - (shl==0?1:0);
						if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
						else         hpred[col & 1] += diff;
						
						var clr = Math.min(Math.max(hpred[col & 1],0),(1<<tiff_bps)-1);
						var bti = (row*raw_width+col)*tiff_bps;  
						UTIF.decode._putsF(tgt, bti, clr<<(16-tiff_bps));
					}
				}
			};
			// put 16 bits
			UTIF.decode._putsF= function(dt, pos, val) {  val = val<<(8-(pos&7));  var o=(pos>>>3);  dt[o]|=val>>>16;  dt[o+1]|=val>>>8;  dt[o+2]|=val;  };
			
			
			UTIF.decode._getbithuff = function(data,prm,nbits, huff) {
				var zero_after_ff = 0;
				UTIF.decode._get_byte;
				var c;
			  
				var off=prm[0], bitbuf=prm[1], vbits=prm[2], reset=prm[3];
			
				//if (nbits > 25) return 0;
				//if (nbits <  0) return bitbuf = vbits = reset = 0;
				if (nbits == 0 || vbits < 0) return 0; 
				while (!reset && vbits < nbits && (c = data[off++]) != -1 &&
					!(reset = zero_after_ff)) {
					//console.log("byte read into c");
					bitbuf = (bitbuf << 8) + c;
					vbits += 8;
				} 
				c = (bitbuf << (32-vbits)) >>> (32-nbits);
				if (huff) {
					vbits -= huff[c+1] >>> 8;  //console.log(c, huff[c]>>8);
					c =  huff[c+1]&255;
				} else
					vbits -= nbits;
				if (vbits < 0) throw "e";
			  
				prm[0]=off;  prm[1]=bitbuf;  prm[2]=vbits;  prm[3]=reset;
			  
				return c;
			};
			
			UTIF.decode._make_decoder = function(source) {
				var max, len, h, i, j;
				var huff = [];
			
				for (max=16; max!=0 && !source[max]; max--);
				var si=17;
				
				huff[0] = max;
				for (h=len=1; len <= max; len++)
					for (i=0; i < source[len]; i++, ++si)
						for (j=0; j < 1 << (max-len); j++)
							if (h <= 1 << max)
								huff[h++] = (len << 8) | source[si];
				return huff;
			};
			
			UTIF.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff)
			{
				len = Math.min(len, data.length-off);
				var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
				
				if (tables) {
					var SOI = 216, EOI = 217, boff = 0;
					for (var i=0; i<(tlen-1); i++)
					{
						// Skip EOI marker from JPEGTables
						if (tables[i]==255 && tables[i+1]==EOI) break;
						buff[boff++] = tables[i];
					}
			
					// Skip SOI marker from data
					var byte1 = data[off], byte2 = data[off + 1];
					if (byte1!=255 || byte2!=SOI)
					{
						buff[boff++] = byte1;
						buff[boff++] = byte2;
					}
					for (var i=2; i<len; i++) buff[boff++] = data[off+i];
				}
				else for (var i=0; i<len; i++) buff[i] = data[off+i];
			
				if(img["t262"][0]==32803 || (img["t259"][0]==7 && img["t262"][0]==34892)) // lossless JPEG (used in DNG files)
				{
					var bps = img["t258"][0];//, dcdr = new LosslessJpegDecoder();
					//var time = Date.now();
					var out = UTIF.LosslessJpegDecode(buff), olen=out.length;  //console.log(olen);
					//var out = ULLJPG(buff), olen=out.length;  //console.log(olen);
					//console.log(Date.now()-time);
					
					if(bps==16) {
						if(img.isLE) for(var i=0; i<olen; i++ ) {  tgt[toff+(i<<1)] = (out[i]&255);  tgt[toff+(i<<1)+1] = (out[i]>>>8);  }
						else         for(var i=0; i<olen; i++ ) {  tgt[toff+(i<<1)] = (out[i]>>>8);  tgt[toff+(i<<1)+1] = (out[i]&255);  }
					}
					else if(bps==14 || bps==12 || bps==10) {  // 4 * 14 == 56 == 7 * 8
						var rst = 16-bps;
						for(var i=0; i<olen; i++) UTIF.decode._putsF(tgt, i*bps, out[i]<<rst);
					}
					else if(bps==8) {
						for(var i=0; i<olen; i++) tgt[toff+i]=out[i];
					}
					else throw new Error("unsupported bit depth "+bps);
				}
				else
				{
					var parser = new UTIF.JpegDecoder();  parser.parse(buff);
					var decoded = parser.getData({"width":parser.width,"height":parser.height,"forceRGB":true,"isSourcePDF":false});
					for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];
				}
			
				// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
				// RGB format, so updating the tag value
				if(img["t262"][0] == 6)  img["t262"][0] = 2;
			};
			
			UTIF.decode._decodeOldJPEGInit = function(img, data, off, len)
			{
				var SOI = 216, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS = 218;
				var joff = 0, soff = 0, tables, sosMarker, isTiled = false, i, j, k;
				var jpgIchgFmt    = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
				var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
				var soffTag       = img["t324"] || img["t273"] || jpgIchgFmt;
				var ycbcrss       = img["t530"], ssx = 0, ssy = 0;
				var spp           = img["t277"]?img["t277"][0]:1;
				var jpgresint     = img["t515"];
			
				if(soffTag)
				{
					soff = soffTag[0];
					isTiled = (soffTag.length > 1);
				}
			
				if(!isTiled)
				{
					if(data[off]==255 && data[off+1]==SOI) return { jpegOffset: off };
					if(jpgIchgFmt!=null)
					{
						if(data[off+jifoff]==255 && data[off+jifoff+1]==SOI) joff = off+jifoff;
						else log("JPEGInterchangeFormat does not point to SOI");
			
						if(jpgIchgFmtLen==null) log("JPEGInterchangeFormatLength field is missing");
						else if(jifoff >= soff || (jifoff+jiflen) <= soff) log("JPEGInterchangeFormatLength field value is invalid");
			
						if(joff != null) return { jpegOffset: joff };
					}
				}
			
				if(ycbcrss!=null) {  ssx = ycbcrss[0];  ssy = ycbcrss[1];  }
			
				if(jpgIchgFmt!=null)
					if(jpgIchgFmtLen!=null)
						if(jiflen >= 2 && (jifoff+jiflen) <= soff)
						{
							if(data[off+jifoff+jiflen-2]==255 && data[off+jifoff+jiflen-1]==SOI) tables = new Uint8Array(jiflen-2);
							else tables = new Uint8Array(jiflen);
			
							for(i=0; i<tables.length; i++) tables[i] = data[off+jifoff+i];
							log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
						}
						else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
			
				if(tables == null)
				{
					var ooff = 0, out = [];
					out[ooff++] = 255; out[ooff++] = SOI;
			
					var qtables = img["t519"];
					if(qtables==null) throw new Error("JPEGQTables tag is missing");
					for(i=0; i<qtables.length; i++)
					{
						out[ooff++] = 255; out[ooff++] = DQT; out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
						for(j=0; j<64; j++) out[ooff++] = data[off+qtables[i]+j];
					}
			
					for(k=0; k<2; k++)
					{
						var htables = img[(k == 0) ? "t520" : "t521"];
						if(htables==null) throw new Error(((k == 0) ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
						for(i=0; i<htables.length; i++)
						{
							out[ooff++] = 255; out[ooff++] = DHT;
							//out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;
							var nc = 19;
							for(j=0; j<16; j++) nc += data[off+htables[i]+j];
			
							out[ooff++] = (nc >>> 8); out[ooff++] = nc & 255;
							out[ooff++] = (i | (k << 4));
							for(j=0; j<16; j++) out[ooff++] = data[off+htables[i]+j];
							for(j=0; j<nc; j++) out[ooff++] = data[off+htables[i]+16+j];
						}
					}
			
					out[ooff++] = 255; out[ooff++] = SOF0;
					out[ooff++] = 0;  out[ooff++] = 8 + 3*spp;  out[ooff++] = 8;
					out[ooff++] = (img.height >>> 8) & 255;  out[ooff++] = img.height & 255;
					out[ooff++] = (img.width  >>> 8) & 255;  out[ooff++] = img.width  & 255;
					out[ooff++] = spp;
					if(spp==1) {  out[ooff++] = 1;  out[ooff++] = 17;  out[ooff++] = 0;  }
					else for(i=0; i<3; i++)
					{
						out[ooff++] = i + 1;
						out[ooff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
						out[ooff++] = i;
					}
			
					if(jpgresint!=null && jpgresint[0]!=0)
					{
						out[ooff++] = 255;  out[ooff++] = DRI;  out[ooff++] = 0;  out[ooff++] = 4;
						out[ooff++] = (jpgresint[0] >>> 8) & 255;
						out[ooff++] = jpgresint[0] & 255;
					}
			
					tables = new Uint8Array(out);
				}
			
				var sofpos = -1;
				i = 0;
				while(i < (tables.length - 1)) {
					if(tables[i]==255 && tables[i+1]==SOF0) {  sofpos = i; break;  }
					i++;
				}
			
				if(sofpos == -1)
				{
					var tmptab = new Uint8Array(tables.length + 10 + 3*spp);
					tmptab.set(tables);
					var tmpoff = tables.length;
					sofpos = tables.length;
					tables = tmptab;
			
					tables[tmpoff++] = 255; tables[tmpoff++] = SOF0;
					tables[tmpoff++] = 0;  tables[tmpoff++] = 8 + 3*spp;  tables[tmpoff++] = 8;
					tables[tmpoff++] = (img.height >>> 8) & 255;  tables[tmpoff++] = img.height & 255;
					tables[tmpoff++] = (img.width  >>> 8) & 255;  tables[tmpoff++] = img.width  & 255;
					tables[tmpoff++] = spp;
					if(spp==1) {  tables[tmpoff++] = 1;  tables[tmpoff++] = 17;  tables[tmpoff++] = 0;  }
					else for(i=0; i<3; i++)
					{
						tables[tmpoff++] = i + 1;
						tables[tmpoff++] = (i != 0) ? 17 : (((ssx & 15) << 4) | (ssy & 15));
						tables[tmpoff++] = i;
					}
				}
			
				if(data[soff]==255 && data[soff+1]==SOS)
				{
					var soslen = (data[soff+2]<<8) | data[soff+3];
					sosMarker = new Uint8Array(soslen+2);
					sosMarker[0] = data[soff];  sosMarker[1] = data[soff+1]; sosMarker[2] = data[soff+2];  sosMarker[3] = data[soff+3];
					for(i=0; i<(soslen-2); i++) sosMarker[i+4] = data[soff+i+4];
				}
				else
				{
					sosMarker = new Uint8Array(2 + 6 + 2*spp);
					var sosoff = 0;
					sosMarker[sosoff++] = 255;  sosMarker[sosoff++] = SOS;
					sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 6 + 2*spp;  sosMarker[sosoff++] = spp;
					if(spp==1) {  sosMarker[sosoff++] = 1;  sosMarker[sosoff++] = 0;  }
					else for(i=0; i<3; i++)
					{
						sosMarker[sosoff++] = i+1;  sosMarker[sosoff++] = (i << 4) | i;
					}
					sosMarker[sosoff++] = 0;  sosMarker[sosoff++] = 63;  sosMarker[sosoff++] = 0;
				}
			
				return { jpegOffset: off, tables: tables, sosMarker: sosMarker, sofPosition: sofpos };
			};
			
			UTIF.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff)
			{
				var i, dlen, tlen, buff, buffoff;
				var jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);
			
				if(jpegData.jpegOffset!=null)
				{
					dlen = off+len-jpegData.jpegOffset;
					buff = new Uint8Array(dlen);
					for(i=0; i<dlen; i++) buff[i] = data[jpegData.jpegOffset+i];
				}
				else
				{
					tlen = jpegData.tables.length;
					buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
					buff.set(jpegData.tables);
					buffoff = tlen;
			
					buff[jpegData.sofPosition+5] = (img.height >>> 8) & 255;  buff[jpegData.sofPosition+6] = img.height & 255;
					buff[jpegData.sofPosition+7] = (img.width  >>> 8) & 255;  buff[jpegData.sofPosition+8] = img.width  & 255;
			
					if(data[off]!=255 || data[off+1]!=SOS)
					{
						buff.set(jpegData.sosMarker, buffoff);
						buffoff += sosMarker.length;
					}
					for(i=0; i<len; i++) buff[buffoff++] = data[off+i];
					buff[buffoff++] = 255;  buff[buffoff++] = EOI;
				}
			
				var parser = new UTIF.JpegDecoder();  parser.parse(buff);
				var decoded = parser.getData({"width":parser.width,"height":parser.height,"forceRGB":true,"isSourcePDF":false});
				for (var i=0; i<decoded.length; i++) tgt[toff + i] = decoded[i];
			
				// PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in
				// RGB format, so updating the tag value
				if(img["t262"] && img["t262"][0] == 6)  img["t262"][0] = 2;
			};
			
			UTIF.decode._decodePackBits = function(data, off, len, tgt, toff)
			{
				var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off+len;
				while(off<lim)
				{
					var n = sa[off];  off++;
					if(n>=0  && n<128)    for(var i=0; i< n+1; i++) {  ta[toff]=sa[off];  toff++;  off++;   }
					if(n>=-127 && n<0) {  for(var i=0; i<-n+1; i++) {  ta[toff]=sa[off];  toff++;           }  off++;  }
				}
				return toff;
			};
			
			UTIF.decode._decodeThunder = function(data, off, len, tgt, toff)
			{
				var d2 = [ 0, 1, 0, -1 ],  d3 = [ 0, 1, 2, 3, 0, -3, -2, -1 ];
				var lim = off+len, qoff = toff*2, px = 0;
				while(off<lim)
				{
					var b = data[off], msk = (b>>>6), n = (b&63);  off++;
					if(msk==3) { px=(n&15);  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
					if(msk==0) for(var i=0; i<n; i++) {  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++;   }
					if(msk==2) for(var i=0; i<2; i++) {  var d=(n>>>(3*(1-i)))&7;  if(d!=4) { px+=d3[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
					if(msk==1) for(var i=0; i<3; i++) {  var d=(n>>>(2*(2-i)))&3;  if(d!=2) { px+=d2[d];  tgt[qoff>>>1] |= (px<<(4*(1-qoff&1)));  qoff++; }  }
				}
			};
			
			UTIF.decode._dmap = { "1":0,"011":1,"000011":2,"0000011":3, "010":-1,"000010":-2,"0000010":-3  };
			UTIF.decode._lens = ( function()
			{
				var addKeys = function(lens, arr, i0, inc) {  for(var i=0; i<arr.length; i++) lens[arr[i]] = i0 + i*inc;  };
			
				var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101," // 15
				+ "101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010," // 31
				+ "00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010," // 47
				+ "00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
			
				var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000," // 15
				+ "0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001," // 31
				+ "000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111," // 47
				+ "000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
			
				var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,"
				+ "011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
			
				var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,"
				+ "0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,"
				+ "0000001011011,0000001100100,0000001100101";
			
				var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
			
				termW = termW.split(",");  termB = termB.split(",");  makeW = makeW.split(",");  makeB = makeB.split(",");  makeA = makeA.split(",");
			
				var lensW = {}, lensB = {};
				addKeys(lensW, termW, 0, 1);  addKeys(lensW, makeW, 64,64);  addKeys(lensW, makeA, 1792,64);
				addKeys(lensB, termB, 0, 1);  addKeys(lensB, makeB, 64,64);  addKeys(lensB, makeA, 1792,64);
				return [lensW, lensB];
			} )();
			
			UTIF.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo)
			{
				var U = UTIF.decode, boff=off<<3, len=0, wrd="";	// previous starts with 1
				var line=[], pline=[];  for(var i=0; i<w; i++) pline.push(0);  pline=U._makeDiff(pline);
				var a0=0, a1=0, b1=0, b2=0, clr=0;
				var y=0, mode="", toRead=0;
				var bipl = Math.ceil(w/8)*8;
			
				while((boff>>>3)<off+slen)
				{
					b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
					var bit =0;
					if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
					if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
					boff++;  wrd+=bit;
					if(mode=="H")
					{
						if(U._lens[clr][wrd]!=null)
						{
							var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
							if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
						}
					}
					else
					{
						if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
						if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
						if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
					}
					if(line.length==w && mode=="")
					{
						U._writeBits(line, tgt, toff*8+y*bipl);
						clr=0;  y++;  a0=0;
						pline=U._makeDiff(line);  line=[];
					}
					//if(wrd.length>150) {  log(wrd);  break;  throw "e";  }
				}
			};
			
			UTIF.decode._findDiff = function(line, x, clr) {  for(var i=0; i<line.length; i+=2) if(line[i]>=x && line[i+1]==clr)  return line[i];  };
			
			UTIF.decode._makeDiff = function(line)
			{
				var out = [];  if(line[0]==1) out.push(0,1);
				for(var i=1; i<line.length; i++) if(line[i-1]!=line[i]) out.push(i, line[i]);
				out.push(line.length,0,line.length,1);  return out;
			};
			
			UTIF.decode._decodeG2 = function(data, off, slen, tgt, toff, w, fo)
			{
				var U = UTIF.decode, boff=off<<3, len=0, wrd="";
				var line=[];
				var clr = 0;
				var y=0;
				var bipl = Math.ceil(w/8)*8;
				
				while((boff>>>3)<off+slen) {
					var bit =0;
					if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
					if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
					boff++;  wrd+=bit;
					
					len = U._lens[clr][wrd];
					if(len!=null) {
						U._addNtimes(line,len,clr);  wrd="";
						if(len<64) clr = 1-clr;  
						if(line.length==w) {  U._writeBits(line, tgt, toff*8+y*bipl);  line=[];  y++;  clr=0;  if((boff&7)!=0) boff+=8-(boff&7);  if(len>=64) boff+=8;   }
					}
				}
			};
			
			UTIF.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo, twoDim)
			{
				var U = UTIF.decode, boff=off<<3, len=0, wrd="";
				var line=[], pline=[];  for(var i=0; i<w; i++) line.push(0);
				var a0=0, a1=0, b1=0, b2=0, clr=0;
				var y=-1, mode="", toRead=0, is1D=true;
				var bipl = Math.ceil(w/8)*8;
				while((boff>>>3)<off+slen)
				{
					b1 = U._findDiff(pline, a0+(a0==0?0:1), 1-clr), b2 = U._findDiff(pline, b1, clr);	// could be precomputed
					var bit =0;
					if(fo==1) bit = (data[boff>>>3]>>>(7-(boff&7)))&1;
					if(fo==2) bit = (data[boff>>>3]>>>(  (boff&7)))&1;
					boff++;  wrd+=bit;
			
					if(is1D)
					{
						if(U._lens[clr][wrd]!=null)
						{
							var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
							if(dl<64) {  U._addNtimes(line,len,clr);  clr=1-clr;  len=0;  }
						}
					}
					else
					{
						if(mode=="H")
						{
							if(U._lens[clr][wrd]!=null)
							{
								var dl=U._lens[clr][wrd];  wrd="";  len+=dl;
								if(dl<64) {  U._addNtimes(line,len,clr);  a0+=len;  clr=1-clr;  len=0;  toRead--;  if(toRead==0) mode="";  }
							}
						}
						else
						{
							if(wrd=="0001")  {  wrd="";  U._addNtimes(line,b2-a0,clr);  a0=b2;   }
							if(wrd=="001" )  {  wrd="";  mode="H";  toRead=2;  }
							if(U._dmap[wrd]!=null) {  a1 = b1+U._dmap[wrd];  U._addNtimes(line, a1-a0, clr);  a0=a1;  wrd="";  clr=1-clr;  }
						}
					}
					if(wrd.endsWith("000000000001")) // needed for some files
					{
						if(y>=0) U._writeBits(line, tgt, toff*8+y*bipl);
						if(twoDim) {
							if(fo==1) is1D = ((data[boff>>>3]>>>(7-(boff&7)))&1)==1;
							if(fo==2) is1D = ((data[boff>>>3]>>>(  (boff&7)))&1)==1;
							boff++;
						}
						//log("EOL",y, "next 1D:", is1D);
						wrd="";  clr=0;  y++;  a0=0;
						pline=U._makeDiff(line);  line=[];
					}
				}
				if(line.length==w) U._writeBits(line, tgt, toff*8+y*bipl);
			};
			
			UTIF.decode._addNtimes = function(arr, n, val) {  for(var i=0; i<n; i++) arr.push(val);  };
			
			UTIF.decode._writeBits = function(bits, tgt, boff)
			{
				for(var i=0; i<bits.length; i++) tgt[(boff+i)>>>3] |= (bits[i]<<(7-((boff+i)&7)));
			};
			
			UTIF.decode._decodeLZW=UTIF.decode._decodeLZW=function(){var e,U,Z,u,K=0,V=0,g=0,N=0,O=function(){var S=e>>>3,A=U[S]<<16|U[S+1]<<8|U[S+2],j=A>>>24-(e&7)-V&(1<<V)-1;
			e+=V;return j},h=new Uint32Array(4096*4),w=0,m=function(S){if(S==w)return;w=S;g=1<<S;N=g+1;for(var A=0;
			A<N+1;A++){h[4*A]=h[4*A+3]=A;h[4*A+1]=65535;h[4*A+2]=1;}},i=function(S){V=S+1;K=N+1;},D=function(S){var A=S<<2,j=h[A+2],a=u+j-1;
			while(A!=65535){Z[a--]=h[A];A=h[A+1];}u+=j;},L=function(S,A){var j=K<<2,a=S<<2;h[j]=h[(A<<2)+3];h[j+1]=a;
			h[j+2]=h[a+2]+1;h[j+3]=h[a+3];K++;if(K+1==1<<V&&V!=12)V++;},T=function(S,A,j,a,n,q){e=A<<3;U=S;Z=a;u=n;
			var B=A+j<<3,_=0,t=0;m(q);i(q);while(e<B&&(_=O())!=N){if(_==g){i(q);_=O();if(_==N)break;D(_);}else {if(_<K){D(_);
			L(t,_);}else {L(t,t);D(K-1);}}t=_;}return u};return T}();
			
			UTIF.tags = {};
			//UTIF.ttypes = {  256:3,257:3,258:3,   259:3, 262:3,  273:4,  274:3, 277:3,278:4,279:4, 282:5, 283:5, 284:3, 286:5,287:5, 296:3, 305:2, 306:2, 338:3, 513:4, 514:4, 34665:4  };
			// start at tag 250
			UTIF._types = function() {
				var main = new Array(250);  main.fill(0);
				main = main.concat([0,0,0,0,4,3,3,3,3,3,0,0,3,0,0,0,3,0,0,2,2,2,2,4,3,0,0,3,4,4,3,3,5,5,3,2,5,5,0,0,0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,2,2,3,5,5,3,0,3,3,4,4,4,3,4,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
				var rest = {33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7};
				return {
					basic: {
						main: main,
						rest: rest
					},
					gps: {
						main: [1,2,5,2,5,1,5,5,0,9],
						rest: {18:2,29:2}
					}
				}
			}();
			
			UTIF._readIFD = function(bin, data, offset, ifds, depth, prm)
			{
				var cnt = bin.readUshort(data, offset);  offset+=2;
				var ifd = {};
			
				if(prm.debug) log("   ".repeat(depth),ifds.length-1,">>>----------------");
				for(var i=0; i<cnt; i++)
				{
					var tag  = bin.readUshort(data, offset);    offset+=2;
					var type = bin.readUshort(data, offset);    offset+=2;
					var num  = bin.readUint  (data, offset);    offset+=4;
					var voff = bin.readUint  (data, offset);    offset+=4;
					
					var arr = [];
					//ifd["t"+tag+"-"+UTIF.tags[tag]] = arr;
					if(type== 1 || type==7) {  var no=(num<5 ? offset-4 : voff);  if(no+num>data.buffer.byteLength) num=data.buffer.byteLength-no;  arr = new Uint8Array(data.buffer, no, num);  }
					if(type== 2) {  var o0 = (num<5 ? offset-4 : voff), c=data[o0], len=Math.max(0, Math.min(num-1,data.length-o0));
									if(c<128 || len==0) arr.push( bin.readASCII(data, o0, len) );
									else      arr = new Uint8Array(data.buffer, o0, len);  }
					if(type== 3) {  for(var j=0; j<num; j++) arr.push(bin.readUshort(data, (num<3 ? offset-4 : voff)+2*j));  }
					if(type== 4 
					|| type==13) {  for(var j=0; j<num; j++) arr.push(bin.readUint  (data, (num<2 ? offset-4 : voff)+4*j));  }
					if(type== 5 || type==10) {  
						var ri = type==5 ? bin.readUint : bin.readInt;
						for(var j=0; j<num; j++) arr.push([ri(data, voff+j*8), ri(data,voff+j*8+4)]);  }
					if(type== 8) {  for(var j=0; j<num; j++) arr.push(bin.readShort (data, (num<3 ? offset-4 : voff)+2*j));  }
					if(type== 9) {  for(var j=0; j<num; j++) arr.push(bin.readInt   (data, (num<2 ? offset-4 : voff)+4*j));  }
					if(type==11) {  for(var j=0; j<num; j++) arr.push(bin.readFloat (data, voff+j*4));  }
					if(type==12) {  for(var j=0; j<num; j++) arr.push(bin.readDouble(data, voff+j*8));  }
					
					if(num!=0 && arr.length==0) {  log(tag, "unknown TIFF tag type: ", type, "num:",num);  if(i==0)return;  continue;  }
					if(prm.debug) log("   ".repeat(depth), tag, type, UTIF.tags[tag], arr);
					
					ifd["t"+tag] = arr;
					
					if(tag==330 && ifd["t272"] && ifd["t272"][0]=="DSLR-A100") ; 
					else if(tag==330 || tag==34665 || tag==34853 || (tag==50740 && bin.readUshort(data,bin.readUint(arr,0))<300  ) ||tag==61440) {
						var oarr = tag==50740 ? [bin.readUint(arr,0)] : arr;
						var subfd = [];
						for(var j=0; j<oarr.length; j++) UTIF._readIFD(bin, data, oarr[j], subfd, depth+1, prm);
						if(tag==  330) ifd.subIFD = subfd;
						if(tag==34665) ifd.exifIFD = subfd[0];
						if(tag==34853) ifd.gpsiIFD = subfd[0];  //console.log("gps", subfd[0]);  }
						if(tag==50740) ifd.dngPrvt = subfd[0];
						if(tag==61440) ifd.fujiIFD = subfd[0];
					}
					if(tag==37500 && prm.parseMN) {
						var mn = arr;
						//console.log(bin.readASCII(mn,0,mn.length), mn);
						if(bin.readASCII(mn,0,5)=="Nikon")  ifd.makerNote = UTIF["decode"](mn.slice(10).buffer)[0];
						else if(bin.readASCII(mn,0,5)=="OLYMP" || bin.readASCII(mn,0,9)=="OM SYSTEM") { // ???
							var inds = [8208,8224,8240,8256,8272];
							var subsub = [];  UTIF._readIFD(bin, mn, mn[1]==77 ? 16 : (mn[5]==85 ? 12 : 8), subsub, depth+1, prm);
							var obj = ifd.makerNote = subsub.pop();
							for(var j=0; j<inds.length; j++) {
								var k="t"+inds[j];  if(obj[k]==null) continue;
								UTIF._readIFD(bin, mn, obj[k][0], subsub, depth+1, prm);
								obj[k] = subsub.pop();
							}
							if(obj["t12288"]) {
								UTIF._readIFD(bin, obj["t12288"], 0, subsub, depth+1, prm);
								obj["t12288"]=subsub.pop();
							}
						}
						else if(bin.readUshort(data,voff)<300 && bin.readUshort(data,voff+4)<=12){
							var subsub=[];  UTIF._readIFD(bin, data, voff, subsub, depth+1, prm);
							ifd.makerNote = subsub[0];
						}
					}
				}
				ifds.push(ifd);
				if(prm.debug) log("   ".repeat(depth),"<<<---------------");
				return offset;
			};
			
			UTIF._writeIFD = function(bin, types, data, offset, ifd)
			{
				var keys = Object.keys(ifd), knum=keys.length;  if(ifd["exifIFD"]) knum--;  if(ifd["gpsiIFD"]) knum--;
				bin.writeUshort(data, offset, knum);  offset+=2;
			
				var eoff = offset + knum*12 + 4;
			
				for(var ki=0; ki<keys.length; ki++)
				{
					var key = keys[ki];  if(key=="t34665" || key=="t34853") continue;  
					if(key=="exifIFD") key="t34665";  if(key=="gpsiIFD") key="t34853";
					var tag = parseInt(key.slice(1)), type = types.main[tag];  if(type==null) type=types.rest[tag];		
					if(type==null || type==0) throw new Error("unknown type of tag: "+tag);
					//console.log(offset+":", tag, type, eoff);
					var val = ifd[key];  
					if(tag==34665) {
						var outp = UTIF._writeIFD(bin, types, data, eoff, ifd["exifIFD"]);
						val = [eoff];  eoff = outp[1];
					}
					if(tag==34853) {
						var outp = UTIF._writeIFD(bin, UTIF._types.gps, data, eoff, ifd["gpsiIFD"]);
						val = [eoff];  eoff = outp[1];
					}
					if(type==2) val=val[0]+"\u0000";  var num = val.length;
					bin.writeUshort(data, offset, tag );  offset+=2;
					bin.writeUshort(data, offset, type);  offset+=2;
					bin.writeUint  (data, offset, num );  offset+=4;
			
					var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;  //if(dlen<1) throw "e";
					var toff = offset;
					if(dlen>4) {  bin.writeUint(data, offset, eoff);  toff=eoff;  }
			
					if     (type== 1 || type==7) {  for(var i=0; i<num; i++) data[toff+i] = val[i];  }
					else if(type== 2) {  bin.writeASCII(data, toff, val);   }
					else if(type== 3) {  for(var i=0; i<num; i++) bin.writeUshort(data, toff+2*i, val[i]);    }
					else if(type== 4) {  for(var i=0; i<num; i++) bin.writeUint  (data, toff+4*i, val[i]);    }
					else if(type== 5 || type==10) {  
						var wr = type==5?bin.writeUint:bin.writeInt;
						for(var i=0; i<num; i++) {  
						var v=val[i],nu=v[0],de=v[1];  if(nu==null) throw "e";  wr(data, toff+8*i, nu);  wr(data, toff+8*i+4, de);  }   }
					else if(type== 9) {  for(var i=0; i<num; i++) bin.writeInt   (data, toff+4*i, val[i]);    }
					else if(type==12) {  for(var i=0; i<num; i++) bin.writeDouble(data, toff+8*i, val[i]);    }
					else throw type;
			
					if(dlen>4) {  dlen += (dlen&1);  eoff += dlen;  }
					offset += 4;
				}
				return [offset, eoff];
			};
			
			UTIF.toRGBA8 = function(out, scl)
			{
				function gamma(x) {  return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;  }
				
				
				var w = out.width, h = out.height, area = w*h, data = out.data;
				var img = new Uint8Array(area*4);
				//console.log(out);
				// 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK
				var intp = (out["t262"] ? out["t262"][0]: 2), bps = (out["t258"]?Math.min(32,out["t258"][0]):1);
				if(out["t262"]==null && bps==1) intp=0;
				
				var smpls = out["t277"]?out["t277"][0] : (out["t258"]?out["t258"].length : [1,1,3,1,1,4,3][intp]);
				var sfmt  = out["t339"]?out["t339"][0] : null;  if(intp==1 && bps==32 && sfmt!=3) throw "e";  // sample format
				var bpl = Math.ceil(smpls*bps*w/8);
				
				//log("interpretation: ", intp, "smpls", smpls, "bps", bps, "sample format",sfmt, out);
				
				if(intp==0)
				{
					scl = 1/256; // "Photopeatest.tif"
					for(var y=0; y<h; y++) {
						var off = y*bpl, io = y*w;
						if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))& 1;  img[qi]=img[qi+1]=img[qi+2]=( 1-px)*255;  img[qi+3]=255;    }
						if(bps== 4) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>1)])>>(4-4*(i&1)))&15;  img[qi]=img[qi+1]=img[qi+2]=(15-px)* 17;  img[qi+3]=255;    }
						if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i];  img[qi]=img[qi+1]=img[qi+2]=255-px;  img[qi+3]=255;    }
						if(bps==16) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=off+(2*i), px=(data[o+1]<<8)|data[o];  img[qi]=img[qi+1]=img[qi+2]= Math.min(255,255-(~~(px*scl)));  img[qi+3]=255;    } // ladoga.tif
					}
				}
				else if(intp==1)
				{
					if(scl==null) scl=1/256;
					var f32 = ((data.length&3)==0) ? new Float32Array(data.buffer) : null;
					
					for(var y=0; y<h; y++) {
						var off = y*bpl, io = y*w;
						if(bps== 1) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>3)])>>(7-  (i&7)))&1;   img[qi]=img[qi+1]=img[qi+2]=(px)*255;  img[qi+3]=255;    }
						if(bps== 2) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=((data[off+(i>>2)])>>(6-2*(i&3)))&3;   img[qi]=img[qi+1]=img[qi+2]=(px)* 85;  img[qi+3]=255;    }
						if(bps== 8) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, px=data[off+i*smpls];  img[qi]=img[qi+1]=img[qi+2]=    px;  img[qi+3]=255;    }
						if(bps==16) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=off+(2*i), px=(data[o+1]<<8)|data[o];  img[qi]=img[qi+1]=img[qi+2]= Math.min(255,~~(px*scl));  img[qi+3]=255;    } // ladoga.tif
						if(bps==32) for(var i=0; i<w; i++) {  var qi=(io+i)<<2, o=(off>>>2)+i, px=f32[o];  img[qi]=img[qi+1]=img[qi+2]= ~~(0.5+255*px);  img[qi+3]=255;    }
					}
				}
				else if(intp==2)
				{
					if(bps== 8) 
					{
						if(smpls==1) for(var i=0; i<area; i++) {  img[4*i]=img[4*i+1]=img[4*i+2]=data[i];  img[4*i+3]=255;  }
						if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3    ;  img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  img[qi+3]=255;    }
						if(smpls>=4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*smpls;  img[qi]=data[ti];  img[qi+1]=data[ti+1];  img[qi+2]=data[ti+2];  img[qi+3]=data[ti+3];    }
					}
					else if(bps==16){  // 3x 16-bit channel
						if(smpls==4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*8+1;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=data[ti+6];    }
						if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6+1;  img[qi]=data[ti];  img[qi+1]=data[ti+2];  img[qi+2]=data[ti+4];  img[qi+3]=255;           }
					}
					else if(bps==32){
						var ndt = new Float32Array(data.buffer);  // t339 is [3,3,3]
						// check the endianity
						var min = 0;  for(var i=0; i<ndt.length; i++) min = Math.min(min,ndt[i]);
						if(min<0) for(var i=0; i<data.length; i+=4) {  var t=data[i];  data[i]=data[i+3];  data[i+3]=t;  t=data[i+1];  data[i+1]=data[i+2];  data[i+2]=t;  }
						// gamma correction
						var pmap = [];  for(var i=0; i<65536; i++) pmap.push(gamma(i/65535));
						for(var i=0; i<ndt.length; i++) {  var cv = Math.max(0, Math.min(1, ndt[i]));  ndt[i] = pmap[~~(0.5+cv*65535)];  }
						
						if(smpls==3) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  
							img[qi]=~~(0.5+ndt[ti]*255);  img[qi+1]=~~(0.5+ndt[ti+1]*255);  img[qi+2]=~~(0.5+ndt[ti+2]*255);  img[qi+3]=255;           }
						else if(smpls==4) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*4;  
							img[qi]=~~(0.5+ndt[ti]*255);  img[qi+1]=~~(0.5+ndt[ti+1]*255);  img[qi+2]=~~(0.5+ndt[ti+2]*255);  img[qi+3]=~~(0.5+ndt[ti+3]*255);           }
						else throw smpls;
					}
					else throw bps;
				}
				else if(intp==3)
				{
					var map = out["t320"];
					var cn = 1<<bps;
					
					var nexta = bps==8 && smpls>1 && out["t338"] && out["t338"][0]!=0;
					
					for(var y=0; y<h; y++) 
						for(var x=0; x<w; x++) {  
							var i = y*w+x;
							var qi=i<<2, mi=0;
							var dof = y*bpl;
							if(bps==1) mi=(data[dof+(x>>>3)]>>>(7-  (x&7)))& 1;
							else if(bps==2) mi=(data[dof+(x>>>2)]>>>(6-2*(x&3)))& 3;
							else if(bps==4) mi=(data[dof+(x>>>1)]>>>(4-4*(x&1)))&15;
							else if(bps==8) mi= data[dof+x*smpls]; 
							else throw bps;
							img[qi]=(map[mi]>>8);  img[qi+1]=(map[cn+mi]>>8);  img[qi+2]=(map[cn+cn+mi]>>8);  img[qi+3]=nexta ? data[dof+x*smpls+1] : 255;   
						}
				}
				else if(intp==5) 
				{
					var gotAlpha = smpls>4 ? 1 : 0;
					for(var i=0; i<area; i++) {
						var qi=i<<2, si=i*smpls;  
						
						if(window.UDOC) {
							var C=data[si], M=data[si+1], Y=data[si+2], K=data[si+3];
							var c = UDOC.C.cmykToRgb([C*(1/255), M*(1/255), Y*(1/255), K*(1/255)]);
							img[qi] = ~~(0.5+255*c[0]);  img[qi+1] = ~~(0.5+255*c[1]);  img[qi+2] = ~~(0.5+255*c[2]);
						}
						else {
							var C=255-data[si], M=255-data[si+1], Y=255-data[si+2], K=(255-data[si+3])*(1/255);
							img[qi]=~~(C*K+0.5);  img[qi+1]=~~(M*K+0.5);  img[qi+2]=~~(Y*K+0.5);
						}
						
						img[qi+3]=255*(1-gotAlpha)+data[si+4]*gotAlpha;
					}
				}
				else if(intp==6 && out["t278"]) {  // only for DSC_1538.TIF
					var rps = out["t278"][0];
					for(var y=0; y<h; y+=rps) {
						var i=(y*w), len = rps*w;
						
						for(var j=0; j<len; j++) {
							var qi = 4*(i+j), si = 3*i+4*(j>>>1);
							var Y = data[si+(j&1)], Cb=data[si+2]-128, Cr=data[si+3]-128;
							
							var r = Y + ( (Cr >> 2) + (Cr >> 3) + (Cr >> 5) ) ;
							var g = Y - ( (Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ( (Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5)) ;
							var b = Y + ( Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6)) ;
							
							img[qi  ]=Math.max(0,Math.min(255,r));
							img[qi+1]=Math.max(0,Math.min(255,g));
							img[qi+2]=Math.max(0,Math.min(255,b));
							img[qi+3]=255;
						}
					}
				}
				else if(intp==32845) {
					
					for(var y=0; y<h; y++)
						for(var x=0; x<w; x++) {
							var si = (y*w+x)*6, qi=(y*w+x)*4;
							var L =  (data[si+1]<<8) | data[si];
							
							var L = Math.pow(2, (L + 0.5) / 256 - 64);
							var u = (data[si+3] + 0.5) / 410;
							var v = (data[si+5] + 0.5) / 410;
							
							// Luv to xyY
							var sX = (9 * u) / (6 * u - 16 * v + 12);
							var sY = (4 * v) / (6 * u - 16 * v + 12);
							var bY = L;  
							
							// xyY to XYZ
							var X = (sX*bY)/sY, Y = bY, Z = (1-sX-sY)*bY/sY;  
							
							
							var r =  2.690*X -1.276*Y -0.414*Z;
							var g = -1.022*X +1.978*Y +0.044*Z;
							var b =  0.061*X -0.224*Y +1.163*Z;
							
							img[qi  ] = gamma(Math.min(r,1))*255;
							img[qi+1] = gamma(Math.min(g,1))*255;
							img[qi+2] = gamma(Math.min(b,1))*255;
							img[qi+3] = 255;
						}
				}
				else log("Unknown Photometric interpretation: "+intp);
				return img;
			};
			
			UTIF.replaceIMG = function(imgs)
			{
				if(imgs==null) imgs = document.getElementsByTagName("img");
				var sufs = ["tif","tiff","dng","cr2","nef"];
				for (var i=0; i<imgs.length; i++)
				{
					var img=imgs[i], src=img.getAttribute("src");  if(src==null) continue;
					var suff=src.split(".").pop().toLowerCase();
					if(sufs.indexOf(suff)==-1) continue;
					var xhr = new XMLHttpRequest();  UTIF._xhrs.push(xhr);  UTIF._imgs.push(img);
					xhr.open("GET", src);  xhr.responseType = "arraybuffer";
					xhr.onload = UTIF._imgLoaded;   xhr.send();
				}
			};
			
			UTIF._xhrs = [];  UTIF._imgs = [];
			UTIF._imgLoaded = function(e) {
				var ind = UTIF._xhrs.indexOf(e.target), img = UTIF._imgs[ind];
				UTIF._xhrs.splice(ind,1);  UTIF._imgs.splice(ind,1);
				
				img.setAttribute("src",UTIF.bufferToURI(e.target.response));
			};
			
			UTIF.bufferToURI = function(buff) {
				var ifds = UTIF.decode(buff);  //console.log(ifds);
				var vsns = ifds, ma=0, page=vsns[0];  if(ifds[0].subIFD) vsns = vsns.concat(ifds[0].subIFD);
				for(var i=0; i<vsns.length; i++) {
					var img = vsns[i];
					if(img["t258"]==null || img["t258"].length<3) continue;
					var ar = img["t256"]*img["t257"];
					if(ar>ma) {  ma=ar;  page=img;  }
				}
				UTIF.decodeImage(buff, page, ifds);
				var rgba = UTIF.toRGBA8(page), w=page.width, h=page.height;
				
				var cnv = document.createElement("canvas");  cnv.width=w;  cnv.height=h;
				var ctx = cnv.getContext("2d");
				var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer),w,h);
				ctx.putImageData(imgd,0,0);
				return cnv.toDataURL();
			};
			
			
			UTIF._binBE =
			{
				nextZero   : function(data, o) {  while(data[o]!=0) o++;  return o;  },
				readUshort : function(buff, p) {  return (buff[p]<< 8) |  buff[p+1];  },
				readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+1];  a[1]=buff[p+0];							        return UTIF._binBE. i16[0];  },
				readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE. i32[0];  },
				readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+3];  a[1]=buff[p+2];  a[2]=buff[p+1];  a[3]=buff[p+0];  return UTIF._binBE.ui32[0];  },
				readASCII  : function(buff, p, l) {  var s = "";   for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);   return s; },
				readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+3-i];  return UTIF._binBE.fl32[0];  },
				readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+7-i];  return UTIF._binBE.fl64[0];  },
			
				writeUshort: function(buff, p, n) {  buff[p] = (n>> 8)&255;  buff[p+1] =  n&255;  },
				writeInt   : function(buff, p, n) {  var a=UTIF._binBE.ui8;  UTIF._binBE.i32[0]=n;  buff[p+3]=a[0];  buff[p+2]=a[1];  buff[p+1]=a[2];  buff[p+0]=a[3];  },
				writeUint  : function(buff, p, n) {  buff[p] = (n>>24)&255;  buff[p+1] = (n>>16)&255;  buff[p+2] = (n>>8)&255;  buff[p+3] = (n>>0)&255;  },
				writeASCII : function(buff, p, s) {  for(var i = 0; i < s.length; i++)  buff[p+i] = s.charCodeAt(i);  },
				writeDouble: function(buff, p, n)
				{
					UTIF._binBE.fl64[0] = n;
					for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];
				}
			};
			UTIF._binBE.ui8  = new Uint8Array  (8);
			UTIF._binBE.i16  = new Int16Array  (UTIF._binBE.ui8.buffer);
			UTIF._binBE.i32  = new Int32Array  (UTIF._binBE.ui8.buffer);
			UTIF._binBE.ui32 = new Uint32Array (UTIF._binBE.ui8.buffer);
			UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer);
			UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer);
			
			UTIF._binLE =
			{
				nextZero   : UTIF._binBE.nextZero,
				readUshort : function(buff, p) {  return (buff[p+1]<< 8) |  buff[p];  },
				readShort  : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];							        return UTIF._binBE. i16[0];  },
				readInt    : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE. i32[0];  },
				readUint   : function(buff, p) {  var a=UTIF._binBE.ui8;  a[0]=buff[p+0];  a[1]=buff[p+1];  a[2]=buff[p+2];  a[3]=buff[p+3];  return UTIF._binBE.ui32[0];  },
				readASCII  : UTIF._binBE.readASCII,
				readFloat  : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<4;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl32[0];  },
				readDouble : function(buff, p) {  var a=UTIF._binBE.ui8;  for(var i=0;i<8;i++) a[i]=buff[p+  i];  return UTIF._binBE.fl64[0];  },
				
				writeUshort: function(buff, p, n) {  buff[p] = (n)&255;  buff[p+1] =  (n>>8)&255;  },
				writeInt   : function(buff, p, n) {  var a=UTIF._binBE.ui8;  UTIF._binBE.i32[0]=n;  buff[p+0]=a[0];  buff[p+1]=a[1];  buff[p+2]=a[2];  buff[p+3]=a[3];  },
				writeUint  : function(buff, p, n) {  buff[p] = (n>>>0)&255;  buff[p+1] = (n>>>8)&255;  buff[p+2] = (n>>>16)&255;  buff[p+3] = (n>>>24)&255;  },
				writeASCII : UTIF._binBE.writeASCII
			};
			UTIF._copyTile = function(tb, tw, th, b, w, h, xoff, yoff)
			{
				//log("copyTile", tw, th,  w, h, xoff, yoff);
				var xlim = Math.min(tw, w-xoff);
				var ylim = Math.min(th, h-yoff);
				for(var y=0; y<ylim; y++)
				{
					var tof = (yoff+y)*w+xoff;
					var sof = y*tw;
					for(var x=0; x<xlim; x++) b[tof+x] = tb[sof+x];
				}
			};
			
			UTIF.LosslessJpegDecode =function(){var b,O;function l(){return b[O++]}function m(){return b[O++]<<8|b[O++]}function a0(h){var V=l(),I=[0,0,0,255],f=[],G=8;
			for(var w=0;w<16;w++)f[w]=l();for(var w=0;w<16;w++){for(var x=0;x<f[w];x++){var T=z(I,0,w+1,1);I[T+3]=l();}}var E=new Uint8Array(1<<G);
			h[V]=[new Uint8Array(I),E];for(var w=0;w<1<<G;w++){var s=G,_=w,Y=0,F=0;while(I[Y+3]==255&&s!=0){F=_>>--s&1;
			Y=I[Y+F];}E[w]=Y;}}function z(h,V,I,f){if(h[V+3]!=255)return 0;if(I==0)return V;for(var w=0;w<2;w++){if(h[V+w]==0){h[V+w]=h.length;
			h.push(0,0,f,255);}var x=z(h,h[V+w],I-1,f+1);if(x!=0)return x}return 0}function i(h){var V=h.b,I=h.f;
			while(V<25&&h.a<h.d){var f=h.data[h.a++];if(f==255&&!h.c)h.a++;I=I<<8|f;V+=8;}if(V<0)throw "e";h.b=V;h.f=I;}function H(h,V){if(V.b<h)i(V);
			return V.f>>(V.b-=h)&65535>>16-h}function g(h,V){var I=h[0],f=0,w=255,x=0;if(V.b<16)i(V);var T=V.f>>V.b-8&255;
			f=h[1][T];w=I[f+3];V.b-=I[f+2];while(w==255){x=V.f>>--V.b&1;f=I[f+x];w=I[f+3];}return w}function P(h,V){if(h<32768>>16-V)h+=-(1<<V)+1;
			return h}function a2(h,V){var I=g(h,V);if(I==0)return 0;if(I==16)return  -32768;var f=H(I,V);return P(f,I)}function X(h,V,I,f,w,x){var T=0;
			for(var G=0;G<x;G++){var s=G*V;for(var _=0;_<V;_+=w){T++;for(var Y=0;Y<w;Y++)h[s+_+Y]=a2(f[Y],I);}if(I.e!=0&&T%I.e==0&&G!=0){var F=I.a,t=I.data;
			while(t[F]!=255||!(208<=t[F+1]&&t[F+1]<=215))F--;I.a=F+2;I.f=0;I.b=0;}}}function o(h,V){return P(H(h,V),h)}function a1(h,V,I,f,w){var x=b.length-O;
			for(var T=0;T<x;T+=4){var G=b[O+T];b[O+T]=b[O+T+3];b[O+T+3]=G;var G=b[O+T+1];b[O+T+1]=b[O+T+2];b[O+T+2]=G;}for(var E=0;
			E<w;E++){var s=32768,_=32768;for(var Y=0;Y<V;Y+=2){var F=g(f,I),t=g(f,I);if(F!=0)s+=o(F,I);if(t!=0)_+=o(t,I);
			h[E*V+Y]=s&65535;h[E*V+Y+1]=_&65535;}}}function C(h){b=h;O=0;if(m()!=65496)throw "e";var V=[],I=0,f=0,w=0,x=[],T=[],G=[],E=0,s=0,_=0;
			while(true){var Y=m();if(Y==65535){O--;continue}var F=m();if(Y==65475){f=l();s=m();_=m();E=l();for(var t=0;
			t<E;t++){var a=l(),J=l(),r=l();if(r!=0)throw "e";V[a]=[t,J>>4,J&15];}}else if(Y==65476){var a3=O+F-2;while(O<a3)a0(T);}else if(Y==65498){O++;
			for(var t=0;t<E;t++){var a5=l(),v=V[a5];G[v[0]]=T[l()>>>4];x[v[0]]=v.slice(1);}I=l();O+=2;break}else if(Y==65501){w=m();}else {O+=F-2;}}var a4=f>8?Uint16Array:Uint8Array,$=new a4(s*_*E),M={b:0,f:0,c:I==8,a:O,data:b,d:b.length,e:w};
			if(M.c)a1($,_*E,M,G[0],s);else {var c=[],p=0,D=0;for(var t=0;t<E;t++){var N=x[t],S=N[0],K=N[1];if(S>p)p=S;
			if(K>D)D=K;c.push(S*K);}if(p!=1||D!=1){if(E!=3||c[1]!=1||c[2]!=1)throw "e";if(p!=2||D!=1&&D!=2)throw "e";
			var u=[],Z=0;for(var t=0;t<E;t++){for(var R=0;R<c[t];R++)u.push(G[t]);Z+=c[t];}var B=_/p,e=s/D,d=B*e;
			X($,B*Z,M,u,Z,e);j($,I,B,e,Z-2,Z,Z,f);var A=new Uint16Array(d*c[0]);if(p==2&&D==2){for(var t=0;t<d;t++){A[4*t]=$[6*t];
			A[4*t+1]=$[6*t+1];A[4*t+2]=$[6*t+2];A[4*t+3]=$[6*t+3];}j(A,I,B*4,e,0,1,1,f);for(var t=0;t<d;t++){$[6*t]=A[4*t];
			$[6*t+1]=A[4*t+1];$[6*t+2]=A[4*t+2];$[6*t+3]=A[4*t+3];}}if(p==2&&D==1){for(var t=0;t<d;t++){A[2*t]=$[4*t];
			A[2*t+1]=$[4*t+1];}j(A,I,B*2,e,0,1,1,f);for(var t=0;t<d;t++){$[4*t]=A[2*t];$[4*t+1]=A[2*t+1];}}var n=$.slice(0);
			for(var K=0;K<s;K++){if(D==2)for(var S=0;S<_;S++){var q=(K*_+S)*E,k=((K>>>1)*B+(S>>>1))*Z,y=(K&1)*2+(S&1);
			$[q]=n[k+y];$[q+1]=n[k+4];$[q+2]=n[k+5];}else for(var S=0;S<_;S++){var q=(K*_+S)*E,k=(K*B+(S>>>1))*Z,y=S&1;
			$[q]=n[k+y];$[q+1]=n[k+2];$[q+2]=n[k+3];}}}else {X($,_*E,M,G,E,s);if(w==0)j($,I,_,s,0,E,E,f);else {var U=Math.floor(w/_);
			for(var K=0;K<s;K+=U){var L=$.slice(K*_*E,(K+U)*_*E);j(L,I,_,U,0,E,E,f);$.set(L,K*_*E);}}}}return $}function j(h,V,I,f,w,x,G,E){var s=I*G;
			for(var _=w;_<x;_++)h[_]+=1<<E-1;for(var Y=G;Y<s;Y+=G)for(var _=w;_<x;_++)h[Y+_]+=h[Y+_-G];for(var F=1;
			F<f;F++){var t=F*s;for(var _=w;_<x;_++)h[t+_]+=h[t+_-s];for(var Y=G;Y<s;Y+=G){for(var _=w;_<x;_++){var a=t+Y+_,J=a-s,r=h[a-G],Q=0;
			if(V==0)Q=0;else if(V==1)Q=r;else if(V==2)Q=h[J];else if(V==3)Q=h[J-G];else if(V==4)Q=r+(h[J]-h[J-G]);
			else if(V==5)Q=r+(h[J]-h[J-G]>>>1);else if(V==6)Q=h[J]+(r-h[J-G]>>>1);else if(V==7)Q=r+h[J]>>>1;else throw V;
			h[a]+=Q;}}}}return C}();
			
			
			(function(){var G=0,F=1,i=2,b=3,J=4,N=5,E=6,s=7,c=8,T=9,a3=10,f=11,q=12,M=13,m=14,x=15,L=16,$=17,p=18;
			function a5(t){var Z=UTIF._binBE.readUshort,u={b:Z(t,0),i:t[2],C:t[3],u:t[4],q:Z(t,5),k:Z(t,7),e:Z(t,9),l:Z(t,11),s:t[13],d:Z(t,14)};
			if(u.b!=18771||u.i>1||u.q<6||u.q%6||u.e<768||u.e%24||u.l!=768||u.k<u.l||u.k%u.l||u.k-u.e>=u.l||u.s>16||u.s!=u.k/u.l||u.s!=Math.ceil(u.e/u.l)||u.d!=u.q/6||u.u!=12&&u.u!=14&&u.u!=16||u.C!=16&&u.C!=0){throw "Invalid data"}if(u.i==0){throw "Not implemented. We need this file!"}u.h=u.C==16;
			u.m=(u.h?u.l*2/3:u.l>>>1)|0;u.A=u.m+2;u.f=64;u.g=(1<<u.u)-1;u.n=4*u.u;return u}function a7(t,Z){var u=new Array(Z.s),e=4*Z.s,Q=16+e;
			if(e&12)Q+=16-(e&12);for(var V=0,O=16;V<Z.s;O+=4){var o=UTIF._binBE.readUint(t,O);u[V]=t.slice(Q,Q+o);u[V].j=0;u[V].a=0;
			Q+=o;V++;}if(Q!=t.length)throw "Invalid data";return u}function a6(t,Z){for(var u=-Z[4],e=0;u<=Z[4];e++,u++){t[e]=u<=-276?-4:u<=-67?-3:u<=-18?-2:u<-0?-1:u<=Z[0]?0:u<Z[1]?1:u<Z[2]?2:u<Z[3]?3:4;}}function a1(t,Z,u){var e=[Z,3*Z+18,5*Z+67,7*Z+276,u];
			t.o=Z;t.w=(e[4]+2*Z)/(2*Z+1)+1|0;t.v=Math.ceil(Math.log2(t.w));t.t=9;a6(t.c,e);}function a2(t){var Z={c:new Int8Array(2<<t.u)};
			a1(Z,0,t.g);return Z}function D(t){var Z=[[],[],[]],u=Math.max(2,t.w+32>>>6);for(var e=0;e<3;e++){for(var Q=0;
			Q<41;Q++){Z[e][Q]=[u,1];}}return Z}function a4(t){for(var Z=-1,u=0;!u;Z++){u=t[t.j]>>>7-t.a&1;t.a++;t.a&=7;
			if(!t.a)t.j++;}return Z}function K(t,Z){var u=0,e=8-t.a;t.j;t.a;if(Z){if(Z>=e){do{u<<=e;Z-=e;u|=t[t.j]&(1<<e)-1;
			t.j++;e=8;}while(Z>=8)}if(Z){u<<=Z;e-=Z;u|=t[t.j]>>>e&(1<<Z)-1;}t.a=8-e;}return u}function a0(t,Z){var u=0;
			if(Z<t){while(u<=14&&Z<<++u<t);}return u}function r(t,Z,u,e,Q,V,O,o){if(o==null)o=0;var X=V+1,k=X%2,a=0,l,R,w=e[Q],S=e[Q-1],H=e[Q-2][X],g=S[X-1],Y=S[X],P=S[X+1],A=w[X-1],v=w[X+1],y=Math.abs,d,C,n,h;
			if(k){d=y(P-Y);C=y(H-Y);n=y(g-Y);}if(k){h=d>n&&C<d?H+g:d<n&&C<n?H+P:P+g;h=h+2*Y>>>2;if(o){w[X]=h;return}l=Z.t*Z.c[t.g+Y-H]+Z.c[t.g+g-Y];}else {h=Y>g&&Y>P||Y<g&&Y<P?v+A+2*Y>>>2:A+v>>>1;
			l=Z.t*Z.c[t.g+Y-g]+Z.c[t.g+g-A];}R=y(l);var W=a4(u);if(W<t.n-Z.v-1){var z=a0(O[R][0],O[R][1]);a=K(u,z)+(W<<z);}else {a=K(u,Z.v)+1;}a=a&1?-1-(a>>>1):a>>>1;
			O[R][0]+=y(a);if(O[R][1]==t.f){O[R][0]>>>=1;O[R][1]>>>=1;}O[R][1]++;h=l<0?h-a:h+a;if(t.i){if(h<0)h+=Z.w;
			else if(h>t.g)h-=Z.w;}w[X]=h>=0?Math.min(h,t.g):0;}function U(t,Z,u){var e=t[0].length;for(var Q=Z;Q<=u;
			Q++){t[Q][0]=t[Q-1][1];t[Q][e-1]=t[Q-1][e-2];}}function B(t){U(t,s,q);U(t,i,J);U(t,x,$);}function _(t,Z,u,e,Q,V,O,o,X,k,j,I,a){var l=0,R=1,w=Q<M&&Q>J;
			while(R<t.m){if(l<t.m){r(t,Z,u,e,Q,l,O[X],t.h&&(w&&k||!w&&(j||(l&I)==a)));r(t,Z,u,e,V,l,O[X],t.h&&(!w&&k||w&&(j||(l&I)==a)));
			l+=2;}if(l>8){r(t,Z,u,e,Q,R,o[X]);r(t,Z,u,e,V,R,o[X]);R+=2;}}B(e);}function a8(t,Z,u,e,Q,V){_(t,Z,u,e,i,s,Q,V,0,0,1,0,8);
			_(t,Z,u,e,c,x,Q,V,1,0,1,0,8);_(t,Z,u,e,b,T,Q,V,2,1,0,3,0);_(t,Z,u,e,a3,L,Q,V,0,0,0,3,2);_(t,Z,u,e,J,f,Q,V,1,0,0,3,2);
			_(t,Z,u,e,q,$,Q,V,2,1,0,3,0);}function a9(t,Z,u,e,Q,V){var O=V.length,o=t.l;if(Q+1==t.s)o=t.e-Q*t.l;var X=6*t.e*e+Q*t.l;
			for(var k=0;k<6;k++){for(var j=0;j<o;j++){var I=V[k%O][j%O],a;if(I==0){a=i+(k>>>1);}else if(I==2){a=x+(k>>>1);}else {a=s+k;}var l=t.h?(j*2/3&2147483646|j%3&1)+(j%3>>>1):j>>>1;
			Z[X+j]=u[a][l+1];}X+=t.e;}}UTIF._decompressRAF=function(t,Z){var u=a5(t),e=a7(t,u),Q=a2(u),V=new Int16Array(u.e*u.q);
			if(Z==null){Z=u.h?[[1,1,0,1,1,2],[1,1,2,1,1,0],[2,0,1,0,2,1],[1,1,2,1,1,0],[1,1,0,1,1,2],[0,2,1,2,0,1]]:[[0,1],[3,2]];}var O=[[G,b],[F,J],[N,f],[E,q],[M,L],[m,$]],o=[];
			for(var X=0;X<p;X++){o[X]=new Uint16Array(u.A);}for(var k=0;k<u.s;k++){var j=D(Q),I=D(Q);for(var X=0;
			X<p;X++){for(var a=0;a<u.A;a++){o[X][a]=0;}}for(var l=0;l<u.d;l++){a8(u,Q,e[k],o,j,I);for(var X=0;X<6;
			X++){for(var a=0;a<u.A;a++){o[O[X][0]][a]=o[O[X][1]][a];}}a9(u,V,o,l,k,Z);for(var X=i;X<p;X++){if([N,E,M,m].indexOf(X)==-1){for(var a=0;
			a<u.A;a++){o[X][a]=0;}}}B(o);}}return V};}());
			
			
			
			})(UTIF, pako);
			})(); 
	} (UTIF));
	return UTIF.exports;
}

var UTIFExports = requireUTIF();
var utif = /*@__PURE__*/getDefaultExportFromCjs(UTIFExports);

function getDimensionValue(dimension) {
    if (typeof dimension === "number") {
        return dimension;
    }
    if (dimension instanceof Uint8Array) {
        return dimension[0];
    }
    if (typeof dimension[0] === "string") {
        return parseInt(dimension[0]);
    }
    return dimension[0];
}
function tiff() {
    return {
        mime: "image/tiff",
        encode: (bitmap) => {
            const tiff = utif.encodeImage(bitmap.data, bitmap.width, bitmap.height);
            return Buffer.from(tiff);
        },
        decode: (data) => {
            const ifds = utif.decode(data);
            const page = ifds[0];
            if (!page) {
                throw new Error("No page found in TIFF");
            }
            if (!page.t256) {
                throw new Error("No image width found in TIFF");
            }
            if (!page.t257) {
                throw new Error("No image height found in TIFF");
            }
            ifds.forEach((ifd) => {
                utif.decodeImage(data, ifd);
            });
            const rgba = utif.toRGBA8(page);
            return {
                data: Buffer.from(rgba),
                width: getDimensionValue(page.t256),
                height: getDimensionValue(page.t257),
            };
        },
    };
}

var util$8;
(function (util) {
    util.assertEqual = (_) => { };
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util$8 || (util$8 = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$8.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util$8.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util$8.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                const firstEl = sub.path[0];
                fieldErrors[firstEl] = fieldErrors[firstEl] || [];
                fieldErrors[firstEl].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$8.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util$8.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util$8.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util$8.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util$8.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "bigint")
                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util$8.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap, // contextual error map is first priority
            ctx.schemaErrorMap, // then schema-bound map if available
            overrideMap, // then global override map
            overrideMap === errorMap ? undefined : errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    // biome-ignore lint:
    errorUtil.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message ?? ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: message ?? required_error ?? ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap,
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return isValid(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if (err?.message?.toLowerCase()?.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true,
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        if (!header)
            return false;
        // Convert base64url to base64
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if ("typ" in decoded && decoded?.typ !== "JWT")
            return false;
        if (!decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$8.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...errorUtil.errToObj(options?.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...errorUtil.errToObj(options?.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options?.position,
            ...errorUtil.errToObj(options?.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util$8.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$8.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || (ch.kind === "multipleOf" && util$8.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$8.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util$8.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util$8.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: errorUtil.errToObj(message).message ?? defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        for (const key of util$8.objectKeys(mask)) {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        for (const key of util$8.objectKeys(this.shape)) {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        for (const key of util$8.objectKeys(this.shape)) {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        for (const key of util$8.objectKeys(this.shape)) {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util$8.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util$8.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util$8.objectKeys(b);
        const sharedKeys = util$8.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util$8.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!this._cache) {
            this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util$8.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util$8.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util$8.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!this._cache) {
            this._cache = new Set(util$8.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
            const expectedValues = util$8.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                    if (!isValid(base))
                        return INVALID;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                        status: status.value,
                        value: result,
                    }));
                });
            }
        }
        util$8.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
}
function custom(check, _params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            const r = check(data);
            if (r instanceof Promise) {
                return r.then((r) => {
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = params.fatal ?? fatal ?? true;
                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
                    }
                });
            }
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
            return;
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BRAND: BRAND,
    DIRTY: DIRTY,
    EMPTY_PATH: EMPTY_PATH,
    INVALID: INVALID,
    NEVER: NEVER,
    OK: OK,
    ParseStatus: ParseStatus,
    Schema: ZodType,
    ZodAny: ZodAny,
    ZodArray: ZodArray,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodBranded: ZodBranded,
    ZodCatch: ZodCatch,
    ZodDate: ZodDate,
    ZodDefault: ZodDefault,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodEffects: ZodEffects,
    ZodEnum: ZodEnum,
    ZodError: ZodError,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    ZodFunction: ZodFunction,
    ZodIntersection: ZodIntersection,
    ZodIssueCode: ZodIssueCode,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodMap: ZodMap,
    ZodNaN: ZodNaN,
    ZodNativeEnum: ZodNativeEnum,
    ZodNever: ZodNever,
    ZodNull: ZodNull,
    ZodNullable: ZodNullable,
    ZodNumber: ZodNumber,
    ZodObject: ZodObject,
    ZodOptional: ZodOptional,
    ZodParsedType: ZodParsedType,
    ZodPipeline: ZodPipeline,
    ZodPromise: ZodPromise,
    ZodReadonly: ZodReadonly,
    ZodRecord: ZodRecord,
    ZodSchema: ZodType,
    ZodSet: ZodSet,
    ZodString: ZodString,
    ZodSymbol: ZodSymbol,
    ZodTransformer: ZodEffects,
    ZodTuple: ZodTuple,
    ZodType: ZodType,
    ZodUndefined: ZodUndefined,
    ZodUnion: ZodUnion,
    ZodUnknown: ZodUnknown,
    ZodVoid: ZodVoid,
    addIssueToContext: addIssueToContext,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    coerce: coerce,
    custom: custom,
    date: dateType,
    datetimeRegex: datetimeRegex,
    defaultErrorMap: errorMap,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    getErrorMap: getErrorMap,
    getParsedType: getParsedType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    isAborted: isAborted,
    isAsync: isAsync,
    isDirty: isDirty,
    isValid: isValid,
    late: late,
    lazy: lazyType,
    literal: literalType,
    makeIssue: makeIssue,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    get objectUtil () { return objectUtil; },
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    quotelessJson: quotelessJson,
    record: recordType,
    set: setType,
    setErrorMap: setErrorMap,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    get util () { return util$8; },
    void: voidType
});

var Edge;
(function (Edge) {
    Edge[Edge["EXTEND"] = 1] = "EXTEND";
    Edge[Edge["WRAP"] = 2] = "WRAP";
    Edge[Edge["CROP"] = 3] = "CROP";
})(Edge || (Edge = {}));
const JimpClassSchema = objectType({
    bitmap: objectType({
        data: unionType([instanceOfType(Buffer), instanceOfType(Uint8Array)]),
        width: numberType(),
        height: numberType(),
    }),
});

const BlitOptionsSchemaComplex = objectType({
    src: JimpClassSchema,
    /** the x position to blit the image */
    x: numberType().optional(),
    /** the y position to blit the image */
    y: numberType().optional(),
    /** the x position from which to crop the source image */
    srcX: numberType().optional(),
    /** the y position from which to crop the source image */
    srcY: numberType().optional(),
    /** the width to which to crop the source image */
    srcW: numberType().optional(),
    /** the height to which to crop the source image */
    srcH: numberType().optional(),
});
const BlitOptionsSchema = unionType([JimpClassSchema, BlitOptionsSchemaComplex]);
const methods$h = {
    /**
     * Short for "bit-block transfer".
     * It involves the transfer of a block of pixel data from one area of a computer's memory to another area, typically for the purpose of rendering images on the screen or manipulating them in various ways.
     * It's a fundamental operation in computer graphics utilized in various applications, from operating systems to video games.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const parrot = await Jimp.read("test/party-parrot.png");
     *
     * image.blit({ src: parrot, x: 10, y: 10 });
     * ```
     */
    blit(image, options) {
        const parsed = BlitOptionsSchema.parse(options);
        let { 
        // eslint-disable-next-line prefer-const
        src, x = 0, y = 0, srcX = 0, srcY = 0, srcW = src.bitmap.width, srcH = src.bitmap.height, } = "bitmap" in parsed ? { src: parsed } : parsed;
        if (!("bitmap" in src)) {
            throw new Error("The source must be a Jimp image");
        }
        if (typeof x !== "number" || typeof y !== "number") {
            throw new Error("x and y must be numbers");
        }
        // round input
        x = Math.round(x);
        y = Math.round(y);
        // round input
        srcX = Math.round(srcX);
        srcY = Math.round(srcY);
        srcW = Math.round(srcW);
        srcH = Math.round(srcH);
        const maxWidth = image.bitmap.width;
        const maxHeight = image.bitmap.height;
        scan(src, srcX, srcY, srcW, srcH, function (sx, sy, idx) {
            const xOffset = x + sx - srcX;
            const yOffset = y + sy - srcY;
            if (xOffset >= 0 &&
                yOffset >= 0 &&
                maxWidth - xOffset > 0 &&
                maxHeight - yOffset > 0) {
                const dstIdx = image.getPixelIndex(xOffset, yOffset);
                const srcColor = {
                    r: src.bitmap.data[idx] || 0,
                    g: src.bitmap.data[idx + 1] || 0,
                    b: src.bitmap.data[idx + 2] || 0,
                    a: src.bitmap.data[idx + 3] || 0,
                };
                const dst = {
                    r: image.bitmap.data[dstIdx] || 0,
                    g: image.bitmap.data[dstIdx + 1] || 0,
                    b: image.bitmap.data[dstIdx + 2] || 0,
                    a: image.bitmap.data[dstIdx + 3] || 0,
                };
                image.bitmap.data[dstIdx] =
                    ((srcColor.a * (srcColor.r - dst.r) - dst.r + 255) >> 8) + dst.r;
                image.bitmap.data[dstIdx + 1] =
                    ((srcColor.a * (srcColor.g - dst.g) - dst.g + 255) >> 8) + dst.g;
                image.bitmap.data[dstIdx + 2] =
                    ((srcColor.a * (srcColor.b - dst.b) - dst.b + 255) >> 8) + dst.b;
                image.bitmap.data[dstIdx + 3] = limit255(dst.a + srcColor.a);
            }
        });
        return image;
    },
};

const mulTable = [
    1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107,
    3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221,
    209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103,
    99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119,
    231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151,
    147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13,
    51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75,
    147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229,
    113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183,
    181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37,
    73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61,
    121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207,
    205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178,
    176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153,
    19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133,
    66, 131, 65, 129, 1,
];
const shgTable = [
    0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18,
    16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20,
    20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21,
    20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20,
    22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22,
    22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18,
    22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22,
    21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24,
    24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24,
    24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22,
    25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23,
    25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25,
    20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25,
    22, 25, 25, 25, 24, 25, 24, 25, 18,
];

/*
    Superfast Blur (0.5)
    http://www.quasimondo.com/BoxBlurForCanvas/FastBlur.js

    Copyright (c) 2011 Mario Klingemann

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
*/
const methods$g = {
    /**
     * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
     * @param r the pixel radius of the blur
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.blur(5);
     * ```
     */
    blur(image, r) {
        if (typeof r !== "number") {
            throw new Error("r must be a number");
        }
        if (r < 1) {
            throw new Error("r must be greater than 0");
        }
        let rsum;
        let gsum;
        let bsum;
        let asum;
        let x;
        let y;
        let i;
        let p;
        let p1;
        let p2;
        let yp;
        let yi;
        let yw;
        const wm = image.bitmap.width - 1;
        const hm = image.bitmap.height - 1;
        // const wh = image.bitmap.width * image.bitmap.height;
        const rad1 = r + 1;
        const mulSum = mulTable[r];
        const shgSum = shgTable[r];
        const red = [];
        const green = [];
        const blue = [];
        const alpha = [];
        const vmin = [];
        const vmax = [];
        let iterations = 2;
        while (iterations-- > 0) {
            yi = 0;
            yw = 0;
            for (y = 0; y < image.bitmap.height; y++) {
                rsum = image.bitmap.data[yw] * rad1;
                gsum = image.bitmap.data[yw + 1] * rad1;
                bsum = image.bitmap.data[yw + 2] * rad1;
                asum = image.bitmap.data[yw + 3] * rad1;
                for (i = 1; i <= r; i++) {
                    p = yw + ((i > wm ? wm : i) << 2);
                    rsum += image.bitmap.data[p++];
                    gsum += image.bitmap.data[p++];
                    bsum += image.bitmap.data[p++];
                    asum += image.bitmap.data[p];
                }
                for (x = 0; x < image.bitmap.width; x++) {
                    red[yi] = rsum;
                    green[yi] = gsum;
                    blue[yi] = bsum;
                    alpha[yi] = asum;
                    if (y === 0) {
                        vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                        vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
                    }
                    p1 = yw + vmin[x];
                    p2 = yw + vmax[x];
                    rsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
                    gsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
                    bsum += image.bitmap.data[p1++] - image.bitmap.data[p2++];
                    asum += image.bitmap.data[p1] - image.bitmap.data[p2++];
                    yi++;
                }
                yw += image.bitmap.width << 2;
            }
            for (x = 0; x < image.bitmap.width; x++) {
                yp = x;
                rsum = red[yp] * rad1;
                gsum = green[yp] * rad1;
                bsum = blue[yp] * rad1;
                asum = alpha[yp] * rad1;
                for (i = 1; i <= r; i++) {
                    yp += i > hm ? 0 : image.bitmap.width;
                    rsum += red[yp];
                    gsum += green[yp];
                    bsum += blue[yp];
                    asum += alpha[yp];
                }
                yi = x << 2;
                for (y = 0; y < image.bitmap.height; y++) {
                    image.bitmap.data[yi] = limit255((rsum * mulSum) >>> shgSum);
                    image.bitmap.data[yi + 1] = limit255((gsum * mulSum) >>> shgSum);
                    image.bitmap.data[yi + 2] = limit255((bsum * mulSum) >>> shgSum);
                    image.bitmap.data[yi + 3] = limit255((asum * mulSum) >>> shgSum);
                    if (x === 0) {
                        vmin[y] = ((p = y + rad1) < hm ? p : hm) * image.bitmap.width;
                        vmax[y] = (p = y - r) > 0 ? p * image.bitmap.width : 0;
                    }
                    p1 = x + vmin[y];
                    p2 = x + vmax[y];
                    rsum += red[p1] - red[p2];
                    gsum += green[p1] - green[p2];
                    bsum += blue[p1] - blue[p2];
                    asum += alpha[p1] - alpha[p2];
                    yi += image.bitmap.width << 2;
                }
            }
        }
        return image;
    },
    // http://blog.ivank.net/fastest-gaussian-blur.html
    /**
     * Applies a true Gaussian blur to the image (warning: this is VERY slow)
     * @param r the pixel radius of the blur
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.gaussian(15);
     * ```
     */
    gaussian(image, r) {
        if (typeof r !== "number") {
            throw new Error("r must be a number");
        }
        if (r < 1) {
            throw new Error("r must be greater than 0");
        }
        const rs = Math.ceil(r * 2.57); // significant radius
        const range = rs * 2 + 1;
        const rr2 = r * r * 2;
        const rr2pi = rr2 * Math.PI;
        const weights = [];
        for (let y = 0; y < range; y++) {
            const weightsRow = [];
            for (let x = 0; x < range; x++) {
                const dsq = (x - rs) ** 2 + (y - rs) ** 2;
                weightsRow[x] = Math.exp(-dsq / rr2) / rr2pi;
            }
            weights.push(weightsRow);
        }
        for (let y = 0; y < image.bitmap.height; y++) {
            for (let x = 0; x < image.bitmap.width; x++) {
                let red = 0;
                let green = 0;
                let blue = 0;
                let alpha = 0;
                let wsum = 0;
                for (let iy = 0; iy < range; iy++) {
                    for (let ix = 0; ix < range; ix++) {
                        const x1 = Math.min(image.bitmap.width - 1, Math.max(0, ix + x - rs));
                        const y1 = Math.min(image.bitmap.height - 1, Math.max(0, iy + y - rs));
                        const weight = weights[iy][ix];
                        const idx = (y1 * image.bitmap.width + x1) << 2;
                        red += image.bitmap.data[idx] * weight;
                        green += image.bitmap.data[idx + 1] * weight;
                        blue += image.bitmap.data[idx + 2] * weight;
                        alpha += image.bitmap.data[idx + 3] * weight;
                        wsum += weight;
                    }
                    const idx = (y * image.bitmap.width + x) << 2;
                    image.bitmap.data[idx] = Math.round(red / wsum);
                    image.bitmap.data[idx + 1] = Math.round(green / wsum);
                    image.bitmap.data[idx + 2] = Math.round(blue / wsum);
                    image.bitmap.data[idx + 3] = Math.round(alpha / wsum);
                }
            }
        }
        return image;
    },
};

const CircleOptionsSchema = objectType({
    /** the x position to draw the circle */
    x: numberType().optional(),
    /** the y position to draw the circle */
    y: numberType().optional(),
    /** the radius of the circle */
    radius: numberType().min(0).optional(),
});
const methods$f = {
    /**
     * Creates a circle out of an image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.circle();
     * // or
     * image.circle({ radius: 50, x: 25, y: 25 });
     * ```
     */
    circle(image, options = {}) {
        const parsed = CircleOptionsSchema.parse(options);
        const radius = parsed.radius ||
            (image.bitmap.width > image.bitmap.height
                ? image.bitmap.height
                : image.bitmap.width) / 2;
        const center = {
            x: typeof parsed.x === "number" ? parsed.x : image.bitmap.width / 2,
            y: typeof parsed.y === "number" ? parsed.y : image.bitmap.height / 2,
        };
        image.scan((x, y, idx) => {
            const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
            if (radius - curR <= 0.0) {
                image.bitmap.data[idx + 3] = 0;
            }
            else if (radius - curR < 1.0) {
                image.bitmap.data[idx + 3] = 255 * (radius - curR);
            }
        });
        return image;
    },
};

const ConvolutionMatrixSchema = arrayType(numberType()).min(1).array();
const ConvolutionComplexOptionsSchema = objectType({
    /** a matrix to weight the neighbors sum */
    kernel: ConvolutionMatrixSchema,
    /**define how to sum pixels from outside the border */
    edgeHandling: nativeEnumType(Edge).optional(),
});
const ConvolutionOptionsSchema = unionType([
    ConvolutionMatrixSchema,
    ConvolutionComplexOptionsSchema,
]);
const ConvoluteComplexOptionsSchema = objectType({
    /** the convolution kernel */
    kernel: ConvolutionMatrixSchema,
    /** the x position of the region to apply convolution to */
    x: numberType().optional(),
    /** the y position of the region to apply convolution to */
    y: numberType().optional(),
    /** the width of the region to apply convolution to */
    w: numberType().optional(),
    /** the height of the region to apply convolution to */
    h: numberType().optional(),
});
const ConvoluteOptionsSchema = unionType([
    ConvolutionMatrixSchema,
    ConvoluteComplexOptionsSchema,
]);
const PixelateSize = numberType().min(1).max(Infinity);
const PixelateComplexOptionsSchema = objectType({
    /** the size of the pixels */
    size: PixelateSize,
    /** the x position of the region to pixelate */
    x: numberType().optional(),
    /** the y position of the region to pixelate */
    y: numberType().optional(),
    /** the width of the region to pixelate */
    w: numberType().optional(),
    /** the height of the region to pixelate */
    h: numberType().optional(),
});
const PixelateOptionsSchema = unionType([
    PixelateSize,
    PixelateComplexOptionsSchema,
]);
function applyKernel(image, kernel, x, y) {
    const value = [0, 0, 0, 0];
    const size = (kernel.length - 1) / 2;
    for (let kx = 0; kx < kernel.length; kx += 1) {
        for (let ky = 0; ky < kernel[kx].length; ky += 1) {
            const idx = image.getPixelIndex(x + kx - size, y + ky - size);
            value[0] += image.bitmap.data[idx] * kernel[kx][ky];
            value[1] += image.bitmap.data[idx + 1] * kernel[kx][ky];
            value[2] += image.bitmap.data[idx + 2] * kernel[kx][ky];
            value[3] += image.bitmap.data[idx + 3] * kernel[kx][ky];
        }
    }
    return value;
}
function mix(clr, clr2, p = 50) {
    return {
        r: (clr2.r - clr.r) * (p / 100) + clr.r,
        g: (clr2.g - clr.g) * (p / 100) + clr.g,
        b: (clr2.b - clr.b) * (p / 100) + clr.b,
    };
}
const HueActionSchema = objectType({
    apply: literalType("hue"),
    params: tupleType([numberType().min(-360).max(360)]),
});
const SpinActionSchema = objectType({
    apply: literalType("spin"),
    params: tupleType([numberType().min(-360).max(360)]),
});
const LightenActionSchema = objectType({
    apply: literalType("lighten"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const RGBColorSchema = objectType({
    r: numberType().min(0).max(255),
    g: numberType().min(0).max(255),
    b: numberType().min(0).max(255),
});
const MixActionSchema = objectType({
    apply: literalType("mix"),
    params: unionType([
        tupleType([RGBColorSchema]),
        tupleType([RGBColorSchema, numberType().min(0).max(100)]),
    ]),
});
const TintActionSchema = objectType({
    apply: literalType("tint"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const ShadeActionSchema = objectType({
    apply: literalType("shade"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const XorActionSchema = objectType({
    apply: literalType("xor"),
    params: tupleType([RGBColorSchema]),
});
const RedActionSchema = objectType({
    apply: literalType("red"),
    params: tupleType([numberType().min(-255).max(255)]),
});
const GreenActionSchema = objectType({
    apply: literalType("green"),
    params: tupleType([numberType().min(-255).max(255)]),
});
const BlueActionSchema = objectType({
    apply: literalType("blue"),
    params: tupleType([numberType().min(-255).max(255)]),
});
const BrightenActionSchema = objectType({
    apply: literalType("brighten"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const DarkenActionSchema = objectType({
    apply: literalType("darken"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const DesaturateActionSchema = objectType({
    apply: literalType("desaturate"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const SaturateActionSchema = objectType({
    apply: literalType("saturate"),
    params: tupleType([numberType().min(0).max(100)]).optional(),
});
const GrayscaleActionSchema = objectType({
    apply: literalType("greyscale"),
    params: tupleType([]).optional(),
});
const ColorActionNameSchema = unionType([
    HueActionSchema,
    SpinActionSchema,
    LightenActionSchema,
    MixActionSchema,
    TintActionSchema,
    ShadeActionSchema,
    XorActionSchema,
    RedActionSchema,
    GreenActionSchema,
    BlueActionSchema,
    BrightenActionSchema,
    DarkenActionSchema,
    DesaturateActionSchema,
    SaturateActionSchema,
    GrayscaleActionSchema,
]);
/**
 * Get an image's histogram
 * @return An object with an array of color occurrence counts for each channel (r,g,b)
 */
function histogram(image) {
    const histogram = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0),
    };
    image.scan((_, __, index) => {
        histogram.r[image.bitmap.data[index + 0]]++;
        histogram.g[image.bitmap.data[index + 1]]++;
        histogram.b[image.bitmap.data[index + 2]]++;
    });
    return histogram;
}
/**
 * Normalize values
 * @param  value Pixel channel value.
 * @param  min   Minimum value for channel
 * @param  max   Maximum value for channel
 */
const normalizeValue = function (value, min, max) {
    return ((value - min) * 255) / (max - min);
};
const getBounds = function (histogramChannel) {
    return [
        histogramChannel.findIndex((value) => value > 0),
        255 -
            histogramChannel
                .slice()
                .reverse()
                .findIndex((value) => value > 0),
    ];
};
const methods$e = {
    /**
     * Normalizes the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.normalize();
     * ```
     */
    normalize(image) {
        const h = histogram(image);
        // store bounds (minimum and maximum values)
        const bounds = {
            r: getBounds(h.r),
            g: getBounds(h.g),
            b: getBounds(h.b),
        };
        // apply value transformations
        image.scan((_, __, idx) => {
            const r = image.bitmap.data[idx + 0];
            const g = image.bitmap.data[idx + 1];
            const b = image.bitmap.data[idx + 2];
            image.bitmap.data[idx + 0] = normalizeValue(r, bounds.r[0], bounds.r[1]);
            image.bitmap.data[idx + 1] = normalizeValue(g, bounds.g[0], bounds.g[1]);
            image.bitmap.data[idx + 2] = normalizeValue(b, bounds.b[0], bounds.b[1]);
        });
        return image;
    },
    /**
     * Inverts the colors in the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.invert();
     * ```
     */
    invert(image) {
        image.scan((_, __, idx) => {
            image.bitmap.data[idx] = 255 - image.bitmap.data[idx];
            image.bitmap.data[idx + 1] = 255 - image.bitmap.data[idx + 1];
            image.bitmap.data[idx + 2] = 255 - image.bitmap.data[idx + 2];
        });
        return image;
    },
    /**
     * Adjusts the brightness of the image
     * @param val the amount to adjust the brightness.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.brightness(0.5);
     * ```
     */
    brightness(image, val) {
        if (typeof val !== "number") {
            throw new Error("val must be numbers");
        }
        image.scan((_, __, idx) => {
            image.bitmap.data[idx] = limit255(image.bitmap.data[idx] * val);
            image.bitmap.data[idx + 1] = limit255(image.bitmap.data[idx + 1] * val);
            image.bitmap.data[idx + 2] = limit255(image.bitmap.data[idx + 2] * val);
        });
        return image;
    },
    /**
     * Adjusts the contrast of the image
     * @param val the amount to adjust the contrast, a number between -1 and +1
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.contrast(0.75);
     * ```
     */
    contrast(image, val) {
        if (typeof val !== "number") {
            throw new Error("val must be numbers");
        }
        if (val < -1 || val > 1) {
            throw new Error("val must be a number between -1 and +1");
        }
        const factor = (val + 1) / (1 - val);
        function adjust(value) {
            value = Math.floor(factor * (value - 127) + 127);
            return value < 0 ? 0 : value > 255 ? 255 : value;
        }
        image.scan((_, __, idx) => {
            image.bitmap.data[idx] = adjust(image.bitmap.data[idx]);
            image.bitmap.data[idx + 1] = adjust(image.bitmap.data[idx + 1]);
            image.bitmap.data[idx + 2] = adjust(image.bitmap.data[idx + 2]);
        });
        return image;
    },
    /**
     * Apply a posterize effect
     * @param  n the amount to adjust the contrast, minimum threshold is two
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.posterize(5);
     * ```
     */
    posterize(image, n) {
        if (typeof n !== "number") {
            throw new Error("n must be numbers");
        }
        // minimum of 2 levels
        if (n < 2) {
            n = 2;
        }
        image.scan((_, __, idx) => {
            const r = image.bitmap.data[idx];
            const g = image.bitmap.data[idx + 1];
            const b = image.bitmap.data[idx + 2];
            image.bitmap.data[idx] =
                (Math.floor((r / 255) * (n - 1)) / (n - 1)) * 255;
            image.bitmap.data[idx + 1] =
                (Math.floor((g / 255) * (n - 1)) / (n - 1)) * 255;
            image.bitmap.data[idx + 2] =
                (Math.floor((b / 255) * (n - 1)) / (n - 1)) * 255;
        });
        return image;
    },
    /**
     * Removes colour from the image using ITU Rec 709 luminance values
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.greyscale();
     * ```
     */
    greyscale(image) {
        image.scan((_, __, idx) => {
            // const grey = parseInt(
            //   0.2126 * image.bitmap.data[idx]! +
            //     0.7152 * image.bitmap.data[idx + 1]! +
            //     0.0722 * image.bitmap.data[idx + 2]!,
            //   10
            // );
            const grey = 0.2126 * image.bitmap.data[idx] +
                0.7152 * image.bitmap.data[idx + 1] +
                0.0722 * image.bitmap.data[idx + 2];
            image.bitmap.data[idx] = grey;
            image.bitmap.data[idx + 1] = grey;
            image.bitmap.data[idx + 2] = grey;
        });
        return image;
    },
    /**
     * Multiplies the opacity of each pixel by a factor between 0 and 1
     * @param f A number, the factor by which to multiply the opacity of each pixel
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.opacity(0.5);
     * ```
     */
    opacity(image, f) {
        if (typeof f !== "number") {
            throw new Error("f must be a number");
        }
        if (f < 0 || f > 1) {
            throw new Error("f must be a number from 0 to 1");
        }
        image.scan((_, __, idx) => {
            const v = image.bitmap.data[idx + 3] * f;
            image.bitmap.data[idx + 3] = v;
        });
        return image;
    },
    /**
     * Applies a sepia tone to the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.sepia();
     * ```
     */
    sepia(image) {
        image.scan((_, __, idx) => {
            let red = image.bitmap.data[idx];
            let green = image.bitmap.data[idx + 1];
            let blue = image.bitmap.data[idx + 2];
            red = red * 0.393 + green * 0.769 + blue * 0.189;
            green = red * 0.349 + green * 0.686 + blue * 0.168;
            blue = red * 0.272 + green * 0.534 + blue * 0.131;
            image.bitmap.data[idx] = red < 255 ? red : 255;
            image.bitmap.data[idx + 1] = green < 255 ? green : 255;
            image.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
        });
        return image;
    },
    /**
     * Fades each pixel by a factor between 0 and 1
     * @param f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.fade(0.7);
     * ```
     */
    fade(image, f) {
        if (typeof f !== "number") {
            throw new Error("f must be a number");
        }
        if (f < 0 || f > 1) {
            throw new Error("f must be a number from 0 to 1");
        }
        // this method is an alternative to opacity (which may be deprecated)
        return this.opacity(image, 1 - f);
    },
    /**
     * Adds each element of the image to its local neighbors, weighted by the kernel
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.convolute([
     *   [-1, -1, 0],
     *   [-1, 1, 1],
     *   [0, 1, 1],
     * ]);
     * ```
     */
    convolution(image, options) {
        const parsed = ConvolutionOptionsSchema.parse(options);
        const { kernel, edgeHandling = Edge.EXTEND } = "kernel" in parsed ? parsed : { kernel: parsed, edgeHandling: undefined };
        if (!kernel[0]) {
            throw new Error("kernel must be a matrix");
        }
        const newData = Buffer.from(image.bitmap.data);
        const kRows = kernel.length;
        const kCols = kernel[0].length;
        const rowEnd = Math.floor(kRows / 2);
        const colEnd = Math.floor(kCols / 2);
        const rowIni = -rowEnd;
        const colIni = -colEnd;
        let weight;
        let rSum;
        let gSum;
        let bSum;
        let ri;
        let gi;
        let bi;
        let xi;
        let yi;
        let idxi;
        image.scan((x, y, idx) => {
            bSum = 0;
            gSum = 0;
            rSum = 0;
            for (let row = rowIni; row <= rowEnd; row++) {
                for (let col = colIni; col <= colEnd; col++) {
                    xi = x + col;
                    yi = y + row;
                    weight = kernel[row + rowEnd][col + colEnd];
                    idxi = image.getPixelIndex(xi, yi, edgeHandling);
                    if (idxi === -1) {
                        bi = 0;
                        gi = 0;
                        ri = 0;
                    }
                    else {
                        ri = image.bitmap.data[idxi + 0];
                        gi = image.bitmap.data[idxi + 1];
                        bi = image.bitmap.data[idxi + 2];
                    }
                    rSum += weight * ri;
                    gSum += weight * gi;
                    bSum += weight * bi;
                }
            }
            if (rSum < 0) {
                rSum = 0;
            }
            if (gSum < 0) {
                gSum = 0;
            }
            if (bSum < 0) {
                bSum = 0;
            }
            if (rSum > 255) {
                rSum = 255;
            }
            if (gSum > 255) {
                gSum = 255;
            }
            if (bSum > 255) {
                bSum = 255;
            }
            newData[idx + 0] = rSum;
            newData[idx + 1] = gSum;
            newData[idx + 2] = bSum;
        });
        image.bitmap.data = newData;
        return image;
    },
    /**
     * Set the alpha channel on every pixel to fully opaque.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.opaque();
     * ```
     */
    opaque(image) {
        image.scan((_, __, idx) => {
            image.bitmap.data[idx + 3] = 255;
        });
        return image;
    },
    /**
     * Pixelates the image or a region
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * // pixelate the whole image
     * image.pixelate(10);
     *
     * // pixelate a region
     * image.pixelate(10, 10, 10, 20, 20);
     * ```
     */
    pixelate(image, options) {
        const parsed = PixelateOptionsSchema.parse(options);
        const { size, x = 0, y = 0, w = image.bitmap.width - x, h = image.bitmap.height - y, } = typeof parsed === "number"
            ? { size: parsed }
            : parsed;
        const kernel = [
            [1 / 16, 2 / 16, 1 / 16],
            [2 / 16, 4 / 16, 2 / 16],
            [1 / 16, 2 / 16, 1 / 16],
        ];
        const source = clone(image);
        scan(source, x, y, w, h, (xx, yx, idx) => {
            xx = size * Math.floor(xx / size);
            yx = size * Math.floor(yx / size);
            const value = applyKernel(source, kernel, xx, yx);
            image.bitmap.data[idx] = value[0];
            image.bitmap.data[idx + 1] = value[1];
            image.bitmap.data[idx + 2] = value[2];
            image.bitmap.data[idx + 3] = value[3];
        });
        return image;
    },
    /**
     * Applies a convolution kernel to the image or a region
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * // apply a convolution kernel to the whole image
     * image.convolution([
     *   [-1, -1, 0],
     *   [-1, 1, 1],
     *   [0, 1, 1],
     * ]);
     *
     * // apply a convolution kernel to a region
     * image.convolution([
     *   [-1, -1, 0],
     *   [-1, 1, 1],
     *   [0, 1, 1],
     * ], 10, 10, 10, 20);
     * ```
     */
    convolute(image, options) {
        const parsed = ConvoluteOptionsSchema.parse(options);
        const { kernel, x = 0, y = 0, w = image.bitmap.width - x, h = image.bitmap.height - y, } = "kernel" in parsed
            ? parsed
            : { kernel: parsed };
        const source = clone(image);
        scan(source, x, y, w, h, (xx, yx, idx) => {
            const value = applyKernel(source, kernel, xx, yx);
            image.bitmap.data[idx] = limit255(value[0]);
            image.bitmap.data[idx + 1] = limit255(value[1]);
            image.bitmap.data[idx + 2] = limit255(value[2]);
            image.bitmap.data[idx + 3] = limit255(value[3]);
        });
        return image;
    },
    /**
     * Apply multiple color modification rules
     * @param  actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.color([
     *   { apply: "hue", params: [-90] },
     *   { apply: "lighten", params: [50] },
     *   { apply: "xor", params: ["#06D"] },
     * ]);
     * ```
     */
    color(image, actions) {
        if (!actions || !Array.isArray(actions)) {
            throw new Error("actions must be an array");
        }
        actions.forEach((action) => ColorActionNameSchema.parse(action));
        actions = actions.map((action) => {
            if (action.apply === "xor" || action.apply === "mix") {
                action.params[0] = tinycolor(action.params[0]).toRgb();
            }
            return action;
        });
        image.scan((_, __, idx) => {
            let clr = {
                r: image.bitmap.data[idx],
                g: image.bitmap.data[idx + 1],
                b: image.bitmap.data[idx + 2],
            };
            const colorModifier = (i, amount) => limit255(clr[i] + amount);
            actions.forEach((action) => {
                if (action.apply === "mix") {
                    clr = mix(clr, action.params[0], action.params[1]);
                }
                else if (action.apply === "tint") {
                    clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params?.[0]);
                }
                else if (action.apply === "shade") {
                    clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params?.[0]);
                }
                else if (action.apply === "xor") {
                    clr = {
                        r: clr.r ^ action.params[0].r,
                        g: clr.g ^ action.params[0].g,
                        b: clr.b ^ action.params[0].b,
                    };
                }
                else if (action.apply === "red") {
                    clr.r = colorModifier("r", action.params[0]);
                }
                else if (action.apply === "green") {
                    clr.g = colorModifier("g", action.params[0]);
                }
                else if (action.apply === "blue") {
                    clr.b = colorModifier("b", action.params[0]);
                }
                else {
                    if (action.apply === "hue") {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        action.apply = "spin";
                    }
                    const tnyClr = tinycolor(clr);
                    const fn = tnyClr[action.apply].bind(tnyClr);
                    if (!fn) {
                        throw new Error("action " + action.apply + " not supported");
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    clr = fn(...(action.params || [])).toRgb();
                }
            });
            image.bitmap.data[idx] = clr.r;
            image.bitmap.data[idx + 1] = clr.g;
            image.bitmap.data[idx + 2] = clr.b;
        });
        return image;
    },
};

var lib$2 = {};

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = void 0;
		const ieee754 = requireIeee754();
		// Primitive types
		function dv(array) {
		    return new DataView(array.buffer, array.byteOffset);
		}
		/**
		 * 8-bit unsigned integer
		 */
		exports.UINT8 = {
		    len: 1,
		    get(array, offset) {
		        return dv(array).getUint8(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setUint8(offset, value);
		        return offset + 1;
		    }
		};
		/**
		 * 16-bit unsigned integer, Little Endian byte order
		 */
		exports.UINT16_LE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getUint16(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setUint16(offset, value, true);
		        return offset + 2;
		    }
		};
		/**
		 * 16-bit unsigned integer, Big Endian byte order
		 */
		exports.UINT16_BE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getUint16(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setUint16(offset, value);
		        return offset + 2;
		    }
		};
		/**
		 * 24-bit unsigned integer, Little Endian byte order
		 */
		exports.UINT24_LE = {
		    len: 3,
		    get(array, offset) {
		        const dataView = dv(array);
		        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint8(offset, value & 0xff);
		        dataView.setUint16(offset + 1, value >> 8, true);
		        return offset + 3;
		    }
		};
		/**
		 * 24-bit unsigned integer, Big Endian byte order
		 */
		exports.UINT24_BE = {
		    len: 3,
		    get(array, offset) {
		        const dataView = dv(array);
		        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint16(offset, value >> 8);
		        dataView.setUint8(offset + 2, value & 0xff);
		        return offset + 3;
		    }
		};
		/**
		 * 32-bit unsigned integer, Little Endian byte order
		 */
		exports.UINT32_LE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getUint32(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setUint32(offset, value, true);
		        return offset + 4;
		    }
		};
		/**
		 * 32-bit unsigned integer, Big Endian byte order
		 */
		exports.UINT32_BE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getUint32(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setUint32(offset, value);
		        return offset + 4;
		    }
		};
		/**
		 * 8-bit signed integer
		 */
		exports.INT8 = {
		    len: 1,
		    get(array, offset) {
		        return dv(array).getInt8(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setInt8(offset, value);
		        return offset + 1;
		    }
		};
		/**
		 * 16-bit signed integer, Big Endian byte order
		 */
		exports.INT16_BE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getInt16(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setInt16(offset, value);
		        return offset + 2;
		    }
		};
		/**
		 * 16-bit signed integer, Little Endian byte order
		 */
		exports.INT16_LE = {
		    len: 2,
		    get(array, offset) {
		        return dv(array).getInt16(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setInt16(offset, value, true);
		        return offset + 2;
		    }
		};
		/**
		 * 24-bit signed integer, Little Endian byte order
		 */
		exports.INT24_LE = {
		    len: 3,
		    get(array, offset) {
		        const unsigned = exports.UINT24_LE.get(array, offset);
		        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint8(offset, value & 0xff);
		        dataView.setUint16(offset + 1, value >> 8, true);
		        return offset + 3;
		    }
		};
		/**
		 * 24-bit signed integer, Big Endian byte order
		 */
		exports.INT24_BE = {
		    len: 3,
		    get(array, offset) {
		        const unsigned = exports.UINT24_BE.get(array, offset);
		        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
		    },
		    put(array, offset, value) {
		        const dataView = dv(array);
		        dataView.setUint16(offset, value >> 8);
		        dataView.setUint8(offset + 2, value & 0xff);
		        return offset + 3;
		    }
		};
		/**
		 * 32-bit signed integer, Big Endian byte order
		 */
		exports.INT32_BE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getInt32(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setInt32(offset, value);
		        return offset + 4;
		    }
		};
		/**
		 * 32-bit signed integer, Big Endian byte order
		 */
		exports.INT32_LE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getInt32(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setInt32(offset, value, true);
		        return offset + 4;
		    }
		};
		/**
		 * 64-bit unsigned integer, Little Endian byte order
		 */
		exports.UINT64_LE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigUint64(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setBigUint64(offset, value, true);
		        return offset + 8;
		    }
		};
		/**
		 * 64-bit signed integer, Little Endian byte order
		 */
		exports.INT64_LE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigInt64(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setBigInt64(offset, value, true);
		        return offset + 8;
		    }
		};
		/**
		 * 64-bit unsigned integer, Big Endian byte order
		 */
		exports.UINT64_BE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigUint64(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setBigUint64(offset, value);
		        return offset + 8;
		    }
		};
		/**
		 * 64-bit signed integer, Big Endian byte order
		 */
		exports.INT64_BE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getBigInt64(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setBigInt64(offset, value);
		        return offset + 8;
		    }
		};
		/**
		 * IEEE 754 16-bit (half precision) float, big endian
		 */
		exports.Float16_BE = {
		    len: 2,
		    get(dataView, offset) {
		        return ieee754.read(dataView, offset, false, 10, this.len);
		    },
		    put(dataView, offset, value) {
		        ieee754.write(dataView, value, offset, false, 10, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * IEEE 754 16-bit (half precision) float, little endian
		 */
		exports.Float16_LE = {
		    len: 2,
		    get(array, offset) {
		        return ieee754.read(array, offset, true, 10, this.len);
		    },
		    put(array, offset, value) {
		        ieee754.write(array, value, offset, true, 10, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * IEEE 754 32-bit (single precision) float, big endian
		 */
		exports.Float32_BE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getFloat32(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat32(offset, value);
		        return offset + 4;
		    }
		};
		/**
		 * IEEE 754 32-bit (single precision) float, little endian
		 */
		exports.Float32_LE = {
		    len: 4,
		    get(array, offset) {
		        return dv(array).getFloat32(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat32(offset, value, true);
		        return offset + 4;
		    }
		};
		/**
		 * IEEE 754 64-bit (double precision) float, big endian
		 */
		exports.Float64_BE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getFloat64(offset);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat64(offset, value);
		        return offset + 8;
		    }
		};
		/**
		 * IEEE 754 64-bit (double precision) float, little endian
		 */
		exports.Float64_LE = {
		    len: 8,
		    get(array, offset) {
		        return dv(array).getFloat64(offset, true);
		    },
		    put(array, offset, value) {
		        dv(array).setFloat64(offset, value, true);
		        return offset + 8;
		    }
		};
		/**
		 * IEEE 754 80-bit (extended precision) float, big endian
		 */
		exports.Float80_BE = {
		    len: 10,
		    get(array, offset) {
		        return ieee754.read(array, offset, false, 63, this.len);
		    },
		    put(array, offset, value) {
		        ieee754.write(array, value, offset, false, 63, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * IEEE 754 80-bit (extended precision) float, little endian
		 */
		exports.Float80_LE = {
		    len: 10,
		    get(array, offset) {
		        return ieee754.read(array, offset, true, 63, this.len);
		    },
		    put(array, offset, value) {
		        ieee754.write(array, value, offset, true, 63, this.len);
		        return offset + this.len;
		    }
		};
		/**
		 * Ignore a given number of bytes
		 */
		class IgnoreType {
		    /**
		     * @param len number of bytes to ignore
		     */
		    constructor(len) {
		        this.len = len;
		    }
		    // ToDo: don't read, but skip data
		    get(array, off) {
		    }
		}
		exports.IgnoreType = IgnoreType;
		class Uint8ArrayType {
		    constructor(len) {
		        this.len = len;
		    }
		    get(array, offset) {
		        return array.subarray(offset, offset + this.len);
		    }
		}
		exports.Uint8ArrayType = Uint8ArrayType;
		class BufferType {
		    constructor(len) {
		        this.len = len;
		    }
		    get(uint8Array, off) {
		        return Buffer.from(uint8Array.subarray(off, off + this.len));
		    }
		}
		exports.BufferType = BufferType;
		/**
		 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
		 */
		class StringType {
		    constructor(len, encoding) {
		        this.len = len;
		        this.encoding = encoding;
		    }
		    get(uint8Array, offset) {
		        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
		    }
		}
		exports.StringType = StringType;
		/**
		 * ANSI Latin 1 String
		 * Using windows-1252 / ISO 8859-1 decoding
		 */
		class AnsiStringType {
		    constructor(len) {
		        this.len = len;
		    }
		    static decode(buffer, offset, until) {
		        let str = '';
		        for (let i = offset; i < until; ++i) {
		            str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
		        }
		        return str;
		    }
		    static inRange(a, min, max) {
		        return min <= a && a <= max;
		    }
		    static codePointToString(cp) {
		        if (cp <= 0xFFFF) {
		            return String.fromCharCode(cp);
		        }
		        else {
		            cp -= 0x10000;
		            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
		        }
		    }
		    static singleByteDecoder(bite) {
		        if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {
		            return bite;
		        }
		        const codePoint = AnsiStringType.windows1252[bite - 0x80];
		        if (codePoint === null) {
		            throw Error('invaliding encoding');
		        }
		        return codePoint;
		    }
		    get(buffer, offset = 0) {
		        return AnsiStringType.decode(buffer, offset, offset + this.len);
		    }
		}
		exports.AnsiStringType = AnsiStringType;
		AnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,
		    8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,
		    8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,
		    169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
		    185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,
		    201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
		    217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
		    233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
		    248, 249, 250, 251, 252, 253, 254, 255]; 
	} (lib$2));
	return lib$2;
}

var core$2 = {};

var ReadStreamTokenizer = {};

var AbstractTokenizer = {};

var lib$1 = {};

var EndOfFileStream = {};

var hasRequiredEndOfFileStream;

function requireEndOfFileStream () {
	if (hasRequiredEndOfFileStream) return EndOfFileStream;
	hasRequiredEndOfFileStream = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.EndOfStreamError = exports.defaultMessages = void 0;
		exports.defaultMessages = 'End-Of-Stream';
		/**
		 * Thrown on read operation of the end of file or stream has been reached
		 */
		class EndOfStreamError extends Error {
		    constructor() {
		        super(exports.defaultMessages);
		    }
		}
		exports.EndOfStreamError = EndOfStreamError; 
	} (EndOfFileStream));
	return EndOfFileStream;
}

var StreamReader = {};

var Deferred = {};

var hasRequiredDeferred;

function requireDeferred () {
	if (hasRequiredDeferred) return Deferred;
	hasRequiredDeferred = 1;
	Object.defineProperty(Deferred, "__esModule", { value: true });
	Deferred.Deferred = void 0;
	let Deferred$1 = class Deferred {
	    constructor() {
	        this.resolve = () => null;
	        this.reject = () => null;
	        this.promise = new Promise((resolve, reject) => {
	            this.reject = reject;
	            this.resolve = resolve;
	        });
	    }
	};
	Deferred.Deferred = Deferred$1;
	return Deferred;
}

var hasRequiredStreamReader;

function requireStreamReader () {
	if (hasRequiredStreamReader) return StreamReader;
	hasRequiredStreamReader = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.StreamReader = exports.EndOfStreamError = void 0;
		const EndOfFileStream_1 = requireEndOfFileStream();
		const Deferred_1 = requireDeferred();
		var EndOfFileStream_2 = requireEndOfFileStream();
		Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });
		const maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation
		class StreamReader {
		    constructor(s) {
		        this.s = s;
		        /**
		         * Deferred used for postponed read request (as not data is yet available to read)
		         */
		        this.deferred = null;
		        this.endOfStream = false;
		        /**
		         * Store peeked data
		         * @type {Array}
		         */
		        this.peekQueue = [];
		        if (!s.read || !s.once) {
		            throw new Error('Expected an instance of stream.Readable');
		        }
		        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
		        this.s.once('error', err => this.reject(err));
		        this.s.once('close', () => this.reject(new Error('Stream closed')));
		    }
		    /**
		     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
		     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
		     * @param offset - Offset target
		     * @param length - Number of bytes to read
		     * @returns Number of bytes peeked
		     */
		    async peek(uint8Array, offset, length) {
		        const bytesRead = await this.read(uint8Array, offset, length);
		        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
		        return bytesRead;
		    }
		    /**
		     * Read chunk from stream
		     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
		     * @param offset - Offset target
		     * @param length - Number of bytes to read
		     * @returns Number of bytes read
		     */
		    async read(buffer, offset, length) {
		        if (length === 0) {
		            return 0;
		        }
		        if (this.peekQueue.length === 0 && this.endOfStream) {
		            throw new EndOfFileStream_1.EndOfStreamError();
		        }
		        let remaining = length;
		        let bytesRead = 0;
		        // consume peeked data first
		        while (this.peekQueue.length > 0 && remaining > 0) {
		            const peekData = this.peekQueue.pop(); // Front of queue
		            if (!peekData)
		                throw new Error('peekData should be defined');
		            const lenCopy = Math.min(peekData.length, remaining);
		            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
		            bytesRead += lenCopy;
		            remaining -= lenCopy;
		            if (lenCopy < peekData.length) {
		                // remainder back to queue
		                this.peekQueue.push(peekData.subarray(lenCopy));
		            }
		        }
		        // continue reading from stream if required
		        while (remaining > 0 && !this.endOfStream) {
		            const reqLen = Math.min(remaining, maxStreamReadSize);
		            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
		            bytesRead += chunkLen;
		            if (chunkLen < reqLen)
		                break;
		            remaining -= chunkLen;
		        }
		        return bytesRead;
		    }
		    /**
		     * Read chunk from stream
		     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
		     * @param offset Offset target
		     * @param length Number of bytes to read
		     * @returns Number of bytes read
		     */
		    async readFromStream(buffer, offset, length) {
		        const readBuffer = this.s.read(length);
		        if (readBuffer) {
		            buffer.set(readBuffer, offset);
		            return readBuffer.length;
		        }
		        else {
		            const request = {
		                buffer,
		                offset,
		                length,
		                deferred: new Deferred_1.Deferred()
		            };
		            this.deferred = request.deferred;
		            this.s.once('readable', () => {
		                this.readDeferred(request);
		            });
		            return request.deferred.promise;
		        }
		    }
		    /**
		     * Process deferred read request
		     * @param request Deferred read request
		     */
		    readDeferred(request) {
		        const readBuffer = this.s.read(request.length);
		        if (readBuffer) {
		            request.buffer.set(readBuffer, request.offset);
		            request.deferred.resolve(readBuffer.length);
		            this.deferred = null;
		        }
		        else {
		            this.s.once('readable', () => {
		                this.readDeferred(request);
		            });
		        }
		    }
		    reject(err) {
		        this.endOfStream = true;
		        if (this.deferred) {
		            this.deferred.reject(err);
		            this.deferred = null;
		        }
		    }
		}
		exports.StreamReader = StreamReader; 
	} (StreamReader));
	return StreamReader;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.StreamReader = exports.EndOfStreamError = void 0;
		var EndOfFileStream_1 = requireEndOfFileStream();
		Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function () { return EndOfFileStream_1.EndOfStreamError; } });
		var StreamReader_1 = requireStreamReader();
		Object.defineProperty(exports, "StreamReader", { enumerable: true, get: function () { return StreamReader_1.StreamReader; } }); 
	} (lib$1));
	return lib$1;
}

var hasRequiredAbstractTokenizer;

function requireAbstractTokenizer () {
	if (hasRequiredAbstractTokenizer) return AbstractTokenizer;
	hasRequiredAbstractTokenizer = 1;
	Object.defineProperty(AbstractTokenizer, "__esModule", { value: true });
	AbstractTokenizer.AbstractTokenizer = void 0;
	const peek_readable_1 = requireLib$1();
	/**
	 * Core tokenizer
	 */
	let AbstractTokenizer$1 = class AbstractTokenizer {
	    constructor(fileInfo) {
	        /**
	         * Tokenizer-stream position
	         */
	        this.position = 0;
	        this.numBuffer = new Uint8Array(8);
	        this.fileInfo = fileInfo ? fileInfo : {};
	    }
	    /**
	     * Read a token from the tokenizer-stream
	     * @param token - The token to read
	     * @param position - If provided, the desired position in the tokenizer-stream
	     * @returns Promise with token data
	     */
	    async readToken(token, position = this.position) {
	        const uint8Array = Buffer.alloc(token.len);
	        const len = await this.readBuffer(uint8Array, { position });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(uint8Array, 0);
	    }
	    /**
	     * Peek a token from the tokenizer-stream.
	     * @param token - Token to peek from the tokenizer-stream.
	     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
	     * @returns Promise with token data
	     */
	    async peekToken(token, position = this.position) {
	        const uint8Array = Buffer.alloc(token.len);
	        const len = await this.peekBuffer(uint8Array, { position });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(uint8Array, 0);
	    }
	    /**
	     * Read a numeric token from the stream
	     * @param token - Numeric token
	     * @returns Promise with number
	     */
	    async readNumber(token) {
	        const len = await this.readBuffer(this.numBuffer, { length: token.len });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(this.numBuffer, 0);
	    }
	    /**
	     * Read a numeric token from the stream
	     * @param token - Numeric token
	     * @returns Promise with number
	     */
	    async peekNumber(token) {
	        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
	        if (len < token.len)
	            throw new peek_readable_1.EndOfStreamError();
	        return token.get(this.numBuffer, 0);
	    }
	    /**
	     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
	     * @param length - Number of bytes to ignore
	     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
	     */
	    async ignore(length) {
	        if (this.fileInfo.size !== undefined) {
	            const bytesLeft = this.fileInfo.size - this.position;
	            if (length > bytesLeft) {
	                this.position += bytesLeft;
	                return bytesLeft;
	            }
	        }
	        this.position += length;
	        return length;
	    }
	    async close() {
	        // empty
	    }
	    normalizeOptions(uint8Array, options) {
	        if (options && options.position !== undefined && options.position < this.position) {
	            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	        }
	        if (options) {
	            return {
	                mayBeLess: options.mayBeLess === true,
	                offset: options.offset ? options.offset : 0,
	                length: options.length ? options.length : (uint8Array.length - (options.offset ? options.offset : 0)),
	                position: options.position ? options.position : this.position
	            };
	        }
	        return {
	            mayBeLess: false,
	            offset: 0,
	            length: uint8Array.length,
	            position: this.position
	        };
	    }
	};
	AbstractTokenizer.AbstractTokenizer = AbstractTokenizer$1;
	return AbstractTokenizer;
}

var hasRequiredReadStreamTokenizer;

function requireReadStreamTokenizer () {
	if (hasRequiredReadStreamTokenizer) return ReadStreamTokenizer;
	hasRequiredReadStreamTokenizer = 1;
	Object.defineProperty(ReadStreamTokenizer, "__esModule", { value: true });
	ReadStreamTokenizer.ReadStreamTokenizer = void 0;
	const AbstractTokenizer_1 = requireAbstractTokenizer();
	const peek_readable_1 = requireLib$1();
	const maxBufferSize = 256000;
	let ReadStreamTokenizer$1 = class ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
	    constructor(stream, fileInfo) {
	        super(fileInfo);
	        this.streamReader = new peek_readable_1.StreamReader(stream);
	    }
	    /**
	     * Get file information, an HTTP-client may implement this doing a HEAD request
	     * @return Promise with file information
	     */
	    async getFileInfo() {
	        return this.fileInfo;
	    }
	    /**
	     * Read buffer from tokenizer
	     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
	     * @param options - Read behaviour options
	     * @returns Promise with number of bytes read
	     */
	    async readBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        const skipBytes = normOptions.position - this.position;
	        if (skipBytes > 0) {
	            await this.ignore(skipBytes);
	            return this.readBuffer(uint8Array, options);
	        }
	        else if (skipBytes < 0) {
	            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	        }
	        if (normOptions.length === 0) {
	            return 0;
	        }
	        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
	        this.position += bytesRead;
	        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
	            throw new peek_readable_1.EndOfStreamError();
	        }
	        return bytesRead;
	    }
	    /**
	     * Peek (read ahead) buffer from tokenizer
	     * @param uint8Array - Uint8Array (or Buffer) to write data to
	     * @param options - Read behaviour options
	     * @returns Promise with number of bytes peeked
	     */
	    async peekBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        let bytesRead = 0;
	        if (normOptions.position) {
	            const skipBytes = normOptions.position - this.position;
	            if (skipBytes > 0) {
	                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
	                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
	                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
	                return bytesRead - skipBytes;
	            }
	            else if (skipBytes < 0) {
	                throw new Error('Cannot peek from a negative offset in a stream');
	            }
	        }
	        if (normOptions.length > 0) {
	            try {
	                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
	            }
	            catch (err) {
	                if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
	                    return 0;
	                }
	                throw err;
	            }
	            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {
	                throw new peek_readable_1.EndOfStreamError();
	            }
	        }
	        return bytesRead;
	    }
	    async ignore(length) {
	        // debug(`ignore ${this.position}...${this.position + length - 1}`);
	        const bufSize = Math.min(maxBufferSize, length);
	        const buf = new Uint8Array(bufSize);
	        let totBytesRead = 0;
	        while (totBytesRead < length) {
	            const remaining = length - totBytesRead;
	            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
	            if (bytesRead < 0) {
	                return bytesRead;
	            }
	            totBytesRead += bytesRead;
	        }
	        return totBytesRead;
	    }
	};
	ReadStreamTokenizer.ReadStreamTokenizer = ReadStreamTokenizer$1;
	return ReadStreamTokenizer;
}

var BufferTokenizer = {};

var hasRequiredBufferTokenizer;

function requireBufferTokenizer () {
	if (hasRequiredBufferTokenizer) return BufferTokenizer;
	hasRequiredBufferTokenizer = 1;
	Object.defineProperty(BufferTokenizer, "__esModule", { value: true });
	BufferTokenizer.BufferTokenizer = void 0;
	const peek_readable_1 = requireLib$1();
	const AbstractTokenizer_1 = requireAbstractTokenizer();
	let BufferTokenizer$1 = class BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
	    /**
	     * Construct BufferTokenizer
	     * @param uint8Array - Uint8Array to tokenize
	     * @param fileInfo - Pass additional file information to the tokenizer
	     */
	    constructor(uint8Array, fileInfo) {
	        super(fileInfo);
	        this.uint8Array = uint8Array;
	        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
	    }
	    /**
	     * Read buffer from tokenizer
	     * @param uint8Array - Uint8Array to tokenize
	     * @param options - Read behaviour options
	     * @returns {Promise<number>}
	     */
	    async readBuffer(uint8Array, options) {
	        if (options && options.position) {
	            if (options.position < this.position) {
	                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
	            }
	            this.position = options.position;
	        }
	        const bytesRead = await this.peekBuffer(uint8Array, options);
	        this.position += bytesRead;
	        return bytesRead;
	    }
	    /**
	     * Peek (read ahead) buffer from tokenizer
	     * @param uint8Array
	     * @param options - Read behaviour options
	     * @returns {Promise<number>}
	     */
	    async peekBuffer(uint8Array, options) {
	        const normOptions = this.normalizeOptions(uint8Array, options);
	        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
	        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {
	            throw new peek_readable_1.EndOfStreamError();
	        }
	        else {
	            uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
	            return bytes2read;
	        }
	    }
	    async close() {
	        // empty
	    }
	};
	BufferTokenizer.BufferTokenizer = BufferTokenizer$1;
	return BufferTokenizer;
}

var hasRequiredCore$2;

function requireCore$2 () {
	if (hasRequiredCore$2) return core$2;
	hasRequiredCore$2 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = void 0;
		const ReadStreamTokenizer_1 = requireReadStreamTokenizer();
		const BufferTokenizer_1 = requireBufferTokenizer();
		var peek_readable_1 = requireLib$1();
		Object.defineProperty(exports, "EndOfStreamError", { enumerable: true, get: function () { return peek_readable_1.EndOfStreamError; } });
		/**
		 * Construct ReadStreamTokenizer from given Stream.
		 * Will set fileSize, if provided given Stream has set the .path property/
		 * @param stream - Read from Node.js Stream.Readable
		 * @param fileInfo - Pass the file information, like size and MIME-type of the corresponding stream.
		 * @returns ReadStreamTokenizer
		 */
		function fromStream(stream, fileInfo) {
		    fileInfo = fileInfo ? fileInfo : {};
		    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);
		}
		exports.fromStream = fromStream;
		/**
		 * Construct ReadStreamTokenizer from given Buffer.
		 * @param uint8Array - Uint8Array to tokenize
		 * @param fileInfo - Pass additional file information to the tokenizer
		 * @returns BufferTokenizer
		 */
		function fromBuffer(uint8Array, fileInfo) {
		    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
		}
		exports.fromBuffer = fromBuffer; 
	} (core$2));
	return core$2;
}

var util$7 = {};

var hasRequiredUtil$7;

function requireUtil$7 () {
	if (hasRequiredUtil$7) return util$7;
	hasRequiredUtil$7 = 1;

	util$7.stringToBytes = string => [...string].map(character => character.charCodeAt(0));

	/**
	Checks whether the TAR checksum is valid.

	@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.
	@param {number} offset - TAR header offset.
	@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
	*/
	util$7.tarHeaderChecksumMatches = (buffer, offset = 0) => {
		const readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\0.*$/, '').trim(), 8); // Read sum in header
		if (isNaN(readSum)) {
			return false;
		}

		let sum = 8 * 0x20; // Initialize signed bit sum

		for (let i = offset; i < offset + 148; i++) {
			sum += buffer[i];
		}

		for (let i = offset + 156; i < offset + 512; i++) {
			sum += buffer[i];
		}

		return readSum === sum;
	};

	/**
	ID3 UINT32 sync-safe tokenizer token.
	28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
	*/
	util$7.uint32SyncSafeToken = {
		get: (buffer, offset) => {
			return (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);
		},
		len: 4
	};
	return util$7;
}

var supported;
var hasRequiredSupported;

function requireSupported () {
	if (hasRequiredSupported) return supported;
	hasRequiredSupported = 1;

	supported = {
		extensions: [
			'jpg',
			'png',
			'apng',
			'gif',
			'webp',
			'flif',
			'xcf',
			'cr2',
			'cr3',
			'orf',
			'arw',
			'dng',
			'nef',
			'rw2',
			'raf',
			'tif',
			'bmp',
			'icns',
			'jxr',
			'psd',
			'indd',
			'zip',
			'tar',
			'rar',
			'gz',
			'bz2',
			'7z',
			'dmg',
			'mp4',
			'mid',
			'mkv',
			'webm',
			'mov',
			'avi',
			'mpg',
			'mp2',
			'mp3',
			'm4a',
			'oga',
			'ogg',
			'ogv',
			'opus',
			'flac',
			'wav',
			'spx',
			'amr',
			'pdf',
			'epub',
			'exe',
			'swf',
			'rtf',
			'wasm',
			'woff',
			'woff2',
			'eot',
			'ttf',
			'otf',
			'ico',
			'flv',
			'ps',
			'xz',
			'sqlite',
			'nes',
			'crx',
			'xpi',
			'cab',
			'deb',
			'ar',
			'rpm',
			'Z',
			'lz',
			'cfb',
			'mxf',
			'mts',
			'blend',
			'bpg',
			'docx',
			'pptx',
			'xlsx',
			'3gp',
			'3g2',
			'jp2',
			'jpm',
			'jpx',
			'mj2',
			'aif',
			'qcp',
			'odt',
			'ods',
			'odp',
			'xml',
			'mobi',
			'heic',
			'cur',
			'ktx',
			'ape',
			'wv',
			'dcm',
			'ics',
			'glb',
			'pcap',
			'dsf',
			'lnk',
			'alias',
			'voc',
			'ac3',
			'm4v',
			'm4p',
			'm4b',
			'f4v',
			'f4p',
			'f4b',
			'f4a',
			'mie',
			'asf',
			'ogm',
			'ogx',
			'mpc',
			'arrow',
			'shp',
			'aac',
			'mp1',
			'it',
			's3m',
			'xm',
			'ai',
			'skp',
			'avif',
			'eps',
			'lzh',
			'pgp',
			'asar',
			'stl',
			'chm',
			'3mf',
			'zst',
			'jxl',
			'vcf'
		],
		mimeTypes: [
			'image/jpeg',
			'image/png',
			'image/gif',
			'image/webp',
			'image/flif',
			'image/x-xcf',
			'image/x-canon-cr2',
			'image/x-canon-cr3',
			'image/tiff',
			'image/bmp',
			'image/vnd.ms-photo',
			'image/vnd.adobe.photoshop',
			'application/x-indesign',
			'application/epub+zip',
			'application/x-xpinstall',
			'application/vnd.oasis.opendocument.text',
			'application/vnd.oasis.opendocument.spreadsheet',
			'application/vnd.oasis.opendocument.presentation',
			'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
			'application/vnd.openxmlformats-officedocument.presentationml.presentation',
			'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
			'application/zip',
			'application/x-tar',
			'application/x-rar-compressed',
			'application/gzip',
			'application/x-bzip2',
			'application/x-7z-compressed',
			'application/x-apple-diskimage',
			'application/x-apache-arrow',
			'video/mp4',
			'audio/midi',
			'video/x-matroska',
			'video/webm',
			'video/quicktime',
			'video/vnd.avi',
			'audio/vnd.wave',
			'audio/qcelp',
			'audio/x-ms-asf',
			'video/x-ms-asf',
			'application/vnd.ms-asf',
			'video/mpeg',
			'video/3gpp',
			'audio/mpeg',
			'audio/mp4', // RFC 4337
			'audio/opus',
			'video/ogg',
			'audio/ogg',
			'application/ogg',
			'audio/x-flac',
			'audio/ape',
			'audio/wavpack',
			'audio/amr',
			'application/pdf',
			'application/x-msdownload',
			'application/x-shockwave-flash',
			'application/rtf',
			'application/wasm',
			'font/woff',
			'font/woff2',
			'application/vnd.ms-fontobject',
			'font/ttf',
			'font/otf',
			'image/x-icon',
			'video/x-flv',
			'application/postscript',
			'application/eps',
			'application/x-xz',
			'application/x-sqlite3',
			'application/x-nintendo-nes-rom',
			'application/x-google-chrome-extension',
			'application/vnd.ms-cab-compressed',
			'application/x-deb',
			'application/x-unix-archive',
			'application/x-rpm',
			'application/x-compress',
			'application/x-lzip',
			'application/x-cfb',
			'application/x-mie',
			'application/mxf',
			'video/mp2t',
			'application/x-blender',
			'image/bpg',
			'image/jp2',
			'image/jpx',
			'image/jpm',
			'image/mj2',
			'audio/aiff',
			'application/xml',
			'application/x-mobipocket-ebook',
			'image/heif',
			'image/heif-sequence',
			'image/heic',
			'image/heic-sequence',
			'image/icns',
			'image/ktx',
			'application/dicom',
			'audio/x-musepack',
			'text/calendar',
			'text/vcard',
			'model/gltf-binary',
			'application/vnd.tcpdump.pcap',
			'audio/x-dsf', // Non-standard
			'application/x.ms.shortcut', // Invented by us
			'application/x.apple.alias', // Invented by us
			'audio/x-voc',
			'audio/vnd.dolby.dd-raw',
			'audio/x-m4a',
			'image/apng',
			'image/x-olympus-orf',
			'image/x-sony-arw',
			'image/x-adobe-dng',
			'image/x-nikon-nef',
			'image/x-panasonic-rw2',
			'image/x-fujifilm-raf',
			'video/x-m4v',
			'video/3gpp2',
			'application/x-esri-shape',
			'audio/aac',
			'audio/x-it',
			'audio/x-s3m',
			'audio/x-xm',
			'video/MP1S',
			'video/MP2P',
			'application/vnd.sketchup.skp',
			'image/avif',
			'application/x-lzh-compressed',
			'application/pgp-encrypted',
			'application/x-asar',
			'model/stl',
			'application/vnd.ms-htmlhelp',
			'model/3mf',
			'image/jxl',
			'application/zstd'
		]
	};
	return supported;
}

var core$1;
var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	const Token = requireLib$2();
	const strtok3 = requireCore$2();
	const {
		stringToBytes,
		tarHeaderChecksumMatches,
		uint32SyncSafeToken
	} = requireUtil$7();
	const supported = requireSupported();

	const minimumBytes = 4100; // A fair amount of file-types are detectable within this range

	async function fromStream(stream) {
		const tokenizer = await strtok3.fromStream(stream);
		try {
			return await fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async function fromBuffer(input) {
		if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
			throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
		}

		const buffer = input instanceof Buffer ? input : Buffer.from(input);

		if (!(buffer && buffer.length > 1)) {
			return;
		}

		const tokenizer = strtok3.fromBuffer(buffer);
		return fromTokenizer(tokenizer);
	}

	function _check(buffer, headers, options) {
		options = {
			offset: 0,
			...options
		};

		for (const [index, header] of headers.entries()) {
			// If a bitmask is set
			if (options.mask) {
				// If header doesn't equal `buf` with bits masked off
				if (header !== (options.mask[index] & buffer[index + options.offset])) {
					return false;
				}
			} else if (header !== buffer[index + options.offset]) {
				return false;
			}
		}

		return true;
	}

	async function fromTokenizer(tokenizer) {
		try {
			return _fromTokenizer(tokenizer);
		} catch (error) {
			if (!(error instanceof strtok3.EndOfStreamError)) {
				throw error;
			}
		}
	}

	async function _fromTokenizer(tokenizer) {
		let buffer = Buffer.alloc(minimumBytes);
		const bytesRead = 12;
		const check = (header, options) => _check(buffer, header, options);
		const checkString = (header, options) => check(stringToBytes(header), options);

		// Keep reading until EOF if the file size is unknown.
		if (!tokenizer.fileInfo.size) {
			tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
		}

		await tokenizer.peekBuffer(buffer, {length: bytesRead, mayBeLess: true});

		// -- 2-byte signatures --

		if (check([0x42, 0x4D])) {
			return {
				ext: 'bmp',
				mime: 'image/bmp'
			};
		}

		if (check([0x0B, 0x77])) {
			return {
				ext: 'ac3',
				mime: 'audio/vnd.dolby.dd-raw'
			};
		}

		if (check([0x78, 0x01])) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage'
			};
		}

		if (check([0x4D, 0x5A])) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload'
			};
		}

		if (check([0x25, 0x21])) {
			await tokenizer.peekBuffer(buffer, {length: 24, mayBeLess: true});

			if (checkString('PS-Adobe-', {offset: 2}) &&
				checkString(' EPSF-', {offset: 14})) {
				return {
					ext: 'eps',
					mime: 'application/eps'
				};
			}

			return {
				ext: 'ps',
				mime: 'application/postscript'
			};
		}

		if (
			check([0x1F, 0xA0]) ||
			check([0x1F, 0x9D])
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress'
			};
		}

		// -- 3-byte signatures --

		if (check([0xFF, 0xD8, 0xFF])) {
			return {
				ext: 'jpg',
				mime: 'image/jpeg'
			};
		}

		if (check([0x49, 0x49, 0xBC])) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo'
			};
		}

		if (check([0x1F, 0x8B, 0x8])) {
			return {
				ext: 'gz',
				mime: 'application/gzip'
			};
		}

		if (check([0x42, 0x5A, 0x68])) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2'
			};
		}

		if (checkString('ID3')) {
			await tokenizer.ignore(6); // Skip ID3 header until the header size
			const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
			if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
				// Guess file type based on ID3 header for backward compatibility
				return {
					ext: 'mp3',
					mime: 'audio/mpeg'
				};
			}

			await tokenizer.ignore(id3HeaderLen);
			return fromTokenizer(tokenizer); // Skip ID3 header, recursion
		}

		// Musepack, SV7
		if (checkString('MP+')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack'
			};
		}

		if (
			(buffer[0] === 0x43 || buffer[0] === 0x46) &&
			check([0x57, 0x53], {offset: 1})
		) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash'
			};
		}

		// -- 4-byte signatures --

		if (check([0x47, 0x49, 0x46])) {
			return {
				ext: 'gif',
				mime: 'image/gif'
			};
		}

		if (checkString('FLIF')) {
			return {
				ext: 'flif',
				mime: 'image/flif'
			};
		}

		if (checkString('8BPS')) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop'
			};
		}

		if (checkString('WEBP', {offset: 8})) {
			return {
				ext: 'webp',
				mime: 'image/webp'
			};
		}

		// Musepack, SV8
		if (checkString('MPCK')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack'
			};
		}

		if (checkString('FORM')) {
			return {
				ext: 'aif',
				mime: 'audio/aiff'
			};
		}

		if (checkString('icns', {offset: 0})) {
			return {
				ext: 'icns',
				mime: 'image/icns'
			};
		}

		// Zip-based file formats
		// Need to be before the `zip` check
		if (check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature
			try {
				while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
					await tokenizer.readBuffer(buffer, {length: 30});

					// https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
					const zipHeader = {
						compressedSize: buffer.readUInt32LE(18),
						uncompressedSize: buffer.readUInt32LE(22),
						filenameLength: buffer.readUInt16LE(26),
						extraFieldLength: buffer.readUInt16LE(28)
					};

					zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));
					await tokenizer.ignore(zipHeader.extraFieldLength);

					// Assumes signed `.xpi` from addons.mozilla.org
					if (zipHeader.filename === 'META-INF/mozilla.rsa') {
						return {
							ext: 'xpi',
							mime: 'application/x-xpinstall'
						};
					}

					if (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {
						const type = zipHeader.filename.split('/')[0];
						switch (type) {
							case '_rels':
								break;
							case 'word':
								return {
									ext: 'docx',
									mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
								};
							case 'ppt':
								return {
									ext: 'pptx',
									mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
								};
							case 'xl':
								return {
									ext: 'xlsx',
									mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
								};
							default:
								break;
						}
					}

					if (zipHeader.filename.startsWith('xl/')) {
						return {
							ext: 'xlsx',
							mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
						};
					}

					if (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {
						return {
							ext: '3mf',
							mime: 'model/3mf'
						};
					}

					// The docx, xlsx and pptx file types extend the Office Open XML file format:
					// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
					// We look for:
					// - one entry named '[Content_Types].xml' or '_rels/.rels',
					// - one entry indicating specific type of file.
					// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
					if (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {
						const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));

						switch (mimeType) {
							case 'application/epub+zip':
								return {
									ext: 'epub',
									mime: 'application/epub+zip'
								};
							case 'application/vnd.oasis.opendocument.text':
								return {
									ext: 'odt',
									mime: 'application/vnd.oasis.opendocument.text'
								};
							case 'application/vnd.oasis.opendocument.spreadsheet':
								return {
									ext: 'ods',
									mime: 'application/vnd.oasis.opendocument.spreadsheet'
								};
							case 'application/vnd.oasis.opendocument.presentation':
								return {
									ext: 'odp',
									mime: 'application/vnd.oasis.opendocument.presentation'
								};
							default:
						}
					}

					// Try to find next header manually when current one is corrupted
					if (zipHeader.compressedSize === 0) {
						let nextHeaderIndex = -1;

						while (nextHeaderIndex < 0 && (tokenizer.position < tokenizer.fileInfo.size)) {
							await tokenizer.peekBuffer(buffer, {mayBeLess: true});

							nextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex');
							// Move position to the next header if found, skip the whole buffer otherwise
							await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
						}
					} else {
						await tokenizer.ignore(zipHeader.compressedSize);
					}
				}
			} catch (error) {
				if (!(error instanceof strtok3.EndOfStreamError)) {
					throw error;
				}
			}

			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		if (checkString('OggS')) {
			// This is an OGG container
			await tokenizer.ignore(28);
			const type = Buffer.alloc(8);
			await tokenizer.readBuffer(type);

			// Needs to be before `ogg` check
			if (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
				return {
					ext: 'opus',
					mime: 'audio/opus'
				};
			}

			// If ' theora' in header.
			if (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
				return {
					ext: 'ogv',
					mime: 'video/ogg'
				};
			}

			// If '\x01video' in header.
			if (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
				return {
					ext: 'ogm',
					mime: 'video/ogg'
				};
			}

			// If ' FLAC' in header  https://xiph.org/flac/faq.html
			if (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
				return {
					ext: 'oga',
					mime: 'audio/ogg'
				};
			}

			// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
			if (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
				return {
					ext: 'spx',
					mime: 'audio/ogg'
				};
			}

			// If '\x01vorbis' in header
			if (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
				return {
					ext: 'ogg',
					mime: 'audio/ogg'
				};
			}

			// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
			return {
				ext: 'ogx',
				mime: 'application/ogg'
			};
		}

		if (
			check([0x50, 0x4B]) &&
			(buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) &&
			(buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8)
		) {
			return {
				ext: 'zip',
				mime: 'application/zip'
			};
		}

		//

		// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
		// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
		// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
		// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
		if (
			checkString('ftyp', {offset: 4}) &&
			(buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
		) {
			// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
			// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
			const brandMajor = buffer.toString('binary', 8, 12).replace('\0', ' ').trim();
			switch (brandMajor) {
				case 'avif':
					return {ext: 'avif', mime: 'image/avif'};
				case 'mif1':
					return {ext: 'heic', mime: 'image/heif'};
				case 'msf1':
					return {ext: 'heic', mime: 'image/heif-sequence'};
				case 'heic':
				case 'heix':
					return {ext: 'heic', mime: 'image/heic'};
				case 'hevc':
				case 'hevx':
					return {ext: 'heic', mime: 'image/heic-sequence'};
				case 'qt':
					return {ext: 'mov', mime: 'video/quicktime'};
				case 'M4V':
				case 'M4VH':
				case 'M4VP':
					return {ext: 'm4v', mime: 'video/x-m4v'};
				case 'M4P':
					return {ext: 'm4p', mime: 'video/mp4'};
				case 'M4B':
					return {ext: 'm4b', mime: 'audio/mp4'};
				case 'M4A':
					return {ext: 'm4a', mime: 'audio/x-m4a'};
				case 'F4V':
					return {ext: 'f4v', mime: 'video/mp4'};
				case 'F4P':
					return {ext: 'f4p', mime: 'video/mp4'};
				case 'F4A':
					return {ext: 'f4a', mime: 'audio/mp4'};
				case 'F4B':
					return {ext: 'f4b', mime: 'audio/mp4'};
				case 'crx':
					return {ext: 'cr3', mime: 'image/x-canon-cr3'};
				default:
					if (brandMajor.startsWith('3g')) {
						if (brandMajor.startsWith('3g2')) {
							return {ext: '3g2', mime: 'video/3gpp2'};
						}

						return {ext: '3gp', mime: 'video/3gpp'};
					}

					return {ext: 'mp4', mime: 'video/mp4'};
			}
		}

		if (checkString('MThd')) {
			return {
				ext: 'mid',
				mime: 'audio/midi'
			};
		}

		if (
			checkString('wOFF') &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff',
				mime: 'font/woff'
			};
		}

		if (
			checkString('wOF2') &&
			(
				check([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||
				checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff2',
				mime: 'font/woff2'
			};
		}

		if (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {
			return {
				ext: 'pcap',
				mime: 'application/vnd.tcpdump.pcap'
			};
		}

		// Sony DSD Stream File (DSF)
		if (checkString('DSD ')) {
			return {
				ext: 'dsf',
				mime: 'audio/x-dsf' // Non-standard
			};
		}

		if (checkString('LZIP')) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip'
			};
		}

		if (checkString('fLaC')) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac'
			};
		}

		if (check([0x42, 0x50, 0x47, 0xFB])) {
			return {
				ext: 'bpg',
				mime: 'image/bpg'
			};
		}

		if (checkString('wvpk')) {
			return {
				ext: 'wv',
				mime: 'audio/wavpack'
			};
		}

		if (checkString('%PDF')) {
			await tokenizer.ignore(1350);
			const maxBufferSize = 10 * 1024 * 1024;
			const buffer = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
			await tokenizer.readBuffer(buffer, {mayBeLess: true});

			// Check if this is an Adobe Illustrator file
			if (buffer.includes(Buffer.from('AIPrivateData'))) {
				return {
					ext: 'ai',
					mime: 'application/postscript'
				};
			}

			// Assume this is just a normal PDF
			return {
				ext: 'pdf',
				mime: 'application/pdf'
			};
		}

		if (check([0x00, 0x61, 0x73, 0x6D])) {
			return {
				ext: 'wasm',
				mime: 'application/wasm'
			};
		}

		// TIFF, little-endian type
		if (check([0x49, 0x49, 0x2A, 0x0])) {
			if (checkString('CR', {offset: 8})) {
				return {
					ext: 'cr2',
					mime: 'image/x-canon-cr2'
				};
			}

			if (check([0x1C, 0x00, 0xFE, 0x00], {offset: 8}) || check([0x1F, 0x00, 0x0B, 0x00], {offset: 8})) {
				return {
					ext: 'nef',
					mime: 'image/x-nikon-nef'
				};
			}

			if (
				check([0x08, 0x00, 0x00, 0x00], {offset: 4}) &&
				(check([0x2D, 0x00, 0xFE, 0x00], {offset: 8}) ||
					check([0x27, 0x00, 0xFE, 0x00], {offset: 8}))
			) {
				return {
					ext: 'dng',
					mime: 'image/x-adobe-dng'
				};
			}

			buffer = Buffer.alloc(24);
			await tokenizer.peekBuffer(buffer);
			if (
				(check([0x10, 0xFB, 0x86, 0x01], {offset: 4}) || check([0x08, 0x00, 0x00, 0x00], {offset: 4})) &&
				// This pattern differentiates ARW from other TIFF-ish file types:
				check([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {offset: 9})
			) {
				return {
					ext: 'arw',
					mime: 'image/x-sony-arw'
				};
			}

			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		// TIFF, big-endian type
		if (check([0x4D, 0x4D, 0x0, 0x2A])) {
			return {
				ext: 'tif',
				mime: 'image/tiff'
			};
		}

		if (checkString('MAC ')) {
			return {
				ext: 'ape',
				mime: 'audio/ape'
			};
		}

		// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska
		if (check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML
			async function readField() {
				const msb = await tokenizer.peekNumber(Token.UINT8);
				let mask = 0x80;
				let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

				while ((msb & mask) === 0 && mask !== 0) {
					++ic;
					mask >>= 1;
				}

				const id = Buffer.alloc(ic + 1);
				await tokenizer.readBuffer(id);
				return id;
			}

			async function readElement() {
				const id = await readField();
				const lenField = await readField();
				lenField[0] ^= 0x80 >> (lenField.length - 1);
				const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer
				return {
					id: id.readUIntBE(0, id.length),
					len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
				};
			}

			async function readChildren(level, children) {
				while (children > 0) {
					const e = await readElement();
					if (e.id === 0x4282) {
						return tokenizer.readToken(new Token.StringType(e.len, 'utf-8')); // Return DocType
					}

					await tokenizer.ignore(e.len); // ignore payload
					--children;
				}
			}

			const re = await readElement();
			const docType = await readChildren(1, re.len);

			switch (docType) {
				case 'webm':
					return {
						ext: 'webm',
						mime: 'video/webm'
					};

				case 'matroska':
					return {
						ext: 'mkv',
						mime: 'video/x-matroska'
					};

				default:
					return;
			}
		}

		// RIFF file format which might be AVI, WAV, QCP, etc
		if (check([0x52, 0x49, 0x46, 0x46])) {
			if (check([0x41, 0x56, 0x49], {offset: 8})) {
				return {
					ext: 'avi',
					mime: 'video/vnd.avi'
				};
			}

			if (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
				return {
					ext: 'wav',
					mime: 'audio/vnd.wave'
				};
			}

			// QLCM, QCP file
			if (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
				return {
					ext: 'qcp',
					mime: 'audio/qcelp'
				};
			}
		}

		if (checkString('SQLi')) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3'
			};
		}

		if (check([0x4E, 0x45, 0x53, 0x1A])) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom'
			};
		}

		if (checkString('Cr24')) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension'
			};
		}

		if (
			checkString('MSCF') ||
			checkString('ISc(')
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed'
			};
		}

		if (check([0xED, 0xAB, 0xEE, 0xDB])) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm'
			};
		}

		if (check([0xC5, 0xD0, 0xD3, 0xC6])) {
			return {
				ext: 'eps',
				mime: 'application/eps'
			};
		}

		if (check([0x28, 0xB5, 0x2F, 0xFD])) {
			return {
				ext: 'zst',
				mime: 'application/zstd'
			};
		}

		// -- 5-byte signatures --

		if (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
			return {
				ext: 'otf',
				mime: 'font/otf'
			};
		}

		if (checkString('#!AMR')) {
			return {
				ext: 'amr',
				mime: 'audio/amr'
			};
		}

		if (checkString('{\\rtf')) {
			return {
				ext: 'rtf',
				mime: 'application/rtf'
			};
		}

		if (check([0x46, 0x4C, 0x56, 0x01])) {
			return {
				ext: 'flv',
				mime: 'video/x-flv'
			};
		}

		if (checkString('IMPM')) {
			return {
				ext: 'it',
				mime: 'audio/x-it'
			};
		}

		if (
			checkString('-lh0-', {offset: 2}) ||
			checkString('-lh1-', {offset: 2}) ||
			checkString('-lh2-', {offset: 2}) ||
			checkString('-lh3-', {offset: 2}) ||
			checkString('-lh4-', {offset: 2}) ||
			checkString('-lh5-', {offset: 2}) ||
			checkString('-lh6-', {offset: 2}) ||
			checkString('-lh7-', {offset: 2}) ||
			checkString('-lzs-', {offset: 2}) ||
			checkString('-lz4-', {offset: 2}) ||
			checkString('-lz5-', {offset: 2}) ||
			checkString('-lhd-', {offset: 2})
		) {
			return {
				ext: 'lzh',
				mime: 'application/x-lzh-compressed'
			};
		}

		// MPEG program stream (PS or MPEG-PS)
		if (check([0x00, 0x00, 0x01, 0xBA])) {
			//  MPEG-PS, MPEG-1 Part 1
			if (check([0x21], {offset: 4, mask: [0xF1]})) {
				return {
					ext: 'mpg', // May also be .ps, .mpeg
					mime: 'video/MP1S'
				};
			}

			// MPEG-PS, MPEG-2 Part 1
			if (check([0x44], {offset: 4, mask: [0xC4]})) {
				return {
					ext: 'mpg', // May also be .mpg, .m2p, .vob or .sub
					mime: 'video/MP2P'
				};
			}
		}

		if (checkString('ITSF')) {
			return {
				ext: 'chm',
				mime: 'application/vnd.ms-htmlhelp'
			};
		}

		// -- 6-byte signatures --

		if (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
			return {
				ext: 'xz',
				mime: 'application/x-xz'
			};
		}

		if (checkString('<?xml ')) {
			return {
				ext: 'xml',
				mime: 'application/xml'
			};
		}

		if (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed'
			};
		}

		if (
			check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&
			(buffer[6] === 0x0 || buffer[6] === 0x1)
		) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed'
			};
		}

		if (checkString('solid ')) {
			return {
				ext: 'stl',
				mime: 'model/stl'
			};
		}

		// -- 7-byte signatures --

		if (checkString('BLENDER')) {
			return {
				ext: 'blend',
				mime: 'application/x-blender'
			};
		}

		if (checkString('!<arch>')) {
			await tokenizer.ignore(8);
			const str = await tokenizer.readToken(new Token.StringType(13, 'ascii'));
			if (str === 'debian-binary') {
				return {
					ext: 'deb',
					mime: 'application/x-deb'
				};
			}

			return {
				ext: 'ar',
				mime: 'application/x-unix-archive'
			};
		}

		// -- 8-byte signatures --

		if (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
			// APNG format (https://wiki.mozilla.org/APNG_Specification)
			// 1. Find the first IDAT (image data) chunk (49 44 41 54)
			// 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)

			// Offset calculated as follows:
			// - 8 bytes: PNG signature
			// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk

			await tokenizer.ignore(8); // ignore PNG signature

			async function readChunkHeader() {
				return {
					length: await tokenizer.readToken(Token.INT32_BE),
					type: await tokenizer.readToken(new Token.StringType(4, 'binary'))
				};
			}

			do {
				const chunk = await readChunkHeader();
				if (chunk.length < 0) {
					return; // Invalid chunk length
				}

				switch (chunk.type) {
					case 'IDAT':
						return {
							ext: 'png',
							mime: 'image/png'
						};
					case 'acTL':
						return {
							ext: 'apng',
							mime: 'image/apng'
						};
					default:
						await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
				}
			} while (tokenizer.position + 8 < tokenizer.fileInfo.size);

			return {
				ext: 'png',
				mime: 'image/png'
			};
		}

		if (check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
			return {
				ext: 'arrow',
				mime: 'application/x-apache-arrow'
			};
		}

		if (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
			return {
				ext: 'glb',
				mime: 'model/gltf-binary'
			};
		}

		// `mov` format variants
		if (
			check([0x66, 0x72, 0x65, 0x65], {offset: 4}) || // `free`
			check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // `mdat` MJPEG
			check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) || // `moov`
			check([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`
		) {
			return {
				ext: 'mov',
				mime: 'video/quicktime'
			};
		}

		// -- 9-byte signatures --

		if (check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
			return {
				ext: 'orf',
				mime: 'image/x-olympus-orf'
			};
		}

		if (checkString('gimp xcf ')) {
			return {
				ext: 'xcf',
				mime: 'image/x-xcf'
			};
		}

		// -- 12-byte signatures --

		if (check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
			return {
				ext: 'rw2',
				mime: 'image/x-panasonic-rw2'
			};
		}

		// ASF_Header_Object first 80 bytes
		if (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
			async function readHeader() {
				const guid = Buffer.alloc(16);
				await tokenizer.readBuffer(guid);
				return {
					id: guid,
					size: Number(await tokenizer.readToken(Token.UINT64_LE))
				};
			}

			await tokenizer.ignore(30);
			// Search for header should be in first 1KB of file.
			while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
				const header = await readHeader();
				let payload = header.size - 24;
				if (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
					// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
					const typeId = Buffer.alloc(16);
					payload -= await tokenizer.readBuffer(typeId);

					if (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found audio:
						return {
							ext: 'asf',
							mime: 'audio/x-ms-asf'
						};
					}

					if (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found video:
						return {
							ext: 'asf',
							mime: 'video/x-ms-asf'
						};
					}

					break;
				}

				await tokenizer.ignore(payload);
			}

			// Default to ASF generic extension
			return {
				ext: 'asf',
				mime: 'application/vnd.ms-asf'
			};
		}

		if (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
			return {
				ext: 'ktx',
				mime: 'image/ktx'
			};
		}

		if ((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {
			return {
				ext: 'mie',
				mime: 'application/x-mie'
			};
		}

		if (check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {
			return {
				ext: 'shp',
				mime: 'application/x-esri-shape'
			};
		}

		if (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
			// JPEG-2000 family

			await tokenizer.ignore(20);
			const type = await tokenizer.readToken(new Token.StringType(4, 'ascii'));
			switch (type) {
				case 'jp2 ':
					return {
						ext: 'jp2',
						mime: 'image/jp2'
					};
				case 'jpx ':
					return {
						ext: 'jpx',
						mime: 'image/jpx'
					};
				case 'jpm ':
					return {
						ext: 'jpm',
						mime: 'image/jpm'
					};
				case 'mjp2':
					return {
						ext: 'mj2',
						mime: 'image/mj2'
					};
				default:
					return;
			}
		}

		if (
			check([0xFF, 0x0A]) ||
			check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])
		) {
			return {
				ext: 'jxl',
				mime: 'image/jxl'
			};
		}

		// -- Unsafe signatures --

		if (
			check([0x0, 0x0, 0x1, 0xBA]) ||
			check([0x0, 0x0, 0x1, 0xB3])
		) {
			return {
				ext: 'mpg',
				mime: 'video/mpeg'
			};
		}

		if (check([0x00, 0x01, 0x00, 0x00, 0x00])) {
			return {
				ext: 'ttf',
				mime: 'font/ttf'
			};
		}

		if (check([0x00, 0x00, 0x01, 0x00])) {
			return {
				ext: 'ico',
				mime: 'image/x-icon'
			};
		}

		if (check([0x00, 0x00, 0x02, 0x00])) {
			return {
				ext: 'cur',
				mime: 'image/x-icon'
			};
		}

		if (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
			// Detected Microsoft Compound File Binary File (MS-CFB) Format.
			return {
				ext: 'cfb',
				mime: 'application/x-cfb'
			};
		}

		// Increase sample size from 12 to 256.
		await tokenizer.peekBuffer(buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});

		// -- 15-byte signatures --

		if (checkString('BEGIN:')) {
			if (checkString('VCARD', {offset: 6})) {
				return {
					ext: 'vcf',
					mime: 'text/vcard'
				};
			}

			if (checkString('VCALENDAR', {offset: 6})) {
				return {
					ext: 'ics',
					mime: 'text/calendar'
				};
			}
		}

		// `raf` is here just to keep all the raw image detectors together.
		if (checkString('FUJIFILMCCD-RAW')) {
			return {
				ext: 'raf',
				mime: 'image/x-fujifilm-raf'
			};
		}

		if (checkString('Extended Module:')) {
			return {
				ext: 'xm',
				mime: 'audio/x-xm'
			};
		}

		if (checkString('Creative Voice File')) {
			return {
				ext: 'voc',
				mime: 'audio/x-voc'
			};
		}

		if (check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16) { // Rough & quick check Pickle/ASAR
			const jsonSize = buffer.readUInt32LE(12);
			if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
				try {
					const header = buffer.slice(16, jsonSize + 16).toString();
					const json = JSON.parse(header);
					// Check if Pickle is ASAR
					if (json.files) { // Final check, assuring Pickle/ASAR format
						return {
							ext: 'asar',
							mime: 'application/x-asar'
						};
					}
				} catch (_) {
				}
			}
		}

		if (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
			return {
				ext: 'mxf',
				mime: 'application/mxf'
			};
		}

		if (checkString('SCRM', {offset: 44})) {
			return {
				ext: 's3m',
				mime: 'audio/x-s3m'
			};
		}

		if (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {
			return {
				ext: 'mts',
				mime: 'video/mp2t'
			};
		}

		if (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
			return {
				ext: 'mobi',
				mime: 'application/x-mobipocket-ebook'
			};
		}

		if (check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {
			return {
				ext: 'dcm',
				mime: 'application/dicom'
			};
		}

		if (check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
			return {
				ext: 'lnk',
				mime: 'application/x.ms.shortcut' // Invented by us
			};
		}

		if (check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
			return {
				ext: 'alias',
				mime: 'application/x.apple.alias' // Invented by us
			};
		}

		if (
			check([0x4C, 0x50], {offset: 34}) &&
			(
				check([0x00, 0x00, 0x01], {offset: 8}) ||
				check([0x01, 0x00, 0x02], {offset: 8}) ||
				check([0x02, 0x00, 0x02], {offset: 8})
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/vnd.ms-fontobject'
			};
		}

		if (check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
			return {
				ext: 'indd',
				mime: 'application/x-indesign'
			};
		}

		// Increase sample size from 256 to 512
		await tokenizer.peekBuffer(buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});

		// Requires a buffer size of 512 bytes
		if (tarHeaderChecksumMatches(buffer)) {
			return {
				ext: 'tar',
				mime: 'application/x-tar'
			};
		}

		if (check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {
			return {
				ext: 'skp',
				mime: 'application/vnd.sketchup.skp'
			};
		}

		if (checkString('-----BEGIN PGP MESSAGE-----')) {
			return {
				ext: 'pgp',
				mime: 'application/pgp-encrypted'
			};
		}

		// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
		if (buffer.length >= 2 && check([0xFF, 0xE0], {offset: 0, mask: [0xFF, 0xE0]})) {
			if (check([0x10], {offset: 1, mask: [0x16]})) {
				// Check for (ADTS) MPEG-2
				if (check([0x08], {offset: 1, mask: [0x08]})) {
					return {
						ext: 'aac',
						mime: 'audio/aac'
					};
				}

				// Must be (ADTS) MPEG-4
				return {
					ext: 'aac',
					mime: 'audio/aac'
				};
			}

			// MPEG 1 or 2 Layer 3 header
			// Check for MPEG layer 3
			if (check([0x02], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp3',
					mime: 'audio/mpeg'
				};
			}

			// Check for MPEG layer 2
			if (check([0x04], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp2',
					mime: 'audio/mpeg'
				};
			}

			// Check for MPEG layer 1
			if (check([0x06], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp1',
					mime: 'audio/mpeg'
				};
			}
		}
	}

	const stream = readableStream => new Promise((resolve, reject) => {
		// Using `eval` to work around issues when bundling with Webpack
		const stream = eval('require')('stream'); // eslint-disable-line no-eval

		readableStream.on('error', reject);
		readableStream.once('readable', async () => {
			// Set up output stream
			const pass = new stream.PassThrough();
			let outputStream;
			if (stream.pipeline) {
				outputStream = stream.pipeline(readableStream, pass, () => {
				});
			} else {
				outputStream = readableStream.pipe(pass);
			}

			// Read the input stream and detect the filetype
			const chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
			try {
				const fileType = await fromBuffer(chunk);
				pass.fileType = fileType;
			} catch (error) {
				reject(error);
			}

			resolve(outputStream);
		});
	});

	const fileType = {
		fromStream,
		fromTokenizer,
		fromBuffer,
		stream
	};

	Object.defineProperty(fileType, 'extensions', {
		get() {
			return new Set(supported.extensions);
		}
	});

	Object.defineProperty(fileType, 'mimeTypes', {
		get() {
			return new Set(supported.mimeTypes);
		}
	});

	core$1 = fileType;
	return core$1;
}

var coreExports$1 = requireCore$1();
var fileType = /*@__PURE__*/getDefaultExportFromCjs(coreExports$1);

/**
 * @param { Promise } promise
 * @param { Object= } errorExt - Additional Information you can pass to the err object
 * @return { Promise }
 */
function to(promise, errorExt) {
    return promise
        .then(function (data) { return [null, data]; })
        .catch(function (err) {
        return [err, undefined];
    });
}

const readFile = promises.readFile;
const writeFile = promises.writeFile;

var Mime_1;
var hasRequiredMime;

function requireMime () {
	if (hasRequiredMime) return Mime_1;
	hasRequiredMime = 1;

	/**
	 * @param typeMap [Object] Map of MIME type -> Array[extensions]
	 * @param ...
	 */
	function Mime() {
	  this._types = Object.create(null);
	  this._extensions = Object.create(null);

	  for (let i = 0; i < arguments.length; i++) {
	    this.define(arguments[i]);
	  }

	  this.define = this.define.bind(this);
	  this.getType = this.getType.bind(this);
	  this.getExtension = this.getExtension.bind(this);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * If a type declares an extension that has already been defined, an error will
	 * be thrown.  To suppress this error and force the extension to be associated
	 * with the new type, pass `force`=true.  Alternatively, you may prefix the
	 * extension with "*" to map the type to extension, without mapping the
	 * extension to the type.
	 *
	 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
	 *
	 *
	 * @param map (Object) type definitions
	 * @param force (Boolean) if true, force overriding of existing definitions
	 */
	Mime.prototype.define = function(typeMap, force) {
	  for (let type in typeMap) {
	    let extensions = typeMap[type].map(function(t) {
	      return t.toLowerCase();
	    });
	    type = type.toLowerCase();

	    for (let i = 0; i < extensions.length; i++) {
	      const ext = extensions[i];

	      // '*' prefix = not the preferred type for this extension.  So fixup the
	      // extension, and skip it.
	      if (ext[0] === '*') {
	        continue;
	      }

	      if (!force && (ext in this._types)) {
	        throw new Error(
	          'Attempt to change mapping for "' + ext +
	          '" extension from "' + this._types[ext] + '" to "' + type +
	          '". Pass `force=true` to allow this, otherwise remove "' + ext +
	          '" from the list of extensions for "' + type + '".'
	        );
	      }

	      this._types[ext] = type;
	    }

	    // Use first extension as default
	    if (force || !this._extensions[type]) {
	      const ext = extensions[0];
	      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
	    }
	  }
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.getType = function(path) {
	  path = String(path);
	  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
	  let ext = last.replace(/^.*\./, '').toLowerCase();

	  let hasPath = last.length < path.length;
	  let hasDot = ext.length < last.length - 1;

	  return (hasDot || !hasPath) && this._types[ext] || null;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.getExtension = function(type) {
	  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
	  return type && this._extensions[type.toLowerCase()] || null;
	};

	Mime_1 = Mime;
	return Mime_1;
}

var standard;
var hasRequiredStandard;

function requireStandard () {
	if (hasRequiredStandard) return standard;
	hasRequiredStandard = 1;
	standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};
	return standard;
}

var lite;
var hasRequiredLite;

function requireLite () {
	if (hasRequiredLite) return lite;
	hasRequiredLite = 1;

	let Mime = requireMime();
	lite = new Mime(requireStandard());
	return lite;
}

var liteExports = requireLite();
var mime = /*@__PURE__*/getDefaultExportFromCjs(liteExports);

/* Horizontal align modes for cover, contain, bit masks */
var HorizontalAlign;
(function (HorizontalAlign) {
    HorizontalAlign[HorizontalAlign["LEFT"] = 1] = "LEFT";
    HorizontalAlign[HorizontalAlign["CENTER"] = 2] = "CENTER";
    HorizontalAlign[HorizontalAlign["RIGHT"] = 4] = "RIGHT";
})(HorizontalAlign || (HorizontalAlign = {}));
/* Vertical align modes for cover, contain, bit masks */
var VerticalAlign;
(function (VerticalAlign) {
    VerticalAlign[VerticalAlign["TOP"] = 8] = "TOP";
    VerticalAlign[VerticalAlign["MIDDLE"] = 16] = "MIDDLE";
    VerticalAlign[VerticalAlign["BOTTOM"] = 32] = "BOTTOM";
})(VerticalAlign || (VerticalAlign = {}));
/**
 * How to blend two images together
 */
var BlendMode;
(function (BlendMode) {
    /**
     * Composite the source image over the destination image.
     * This is the default value. It represents the most intuitive case, where shapes are painted on top of what is below, with transparent areas showing the destination layer.
     */
    BlendMode["SRC_OVER"] = "srcOver";
    /** Composite the source image under the destination image. */
    BlendMode["DST_OVER"] = "dstOver";
    /**
     * Multiply the color components of the source and destination images.
     * This can only result in the same or darker colors (multiplying by white, 1.0, results in no change; multiplying by black, 0.0, results in black).
     * When compositing two opaque images, this has similar effect to overlapping two transparencies on a projector.
     *
     * This mode is useful for coloring shadows.
     */
    BlendMode["MULTIPLY"] = "multiply";
    /**
     * The Add mode adds the color information of the base layers and the blending layer.
     * In digital terms, adding color increases the brightness.
     */
    BlendMode["ADD"] = "add";
    /**
     * Multiply the inverse of the components of the source and destination images, and inverse the result.
     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.
     * This is essentially the same as modulate blend mode, but with the values of the colors inverted before the multiplication and the result being inverted back before rendering.
     * This can only result in the same or lighter colors (multiplying by black, 1.0, results in no change; multiplying by white, 0.0, results in white). Similarly, in the alpha channel, it can only result in more opaque colors.
     * This has similar effect to two projectors displaying their images on the same screen simultaneously.
     */
    BlendMode["SCREEN"] = "screen";
    /**
     * Multiply the components of the source and destination images after adjusting them to favor the destination.
     * Specifically, if the destination value is smaller, this multiplies it with the source value, whereas is the source value is smaller, it multiplies the inverse of the source value with the inverse of the destination value, then inverts the result.
     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.
     *
     * The Overlay mode behaves like Screen mode in bright areas, and like Multiply mode in darker areas.
     * With this mode, the bright areas will look brighter and the dark areas will look darker.
     */
    BlendMode["OVERLAY"] = "overlay";
    /**
     * Composite the source and destination image by choosing the lowest value from each color channel.
     * The opacity of the output image is computed in the same way as for srcOver.
     */
    BlendMode["DARKEN"] = "darken";
    /**
     * Composite the source and destination image by choosing the highest value from each color channel.
     * The opacity of the output image is computed in the same way as for srcOver.
     */
    BlendMode["LIGHTEN"] = "lighten";
    /**
     * Multiply the components of the source and destination images after adjusting them to favor the source.
     * Specifically, if the source value is smaller, this multiplies it with the destination value, whereas is the destination value is smaller, it multiplies the inverse of the destination value with the inverse of the source value, then inverts the result.
     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.
     *
     * The effect of the Hard light mode depends on the density of the superimposed color. Using bright colors on the blending layer will create a brighter effect like the Screen modes, while dark colors will create darker colors like the Multiply mode.
     */
    BlendMode["HARD_LIGHT"] = "hardLight";
    /**
     * Subtract the smaller value from the bigger value for each channel.
     * Compositing black has no effect; compositing white inverts the colors of the other image.
     * The opacity of the output image is computed in the same way as for srcOver.
     * The effect is similar to exclusion but harsher.
     */
    BlendMode["DIFFERENCE"] = "difference";
    /**
     * Subtract double the product of the two images from the sum of the two images.
     * Compositing black has no effect; compositing white inverts the colors of the other image.
     * The opacity of the output image is computed in the same way as for srcOver.
     * The effect is similar to difference but softer.
     */
    BlendMode["EXCLUSION"] = "exclusion";
})(BlendMode || (BlendMode = {}));

function srcOver(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
    const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
    const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
    return { r, g, b, a };
}
function dstOver(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
    const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
    const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
    return { r, g, b, a };
}
function multiply(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
    const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
    const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
    return { r, g, b, a };
}
function add$1(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra + dra) / a;
    const g = (sga + dga) / a;
    const b = (sba + dba) / a;
    return { r, g, b, a };
}
function screen(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra * dst.a +
        dra * src.a -
        sra * dra +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (sga * dst.a +
        dga * src.a -
        sga * dga +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (sba * dst.a +
        dba * src.a -
        sba * dba +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
function overlay(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (2 * dra <= dst.a
        ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)
        : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /
        a;
    const g = (2 * dga <= dst.a
        ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)
        : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /
        a;
    const b = (2 * dba <= dst.a
        ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)
        : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /
        a;
    return { r, g, b, a };
}
function darken(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (Math.min(sra * dst.a, dra * src.a) +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (Math.min(sga * dst.a, dga * src.a) +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (Math.min(sba * dst.a, dba * src.a) +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
function lighten(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (Math.max(sra * dst.a, dra * src.a) +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (Math.max(sga * dst.a, dga * src.a) +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (Math.max(sba * dst.a, dba * src.a) +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
function hardLight(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (2 * sra <= src.a
        ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)
        : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /
        a;
    const g = (2 * sga <= src.a
        ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)
        : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /
        a;
    const b = (2 * sba <= src.a
        ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)
        : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /
        a;
    return { r, g, b, a };
}
function difference(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
    const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
    const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
    return { r, g, b, a };
}
function exclusion(src, dst, ops = 1) {
    src.a *= ops;
    const a = dst.a + src.a - dst.a * src.a;
    const sra = src.r * src.a;
    const sga = src.g * src.a;
    const sba = src.b * src.a;
    const dra = dst.r * dst.a;
    const dga = dst.g * dst.a;
    const dba = dst.b * dst.a;
    const r = (sra * dst.a +
        dra * src.a -
        2 * sra * dra +
        sra * (1 - dst.a) +
        dra * (1 - src.a)) /
        a;
    const g = (sga * dst.a +
        dga * src.a -
        2 * sga * dga +
        sga * (1 - dst.a) +
        dga * (1 - src.a)) /
        a;
    const b = (sba * dst.a +
        dba * src.a -
        2 * sba * dba +
        sba * (1 - dst.a) +
        dba * (1 - src.a)) /
        a;
    return { r, g, b, a };
}
const names = [
    srcOver,
    dstOver,
    multiply,
    add$1,
    screen,
    overlay,
    darken,
    lighten,
    hardLight,
    difference,
    exclusion,
];

var compositeModes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$1,
    darken: darken,
    difference: difference,
    dstOver: dstOver,
    exclusion: exclusion,
    hardLight: hardLight,
    lighten: lighten,
    multiply: multiply,
    names: names,
    overlay: overlay,
    screen: screen,
    srcOver: srcOver
});

function composite(baseImage, src, x = 0, y = 0, options = {}) {
    if (!(src instanceof baseImage.constructor)) {
        throw new Error("The source must be a Jimp image");
    }
    if (typeof x !== "number" || typeof y !== "number") {
        throw new Error("x and y must be numbers");
    }
    const { mode = BlendMode.SRC_OVER } = options;
    let { opacitySource = 1.0, opacityDest = 1.0 } = options;
    if (typeof opacitySource !== "number" ||
        opacitySource < 0 ||
        opacitySource > 1) {
        opacitySource = 1.0;
    }
    if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
        opacityDest = 1.0;
    }
    const blendmode = compositeModes[mode];
    // round input
    x = Math.round(x);
    y = Math.round(y);
    if (opacityDest !== 1.0) {
        baseImage.scan((_, __, idx) => {
            const v = baseImage.bitmap.data[idx + 3] * opacityDest;
            baseImage.bitmap.data[idx + 3] = v;
        });
    }
    src.scan((sx, sy, idx) => {
        const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, Edge.CROP);
        if (dstIdx === -1) {
            // Skip target pixels outside of dst
            return;
        }
        const blended = blendmode({
            r: src.bitmap.data[idx + 0] / 255,
            g: src.bitmap.data[idx + 1] / 255,
            b: src.bitmap.data[idx + 2] / 255,
            a: src.bitmap.data[idx + 3] / 255,
        }, {
            r: baseImage.bitmap.data[dstIdx + 0] / 255,
            g: baseImage.bitmap.data[dstIdx + 1] / 255,
            b: baseImage.bitmap.data[dstIdx + 2] / 255,
            a: baseImage.bitmap.data[dstIdx + 3] / 255,
        }, opacitySource);
        baseImage.bitmap.data[dstIdx + 0] = limit255(blended.r * 255);
        baseImage.bitmap.data[dstIdx + 1] = limit255(blended.g * 255);
        baseImage.bitmap.data[dstIdx + 2] = limit255(blended.b * 255);
        baseImage.bitmap.data[dstIdx + 3] = limit255(blended.a * 255);
    });
    return baseImage;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var jpeg;
var hasRequiredJpeg;

function requireJpeg () {
	if (hasRequiredJpeg) return jpeg;
	hasRequiredJpeg = 1;
	jpeg = {
		parseSections: function(stream, iterator) {
			var len, markerType;
			stream.setBigEndian(true);
			//stop reading the stream at the SOS (Start of Stream) marker,
			//because its length is not stored in the header so we can't
			//know where to jump to. The only marker after that is just EOI (End Of Image) anyway
			while(stream.remainingLength() > 0 && markerType !== 0xDA) {
				if(stream.nextUInt8() !== 0xFF) {
					throw new Error('Invalid JPEG section offset');
				}
				markerType = stream.nextUInt8();
				//don't read size from markers that have no datas
				if((markerType >= 0xD0 && markerType <= 0xD9) || markerType === 0xDA) {
					len = 0;
				} else {
					len = stream.nextUInt16() - 2;
				}
				iterator(markerType, stream.branch(0, len));
				stream.skip(len);
			}
		},
		//stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
		getSizeFromSOFSection: function(stream) {
			stream.skip(1);
			return {
				height: stream.nextUInt16(),
				width: stream.nextUInt16()
			};
		},
		getSectionName: function(markerType) {
			var name, index;
			switch(markerType) {
				case 0xD8: name = 'SOI'; break;
				case 0xC4: name = 'DHT'; break;
				case 0xDB: name = 'DQT'; break;
				case 0xDD: name = 'DRI'; break;
				case 0xDA: name = 'SOS'; break;
				case 0xFE: name = 'COM'; break;
				case 0xD9: name = 'EOI'; break;
				default:
					if(markerType >= 0xE0 && markerType <= 0xEF) {
						name = 'APP';
						index = markerType - 0xE0;
					}
					else if(markerType >= 0xC0 && markerType <= 0xCF && markerType !== 0xC4 && markerType !== 0xC8 && markerType !== 0xCC) {
						name = 'SOF';
						index = markerType - 0xC0;
					}
					else if(markerType >= 0xD0 && markerType <= 0xD7) {
						name = 'RST';
						index = markerType - 0xD0;
					}
					break;
			}
			var nameStruct = {
				name: name
			};
			if(typeof index === 'number') {
				nameStruct.index = index;
			}
			return nameStruct;
		}
	};
	return jpeg;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var exif;
var hasRequiredExif;

function requireExif () {
	if (hasRequiredExif) return exif;
	hasRequiredExif = 1;
	function readExifValue(format, stream) {
		switch(format) {
			case 1: return stream.nextUInt8();
			case 3: return stream.nextUInt16();
			case 4: return stream.nextUInt32();
			case 5: return [stream.nextUInt32(), stream.nextUInt32()];
			case 6: return stream.nextInt8();
			case 8: return stream.nextUInt16();
			case 9: return stream.nextUInt32();
			case 10: return [stream.nextInt32(), stream.nextInt32()];
			case 11: return stream.nextFloat();
			case 12: return stream.nextDouble();
			default: throw new Error('Invalid format while decoding: ' + format);
		}
	}

	function getBytesPerComponent(format) {
		switch(format) {
			case 1:
			case 2:
			case 6:
			case 7:
				return 1;
			case 3:
			case 8:
				return 2;
			case 4:
			case 9:
			case 11:
				return 4;
			case 5:
			case 10:
			case 12:
				return 8;
			default:
				return 0;
		}
	}

	function readExifTag(tiffMarker, stream) {
		var tagType = stream.nextUInt16(),
			format = stream.nextUInt16(),
			bytesPerComponent = getBytesPerComponent(format),
			components = stream.nextUInt32(),
			valueBytes = bytesPerComponent * components,
			values,
			c;

		/* if the value is bigger then 4 bytes, the value is in the data section of the IFD
		and the value present in the tag is the offset starting from the tiff header. So we replace the stream
		with a stream that is located at the given offset in the data section. s*/
		if(valueBytes > 4) {
			stream = tiffMarker.openWithOffset(stream.nextUInt32());
		}
		//we don't want to read strings as arrays
		if(format === 2) {
			values = stream.nextString(components);
			//cut off \0 characters
			var lastNull = values.indexOf('\0');
			if(lastNull !== -1) {
				values = values.substr(0, lastNull);
			}
		}
		else if(format === 7) {
			values = stream.nextBuffer(components);
		}
		else if(format !== 0) {
			values = [];
			for(c = 0; c < components; ++c) {
				values.push(readExifValue(format, stream));
			}
		}
		//since our stream is a stateful object, we need to skip remaining bytes
		//so our offset stays correct
		if(valueBytes < 4) {
			stream.skip(4 - valueBytes);
		}

		return [tagType, values, format];
	}

	function readIFDSection(tiffMarker, stream, iterator) {
		var numberOfEntries = stream.nextUInt16(), tag, i;
		for(i = 0; i < numberOfEntries; ++i) {
			tag = readExifTag(tiffMarker, stream);
			iterator(tag[0], tag[1], tag[2]);
		}
	}

	function readHeader(stream) {
		var exifHeader = stream.nextString(6);
		if(exifHeader !== 'Exif\0\0') {
			throw new Error('Invalid EXIF header');
		}

		var tiffMarker = stream.mark();
		var tiffHeader = stream.nextUInt16();
		if(tiffHeader === 0x4949) {
			stream.setBigEndian(false);
		} else if(tiffHeader === 0x4D4D) {
			stream.setBigEndian(true);
		} else {
			throw new Error('Invalid TIFF header');
		}
		if(stream.nextUInt16() !== 0x002A) {
			throw new Error('Invalid TIFF data');
		}
		return tiffMarker;
	}

	exif = {
		IFD0: 1,
		IFD1: 2,
		GPSIFD: 3,
		SubIFD: 4,
		InteropIFD: 5,
		parseTags: function(stream, iterator) {
			var tiffMarker;
			try {
				tiffMarker = readHeader(stream);
			} catch(e) {
				return false;	//ignore APP1 sections with invalid headers
			}
			var subIfdOffset, gpsOffset, interopOffset;
			var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()),
				IFD0 = this.IFD0;
			readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {
				switch(tagType) {
					case 0x8825: gpsOffset = value[0]; break;
					case 0x8769: subIfdOffset = value[0]; break;
					default: iterator(IFD0, tagType, value, format); break;
				}
			});
			var ifd1Offset = ifd0Stream.nextUInt32();
			if(ifd1Offset !== 0) {
				var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
				readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
			}

			if(gpsOffset) {
				var gpsStream = tiffMarker.openWithOffset(gpsOffset);
				readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
			}

			if(subIfdOffset) {
				var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
				readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {
					if(tagType === 0xA005) {
						interopOffset = value[0];
					} else {
						iterator(InteropIFD, tagType, value, format);
					}
				});
			}

			if(interopOffset) {
				var interopStream = tiffMarker.openWithOffset(interopOffset);
				readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
			}
			return true;
		}
	};
	return exif;
}

var date;
var hasRequiredDate;

function requireDate () {
	if (hasRequiredDate) return date;
	hasRequiredDate = 1;
	function parseNumber(s) {
		return parseInt(s, 10);
	}

	//in seconds
	var hours = 3600;
	var minutes = 60;

	//take date (year, month, day) and time (hour, minutes, seconds) digits in UTC
	//and return a timestamp in seconds
	function parseDateTimeParts(dateParts, timeParts) {
		dateParts = dateParts.map(parseNumber);
		timeParts = timeParts.map(parseNumber);
		var year = dateParts[0];
		var month = dateParts[1] - 1;
		var day = dateParts[2];
		var hours = timeParts[0];
		var minutes = timeParts[1];
		var seconds = timeParts[2];
		var date = Date.UTC(year, month, day, hours, minutes, seconds, 0);
		var timestamp = date / 1000;
		return timestamp;
	}

	//parse date with "2004-09-04T23:39:06-08:00" format,
	//one of the formats supported by ISO 8601, and
	//convert to utc timestamp in seconds
	function parseDateWithTimezoneFormat(dateTimeStr) {

		var dateParts = dateTimeStr.substr(0, 10).split('-');
		var timeParts = dateTimeStr.substr(11, 8).split(':');
		var timezoneStr = dateTimeStr.substr(19, 6);
		var timezoneParts = timezoneStr.split(':').map(parseNumber);
		var timezoneOffset = (timezoneParts[0] * hours) +
			(timezoneParts[1] * minutes);

		var timestamp = parseDateTimeParts(dateParts, timeParts);
		//minus because the timezoneOffset describes
		//how much the described time is ahead of UTC
		timestamp -= timezoneOffset;

		if(typeof timestamp === 'number' && !isNaN(timestamp)) {
			return timestamp;
		}
	}

	//parse date with "YYYY:MM:DD hh:mm:ss" format, convert to utc timestamp in seconds
	function parseDateWithSpecFormat(dateTimeStr) {
		var parts = dateTimeStr.split(' '),
			dateParts = parts[0].split(':'),
			timeParts = parts[1].split(':');

		var timestamp = parseDateTimeParts(dateParts, timeParts);

		if(typeof timestamp === 'number' && !isNaN(timestamp)) {
			return timestamp;
		}
	}

	function parseExifDate(dateTimeStr) {
		//some easy checks to determine two common date formats

		//is the date in the standard "YYYY:MM:DD hh:mm:ss" format?
		var isSpecFormat = dateTimeStr.length === 19 &&
			dateTimeStr.charAt(4) === ':';
		//is the date in the non-standard format,
		//"2004-09-04T23:39:06-08:00" to include a timezone?
		var isTimezoneFormat = dateTimeStr.length === 25 &&
			dateTimeStr.charAt(10) === 'T';

		if(isTimezoneFormat) {
			return parseDateWithTimezoneFormat(dateTimeStr);
		}
		else if(isSpecFormat) {
			return parseDateWithSpecFormat(dateTimeStr);
		}
	}

	date = {
		parseDateWithSpecFormat: parseDateWithSpecFormat,
		parseDateWithTimezoneFormat: parseDateWithTimezoneFormat,
		parseExifDate: parseExifDate
	};
	return date;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;
	var exif = requireExif();
	var date = requireDate();

	var degreeTags = [{
		section: exif.GPSIFD,
		type: 0x0002,
		name: 'GPSLatitude',
		refType: 0x0001,
		refName: 'GPSLatitudeRef',
		posVal: 'N'
	},
	{
		section: exif.GPSIFD,
		type: 0x0004,
		name: 'GPSLongitude',
		refType: 0x0003,
		refName: 'GPSLongitudeRef',
		posVal: 'E'
	}];
	var dateTags = [{
		section: exif.SubIFD,
		type: 0x0132,
		name: 'ModifyDate'
	},
	{
		section: exif.SubIFD,
		type: 0x9003,
		name: 'DateTimeOriginal'
	},
	{
		section: exif.SubIFD,
		type: 0x9004,
		name: 'CreateDate'
	},
	{
		section: exif.SubIFD,
		type: 0x0132,
		name : 'ModifyDate',
	}];

	simplify = {
		castDegreeValues: function(getTagValue, setTagValue) {
			degreeTags.forEach(function(t) {
				var degreeVal = getTagValue(t);
				if(degreeVal) {
					var degreeRef = getTagValue({section: t.section, type: t.refType, name: t.refName});
					var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
					var degree = (degreeVal[0] + (degreeVal[1] / 60) + (degreeVal[2] / 3600)) * degreeNumRef;
					setTagValue(t, degree);
				}
			});
		},
		castDateValues: function(getTagValue, setTagValue) {
			dateTags.forEach(function(t) {
				var dateStrVal = getTagValue(t);
				if(dateStrVal) {
					//some easy checks to determine two common date formats
					var timestamp = date.parseExifDate(dateStrVal);
					if(typeof timestamp !== 'undefined') {
						setTagValue(t, timestamp);
					}
				}
			});
		},
		simplifyValue: function(values, format) {
			if(Array.isArray(values)) {
				values = values.map(function(value) {
					if(format === 10 || format === 5) {
						return value[0] / value[1];
					}
					return value;
				});
				if(values.length === 1) {
					values = values[0];
				}
			}
			return values;
		}
	};
	return simplify;
}

var exifTags;
var hasRequiredExifTags;

function requireExifTags () {
	if (hasRequiredExifTags) return exifTags;
	hasRequiredExifTags = 1;
	exifTags = {
		exif : {
			0x0001 : "InteropIndex",
			0x0002 : "InteropVersion",
			0x000B : "ProcessingSoftware",
			0x00FE : "SubfileType",
			0x00FF : "OldSubfileType",
			0x0100 : "ImageWidth",
			0x0101 : "ImageHeight",
			0x0102 : "BitsPerSample",
			0x0103 : "Compression",
			0x0106 : "PhotometricInterpretation",
			0x0107 : "Thresholding",
			0x0108 : "CellWidth",
			0x0109 : "CellLength",
			0x010A : "FillOrder",
			0x010D : "DocumentName",
			0x010E : "ImageDescription",
			0x010F : "Make",
			0x0110 : "Model",
			0x0111 : "StripOffsets",
			0x0112 : "Orientation",
			0x0115 : "SamplesPerPixel",
			0x0116 : "RowsPerStrip",
			0x0117 : "StripByteCounts",
			0x0118 : "MinSampleValue",
			0x0119 : "MaxSampleValue",
			0x011A : "XResolution",
			0x011B : "YResolution",
			0x011C : "PlanarConfiguration",
			0x011D : "PageName",
			0x011E : "XPosition",
			0x011F : "YPosition",
			0x0120 : "FreeOffsets",
			0x0121 : "FreeByteCounts",
			0x0122 : "GrayResponseUnit",
			0x0123 : "GrayResponseCurve",
			0x0124 : "T4Options",
			0x0125 : "T6Options",
			0x0128 : "ResolutionUnit",
			0x0129 : "PageNumber",
			0x012C : "ColorResponseUnit",
			0x012D : "TransferFunction",
			0x0131 : "Software",
			0x0132 : "ModifyDate",
			0x013B : "Artist",
			0x013C : "HostComputer",
			0x013D : "Predictor",
			0x013E : "WhitePoint",
			0x013F : "PrimaryChromaticities",
			0x0140 : "ColorMap",
			0x0141 : "HalftoneHints",
			0x0142 : "TileWidth",
			0x0143 : "TileLength",
			0x0144 : "TileOffsets",
			0x0145 : "TileByteCounts",
			0x0146 : "BadFaxLines",
			0x0147 : "CleanFaxData",
			0x0148 : "ConsecutiveBadFaxLines",
			0x014A : "SubIFD",
			0x014C : "InkSet",
			0x014D : "InkNames",
			0x014E : "NumberofInks",
			0x0150 : "DotRange",
			0x0151 : "TargetPrinter",
			0x0152 : "ExtraSamples",
			0x0153 : "SampleFormat",
			0x0154 : "SMinSampleValue",
			0x0155 : "SMaxSampleValue",
			0x0156 : "TransferRange",
			0x0157 : "ClipPath",
			0x0158 : "XClipPathUnits",
			0x0159 : "YClipPathUnits",
			0x015A : "Indexed",
			0x015B : "JPEGTables",
			0x015F : "OPIProxy",
			0x0190 : "GlobalParametersIFD",
			0x0191 : "ProfileType",
			0x0192 : "FaxProfile",
			0x0193 : "CodingMethods",
			0x0194 : "VersionYear",
			0x0195 : "ModeNumber",
			0x01B1 : "Decode",
			0x01B2 : "DefaultImageColor",
			0x01B3 : "T82Options",
			0x01B5 : "JPEGTables",
			0x0200 : "JPEGProc",
			0x0201 : "ThumbnailOffset",
			0x0202 : "ThumbnailLength",
			0x0203 : "JPEGRestartInterval",
			0x0205 : "JPEGLosslessPredictors",
			0x0206 : "JPEGPointTransforms",
			0x0207 : "JPEGQTables",
			0x0208 : "JPEGDCTables",
			0x0209 : "JPEGACTables",
			0x0211 : "YCbCrCoefficients",
			0x0212 : "YCbCrSubSampling",
			0x0213 : "YCbCrPositioning",
			0x0214 : "ReferenceBlackWhite",
			0x022F : "StripRowCounts",
			0x02BC : "ApplicationNotes",
			0x03E7 : "USPTOMiscellaneous",
			0x1000 : "RelatedImageFileFormat",
			0x1001 : "RelatedImageWidth",
			0x1002 : "RelatedImageHeight",
			0x4746 : "Rating",
			0x4747 : "XP_DIP_XML",
			0x4748 : "StitchInfo",
			0x4749 : "RatingPercent",
			0x800D : "ImageID",
			0x80A3 : "WangTag1",
			0x80A4 : "WangAnnotation",
			0x80A5 : "WangTag3",
			0x80A6 : "WangTag4",
			0x80E3 : "Matteing",
			0x80E4 : "DataType",
			0x80E5 : "ImageDepth",
			0x80E6 : "TileDepth",
			0x827D : "Model2",
			0x828D : "CFARepeatPatternDim",
			0x828E : "CFAPattern2",
			0x828F : "BatteryLevel",
			0x8290 : "KodakIFD",
			0x8298 : "Copyright",
			0x829A : "ExposureTime",
			0x829D : "FNumber",
			0x82A5 : "MDFileTag",
			0x82A6 : "MDScalePixel",
			0x82A7 : "MDColorTable",
			0x82A8 : "MDLabName",
			0x82A9 : "MDSampleInfo",
			0x82AA : "MDPrepDate",
			0x82AB : "MDPrepTime",
			0x82AC : "MDFileUnits",
			0x830E : "PixelScale",
			0x8335 : "AdventScale",
			0x8336 : "AdventRevision",
			0x835C : "UIC1Tag",
			0x835D : "UIC2Tag",
			0x835E : "UIC3Tag",
			0x835F : "UIC4Tag",
			0x83BB : "IPTC-NAA",
			0x847E : "IntergraphPacketData",
			0x847F : "IntergraphFlagRegisters",
			0x8480 : "IntergraphMatrix",
			0x8481 : "INGRReserved",
			0x8482 : "ModelTiePoint",
			0x84E0 : "Site",
			0x84E1 : "ColorSequence",
			0x84E2 : "IT8Header",
			0x84E3 : "RasterPadding",
			0x84E4 : "BitsPerRunLength",
			0x84E5 : "BitsPerExtendedRunLength",
			0x84E6 : "ColorTable",
			0x84E7 : "ImageColorIndicator",
			0x84E8 : "BackgroundColorIndicator",
			0x84E9 : "ImageColorValue",
			0x84EA : "BackgroundColorValue",
			0x84EB : "PixelIntensityRange",
			0x84EC : "TransparencyIndicator",
			0x84ED : "ColorCharacterization",
			0x84EE : "HCUsage",
			0x84EF : "TrapIndicator",
			0x84F0 : "CMYKEquivalent",
			0x8546 : "SEMInfo",
			0x8568 : "AFCP_IPTC",
			0x85B8 : "PixelMagicJBIGOptions",
			0x85D8 : "ModelTransform",
			0x8602 : "WB_GRGBLevels",
			0x8606 : "LeafData",
			0x8649 : "PhotoshopSettings",
			0x8769 : "ExifOffset",
			0x8773 : "ICC_Profile",
			0x877F : "TIFF_FXExtensions",
			0x8780 : "MultiProfiles",
			0x8781 : "SharedData",
			0x8782 : "T88Options",
			0x87AC : "ImageLayer",
			0x87AF : "GeoTiffDirectory",
			0x87B0 : "GeoTiffDoubleParams",
			0x87B1 : "GeoTiffAsciiParams",
			0x8822 : "ExposureProgram",
			0x8824 : "SpectralSensitivity",
			0x8825 : "GPSInfo",
			0x8827 : "ISO",
			0x8828 : "Opto-ElectricConvFactor",
			0x8829 : "Interlace",
			0x882A : "TimeZoneOffset",
			0x882B : "SelfTimerMode",
			0x8830 : "SensitivityType",
			0x8831 : "StandardOutputSensitivity",
			0x8832 : "RecommendedExposureIndex",
			0x8833 : "ISOSpeed",
			0x8834 : "ISOSpeedLatitudeyyy",
			0x8835 : "ISOSpeedLatitudezzz",
			0x885C : "FaxRecvParams",
			0x885D : "FaxSubAddress",
			0x885E : "FaxRecvTime",
			0x888A : "LeafSubIFD",
			0x9000 : "ExifVersion",
			0x9003 : "DateTimeOriginal",
			0x9004 : "CreateDate",
			0x9101 : "ComponentsConfiguration",
			0x9102 : "CompressedBitsPerPixel",
			0x9201 : "ShutterSpeedValue",
			0x9202 : "ApertureValue",
			0x9203 : "BrightnessValue",
			0x9204 : "ExposureCompensation",
			0x9205 : "MaxApertureValue",
			0x9206 : "SubjectDistance",
			0x9207 : "MeteringMode",
			0x9208 : "LightSource",
			0x9209 : "Flash",
			0x920A : "FocalLength",
			0x920B : "FlashEnergy",
			0x920C : "SpatialFrequencyResponse",
			0x920D : "Noise",
			0x920E : "FocalPlaneXResolution",
			0x920F : "FocalPlaneYResolution",
			0x9210 : "FocalPlaneResolutionUnit",
			0x9211 : "ImageNumber",
			0x9212 : "SecurityClassification",
			0x9213 : "ImageHistory",
			0x9214 : "SubjectArea",
			0x9215 : "ExposureIndex",
			0x9216 : "TIFF-EPStandardID",
			0x9217 : "SensingMethod",
			0x923A : "CIP3DataFile",
			0x923B : "CIP3Sheet",
			0x923C : "CIP3Side",
			0x923F : "StoNits",
			0x927C : "MakerNote",
			0x9286 : "UserComment",
			0x9290 : "SubSecTime",
			0x9291 : "SubSecTimeOriginal",
			0x9292 : "SubSecTimeDigitized",
			0x932F : "MSDocumentText",
			0x9330 : "MSPropertySetStorage",
			0x9331 : "MSDocumentTextPosition",
			0x935C : "ImageSourceData",
			0x9C9B : "XPTitle",
			0x9C9C : "XPComment",
			0x9C9D : "XPAuthor",
			0x9C9E : "XPKeywords",
			0x9C9F : "XPSubject",
			0xA000 : "FlashpixVersion",
			0xA001 : "ColorSpace",
			0xA002 : "ExifImageWidth",
			0xA003 : "ExifImageHeight",
			0xA004 : "RelatedSoundFile",
			0xA005 : "InteropOffset",
			0xA20B : "FlashEnergy",
			0xA20C : "SpatialFrequencyResponse",
			0xA20D : "Noise",
			0xA20E : "FocalPlaneXResolution",
			0xA20F : "FocalPlaneYResolution",
			0xA210 : "FocalPlaneResolutionUnit",
			0xA211 : "ImageNumber",
			0xA212 : "SecurityClassification",
			0xA213 : "ImageHistory",
			0xA214 : "SubjectLocation",
			0xA215 : "ExposureIndex",
			0xA216 : "TIFF-EPStandardID",
			0xA217 : "SensingMethod",
			0xA300 : "FileSource",
			0xA301 : "SceneType",
			0xA302 : "CFAPattern",
			0xA401 : "CustomRendered",
			0xA402 : "ExposureMode",
			0xA403 : "WhiteBalance",
			0xA404 : "DigitalZoomRatio",
			0xA405 : "FocalLengthIn35mmFormat",
			0xA406 : "SceneCaptureType",
			0xA407 : "GainControl",
			0xA408 : "Contrast",
			0xA409 : "Saturation",
			0xA40A : "Sharpness",
			0xA40B : "DeviceSettingDescription",
			0xA40C : "SubjectDistanceRange",
			0xA420 : "ImageUniqueID",
			0xA430 : "OwnerName",
			0xA431 : "SerialNumber",
			0xA432 : "LensInfo",
			0xA433 : "LensMake",
			0xA434 : "LensModel",
			0xA435 : "LensSerialNumber",
			0xA480 : "GDALMetadata",
			0xA481 : "GDALNoData",
			0xA500 : "Gamma",
			0xAFC0 : "ExpandSoftware",
			0xAFC1 : "ExpandLens",
			0xAFC2 : "ExpandFilm",
			0xAFC3 : "ExpandFilterLens",
			0xAFC4 : "ExpandScanner",
			0xAFC5 : "ExpandFlashLamp",
			0xBC01 : "PixelFormat",
			0xBC02 : "Transformation",
			0xBC03 : "Uncompressed",
			0xBC04 : "ImageType",
			0xBC80 : "ImageWidth",
			0xBC81 : "ImageHeight",
			0xBC82 : "WidthResolution",
			0xBC83 : "HeightResolution",
			0xBCC0 : "ImageOffset",
			0xBCC1 : "ImageByteCount",
			0xBCC2 : "AlphaOffset",
			0xBCC3 : "AlphaByteCount",
			0xBCC4 : "ImageDataDiscard",
			0xBCC5 : "AlphaDataDiscard",
			0xC427 : "OceScanjobDesc",
			0xC428 : "OceApplicationSelector",
			0xC429 : "OceIDNumber",
			0xC42A : "OceImageLogic",
			0xC44F : "Annotations",
			0xC4A5 : "PrintIM",
			0xC580 : "USPTOOriginalContentType",
			0xC612 : "DNGVersion",
			0xC613 : "DNGBackwardVersion",
			0xC614 : "UniqueCameraModel",
			0xC615 : "LocalizedCameraModel",
			0xC616 : "CFAPlaneColor",
			0xC617 : "CFALayout",
			0xC618 : "LinearizationTable",
			0xC619 : "BlackLevelRepeatDim",
			0xC61A : "BlackLevel",
			0xC61B : "BlackLevelDeltaH",
			0xC61C : "BlackLevelDeltaV",
			0xC61D : "WhiteLevel",
			0xC61E : "DefaultScale",
			0xC61F : "DefaultCropOrigin",
			0xC620 : "DefaultCropSize",
			0xC621 : "ColorMatrix1",
			0xC622 : "ColorMatrix2",
			0xC623 : "CameraCalibration1",
			0xC624 : "CameraCalibration2",
			0xC625 : "ReductionMatrix1",
			0xC626 : "ReductionMatrix2",
			0xC627 : "AnalogBalance",
			0xC628 : "AsShotNeutral",
			0xC629 : "AsShotWhiteXY",
			0xC62A : "BaselineExposure",
			0xC62B : "BaselineNoise",
			0xC62C : "BaselineSharpness",
			0xC62D : "BayerGreenSplit",
			0xC62E : "LinearResponseLimit",
			0xC62F : "CameraSerialNumber",
			0xC630 : "DNGLensInfo",
			0xC631 : "ChromaBlurRadius",
			0xC632 : "AntiAliasStrength",
			0xC633 : "ShadowScale",
			0xC634 : "DNGPrivateData",
			0xC635 : "MakerNoteSafety",
			0xC640 : "RawImageSegmentation",
			0xC65A : "CalibrationIlluminant1",
			0xC65B : "CalibrationIlluminant2",
			0xC65C : "BestQualityScale",
			0xC65D : "RawDataUniqueID",
			0xC660 : "AliasLayerMetadata",
			0xC68B : "OriginalRawFileName",
			0xC68C : "OriginalRawFileData",
			0xC68D : "ActiveArea",
			0xC68E : "MaskedAreas",
			0xC68F : "AsShotICCProfile",
			0xC690 : "AsShotPreProfileMatrix",
			0xC691 : "CurrentICCProfile",
			0xC692 : "CurrentPreProfileMatrix",
			0xC6BF : "ColorimetricReference",
			0xC6D2 : "PanasonicTitle",
			0xC6D3 : "PanasonicTitle2",
			0xC6F3 : "CameraCalibrationSig",
			0xC6F4 : "ProfileCalibrationSig",
			0xC6F5 : "ProfileIFD",
			0xC6F6 : "AsShotProfileName",
			0xC6F7 : "NoiseReductionApplied",
			0xC6F8 : "ProfileName",
			0xC6F9 : "ProfileHueSatMapDims",
			0xC6FA : "ProfileHueSatMapData1",
			0xC6FB : "ProfileHueSatMapData2",
			0xC6FC : "ProfileToneCurve",
			0xC6FD : "ProfileEmbedPolicy",
			0xC6FE : "ProfileCopyright",
			0xC714 : "ForwardMatrix1",
			0xC715 : "ForwardMatrix2",
			0xC716 : "PreviewApplicationName",
			0xC717 : "PreviewApplicationVersion",
			0xC718 : "PreviewSettingsName",
			0xC719 : "PreviewSettingsDigest",
			0xC71A : "PreviewColorSpace",
			0xC71B : "PreviewDateTime",
			0xC71C : "RawImageDigest",
			0xC71D : "OriginalRawFileDigest",
			0xC71E : "SubTileBlockSize",
			0xC71F : "RowInterleaveFactor",
			0xC725 : "ProfileLookTableDims",
			0xC726 : "ProfileLookTableData",
			0xC740 : "OpcodeList1",
			0xC741 : "OpcodeList2",
			0xC74E : "OpcodeList3",
			0xC761 : "NoiseProfile",
			0xC763 : "TimeCodes",
			0xC764 : "FrameRate",
			0xC772 : "TStop",
			0xC789 : "ReelName",
			0xC791 : "OriginalDefaultFinalSize",
			0xC792 : "OriginalBestQualitySize",
			0xC793 : "OriginalDefaultCropSize",
			0xC7A1 : "CameraLabel",
			0xC7A3 : "ProfileHueSatMapEncoding",
			0xC7A4 : "ProfileLookTableEncoding",
			0xC7A5 : "BaselineExposureOffset",
			0xC7A6 : "DefaultBlackRender",
			0xC7A7 : "NewRawImageDigest",
			0xC7A8 : "RawToPreviewGain",
			0xC7B5 : "DefaultUserCrop",
			0xEA1C : "Padding",
			0xEA1D : "OffsetSchema",
			0xFDE8 : "OwnerName",
			0xFDE9 : "SerialNumber",
			0xFDEA : "Lens",
			0xFE00 : "KDC_IFD",
			0xFE4C : "RawFile",
			0xFE4D : "Converter",
			0xFE4E : "WhiteBalance",
			0xFE51 : "Exposure",
			0xFE52 : "Shadows",
			0xFE53 : "Brightness",
			0xFE54 : "Contrast",
			0xFE55 : "Saturation",
			0xFE56 : "Sharpness",
			0xFE57 : "Smoothness",
			0xFE58 : "MoireFilter"
			
		},
		gps : {	
			0x0000 : 'GPSVersionID',
			0x0001 : 'GPSLatitudeRef',
			0x0002 : 'GPSLatitude',
			0x0003 : 'GPSLongitudeRef',
			0x0004 : 'GPSLongitude',
			0x0005 : 'GPSAltitudeRef',
			0x0006 : 'GPSAltitude',
			0x0007 : 'GPSTimeStamp',
			0x0008 : 'GPSSatellites',
			0x0009 : 'GPSStatus',
			0x000A : 'GPSMeasureMode',
			0x000B : 'GPSDOP',
			0x000C : 'GPSSpeedRef',
			0x000D : 'GPSSpeed',
			0x000E : 'GPSTrackRef',
			0x000F : 'GPSTrack',
			0x0010 : 'GPSImgDirectionRef',
			0x0011 : 'GPSImgDirection',
			0x0012 : 'GPSMapDatum',
			0x0013 : 'GPSDestLatitudeRef',
			0x0014 : 'GPSDestLatitude',
			0x0015 : 'GPSDestLongitudeRef',
			0x0016 : 'GPSDestLongitude',
			0x0017 : 'GPSDestBearingRef',
			0x0018 : 'GPSDestBearing',
			0x0019 : 'GPSDestDistanceRef',
			0x001A : 'GPSDestDistance',
			0x001B : 'GPSProcessingMethod',
			0x001C : 'GPSAreaInformation',
			0x001D : 'GPSDateStamp',
			0x001E : 'GPSDifferential',
			0x001F : 'GPSHPositioningError'
		}
	};
	return exifTags;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var parser;
var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;
	var jpeg = requireJpeg(),
		exif = requireExif(),
		simplify = requireSimplify();

	function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
		this.startMarker = startMarker;
		this.tags = tags;
		this.imageSize = imageSize;
		this.thumbnailOffset = thumbnailOffset;
		this.thumbnailLength = thumbnailLength;
		this.thumbnailType = thumbnailType;
		this.app1Offset = app1Offset;
	}

	ExifResult.prototype = {
		hasThumbnail: function(mime) {
			if(!this.thumbnailOffset || !this.thumbnailLength) {
				return false;
			}
			if(typeof mime !== 'string') {
				return true;
			}
			if(mime.toLowerCase().trim() === 'image/jpeg') {
				return this.thumbnailType === 6;
			}
			if(mime.toLowerCase().trim() === 'image/tiff') {
				return this.thumbnailType === 1;
			}
			return false;
		},
		getThumbnailOffset: function() {
			return this.app1Offset + 6 + this.thumbnailOffset;
		},
		getThumbnailLength: function() {
			return this.thumbnailLength;
		},
		getThumbnailBuffer: function() {
			return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
		},
		_getThumbnailStream: function() {
			return this.startMarker.openWithOffset(this.getThumbnailOffset());
		},
		getImageSize: function() {
			return this.imageSize;
		},
		getThumbnailSize: function() {
			var stream = this._getThumbnailStream(), size;
			jpeg.parseSections(stream, function(sectionType, sectionStream) {
				if(jpeg.getSectionName(sectionType).name === 'SOF') {
					size = jpeg.getSizeFromSOFSection(sectionStream);
				}
			});
			return size;
		}
	};

	function Parser(stream) {
		this.stream = stream;
		this.flags = {
			readBinaryTags: false,
			resolveTagNames: true,
			simplifyValues: true,
			imageSize: true,
			hidePointers: true,
			returnTags: true
		};
	}

	Parser.prototype = {
		enableBinaryFields: function(enable) {
			this.flags.readBinaryTags = !!enable;
			return this;
		},
		enablePointers: function(enable) {
			this.flags.hidePointers = !enable;
			return this;
		},
		enableTagNames: function(enable) {
			this.flags.resolveTagNames = !!enable;
			return this;
		},
		enableImageSize: function(enable) {
			this.flags.imageSize = !!enable;
			return this;
		},
		enableReturnTags: function(enable) {
			this.flags.returnTags = !!enable;
			return this;
		},
		enableSimpleValues: function(enable) {
			this.flags.simplifyValues = !!enable;
			return this;
		},
		parse: function() {
			var start = this.stream.mark(),
				stream = start.openWithOffset(0),
				flags = this.flags,
				tags,
				imageSize,
				thumbnailOffset,
				thumbnailLength,
				thumbnailType,
				app1Offset,
				tagNames,
				getTagValue, setTagValue;
			if(flags.resolveTagNames) {
				tagNames = requireExifTags();
			}
			if(flags.resolveTagNames) {
				tags = {};
				getTagValue = function(t) {
					return tags[t.name];
				};
				setTagValue = function(t, value) {
					tags[t.name] = value;
				};
			} else {
				tags = [];
				getTagValue = function(t) {
					var i;
					for(i = 0; i < tags.length; ++i) {
						if(tags[i].type === t.type && tags[i].section === t.section) {
							return tags.value;
						}
					}
				};
				setTagValue = function(t, value) {
					var i;
					for(i = 0; i < tags.length; ++i) {
						if(tags[i].type === t.type && tags[i].section === t.section) {
							tags.value = value;
							return;
						}
					}
				};
			}

			jpeg.parseSections(stream, function(sectionType, sectionStream) {
				var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
				if(sectionType === 0xE1) {
					validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format) {
						//ignore binary fields if disabled
						if(!flags.readBinaryTags && format === 7) {
							return;
						}

						if(tagType === 0x0201) {
							thumbnailOffset = value[0];
							if(flags.hidePointers) {return;}
						} else if(tagType === 0x0202) {
							thumbnailLength = value[0];
							if(flags.hidePointers) {return;}
						} else if(tagType === 0x0103) {
							thumbnailType = value[0];
							if(flags.hidePointers) {return;}
						}
						//if flag is set to not store tags, return here after storing pointers
						if(!flags.returnTags) {
							return;
						}

						if(flags.simplifyValues) {
							value = simplify.simplifyValue(value, format);
						}
						if(flags.resolveTagNames) {
							var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
							var name = sectionTagNames[tagType];
							if(!name) {
								name = tagNames.exif[tagType];
							}
							if (!tags.hasOwnProperty(name)) {
								tags[name] = value;
							}
						} else {
							tags.push({
								section: ifdSection,
								type: tagType,
								value: value
							});
						}
					});
					if(validExifHeaders) {
						app1Offset = sectionOffset;
					}
				}
				else if(flags.imageSize && jpeg.getSectionName(sectionType).name === 'SOF') {
					imageSize = jpeg.getSizeFromSOFSection(sectionStream);
				}
			});

			if(flags.simplifyValues) {
				simplify.castDegreeValues(getTagValue, setTagValue);
				simplify.castDateValues(getTagValue, setTagValue);
			}

			return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
		}
	};



	parser = Parser;
	return parser;
}

/*jslint browser: true, devel: true, bitwise: false, debug: true, eqeq: false, es5: true, evil: false, forin: false, newcap: false, nomen: true, plusplus: true, regexp: false, unparam: false, sloppy: true, stupid: false, sub: false, todo: true, vars: true, white: true */

var domBufferstream;
var hasRequiredDomBufferstream;

function requireDomBufferstream () {
	if (hasRequiredDomBufferstream) return domBufferstream;
	hasRequiredDomBufferstream = 1;
	function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
		this.global = global;
		offset = offset || 0;
		length = length || (arrayBuffer.byteLength - offset);
		this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
		this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
		this.setBigEndian(bigEndian);
		this.offset = 0;
		this.parentOffset = (parentOffset || 0) + offset;
	}

	DOMBufferStream.prototype = {
		setBigEndian: function(bigEndian) {
			this.littleEndian = !bigEndian;
		},
		nextUInt8: function() {
			var value = this.view.getUint8(this.offset);
			this.offset += 1;
			return value;
		},
		nextInt8: function() {
			var value = this.view.getInt8(this.offset);
			this.offset += 1;
			return value;
		},
		nextUInt16: function() {
			var value = this.view.getUint16(this.offset, this.littleEndian);
			this.offset += 2;
			return value;
		},
		nextUInt32: function() {
			var value = this.view.getUint32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},
		nextInt16: function() {
			var value = this.view.getInt16(this.offset, this.littleEndian);
			this.offset += 2;
			return value;
		},
		nextInt32: function() {
			var value = this.view.getInt32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},
		nextFloat: function() {
			var value = this.view.getFloat32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},
		nextDouble: function() {
			var value = this.view.getFloat64(this.offset, this.littleEndian);
			this.offset += 8;
			return value;
		},
		nextBuffer: function(length) {
			//this won't work in IE10
			var value = this.arrayBuffer.slice(this.offset, this.offset + length);
			this.offset += length;
			return value;
		},
		remainingLength: function() {
			return this.arrayBuffer.byteLength - this.offset;
		},
		nextString: function(length) {
			var value = this.arrayBuffer.slice(this.offset, this.offset + length);
			value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
			this.offset += length;
			return value;
		},
		mark: function() {
			var self = this;
			return {
				openWithOffset: function(offset) {
					offset = (offset || 0) + this.offset;
					return new DOMBufferStream(self.arrayBuffer, offset, self.arrayBuffer.byteLength - offset, !self.littleEndian, self.global, self.parentOffset);
				},
				offset: this.offset,
				getParentOffset: function() {
					return self.parentOffset;
				}
			};
		},
		offsetFrom: function(marker) {
			return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
		},
		skip: function(amount) {
			this.offset += amount;
		},
		branch: function(offset, length) {
			length = typeof length === 'number' ? length : this.arrayBuffer.byteLength - (this.offset + offset);
			return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
		}
	};

	domBufferstream = DOMBufferStream;
	return domBufferstream;
}

var bufferstream;
var hasRequiredBufferstream;

function requireBufferstream () {
	if (hasRequiredBufferstream) return bufferstream;
	hasRequiredBufferstream = 1;
	function BufferStream(buffer, offset, length, bigEndian) {
		this.buffer = buffer;
		this.offset = offset || 0;
		length = typeof length === 'number' ? length : buffer.length;
		this.endPosition = this.offset + length;
		this.setBigEndian(bigEndian);
	}

	BufferStream.prototype = {
		setBigEndian: function(bigEndian) {
			this.bigEndian = !!bigEndian;
		},
		nextUInt8: function() {
			var value = this.buffer.readUInt8(this.offset);
			this.offset += 1;
			return value;
		},
		nextInt8: function() {
			var value = this.buffer.readInt8(this.offset);
			this.offset += 1;
			return value;
		},
		nextUInt16: function() {
			var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
			this.offset += 2;
			return value;
		},
		nextUInt32: function() {
			var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
			this.offset += 4;
			return value;
		},
		nextInt16: function() {
			var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
			this.offset += 2;
			return value;
		},
		nextInt32: function() {
			var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
			this.offset += 4;
			return value;
		},
		nextFloat: function() {
			var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
			this.offset += 4;
			return value;
		},
		nextDouble: function() {
			var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
			this.offset += 8;
			return value;
		},
		nextBuffer: function(length) {
			var value = this.buffer.slice(this.offset, this.offset + length);
			this.offset += length;
			return value;
		},
		remainingLength: function() {
			return this.endPosition - this.offset;
		},
		nextString: function(length) {
			var value = this.buffer.toString('utf8', this.offset, this.offset + length);
			this.offset += length;
			return value;
		},
		mark: function() {
			var self = this;
			return {
				openWithOffset: function(offset) {
					offset = (offset || 0) + this.offset;
					return new BufferStream(self.buffer, offset, self.endPosition - offset, self.bigEndian);
				},
				offset: this.offset
			};
		},
		offsetFrom: function(marker) {
			return this.offset - marker.offset;
		},
		skip: function(amount) {
			this.offset += amount;
		},
		branch: function(offset, length) {
			length = typeof length === 'number' ? length : this.endPosition - (this.offset + offset);
			return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
		}
	};

	bufferstream = BufferStream;
	return bufferstream;
}

var exifParser;
var hasRequiredExifParser;

function requireExifParser () {
	if (hasRequiredExifParser) return exifParser;
	hasRequiredExifParser = 1;
	var Parser = requireParser();

	function getGlobal() {
		return (0, eval)('this');
	}

	exifParser = {
		create: function(buffer, global) {
			global = global || getGlobal();
			if(buffer instanceof global.ArrayBuffer) {
				var DOMBufferStream = requireDomBufferstream();
				return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global));
			} else {
				var NodeBufferStream = requireBufferstream();
				return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
			}
		}
	};
	return exifParser;
}

var exifParserExports = requireExifParser();
var EXIFParser = /*@__PURE__*/getDefaultExportFromCjs(exifParserExports);

/**
 * Obtains image orientation from EXIF metadata.
 *
 * @param img a Jimp image object
 * @returns a number 1-8 representing EXIF orientation,
 *          in particular 1 if orientation tag is missing
 */
function getExifOrientation(img) {
    const _exif = img._exif;
    return (_exif && _exif.tags && _exif.tags.Orientation) || 1;
}
/**
 * Returns a function which translates EXIF-rotated coordinates into
 * non-rotated ones.
 *
 * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.
 *
 * @param img a Jimp image object
 * @returns transformation function for transformBitmap().
 */
function getExifOrientationTransformation(img) {
    const w = img.bitmap.width;
    const h = img.bitmap.height;
    switch (getExifOrientation(img)) {
        case 1: // Horizontal (normal)
            // does not need to be supported here
            return null;
        case 2: // Mirror horizontal
            return function (x, y) {
                return [w - x - 1, y];
            };
        case 3: // Rotate 180
            return function (x, y) {
                return [w - x - 1, h - y - 1];
            };
        case 4: // Mirror vertical
            return function (x, y) {
                return [x, h - y - 1];
            };
        case 5: // Mirror horizontal and rotate 270 CW
            return function (x, y) {
                return [y, x];
            };
        case 6: // Rotate 90 CW
            return function (x, y) {
                return [y, h - x - 1];
            };
        case 7: // Mirror horizontal and rotate 90 CW
            return function (x, y) {
                return [w - y - 1, h - x - 1];
            };
        case 8: // Rotate 270 CW
            return function (x, y) {
                return [w - y - 1, x];
            };
        default:
            return null;
    }
}
/**
 * Transforms bitmap in place (moves pixels around) according to given
 * transformation function.
 *
 * @param img a Jimp image object, which bitmap is supposed to
 *        be transformed
 * @param width bitmap width after the transformation
 * @param height bitmap height after the transformation
 * @param transformation transformation function which defines pixel
 *        mapping between new and source bitmap. It takes a pair of coordinates
 *        in the target, and returns a respective pair of coordinates in
 *        the source bitmap, i.e. has following form:
 *        `function(new_x, new_y) { return [src_x, src_y] }`.
 */
function transformBitmap(img, width, height, transformation) {
    // Underscore-prefixed values are related to the source bitmap
    // Their counterparts with no prefix are related to the target bitmap
    const _data = img.bitmap.data;
    const _width = img.bitmap.width;
    const data = Buffer.alloc(_data.length);
    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            const [_x, _y] = transformation(x, y);
            const idx = (width * y + x) << 2;
            const _idx = (_width * _y + _x) << 2;
            const pixel = _data.readUInt32BE(_idx);
            data.writeUInt32BE(pixel, idx);
        }
    }
    img.bitmap.data = data;
    img.bitmap.width = width;
    img.bitmap.height = height;
    // @ts-expect-error Accessing private property
    img._exif.tags.Orientation = 1;
}
/**
 * Automagically rotates an image based on its EXIF data (if present).
 * @param img  a Jimp image object
 */
function exifRotate(img) {
    if (getExifOrientation(img) < 2) {
        return;
    }
    const transformation = getExifOrientationTransformation(img);
    const swapDimensions = getExifOrientation(img) > 4;
    const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
    const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
    if (transformation) {
        transformBitmap(img, newWidth, newHeight, transformation);
    }
}
async function attemptExifRotate(image, buffer) {
    try {
        image._exif =
            EXIFParser.create(buffer).parse();
        exifRotate(image); // EXIF data
    }
    catch {
        // do nothing
    }
}

const emptyBitmap = {
    data: Buffer.alloc(0),
    width: 0,
    height: 0,
};
/**
 * Prepare a Buffer object from the arrayBuffer.
 */
function bufferFromArrayBuffer(arrayBuffer) {
    const buffer = Buffer.alloc(arrayBuffer.byteLength);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }
    return buffer;
}
/**
 * Create a Jimp class that support the given image formats and methods
 */
function createJimp({ plugins: pluginsArg, formats: formatsArg, } = {}) {
    const plugins = pluginsArg || [];
    const formats = (formatsArg || []).map((format) => format());
    const CustomJimp = class Jimp {
        /**
         * The bitmap data of the image
         */
        bitmap = emptyBitmap;
        /**  Default color to use for new pixels */
        background = 0x00000000;
        /** Formats that can be used with Jimp */
        formats = [];
        /** The original MIME type of the image */
        mime;
        constructor(options = emptyBitmap) {
            // Add the formats
            this.formats = formats;
            if ("data" in options) {
                this.bitmap = options;
            }
            else {
                this.bitmap = {
                    data: Buffer.alloc(options.width * options.height * 4),
                    width: options.width,
                    height: options.height,
                };
                if (options.color) {
                    this.background =
                        typeof options.color === "string"
                            ? cssColorToHex(options.color)
                            : options.color;
                    for (let i = 0; i < this.bitmap.data.length; i += 4) {
                        this.bitmap.data.writeUInt32BE(this.background, i);
                    }
                }
            }
            // Add the plugins
            for (const methods of plugins) {
                for (const key in methods) {
                    this[key] = (...args) => {
                        const result = methods[key]?.(this, ...args);
                        if (typeof result === "object" && "bitmap" in result) {
                            this.bitmap = result.bitmap;
                            return this;
                        }
                        return result;
                    };
                }
            }
        }
        /**
         * Create a Jimp instance from a URL, a file path, or a Buffer
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * // Read from a file path
         * const image = await Jimp.read("test/image.png");
         *
         * // Read from a URL
         * const image = await Jimp.read("https://upload.wikimedia.org/wikipedia/commons/0/01/Bot-Test.jpg");
         * ```
         */
        static async read(url, options) {
            if (Buffer.isBuffer(url) || url instanceof ArrayBuffer) {
                return this.fromBuffer(url);
            }
            if (existsSync(url)) {
                return this.fromBuffer(await readFile(url));
            }
            const [fetchErr, response] = await to(fetch(url));
            if (fetchErr) {
                throw new Error(`Could not load Buffer from URL: ${url}`);
            }
            if (!response.ok) {
                throw new Error(`HTTP Status ${response.status} for url ${url}`);
            }
            const [arrayBufferErr, data] = await to(response.arrayBuffer());
            if (arrayBufferErr) {
                throw new Error(`Could not load Buffer from ${url}`);
            }
            const buffer = bufferFromArrayBuffer(data);
            return this.fromBuffer(buffer, options);
        }
        /**
         * Create a Jimp instance from a bitmap.
         * The difference between this and just using the constructor is that this will
         * convert raw image data into the bitmap format that Jimp uses.
         *
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = Jimp.fromBitmap({
         *   data: Buffer.from([
         *     0xffffffff, 0xffffffff, 0xffffffff,
         *     0xffffffff, 0xffffffff, 0xffffffff,
         *     0xffffffff, 0xffffffff, 0xffffffff,
         *   ]),
         *   width: 3,
         *   height: 3,
         * });
         * ```
         */
        static fromBitmap(bitmap) {
            let data;
            if (bitmap.data instanceof Buffer) {
                data = Buffer.from(bitmap.data);
            }
            if (bitmap.data instanceof Uint8Array ||
                bitmap.data instanceof Uint8ClampedArray) {
                data = Buffer.from(bitmap.data.buffer);
            }
            if (Array.isArray(bitmap.data)) {
                data = Buffer.concat(bitmap.data.map((hex) => Buffer.from(hex.toString(16).padStart(8, "0"), "hex")));
            }
            if (!data) {
                throw new Error("data must be a Buffer");
            }
            if (typeof bitmap.height !== "number" ||
                typeof bitmap.width !== "number") {
                throw new Error("bitmap must have width and height");
            }
            return new CustomJimp({
                height: bitmap.height,
                width: bitmap.width,
                data,
            });
        }
        /**
         * Parse a bitmap with the loaded image types.
         *
         * @param buffer Raw image data
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const buffer = await fs.readFile("test/image.png");
         * const image = await Jimp.fromBuffer(buffer);
         * ```
         */
        static async fromBuffer(buffer, options) {
            const actualBuffer = buffer instanceof ArrayBuffer ? bufferFromArrayBuffer(buffer) : buffer;
            const mime = await fileType.fromBuffer(actualBuffer);
            if (!mime || !mime.mime) {
                throw new Error("Could not find MIME for Buffer");
            }
            const format = formats.find((format) => format.mime === mime.mime);
            if (!format || !format.decode) {
                throw new Error(`Mime type ${mime.mime} does not support decoding`);
            }
            const image = new CustomJimp(await format.decode(actualBuffer, options?.[format.mime]));
            image.mime = mime.mime;
            attemptExifRotate(image, actualBuffer);
            return image;
        }
        /**
         * Nicely format Jimp object when sent to the console e.g. console.log(image)
         * @returns Pretty printed jimp object
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = await Jimp.read("test/image.png");
         *
         * console.log(image);
         * ```
         */
        inspect() {
            return ("<Jimp " +
                (this.bitmap === emptyBitmap
                    ? "pending..."
                    : this.bitmap.width + "x" + this.bitmap.height) +
                ">");
        }
        /**
         * Nicely format Jimp object when converted to a string
         * @returns pretty printed
         */
        toString() {
            return "[object Jimp]";
        }
        /** Get the width of the image */
        get width() {
            return this.bitmap.width;
        }
        /** Get the height of the image */
        get height() {
            return this.bitmap.height;
        }
        /**
         * Converts the Jimp instance to an image buffer
         * @param mime The mime type to export to
         * @param options The options to use when exporting
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         * import { promises as fs } from "fs";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * await image.write("test/output.jpeg", {
         *   quality: 50,
         * });
         * ```
         */
        async getBuffer(mime, options) {
            const format = this.formats.find((format) => format.mime === mime);
            if (!format || !format.encode) {
                throw new Error(`Unsupported MIME type: ${mime}`);
            }
            let outputImage;
            if (format.hasAlpha) {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                outputImage = this;
            }
            else {
                outputImage = new CustomJimp({
                    width: this.bitmap.width,
                    height: this.bitmap.height,
                    color: this.background,
                });
                composite(outputImage, this);
            }
            return format.encode(outputImage.bitmap, options);
        }
        /**
         * Converts the image to a base 64 string
         *
         * @param mime The mime type to export to
         * @param options The options to use when exporting
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = Jimp.fromBuffer(Buffer.from([
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         * ]));
         *
         * const base64 = image.getBase64("image/jpeg", {
         *   quality: 50,
         * });
         * ```
         */
        async getBase64(mime, options) {
            const data = await this.getBuffer(mime, options);
            return "data:" + mime + ";base64," + data.toString("base64");
        }
        /**
         * Write the image to a file
         * @param path the path to write the image to
         * @param options the options to use when writing the image
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = Jimp.fromBuffer(Buffer.from([
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
         * ]));
         *
         * await image.write("test/output.png");
         * ```
         */
        async write(path, options) {
            const mimeType = mime.getType(path);
            await writeFile(path, await this.getBuffer(mimeType, options));
        }
        /**
         * Clone the image into a new Jimp instance.
         * @param this
         * @returns A new Jimp instance
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * const clone = image.clone();
         * ```
         */
        clone() {
            return new CustomJimp({
                ...this.bitmap,
                data: Buffer.from(this.bitmap.data),
            });
        }
        /**
         * Returns the offset of a pixel in the bitmap buffer
         * @param x the x coordinate
         * @param y the y coordinate
         * @param edgeHandling (optional) define how to sum pixels from outside the border
         * @returns the index of the pixel or -1 if not found
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * image.getPixelIndex(1, 1); // 2
         * ```
         */
        getPixelIndex(x, y, edgeHandling) {
            let xi;
            let yi;
            if (!edgeHandling) {
                edgeHandling = Edge.EXTEND;
            }
            if (typeof x !== "number" || typeof y !== "number") {
                throw new Error("x and y must be numbers");
            }
            // round input
            x = Math.round(x);
            y = Math.round(y);
            xi = x;
            yi = y;
            if (edgeHandling === Edge.EXTEND) {
                if (x < 0)
                    xi = 0;
                if (x >= this.bitmap.width)
                    xi = this.bitmap.width - 1;
                if (y < 0)
                    yi = 0;
                if (y >= this.bitmap.height)
                    yi = this.bitmap.height - 1;
            }
            if (edgeHandling === Edge.WRAP) {
                if (x < 0) {
                    xi = this.bitmap.width + x;
                }
                if (x >= this.bitmap.width) {
                    xi = x % this.bitmap.width;
                }
                if (y < 0) {
                    yi = this.bitmap.height + y;
                }
                if (y >= this.bitmap.height) {
                    yi = y % this.bitmap.height;
                }
            }
            let i = (this.bitmap.width * yi + xi) << 2;
            // if out of bounds index is -1
            if (xi < 0 || xi >= this.bitmap.width) {
                i = -1;
            }
            if (yi < 0 || yi >= this.bitmap.height) {
                i = -1;
            }
            return i;
        }
        /**
         * Returns the hex color value of a pixel
         * @param x the x coordinate
         * @param y the y coordinate
         * @returns the color of the pixel
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * image.getPixelColor(1, 1); // 0xffffffff
         * ```
         */
        getPixelColor(x, y) {
            if (typeof x !== "number" || typeof y !== "number") {
                throw new Error("x and y must be numbers");
            }
            const idx = this.getPixelIndex(x, y);
            return this.bitmap.data.readUInt32BE(idx);
        }
        /**
         * Sets the hex colour value of a pixel
         *
         * @param hex color to set
         * @param x the x coordinate
         * @param y the y coordinate
         *
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * image.setPixelColor(0xff0000ff, 0, 0);
         * ```
         */
        setPixelColor(hex, x, y) {
            if (typeof hex !== "number" ||
                typeof x !== "number" ||
                typeof y !== "number") {
                throw new Error("hex, x and y must be numbers");
            }
            const idx = this.getPixelIndex(x, y);
            this.bitmap.data.writeUInt32BE(hex, idx);
            return this;
        }
        /**
         * Determine if the image contains opaque pixels.
         *
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffaa });
         * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });
         *
         * image.hasAlpha(); // false
         * image2.hasAlpha(); // true
         * ```
         */
        hasAlpha() {
            const { width, height, data } = this.bitmap;
            const byteLen = (width * height) << 2;
            for (let idx = 3; idx < byteLen; idx += 4) {
                if (data[idx] !== 0xff) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Composites a source image over to this image respecting alpha channels
         * @param src the source Jimp instance
         * @param x the x position to blit the image
         * @param y the y position to blit the image
         * @param options determine what mode to use
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 10, height: 10, color: 0xffffffff });
         * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });
         *
         * image.composite(image2, 3, 3);
         * ```
         */
        composite(src, x = 0, y = 0, options = {}) {
            return composite(this, src, x, y, options);
        }
        scan(x, y, w, h, f) {
            return scan(this, x, y, w, h, f);
        }
        /**
         * Iterate scan through a region of the bitmap
         * @param x the x coordinate to begin the scan at
         * @param y the y coordinate to begin the scan at
         * @param w the width of the scan region
         * @param h the height of the scan region
         * @example
         * ```ts
         * import { Jimp } from "jimp";
         *
         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });
         *
         * for (const { x, y, idx, image } of j.scanIterator()) {
         *   // do something with the pixel
         * }
         * ```
         */
        scanIterator(x = 0, y = 0, w = this.bitmap.width, h = this.bitmap.height) {
            if (typeof x !== "number" || typeof y !== "number") {
                throw new Error("x and y must be numbers");
            }
            if (typeof w !== "number" || typeof h !== "number") {
                throw new Error("w and h must be numbers");
            }
            return scanIterator(this, x, y, w, h);
        }
    };
    return CustomJimp;
}

/**
 * What resizing algorithm to use.
 */
var ResizeStrategy;
(function (ResizeStrategy) {
    /**
     * Nearest Neighbor resizing is a method used in image processing that assigns the value of the nearest pixel to the output pixel when resizing an image.
     * While fast, it can lead to lower quality outputs with noticeable pixelation, especially at larger scaling factors.
     */
    ResizeStrategy["NEAREST_NEIGHBOR"] = "nearestNeighbor";
    /**
     * Bilinear resizing is an image scaling method that uses the weighted average of the four nearest pixel values, providing smoother gradients than nearest neighbor resizing.
     * It's computationally more intense than nearest neighbor but results in images of higher quality and fewer artifacts.
     */
    ResizeStrategy["BILINEAR"] = "bilinearInterpolation";
    /**
     * Bicubic resizing is an image interpolation method that uses the values of the nearest 16 pixels in the input image to calculate the output pixel value, providing even more smoothness and sharpness than bilinear resizing.
     * Although it's computationally more expensive than bilinear and nearest neighbor, it produces higher quality images, making it ideal for photographic image scaling.
     */
    ResizeStrategy["BICUBIC"] = "bicubicInterpolation";
    /**
     * Hermite resizing is an image resizing method that uses Hermite interpolation, a mathematical formula, to determine the values of output pixels based on a weighted average of the surrounding pixels.
     * Although slower than some simpler techniques like bilinear or nearest neighbor, Hermite resizing can produce higher quality visuals and detailed renderings with less blurring.
     */
    ResizeStrategy["HERMITE"] = "hermiteInterpolation";
    ResizeStrategy["BEZIER"] = "bezierInterpolation";
})(ResizeStrategy || (ResizeStrategy = {}));

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
// JavaScript Image Resizer (c) 2012 - Grant Galitz
// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4
function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
    this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
    this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
    this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
    this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
    this.colorChannels = blendAlpha ? 4 : 3;
    this.interpolationPass = Boolean(interpolationPass);
    this.resizeCallback =
        typeof resizeCallback === "function" ? resizeCallback : function () { };
    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
    this.originalWidthMultipliedByChannels =
        this.widthOriginal * this.colorChannels;
    this.originalHeightMultipliedByChannels =
        this.heightOriginal * this.colorChannels;
    this.widthPassResultSize =
        this.targetWidthMultipliedByChannels * this.heightOriginal;
    this.finalResultSize =
        this.targetWidthMultipliedByChannels * this.targetHeight;
    this.initialize();
}
Resize.prototype.initialize = function () {
    // Perform some checks:
    if (this.widthOriginal > 0 &&
        this.heightOriginal > 0 &&
        this.targetWidth > 0 &&
        this.targetHeight > 0) {
        this.configurePasses();
    }
    else {
        console.log(this);
        throw new Error("Invalid settings specified for the resizer.");
    }
};
Resize.prototype.configurePasses = function () {
    if (this.widthOriginal === this.targetWidth) {
        // Bypass the width resizer pass:
        this.resizeWidth = this.bypassResizer;
    }
    else {
        // Setup the width resizer pass:
        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
        if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
            this.initializeFirstPassBuffers(true);
            this.resizeWidth =
                this.colorChannels === 4
                    ? this.resizeWidthInterpolatedRGBA
                    : this.resizeWidthInterpolatedRGB;
        }
        else {
            this.initializeFirstPassBuffers(false);
            this.resizeWidth =
                this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
        }
    }
    if (this.heightOriginal === this.targetHeight) {
        // Bypass the height resizer pass:
        this.resizeHeight = this.bypassResizer;
    }
    else {
        // Setup the height resizer pass:
        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
        if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
            this.initializeSecondPassBuffers(true);
            this.resizeHeight = this.resizeHeightInterpolated;
        }
        else {
            this.initializeSecondPassBuffers(false);
            this.resizeHeight =
                this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
        }
    }
};
Resize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {
    const channelsNum = fourthChannel ? 4 : 3;
    const ratioWeight = this.ratioWeightWidthPass;
    const outputBuffer = this.widthBuffer;
    let weight = 0;
    let finalOffset = 0;
    let pixelOffset = 0;
    let firstWeight = 0;
    let secondWeight = 0;
    let targetPosition;
    // Handle for only one interpolation input being valid for start calculation:
    for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,
            finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
            if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
    }
    // Adjust for overshoot of the last pass's counter:
    weight -= 1 / 3;
    let interpolationWidthSourceReadStop;
    for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
        // Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        // Interpolate:
        for (finalOffset = targetPosition,
            pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,
            finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset + 0] =
                buffer[pixelOffset + 0] * firstWeight +
                    buffer[pixelOffset + channelsNum + 0] * secondWeight;
            outputBuffer[finalOffset + 1] =
                buffer[pixelOffset + 1] * firstWeight +
                    buffer[pixelOffset + channelsNum + 1] * secondWeight;
            outputBuffer[finalOffset + 2] =
                buffer[pixelOffset + 2] * firstWeight +
                    buffer[pixelOffset + channelsNum + 2] * secondWeight;
            if (fourthChannel)
                outputBuffer[finalOffset + 3] =
                    buffer[pixelOffset + 3] * firstWeight +
                        buffer[pixelOffset + channelsNum + 3] * secondWeight;
        }
    }
    // Handle for only one interpolation input being valid for end calculation:
    for (interpolationWidthSourceReadStop =
        this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
        for (finalOffset = targetPosition,
            pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,
            finalOffset += this.targetWidthMultipliedByChannels) {
            outputBuffer[finalOffset] = buffer[pixelOffset];
            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
            if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
    }
    return outputBuffer;
};
Resize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {
    const channelsNum = fourthChannel ? 4 : 3;
    const ratioWeight = this.ratioWeightWidthPass;
    const ratioWeightDivisor = 1 / ratioWeight;
    const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
    const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
    const output = this.outputWidthWorkBench;
    const outputBuffer = this.widthBuffer;
    const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
    let weight = 0;
    let amountToNext = 0;
    let actualPosition = 0;
    let currentPosition = 0;
    let line = 0;
    let pixelOffset = 0;
    let outputOffset = 0;
    let multiplier = 1;
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    do {
        for (line = 0; line < this.originalHeightMultipliedByChannels;) {
            output[line++] = 0;
            output[line++] = 0;
            output[line++] = 0;
            if (fourthChannel) {
                output[line++] = 0;
                trustworthyColorsCount[line / channelsNum - 1] = 0;
            }
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            multiplier = Math.min(weight, amountToNext);
            for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
                r = buffer[pixelOffset];
                g = buffer[++pixelOffset];
                b = buffer[++pixelOffset];
                a = fourthChannel ? buffer[++pixelOffset] : 255;
                // Ignore RGB values if pixel is completely transparent
                output[line++] += (a ? r : 0) * multiplier;
                output[line++] += (a ? g : 0) * multiplier;
                output[line++] += (a ? b : 0) * multiplier;
                if (fourthChannel) {
                    output[line++] += a * multiplier;
                    trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
                }
            }
            if (weight >= amountToNext) {
                actualPosition += channelsNum;
                currentPosition = actualPosition;
                weight -= amountToNext;
            }
            else {
                currentPosition += weight;
                break;
            }
        } while (weight > 0 &&
            actualPosition < this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
            weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
            multiplier = fourthChannel
                ? weight
                    ? 1 / weight
                    : 0
                : ratioWeightDivisor;
            outputBuffer[pixelOffset] = output[line++] * multiplier;
            outputBuffer[++pixelOffset] = output[line++] * multiplier;
            outputBuffer[++pixelOffset] = output[line++] * multiplier;
            if (fourthChannel)
                outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
        }
        outputOffset += channelsNum;
    } while (outputOffset < this.targetWidthMultipliedByChannels);
    return outputBuffer;
};
Resize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {
    const ratioWeight = this.ratioWeightHeightPass;
    const ratioWeightDivisor = 1 / ratioWeight;
    const output = this.outputHeightWorkBench;
    const outputBuffer = this.heightBuffer;
    const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
    let weight = 0;
    let amountToNext = 0;
    let actualPosition = 0;
    let currentPosition = 0;
    let pixelOffset = 0;
    let outputOffset = 0;
    let caret = 0;
    let multiplier = 1;
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    do {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            output[pixelOffset++] = 0;
            if (fourthChannel) {
                output[pixelOffset++] = 0;
                trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
            }
        }
        weight = ratioWeight;
        do {
            amountToNext = 1 + actualPosition - currentPosition;
            multiplier = Math.min(weight, amountToNext);
            caret = actualPosition;
            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
                r = buffer[caret++];
                g = buffer[caret++];
                b = buffer[caret++];
                a = fourthChannel ? buffer[caret++] : 255;
                // Ignore RGB values if pixel is completely transparent
                output[pixelOffset++] += (a ? r : 0) * multiplier;
                output[pixelOffset++] += (a ? g : 0) * multiplier;
                output[pixelOffset++] += (a ? b : 0) * multiplier;
                if (fourthChannel) {
                    output[pixelOffset++] += a * multiplier;
                    trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
                }
            }
            if (weight >= amountToNext) {
                actualPosition = caret;
                currentPosition = actualPosition;
                weight -= amountToNext;
            }
            else {
                currentPosition += weight;
                break;
            }
        } while (weight > 0 && actualPosition < this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
            weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
            multiplier = fourthChannel
                ? weight
                    ? 1 / weight
                    : 0
                : ratioWeightDivisor;
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
            if (fourthChannel) {
                outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
            }
        }
    } while (outputOffset < this.finalResultSize);
    return outputBuffer;
};
Resize.prototype.resizeWidthInterpolatedRGB = function (buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {
    return this._resizeWidthInterpolatedRGBChannels(buffer, true);
};
Resize.prototype.resizeWidthRGB = function (buffer) {
    return this._resizeWidthRGBChannels(buffer, false);
};
Resize.prototype.resizeWidthRGBA = function (buffer) {
    return this._resizeWidthRGBChannels(buffer, true);
};
Resize.prototype.resizeHeightInterpolated = function (buffer) {
    const ratioWeight = this.ratioWeightHeightPass;
    const outputBuffer = this.heightBuffer;
    let weight = 0;
    let finalOffset = 0;
    let pixelOffset = 0;
    let pixelOffsetAccumulated = 0;
    let pixelOffsetAccumulated2 = 0;
    let firstWeight = 0;
    let secondWeight = 0;
    let interpolationHeightSourceReadStop;
    // Handle for only one interpolation input being valid for start calculation:
    for (; weight < 1 / 3; weight += ratioWeight) {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
        }
    }
    // Adjust for overshoot of the last pass's counter:
    weight -= 1 / 3;
    for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
        // Calculate weightings:
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        // Interpolate:
        pixelOffsetAccumulated =
            Math.floor(weight) * this.targetWidthMultipliedByChannels;
        pixelOffsetAccumulated2 =
            pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight +
                buffer[pixelOffsetAccumulated2++] * secondWeight);
        }
    }
    // Handle for only one interpolation input being valid for end calculation:
    while (finalOffset < this.finalResultSize) {
        for (pixelOffset = 0,
            pixelOffsetAccumulated =
                interpolationHeightSourceReadStop *
                    this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
        }
    }
    return outputBuffer;
};
Resize.prototype.resizeHeightRGB = function (buffer) {
    return this._resizeHeightRGBChannels(buffer, false);
};
Resize.prototype.resizeHeightRGBA = function (buffer) {
    return this._resizeHeightRGBChannels(buffer, true);
};
Resize.prototype.resize = function (buffer) {
    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
};
Resize.prototype.bypassResizer = function (buffer) {
    // Just return the buffer passed:
    return buffer;
};
Resize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {
    // Initialize the internal width pass buffers:
    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
    if (!BILINEARAlgo) {
        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
        if (this.colorChannels > 3) {
            this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
        }
    }
};
Resize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {
    // Initialize the internal height pass buffers:
    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
    if (!BILINEARAlgo) {
        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
        if (this.colorChannels > 3) {
            this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
        }
    }
};
Resize.prototype.generateFloatBuffer = function (bufferLength) {
    // Generate a float32 typed array buffer:
    try {
        return new Float32Array(bufferLength);
    }
    catch (error) {
        console.error(error);
        return [];
    }
};
Resize.prototype.generateFloat64Buffer = function (bufferLength) {
    // Generate a float64 typed array buffer:
    try {
        return new Float64Array(bufferLength);
    }
    catch (error) {
        console.error(error);
        return [];
    }
};
Resize.prototype.generateUint8Buffer = function (bufferLength) {
    // Generate a uint8 typed array buffer:
    try {
        return new Uint8Array(bufferLength);
    }
    catch (error) {
        console.error(error);
        return [];
    }
};

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Copyright (c) 2015 Guyon Roche
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const operations = {
    nearestNeighbor(src, dst) {
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const bufSrc = src.data;
        const bufDst = dst.data;
        for (let i = 0; i < hDst; i++) {
            for (let j = 0; j < wDst; j++) {
                let posDst = (i * wDst + j) * 4;
                const iSrc = Math.floor((i * hSrc) / hDst);
                const jSrc = Math.floor((j * wSrc) / wDst);
                let posSrc = (iSrc * wSrc + jSrc) * 4;
                bufDst[posDst++] = bufSrc[posSrc++];
                bufDst[posDst++] = bufSrc[posSrc++];
                bufDst[posDst++] = bufSrc[posSrc++];
                bufDst[posDst++] = bufSrc[posSrc++];
            }
        }
    },
    bilinearInterpolation(src, dst) {
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const bufSrc = src.data;
        const bufDst = dst.data;
        const interpolate = function (k, kMin, vMin, kMax, vMax) {
            // special case - k is integer
            if (kMin === kMax) {
                return vMin;
            }
            return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
        };
        const assign = function (pos, offset, x, xMin, xMax, y, yMin, yMax) {
            let posMin = (yMin * wSrc + xMin) * 4 + offset;
            let posMax = (yMin * wSrc + xMax) * 4 + offset;
            const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
            // special case, y is integer
            if (yMax === yMin) {
                bufDst[pos + offset] = vMin;
            }
            else {
                posMin = (yMax * wSrc + xMin) * 4 + offset;
                posMax = (yMax * wSrc + xMax) * 4 + offset;
                const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
                bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
            }
        };
        for (let i = 0; i < hDst; i++) {
            for (let j = 0; j < wDst; j++) {
                const posDst = (i * wDst + j) * 4;
                // x & y in src coordinates
                const x = (j * wSrc) / wDst;
                const xMin = Math.floor(x);
                const xMax = Math.min(Math.ceil(x), wSrc - 1);
                const y = (i * hSrc) / hDst;
                const yMin = Math.floor(y);
                const yMax = Math.min(Math.ceil(y), hSrc - 1);
                assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
                assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
                assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
                assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
            }
        }
    },
    _interpolate2D(src, dst, options, interpolate) {
        const bufSrc = src.data;
        const bufDst = dst.data;
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares
        const wM = Math.max(1, Math.floor(wSrc / wDst));
        const wDst2 = wDst * wM;
        const hM = Math.max(1, Math.floor(hSrc / hDst));
        const hDst2 = hDst * hM;
        // ===========================================================
        // Pass 1 - interpolate rows
        // buf1 has width of dst2 and height of src
        const buf1 = Buffer.alloc(wDst2 * hSrc * 4);
        for (let i = 0; i < hSrc; i++) {
            for (let j = 0; j < wDst2; j++) {
                // i in src coords, j in dst coords
                // calculate x in src coords
                // this interpolation requires 4 sample points and the two inner ones must be real
                // the outer points can be fudged for the edges.
                // therefore (wSrc-1)/wDst2
                const x = (j * (wSrc - 1)) / wDst2;
                const xPos = Math.floor(x);
                const t = x - xPos;
                const srcPos = (i * wSrc + xPos) * 4;
                const buf1Pos = (i * wDst2 + j) * 4;
                for (let k = 0; k < 4; k++) {
                    const kPos = srcPos + k;
                    const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
                    const x1 = bufSrc[kPos];
                    const x2 = bufSrc[kPos + 4];
                    const x3 = xPos < wSrc - 2
                        ? bufSrc[kPos + 8]
                        : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
                    buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
                }
            }
        }
        // this._writeFile(wDst2, hSrc, buf1, "out/buf1.jpg");
        // ===========================================================
        // Pass 2 - interpolate columns
        // buf2 has width and height of dst2
        const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
        for (let i = 0; i < hDst2; i++) {
            for (let j = 0; j < wDst2; j++) {
                // i&j in dst2 coords
                // calculate y in buf1 coords
                // this interpolation requires 4 sample points and the two inner ones must be real
                // the outer points can be fudged for the edges.
                // therefore (hSrc-1)/hDst2
                const y = (i * (hSrc - 1)) / hDst2;
                const yPos = Math.floor(y);
                const t = y - yPos;
                const buf1Pos = (yPos * wDst2 + j) * 4;
                const buf2Pos = (i * wDst2 + j) * 4;
                for (let k = 0; k < 4; k++) {
                    const kPos = buf1Pos + k;
                    const y0 = yPos > 0
                        ? buf1[kPos - wDst2 * 4]
                        : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];
                    const y1 = buf1[kPos];
                    const y2 = buf1[kPos + wDst2 * 4];
                    const y3 = yPos < hSrc - 2
                        ? buf1[kPos + wDst2 * 8]
                        : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];
                    buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);
                }
            }
        }
        // this._writeFile(wDst2, hDst2, buf2, "out/buf2.jpg");
        // ===========================================================
        // Pass 3 - scale to dst
        const m = wM * hM;
        if (m > 1) {
            for (let i = 0; i < hDst; i++) {
                for (let j = 0; j < wDst; j++) {
                    // i&j in dst bounded coords
                    let r = 0;
                    let g = 0;
                    let b = 0;
                    let a = 0;
                    let realColors = 0;
                    for (let y = 0; y < hM; y++) {
                        const yPos = i * hM + y;
                        for (let x = 0; x < wM; x++) {
                            const xPos = j * wM + x;
                            const xyPos = (yPos * wDst2 + xPos) * 4;
                            const pixelAlpha = buf2[xyPos + 3];
                            if (pixelAlpha) {
                                r += buf2[xyPos];
                                g += buf2[xyPos + 1];
                                b += buf2[xyPos + 2];
                                realColors++;
                            }
                            a += pixelAlpha;
                        }
                    }
                    const pos = (i * wDst + j) * 4;
                    bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
                    bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
                    bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
                    bufDst[pos + 3] = Math.round(a / m);
                }
            }
        }
        else {
            // replace dst buffer with buf2
            dst.data = buf2;
        }
    },
    bicubicInterpolation(src, dst, options) {
        const interpolateCubic = function (x0, x1, x2, x3, t) {
            const a0 = x3 - x2 - x0 + x1;
            const a1 = x0 - x1 - a0;
            const a2 = x2 - x0;
            const a3 = x1;
            return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
        };
        return this._interpolate2D(src, dst, options, interpolateCubic);
    },
    hermiteInterpolation(src, dst, options) {
        const interpolateHermite = function (x0, x1, x2, x3, t) {
            const c0 = x1;
            const c1 = 0.5 * (x2 - x0);
            const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
            const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
            return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
        };
        return this._interpolate2D(src, dst, options, interpolateHermite);
    },
    bezierInterpolation(src, dst, options) {
        // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)
        // to predict control points (a & b) to be placed at n+0.5
        //  ya(n) = y(n) + (y(n+1)-y(n-1))/4
        //  yb(n) = y(n+1) - (y(n+2)-y(n))/4
        // then use std bezier to interpolate [n,n+1)
        //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3
        //  note the 3* factor for the two control points
        // for edge cases, can choose:
        //  y(-1) = y(0) - 2*(y(1)-y(0))
        //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))
        // but can go with y(-1) = y(0) and y(w) = y(w-1)
        const interpolateBezier = function (x0, x1, x2, x3, t) {
            // x1, x2 are the knots, use x0 and x3 to calculate control points
            const cp1 = x1 + (x2 - x0) / 4;
            const cp2 = x2 - (x3 - x1) / 4;
            const nt = 1 - t;
            const c0 = x1 * nt * nt * nt;
            const c1 = 3 * cp1 * nt * nt * t;
            const c2 = 3 * cp2 * nt * t * t;
            const c3 = x2 * t * t * t;
            return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
        };
        return this._interpolate2D(src, dst, options, interpolateBezier);
    },
};

const ResizeOptionsSchema = unionType([
    objectType({
        /** the width to resize the image to */
        w: numberType().min(0),
        /** the height to resize the image to */
        h: numberType().min(0).optional(),
        /** a scaling method (e.g. ResizeStrategy.BEZIER) */
        mode: nativeEnumType(ResizeStrategy).optional(),
    }),
    objectType({
        /** the width to resize the image to */
        w: numberType().min(0).optional(),
        /** the height to resize the image to */
        h: numberType().min(0),
        /** a scaling method (e.g. ResizeStrategy.BEZIER) */
        mode: nativeEnumType(ResizeStrategy).optional(),
    }),
]);
const ScaleToFitOptionsSchema = objectType({
    /** the width to resize the image to */
    w: numberType().min(0),
    /** the height to resize the image to */
    h: numberType().min(0),
    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const ScaleComplexOptionsSchema = objectType({
    /** the width to resize the image to */
    f: numberType().min(0),
    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const methods$d = {
    /**
     * Resizes the image to a set width and height using a 2-pass bilinear algorithm
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.resize({ w: 150 });
     * ```
     */
    resize(image, options) {
        const { mode } = ResizeOptionsSchema.parse(options);
        let w;
        let h;
        if (typeof options.w === "number") {
            w = options.w;
            h = options.h ?? image.bitmap.height * (w / image.bitmap.width);
        }
        else if (typeof options.h === "number") {
            h = options.h;
            w = options.w ?? image.bitmap.width * (h / image.bitmap.height);
        }
        else {
            throw new Error("w must be a number");
        }
        // round inputs
        w = Math.round(w) || 1;
        h = Math.round(h) || 1;
        if (mode && typeof operations[mode] === "function") {
            const dst = {
                data: Buffer.alloc(w * h * 4),
                width: w,
                height: h,
            };
            operations[mode](image.bitmap, dst);
            image.bitmap = dst;
        }
        else {
            const resize = new Resize(image.bitmap.width, image.bitmap.height, w, h, true, true, (buffer) => {
                image.bitmap.data = Buffer.from(buffer);
                image.bitmap.width = w;
                image.bitmap.height = h;
            });
            resize.resize(image.bitmap.data);
        }
        return image;
    },
    /**
     * Uniformly scales the image by a factor.
     * @param f the factor to scale the image by
     * @param mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.scale(0.5);
     * ```
     */
    scale(image, options) {
        const { f, mode } = typeof options === "number"
            ? { f: options }
            : ScaleComplexOptionsSchema.parse(options);
        const w = image.bitmap.width * f;
        const h = image.bitmap.height * f;
        return this.resize(image, { w, h, mode: mode });
    },
    /**
     * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
     * @param w the width to resize the image to
     * @param h the height to resize the image to
     * @param mode a scaling method (e.g. ResizeStrategy.BEZIER)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.scaleToFit(100, 100);
     * ```
     */
    scaleToFit(image, options) {
        const { h, w, mode } = ScaleToFitOptionsSchema.parse(options);
        const f = w / h > image.bitmap.width / image.bitmap.height
            ? h / image.bitmap.height
            : w / image.bitmap.width;
        return this.scale(image, { f, mode: mode });
    },
};

const ContainOptionsSchema = objectType({
    /** the width to resize the image to */
    w: numberType(),
    /** the height to resize the image to */
    h: numberType(),
    /** A bitmask for horizontal and vertical alignment */
    align: numberType().optional(),
    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const methods$c = {
    /**
     * Scale the image to the given width and height keeping the aspect ratio. Some parts of the image may be letter boxed.
     * @param w the width to resize the image to
     * @param h the height to resize the image to
     * @param align A bitmask for horizontal and vertical alignment
     * @param mode a scaling method (e.g. Jimp.RESIZE_BEZIER)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.contain({ w: 150, h: 100 });
     * ```
     */
    contain(image, options) {
        const { w, h, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode, } = ContainOptionsSchema.parse(options);
        const hbits = align & ((1 << 3) - 1);
        const vbits = align >> 3;
        // check if more flags than one is in the bit sets
        if (!((hbits !== 0 && !(hbits & (hbits - 1))) ||
            (vbits !== 0 && !(vbits & (vbits - 1))))) {
            throw new Error("only use one flag per alignment direction");
        }
        const alignH = hbits >> 1; // 0, 1, 2
        const alignV = vbits >> 1; // 0, 1, 2
        const f = w / h > image.bitmap.width / image.bitmap.height
            ? h / image.bitmap.height
            : w / image.bitmap.width;
        const c = methods$d.scale(clone(image), { f, mode });
        image = methods$d.resize(image, { w, h, mode });
        image.scan((_, __, idx) => {
            image.bitmap.data.writeUInt32BE(image.background, idx);
        });
        image = methods$h.blit(image, {
            src: c,
            x: ((image.bitmap.width - c.bitmap.width) / 2) * alignH,
            y: ((image.bitmap.height - c.bitmap.height) / 2) * alignV,
        });
        return image;
    },
};

const CropOptionsSchema = objectType({
    /** the x position to crop form */
    x: numberType(),
    /** the y position to crop form */
    y: numberType(),
    /** the width to crop form */
    w: numberType(),
    /** the height to crop form */
    h: numberType(),
});
const AutocropComplexOptionsSchema = objectType({
    /** percent of color difference tolerance (default value) */
    tolerance: numberType().min(0).max(1).optional(),
    /** flag to force cropping only if the image has a real "frame" i.e. all 4 sides have some border (default value) */
    cropOnlyFrames: booleanType().optional(),
    /** force cropping top be symmetric */
    cropSymmetric: booleanType().optional(),
    /** Amount of pixels in border to leave */
    leaveBorder: numberType().optional(),
    ignoreSides: objectType({
        north: booleanType().optional(),
        south: booleanType().optional(),
        east: booleanType().optional(),
        west: booleanType().optional(),
    })
        .optional(),
});
const methods$b = {
    /**
     * Crops the image at a given point to a give size.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const cropped = image.crop(150, 100);
     * ```
     */
    crop(image, options) {
        let { x, y, w, h } = CropOptionsSchema.parse(options);
        // round input
        x = Math.round(x);
        y = Math.round(y);
        w = Math.round(w);
        h = Math.round(h);
        if (x === 0 && w === image.bitmap.width) {
            // shortcut
            const start = (w * y + x) << 2;
            const end = start + ((h * w) << 2);
            image.bitmap.data = image.bitmap.data.slice(start, end);
        }
        else {
            const bitmap = Buffer.allocUnsafe(w * h * 4);
            let offset = 0;
            scan(image, x, y, w, h, function (_, __, idx) {
                const data = image.bitmap.data.readUInt32BE(idx);
                bitmap.writeUInt32BE(data, offset);
                offset += 4;
            });
            image.bitmap.data = bitmap;
        }
        image.bitmap.width = w;
        image.bitmap.height = h;
        return image;
    },
    /**
     * Autocrop same color borders from this image.
     * This function will attempt to crop out transparent pixels from the image.
     *
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const cropped = image.autocrop();
     * ```
     */
    autocrop(image, options = {}) {
        const { tolerance = 0.0002, cropOnlyFrames = true, cropSymmetric = false, leaveBorder = 0, ignoreSides: ignoreSidesArg, } = typeof options === "number"
            ? { tolerance: options }
            : AutocropComplexOptionsSchema.parse(options);
        const w = image.bitmap.width;
        const h = image.bitmap.height;
        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image
        // i.e. north and south / east and west are cropped by the same value
        const ignoreSides = {
            north: false,
            south: false,
            east: false,
            west: false,
            ...ignoreSidesArg,
        };
        /**
         * All borders must be of the same color as the top left pixel, to be cropped.
         * It should be possible to crop borders each with a different color,
         * but since there are many ways for corners to intersect, it would
         * introduce unnecessary complexity to the algorithm.
         */
        // scan each side for same color borders
        let colorTarget = image.getPixelColor(0, 0); // top left pixel color is the target color
        const rgba1 = intToRGBA$1(colorTarget);
        // for north and east sides
        let northPixelsToCrop = 0;
        let eastPixelsToCrop = 0;
        let southPixelsToCrop = 0;
        let westPixelsToCrop = 0;
        // north side (scan rows from north to south)
        colorTarget = image.getPixelColor(0, 0);
        if (!ignoreSides.north) {
            north: for (let y = 0; y < h - minPixelsPerSide; y++) {
                for (let x = 0; x < w; x++) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break north;
                    }
                }
                // this row contains all pixels with the same color: increment this side pixels to crop
                northPixelsToCrop++;
            }
        }
        // west side (scan columns from west to east)
        colorTarget = image.getPixelColor(w, 0);
        if (!ignoreSides.west) {
            west: for (let x = 0; x < w - minPixelsPerSide; x++) {
                for (let y = 0 + northPixelsToCrop; y < h; y++) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break west;
                    }
                }
                // this column contains all pixels with the same color: increment this side pixels to crop
                westPixelsToCrop++;
            }
        }
        // south side (scan rows from south to north)
        colorTarget = image.getPixelColor(0, h);
        if (!ignoreSides.south) {
            south: for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {
                for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break south;
                    }
                }
                // this row contains all pixels with the same color: increment this side pixels to crop
                southPixelsToCrop++;
            }
        }
        // east side (scan columns from east to west)
        colorTarget = image.getPixelColor(w, h);
        if (!ignoreSides.east) {
            east: for (let x = w - 1; x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {
                for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {
                    const colorXY = image.getPixelColor(x, y);
                    const rgba2 = intToRGBA$1(colorXY);
                    if (colorDiff(rgba1, rgba2) > tolerance) {
                        // this pixel is too distant from the first one: abort this side scan
                        break east;
                    }
                }
                // this column contains all pixels with the same color: increment this side pixels to crop
                eastPixelsToCrop++;
            }
        }
        // decide if a crop is needed
        let doCrop = false;
        // apply leaveBorder
        westPixelsToCrop -= leaveBorder;
        eastPixelsToCrop -= leaveBorder;
        northPixelsToCrop -= leaveBorder;
        southPixelsToCrop -= leaveBorder;
        if (cropSymmetric) {
            const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
            const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
            westPixelsToCrop = horizontal;
            eastPixelsToCrop = horizontal;
            northPixelsToCrop = vertical;
            southPixelsToCrop = vertical;
        }
        // make sure that crops are >= 0
        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
        // safety checks
        const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
        const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
        if (cropOnlyFrames) {
            // crop image if all sides should be cropped
            doCrop =
                eastPixelsToCrop !== 0 &&
                    northPixelsToCrop !== 0 &&
                    westPixelsToCrop !== 0 &&
                    southPixelsToCrop !== 0;
        }
        else {
            // crop image if at least one side should be cropped
            doCrop =
                eastPixelsToCrop !== 0 ||
                    northPixelsToCrop !== 0 ||
                    westPixelsToCrop !== 0 ||
                    southPixelsToCrop !== 0;
        }
        if (doCrop) {
            // do the real crop
            this.crop(image, {
                x: westPixelsToCrop,
                y: northPixelsToCrop,
                w: widthOfRemainingPixels,
                h: heightOfRemainingPixels,
            });
        }
        return image;
    },
};

const CoverOptionsSchema = objectType({
    /** the width to resize the image to */
    w: numberType(),
    /** the height to resize the image to */
    h: numberType(),
    /** A bitmask for horizontal and vertical alignment */
    align: numberType().optional(),
    /** a scaling method (e.g. ResizeStrategy.BEZIER) */
    mode: nativeEnumType(ResizeStrategy).optional(),
});
const methods$a = {
    /**
     * Scale the image so the given width and height keeping the aspect ratio. Some parts of the image may be clipped.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.cover(150, 100);
     * ```
     */
    cover(image, options) {
        const { w, h, align = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode, } = CoverOptionsSchema.parse(options);
        const hbits = align & ((1 << 3) - 1);
        const vbits = align >> 3;
        // check if more flags than one is in the bit sets
        if (!((hbits !== 0 && !(hbits & (hbits - 1))) ||
            (vbits !== 0 && !(vbits & (vbits - 1))))) {
            throw new Error("only use one flag per alignment direction");
        }
        const alignH = hbits >> 1; // 0, 1, 2
        const alignV = vbits >> 1; // 0, 1, 2
        const f = w / h > image.bitmap.width / image.bitmap.height
            ? w / image.bitmap.width
            : h / image.bitmap.height;
        image = methods$d.scale(image, {
            f,
            mode,
        });
        image = methods$b.crop(image, {
            x: ((image.bitmap.width - w) / 2) * alignH,
            y: ((image.bitmap.height - h) / 2) * alignV,
            w,
            h,
        });
        return image;
    },
};

const DisplaceOptionsSchema = objectType({
    /** the source Jimp instance */
    map: JimpClassSchema,
    /** the maximum displacement value */
    offset: numberType(),
});
const methods$9 = {
    /**
     * Displaces the image based on the provided displacement map
     * @param map the source Jimp instance
     * @param offset
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const map = await Jimp.read("test/map.png");
     *
     * image.displace(map, 10);
     * ```
     */
    displace(image, options) {
        const { map, offset } = DisplaceOptionsSchema.parse(options);
        const source = clone(image);
        image.scan((x, y, idx) => {
            let displacement = (map.bitmap.data[idx] / 256) * offset;
            displacement = Math.round(displacement);
            const ids = image.getPixelIndex(x + displacement, y);
            image.bitmap.data[ids] = source.bitmap.data[idx];
            image.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
            image.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
        });
        return image;
    },
};

const methods$8 = {
    /**
     * Apply a ordered dithering effect.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.dither();
     * ```
     */
    dither(image) {
        const rgb565Matrix = [
            1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6,
        ];
        image.scan((x, y, idx) => {
            const thresholdId = ((y & 3) << 2) + (x % 4);
            const dither = rgb565Matrix[thresholdId];
            image.bitmap.data[idx] = Math.min(image.bitmap.data[idx] + dither, 0xff);
            image.bitmap.data[idx + 1] = Math.min(image.bitmap.data[idx + 1] + dither, 0xff);
            image.bitmap.data[idx + 2] = Math.min(image.bitmap.data[idx + 2] + dither, 0xff);
        });
        return image;
    },
};

const FisheyeOptionsSchema = objectType({
    /** the radius of the circle */
    radius: numberType().min(0).optional(),
});
const methods$7 = {
    /**
     * Adds a fisheye effect to the image.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.fisheye();
     * ```
     */
    fisheye(image, options = {}) {
        const { radius = 2.5 } = FisheyeOptionsSchema.parse(options);
        const source = clone(image);
        const { width, height } = source.bitmap;
        source.scan((x, y) => {
            const hx = x / width;
            const hy = y / height;
            const rActual = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
            const rn = 2 * Math.pow(rActual, radius);
            const cosA = (hx - 0.5) / rActual;
            const sinA = (hy - 0.5) / rActual;
            const newX = Math.round((rn * cosA + 0.5) * width);
            const newY = Math.round((rn * sinA + 0.5) * height);
            const color = source.getPixelColor(newX, newY);
            image.setPixelColor(color, x, y);
        });
        /* Set center pixel color, otherwise it will be transparent */
        image.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
        return image;
    },
};

const FlipOptionsSchema = objectType({
    /** if true the image will be flipped horizontally */
    horizontal: booleanType().optional(),
    /** if true the image will be flipped vertically */
    vertical: booleanType().optional(),
});
const methods$6 = {
    /**
     * Flip the image.
     * @param horizontal a Boolean, if true the image will be flipped horizontally
     * @param vertical a Boolean, if true the image will be flipped vertically
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.flip(true, false);
     * ```
     */
    flip(image, options) {
        const { horizontal, vertical } = FlipOptionsSchema.parse(options);
        const bitmap = Buffer.alloc(image.bitmap.data.length);
        image.scan((x, y, idx) => {
            const _x = horizontal ? image.bitmap.width - 1 - x : x;
            const _y = vertical ? image.bitmap.height - 1 - y : y;
            const _idx = (image.bitmap.width * _y + _x) << 2;
            const data = image.bitmap.data.readUInt32BE(idx);
            bitmap.writeUInt32BE(data, _idx);
        });
        image.bitmap.data = Buffer.from(bitmap);
        return image;
    },
};

var converter;
var hasRequiredConverter;

function requireConverter () {
	if (hasRequiredConverter) return converter;
	hasRequiredConverter = 1;

	/**
	 * Converter
	 *
	 * @param {string|Array} srcAlphabet
	 * @param {string|Array} dstAlphabet
	 * @constructor
	 */
	function Converter(srcAlphabet, dstAlphabet) {
	    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
	        throw new Error('Bad alphabet');
	    }
	    this.srcAlphabet = srcAlphabet;
	    this.dstAlphabet = dstAlphabet;
	}

	/**
	 * Convert number from source alphabet to destination alphabet
	 *
	 * @param {string|Array} number - number represented as a string or array of points
	 *
	 * @returns {string|Array}
	 */
	Converter.prototype.convert = function(number) {
	    var i, divide, newlen,
	    numberMap = {},
	    fromBase = this.srcAlphabet.length,
	    toBase = this.dstAlphabet.length,
	    length = number.length,
	    result = typeof number === 'string' ? '' : [];

	    if (!this.isValid(number)) {
	        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
	    }

	    if (this.srcAlphabet === this.dstAlphabet) {
	        return number;
	    }

	    for (i = 0; i < length; i++) {
	        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
	    }
	    do {
	        divide = 0;
	        newlen = 0;
	        for (i = 0; i < length; i++) {
	            divide = divide * fromBase + numberMap[i];
	            if (divide >= toBase) {
	                numberMap[newlen++] = parseInt(divide / toBase, 10);
	                divide = divide % toBase;
	            } else if (newlen > 0) {
	                numberMap[newlen++] = 0;
	            }
	        }
	        length = newlen;
	        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
	    } while (newlen !== 0);

	    return result;
	};

	/**
	 * Valid number with source alphabet
	 *
	 * @param {number} number
	 *
	 * @returns {boolean}
	 */
	Converter.prototype.isValid = function(number) {
	    var i = 0;
	    for (; i < number.length; ++i) {
	        if (this.srcAlphabet.indexOf(number[i]) === -1) {
	            return false;
	        }
	    }
	    return true;
	};

	converter = Converter;
	return converter;
}

var anyBase_1;
var hasRequiredAnyBase;

function requireAnyBase () {
	if (hasRequiredAnyBase) return anyBase_1;
	hasRequiredAnyBase = 1;
	var Converter = requireConverter();

	/**
	 * Function get source and destination alphabet and return convert function
	 *
	 * @param {string|Array} srcAlphabet
	 * @param {string|Array} dstAlphabet
	 *
	 * @returns {function(number|Array)}
	 */
	function anyBase(srcAlphabet, dstAlphabet) {
	    var converter = new Converter(srcAlphabet, dstAlphabet);
	    /**
	     * Convert function
	     *
	     * @param {string|Array} number
	     *
	     * @return {string|Array} number
	     */
	    return function (number) {
	        return converter.convert(number);
	    }
	}
	anyBase.BIN = '01';
	anyBase.OCT = '01234567';
	anyBase.DEC = '0123456789';
	anyBase.HEX = '0123456789abcdef';

	anyBase_1 = anyBase;
	return anyBase_1;
}

var anyBaseExports = requireAnyBase();
var anyBase = /*@__PURE__*/getDefaultExportFromCjs(anyBaseExports);

/*
Copyright (c) 2011 Elliot Shepherd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
// https://code.google.com/p/ironchef-team21/source/browse/ironchef_team21/src/ImagePHash.java
/*
 * pHash-like image hash.
 * Author: Elliot Shepherd (elliot@jarofworms.com
 * Based On: http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html
 */
class ImagePHash {
    size;
    smallerSize;
    constructor(size, smallerSize) {
        this.size = size || 32;
        this.smallerSize = smallerSize || 8;
        initCoefficients(this.size);
    }
    distance(s1, s2) {
        let counter = 0;
        for (let k = 0; k < s1.length; k++) {
            if (s1[k] !== s2[k]) {
                counter++;
            }
        }
        return counter / s1.length;
    }
    /**
     * Returns a 'binary string' (like. 001010111011100010) which is easy to do a hamming distance on.
     */
    getHash(img) {
        /* 1. Reduce size.
         * Like Average Hash, pHash starts with a small image.
         * However, the image is larger than 8x8; 32x32 is a good size.
         * This is really done to simplify the DCT computation and not
         * because it is needed to reduce the high frequencies.
         */
        img = methods$d.resize(clone(img), { w: this.size, h: this.size });
        /* 2. Reduce color.
         * The image is reduced to a grayscale just to further simplify
         * the number of computations.
         */
        img = methods$e.greyscale(img);
        const vals = [];
        for (let x = 0; x < img.bitmap.width; x++) {
            const row = [];
            for (let y = 0; y < img.bitmap.height; y++) {
                row[y] = intToRGBA(img.getPixelColor(x, y)).b;
            }
            vals[x] = row;
        }
        /* 3. Compute the DCT.
         * The DCT separates the image into a collection of frequencies
         * and scalars. While JPEG uses an 8x8 DCT, this algorithm uses
         * a 32x32 DCT.
         */
        const dctVals = applyDCT(vals, this.size);
        /* 4. Reduce the DCT.
         * This is the magic step. While the DCT is 32x32, just keep the
         * top-left 8x8. Those represent the lowest frequencies in the
         * picture.
         */
        /* 5. Compute the average value.
         * Like the Average Hash, compute the mean DCT value (using only
         * the 8x8 DCT low-frequency values and excluding the first term
         * since the DC coefficient can be significantly different from
         * the other values and will throw off the average).
         */
        let total = 0;
        for (let x = 0; x < this.smallerSize; x++) {
            for (let y = 0; y < this.smallerSize; y++) {
                total += dctVals[x][y];
            }
        }
        const avg = total / (this.smallerSize * this.smallerSize);
        /* 6. Further reduce the DCT.
         * This is the magic step. Set the 64 hash bits to 0 or 1
         * depending on whether each of the 64 DCT values is above or
         * below the average value. The result doesn't tell us the
         * actual low frequencies; it just tells us the very-rough
         * relative scale of the frequencies to the mean. The result
         * will not vary as long as the overall structure of the image
         * remains the same; this can survive gamma and color histogram
         * adjustments without a problem.
         */
        let hash = "";
        for (let x = 0; x < this.smallerSize; x++) {
            for (let y = 0; y < this.smallerSize; y++) {
                hash += dctVals[x][y] > avg ? "1" : "0";
            }
        }
        return hash;
    }
}
// DCT function stolen from http://stackoverflow.com/questions/4240490/problems-with-dct-and-idct-algorithm-in-java
/**
 Convert a 32-bit integer color value to an RGBA object.
 */
function intToRGBA(i) {
    const a = i & 0xff;
    i >>>= 8;
    const b = i & 0xff;
    i >>>= 8;
    const g = i & 0xff;
    i >>>= 8;
    const r = i & 0xff;
    return { r, g, b, a };
}
const c = [];
function initCoefficients(size) {
    for (let i = 1; i < size; i++) {
        c[i] = 1;
    }
    c[0] = 1 / Math.sqrt(2.0);
}
function applyDCT(f, size) {
    const N = size;
    const F = [];
    for (let u = 0; u < N; u++) {
        const row = [];
        for (let v = 0; v < N; v++) {
            let sum = 0;
            for (let i = 0; i < N; i++) {
                for (let j = 0; j < N; j++) {
                    sum +=
                        Math.cos(((2 * i + 1) / (2.0 * N)) * u * Math.PI) *
                            Math.cos(((2 * j + 1) / (2.0 * N)) * v * Math.PI) *
                            f[i][j];
                }
            }
            sum *= (c[u] * c[v]) / 4;
            row[v] = sum;
            F[u] = row;
        }
    }
    return F;
}

// an array storing the maximum string length of hashes at various bases
// 0 and 1 do not exist as possible hash lengths
// prettier-ignore
const alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
// an array storing the maximum string length of hashes at various bases
// 0 and 1 do not exist as possible hash lengths
const maxHashLength = [NaN, NaN];
for (let i = 2; i < 65; i++) {
    const maxHash = anyBase(anyBase.BIN, alphabet.slice(0, i))(new Array(64 + 1).join("1"));
    maxHashLength.push(maxHash.length);
}
const methods$5 = {
    /**
     * Calculates the perceptual hash
     * @returns the perceptual hash
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.hash();
     * ```
     */
    pHash(image) {
        const pHash = new ImagePHash();
        return pHash.getHash(image);
    },
    /**
     * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
     * @param base A number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.hash(2); // binary
     * image.hash(64); // base 64
     * ```
     */
    hash(image, base = 64) {
        if (base < 2 || base > 64) {
            throw new Error("base must be a number between 2 and 64");
        }
        const subAlphabet = alphabet.slice(0, base);
        const pHash = this.pHash(image);
        const maxLength = maxHashLength[base];
        return anyBase(anyBase.BIN, subAlphabet)(pHash).padStart(maxLength, "0");
    },
    /**
     * Calculates the hamming distance of the current image and a hash based on their perceptual hash
     * @param compareHash hash to compare to
     * @returns  a number ranging from 0 to 1, 0 means they are believed to be identical
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.distanceFromHash(image.pHash());
     * ```
     */
    distanceFromHash(image, compareHash) {
        const pHash = new ImagePHash();
        const currentHash = pHash.getHash(image);
        return pHash.distance(currentHash, compareHash);
    },
};

const MaskOptionsObjectSchema = objectType({
    src: JimpClassSchema,
    /** the x position to draw the image */
    x: numberType().optional(),
    /** the y position to draw the image */
    y: numberType().optional(),
});
const MaskOptionsSchema = unionType([JimpClassSchema, MaskOptionsObjectSchema]);
const methods$4 = {
    /**
     * Masks a source image on to this image using average pixel colour. A completely black pixel on the mask will turn a pixel in the image completely transparent.
     * @param src the source Jimp instance
     * @param x the horizontal position to blit the image
     * @param y the vertical position to blit the image
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const mask = await Jimp.read("test/mask.png");
     *
     * image.mask(mask);
     * ```
     */
    mask(image, options) {
        MaskOptionsSchema.parse(options);
        let src;
        let x;
        let y;
        if ("bitmap" in options) {
            src = options;
            x = 0;
            y = 0;
        }
        else {
            src = options.src;
            x = options.x ?? 0;
            y = options.y ?? 0;
        }
        // round input
        x = Math.round(x);
        y = Math.round(y);
        const w = image.bitmap.width;
        const h = image.bitmap.height;
        src.scan(function (sx, sy, idx) {
            const destX = x + sx;
            const destY = y + sy;
            if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
                const dstIdx = image.getPixelIndex(destX, destY);
                const { data } = src.bitmap;
                const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
                image.bitmap.data[dstIdx + 3] *= avg / 255;
            }
        });
        return image;
    },
};

function measureText(font, text) {
    let x = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const fontChar = font.chars[char];
        if (fontChar) {
            const fontKerning = font.kernings[char];
            const nextChar = text[i + 1];
            const kerning = fontKerning && nextChar && fontKerning[nextChar]
                ? fontKerning[nextChar] || 0
                : 0;
            x += (fontChar.xadvance || 0) + kerning;
        }
    }
    return x;
}
function splitLines(font, text, maxWidth) {
    const words = text.replace(/[\r\n]+/g, " \n").split(" ");
    const lines = [];
    let currentLine = [];
    let longestLine = 0;
    words.forEach((word) => {
        const wordWidth = measureText(font, word + (words.length > 1 ? " " : ""));
        // If a word is longer than the allowable width we need to split it across lines.
        if (wordWidth > maxWidth) {
            const characterIterator = word[Symbol.iterator]();
            let current = "";
            for (const char of characterIterator) {
                const nextLine = [...currentLine, current + char].join(" ");
                const length = measureText(font, nextLine);
                if (length < maxWidth) {
                    current += char;
                }
                else if (length > maxWidth) {
                    lines.push([...currentLine, current]);
                    currentLine = [];
                    current = char;
                }
                else {
                    lines.push([...currentLine, current + char]);
                    currentLine = [];
                    current = "";
                }
            }
            return;
        }
        const line = [...currentLine, word].join(" ");
        const length = measureText(font, line);
        if (length <= maxWidth && !word.includes("\n")) {
            if (length > longestLine) {
                longestLine = length;
            }
            currentLine.push(word);
        }
        else {
            lines.push(currentLine);
            currentLine = [word.replace("\n", "")];
        }
    });
    lines.push(currentLine);
    return {
        lines,
        longestLine,
    };
}
function measureTextHeight(font, text, maxWidth) {
    const { lines } = splitLines(font, text, maxWidth);
    return lines.length * font.common.lineHeight;
}

const PrintOptionsSchema = objectType({
    /** the x position to draw the image */
    x: numberType(),
    /** the y position to draw the image */
    y: numberType(),
    /** the text to print */
    text: unionType([
        unionType([stringType(), numberType()]),
        objectType({
            text: unionType([stringType(), numberType()]),
            alignmentX: nativeEnumType(HorizontalAlign).optional(),
            alignmentY: nativeEnumType(VerticalAlign).optional(),
        }),
    ]),
    /** the boundary width to draw in */
    maxWidth: numberType().optional(),
    /** the boundary height to draw in */
    maxHeight: numberType().optional(),
    /** a callback for when complete that ahs the end co-ordinates of the text */
    cb: functionType(tupleType([objectType({ x: numberType(), y: numberType() })]))
        .optional(),
});
function xOffsetBasedOnAlignment(font, line, maxWidth, alignment) {
    if (alignment === HorizontalAlign.LEFT) {
        return 0;
    }
    if (alignment === HorizontalAlign.CENTER) {
        return (maxWidth - measureText(font, line)) / 2;
    }
    return maxWidth - measureText(font, line);
}
function drawCharacter(image, font, x, y, char) {
    if (char.width > 0 && char.height > 0) {
        const characterPage = font.pages[char.page];
        if (characterPage) {
            image = methods$h.blit(image, {
                src: characterPage,
                x: x + char.xoffset,
                y: y + char.yoffset,
                srcX: char.x,
                srcY: char.y,
                srcW: char.width,
                srcH: char.height,
            });
        }
    }
    return image;
}
function printText(image, font, x, y, text, defaultCharWidth) {
    for (let i = 0; i < text.length; i++) {
        const stringChar = text[i];
        let char;
        if (font.chars[stringChar]) {
            char = stringChar;
        }
        else if (/\s/.test(stringChar)) {
            char = "";
        }
        else {
            char = "?";
        }
        const fontChar = font.chars[char] || { xadvance: undefined };
        const fontKerning = font.kernings[char];
        if (fontChar) {
            drawCharacter(image, font, x, y, fontChar);
        }
        const nextChar = text[i + 1];
        const kerning = fontKerning && nextChar && fontKerning[nextChar]
            ? fontKerning[nextChar] || 0
            : 0;
        x += kerning + (fontChar.xadvance || defaultCharWidth);
    }
}
const methods$3 = {
    /**
     * Draws a text on a image on a given boundary
     * @param font a bitmap font loaded from `Jimp.loadFont` command
     * @param x the x position to start drawing the text
     * @param y the y position to start drawing the text
     * @param text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     * const font = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK);
     *
     * image.print({ font, x: 10, y: 10, text: "Hello world!" });
     * ```
     */
    print(image, { font, ...options }) {
        let { 
        // eslint-disable-next-line prefer-const
        x, y, text, 
        // eslint-disable-next-line prefer-const
        maxWidth = Infinity, 
        // eslint-disable-next-line prefer-const
        maxHeight = Infinity, 
        // eslint-disable-next-line prefer-const
        cb = () => { }, } = PrintOptionsSchema.parse(options);
        let alignmentX;
        let alignmentY;
        if (typeof text === "object" &&
            text.text !== null &&
            text.text !== undefined) {
            alignmentX = text.alignmentX || HorizontalAlign.LEFT;
            alignmentY = text.alignmentY || VerticalAlign.TOP;
            ({ text } = text);
        }
        else {
            alignmentX = HorizontalAlign.LEFT;
            alignmentY = VerticalAlign.TOP;
            text = text.toString();
        }
        if (typeof text === "number") {
            text = text.toString();
        }
        if (maxHeight !== Infinity && alignmentY === VerticalAlign.BOTTOM) {
            y += maxHeight - measureTextHeight(font, text, maxWidth);
        }
        else if (maxHeight !== Infinity && alignmentY === VerticalAlign.MIDDLE) {
            y += maxHeight / 2 - measureTextHeight(font, text, maxWidth) / 2;
        }
        const defaultCharWidth = Object.entries(font.chars).find((c) => c[1].xadvance)?.[1].xadvance;
        if (typeof defaultCharWidth !== "number") {
            throw new Error("Could not find default character width");
        }
        const { lines, longestLine } = splitLines(font, text, maxWidth);
        lines.forEach((line) => {
            const lineString = line.join(" ");
            const alignmentWidth = xOffsetBasedOnAlignment(font, lineString, maxWidth, alignmentX);
            printText(image, font, x + alignmentWidth, y, lineString, defaultCharWidth);
            y += font.common.lineHeight;
        });
        cb.bind(image)({ x: x + longestLine, y });
        return image;
    },
};

const RotateOptionsSchema = unionType([
    numberType(),
    objectType({
        /** the number of degrees to rotate the image by */
        deg: numberType(),
        /** resize mode or a boolean, if false then the width and height of the image will not be changed */
        mode: unionType([booleanType(), nativeEnumType(ResizeStrategy)]).optional(),
    }),
]);
/** function to translate the x, y coordinate to the index of the pixel in the buffer */
function createIdxTranslationFunction(w) {
    return function (x, y) {
        return (y * w + x) << 2;
    };
}
/**
 * Rotates an image counter-clockwise by multiple of 90 degrees. NB: 'this' must be a Jimp object.
 *
 * This function is based on matrix rotation. Check this to get an initial idea how it works: https://stackoverflow.com/a/8664879/10561909
 *
 * @param deg the number of degrees to rotate the image by, it should be a multiple of 90
 */
function matrixRotate(image, deg) {
    if (Math.abs(deg) % 90 !== 0) {
        throw new Error("Unsupported matrix rotation degree");
    }
    const w = image.bitmap.width;
    const h = image.bitmap.height;
    // decide which rotation angle to use
    let angle;
    switch (deg) {
        // 90 degree & -270 degree are same
        case 90:
        case -270:
            angle = 90;
            break;
        case 180:
        case -180:
            angle = 180;
            break;
        case 270:
        case -90:
            angle = -90;
            break;
        default:
            throw new Error("Unsupported matrix rotation degree");
    }
    // After this switch block, angle will be 90, 180 or -90
    // calculate the new width and height
    const nW = angle === 180 ? w : h;
    const nH = angle === 180 ? h : w;
    const dstBuffer = Buffer.alloc(image.bitmap.data.length);
    const srcIdxFunction = createIdxTranslationFunction(w);
    const dstIdxFunction = createIdxTranslationFunction(nW);
    for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
            const srcIdx = srcIdxFunction(x, y);
            const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);
            let dstIdx;
            switch (angle) {
                case 90:
                    dstIdx = dstIdxFunction(y, w - x - 1);
                    break;
                case -90:
                    dstIdx = dstIdxFunction(h - y - 1, x);
                    break;
                case 180:
                    dstIdx = dstIdxFunction(w - x - 1, h - y - 1);
                    break;
                default:
                    throw new Error("Unsupported matrix rotation angle");
            }
            dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
        }
    }
    image.bitmap.data = dstBuffer;
    image.bitmap.width = nW;
    image.bitmap.height = nH;
}
function createTranslationFunction(deltaX, deltaY) {
    return function (x, y) {
        return {
            x: x + deltaX,
            y: y + deltaY,
        };
    };
}
/**
 * Rotates an image counter-clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.
 * @param {number} deg the number of degrees to rotate the image by
 */
function advancedRotate(image, deg, mode) {
    const rad = (deg * Math.PI) / 180;
    const cosine = Math.cos(rad);
    const sine = Math.sin(rad);
    // the final width and height will change if resize == true
    let w = image.bitmap.width;
    let h = image.bitmap.height;
    if (mode === true || typeof mode === "string") {
        // resize the image to it maximum dimension and blit the existing image
        // onto the center so that when it is rotated the image is kept in bounds
        // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle
        // Plus 1 border pixel to ensure to show all rotated result for some cases.
        w =
            Math.ceil(Math.abs(image.bitmap.width * cosine) +
                Math.abs(image.bitmap.height * sine)) + 1;
        h =
            Math.ceil(Math.abs(image.bitmap.width * sine) +
                Math.abs(image.bitmap.height * cosine)) + 1;
        // Ensure destination to have even size to a better result.
        if (w % 2 !== 0) {
            w++;
        }
        if (h % 2 !== 0) {
            h++;
        }
        const c = clone(image);
        image.scan((_, __, idx) => {
            image.bitmap.data.writeUInt32BE(image.background, idx);
        });
        const max = Math.max(w, h, image.bitmap.width, image.bitmap.height);
        image = methods$d.resize(image, {
            h: max,
            w: max,
            mode: mode === true ? undefined : mode,
        });
        image = composite(image, c, image.bitmap.width / 2 - c.bitmap.width / 2, image.bitmap.height / 2 - c.bitmap.height / 2);
    }
    const bW = image.bitmap.width;
    const bH = image.bitmap.height;
    const dstBuffer = Buffer.alloc(image.bitmap.data.length);
    const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
    const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
    for (let y = 1; y <= bH; y++) {
        for (let x = 1; x <= bW; x++) {
            const cartesian = translate2Cartesian(x, y);
            const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
            const dstIdx = (bW * (y - 1) + x - 1) << 2;
            if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
                const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;
                const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);
                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
            }
            else {
                // reset off-image pixels
                dstBuffer.writeUInt32BE(image.background, dstIdx);
            }
        }
    }
    image.bitmap.data = dstBuffer;
    if (mode === true || typeof mode === "string") {
        // now crop the image to the final size
        const x = Math.max(bW / 2 - w / 2, 0);
        const y = Math.max(bH / 2 - h / 2, 0);
        image = methods$b.crop(image, { x, y, w, h });
    }
}
const methods$2 = {
    /**
     * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.rotate(90);
     * ```
     */
    rotate(image, options) {
        const parsed = RotateOptionsSchema.parse(options);
        const actualOptions = typeof parsed === "number" ? { deg: parsed } : parsed;
        const { mode = true } = actualOptions;
        let { deg } = actualOptions;
        // No need to do extra rotation
        deg %= 360;
        // no rotation for 0, 360, -360, 720, -720, ...
        if (deg % 360 === 0) {
            return image;
        }
        // use matrixRotate if the angle is a multiple of 90 degrees (eg: 180 or -90) and resize is allowed or not needed.
        const matrixRotateAllowed = deg % 90 === 0 &&
            (mode || image.bitmap.width === image.bitmap.height || deg % 180 === 0);
        if (matrixRotateAllowed) {
            matrixRotate(image, deg);
        }
        else {
            advancedRotate(image, deg, mode);
        }
        return image;
    },
};

const ThresholdOptionsSchema = objectType({
    /** A number auto limited between 0 - 255 */
    max: numberType().min(0).max(255),
    /** A number auto limited between 0 - 255 (default 255)  */
    replace: numberType().min(0).max(255).optional(),
    /** A boolean whether to apply greyscale beforehand (default true)  */
    autoGreyscale: booleanType().optional(),
});
const methods$1 = {
    /**
     * Applies a minimum color threshold to a grayscale image.
     * Converts image to grayscale by default.
     * @example
     * ```ts
     * import { Jimp } from "jimp";
     *
     * const image = await Jimp.read("test/image.png");
     *
     * image.threshold({ max: 150 });
     * ```
     */
    threshold(image, options) {
        let { max, replace = 255, 
        // eslint-disable-next-line prefer-const
        autoGreyscale = true, } = ThresholdOptionsSchema.parse(options);
        max = limit255(max);
        replace = limit255(replace);
        if (autoGreyscale) {
            methods$e.greyscale(image);
        }
        image.scan((_, __, idx) => {
            const grey = image.bitmap.data[idx] < max ? image.bitmap.data[idx] : replace;
            image.bitmap.data[idx] = grey;
            image.bitmap.data[idx + 1] = grey;
            image.bitmap.data[idx + 2] = grey;
        });
        return image;
    },
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/constants/index.ts
var constants_exports = {};
__export(constants_exports, {
  bt709: () => bt709_exports
});

// src/constants/bt709.ts
var bt709_exports = {};
__export(bt709_exports, {
  Y: () => Y,
  x: () => x,
  y: () => y
});
var Y = /* @__PURE__ */ ((Y2) => {
  Y2[Y2["RED"] = 0.2126] = "RED";
  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
  Y2[Y2["WHITE"] = 1] = "WHITE";
  return Y2;
})(Y || {});
var x = /* @__PURE__ */ ((x2) => {
  x2[x2["RED"] = 0.64] = "RED";
  x2[x2["GREEN"] = 0.3] = "GREEN";
  x2[x2["BLUE"] = 0.15] = "BLUE";
  x2[x2["WHITE"] = 0.3127] = "WHITE";
  return x2;
})(x || {});
var y = /* @__PURE__ */ ((y2) => {
  y2[y2["RED"] = 0.33] = "RED";
  y2[y2["GREEN"] = 0.6] = "GREEN";
  y2[y2["BLUE"] = 0.06] = "BLUE";
  y2[y2["WHITE"] = 0.329] = "WHITE";
  return y2;
})(y || {});

// src/conversion/index.ts
var conversion_exports = {};
__export(conversion_exports, {
  lab2rgb: () => lab2rgb,
  lab2xyz: () => lab2xyz,
  rgb2hsl: () => rgb2hsl,
  rgb2lab: () => rgb2lab,
  rgb2xyz: () => rgb2xyz,
  xyz2lab: () => xyz2lab,
  xyz2rgb: () => xyz2rgb
});

// src/conversion/rgb2xyz.ts
function correctGamma(n) {
  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
}
function rgb2xyz(r, g, b) {
  r = correctGamma(r / 255);
  g = correctGamma(g / 255);
  b = correctGamma(b / 255);
  return {
    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
    z: r * 0.0193 + g * 0.1192 + b * 0.9505
  };
}

// src/utils/arithmetic.ts
var arithmetic_exports = {};
__export(arithmetic_exports, {
  degrees2radians: () => degrees2radians,
  inRange0to255: () => inRange0to255,
  inRange0to255Rounded: () => inRange0to255Rounded,
  intInRange: () => intInRange,
  max3: () => max3,
  min3: () => min3,
  stableSort: () => stableSort
});
function degrees2radians(n) {
  return n * (Math.PI / 180);
}
function max3(a, b, c) {
  let m = a;
  if (m < b)
    m = b;
  if (m < c)
    m = c;
  return m;
}
function min3(a, b, c) {
  let m = a;
  if (m > b)
    m = b;
  if (m > c)
    m = c;
  return m;
}
function intInRange(value, low, high) {
  if (value > high)
    value = high;
  if (value < low)
    value = low;
  return value | 0;
}
function inRange0to255Rounded(n) {
  n = Math.round(n);
  if (n > 255)
    n = 255;
  else if (n < 0)
    n = 0;
  return n;
}
function inRange0to255(n) {
  if (n > 255)
    n = 255;
  else if (n < 0)
    n = 0;
  return n;
}
function stableSort(arrayToSort, callback) {
  const type = typeof arrayToSort[0];
  let sorted;
  if (type === "number" || type === "string") {
    const ord = /* @__PURE__ */ Object.create(null);
    for (let i = 0, l = arrayToSort.length; i < l; i++) {
      const val = arrayToSort[i];
      if (ord[val] || ord[val] === 0)
        continue;
      ord[val] = i;
    }
    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
  } else {
    const ord2 = arrayToSort.slice(0);
    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
  }
  return sorted;
}

// src/conversion/rgb2hsl.ts
function rgb2hsl(r, g, b) {
  const min = min3(r, g, b);
  const max = max3(r, g, b);
  const delta = max - min;
  const l = (min + max) / 510;
  let s = 0;
  if (l > 0 && l < 1)
    s = delta / (l < 0.5 ? max + min : 510 - max - min);
  let h = 0;
  if (delta > 0) {
    if (max === r) {
      h = (g - b) / delta;
    } else if (max === g) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h *= 60;
    if (h < 0)
      h += 360;
  }
  return { h, s, l };
}

// src/conversion/xyz2lab.ts
var refX = 0.95047;
var refY = 1;
var refZ = 1.08883;
function pivot(n) {
  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
}
function xyz2lab(x2, y2, z) {
  x2 = pivot(x2 / refX);
  y2 = pivot(y2 / refY);
  z = pivot(z / refZ);
  if (116 * y2 - 16 < 0)
    throw new Error("xxx");
  return {
    L: Math.max(0, 116 * y2 - 16),
    a: 500 * (x2 - y2),
    b: 200 * (y2 - z)
  };
}

// src/conversion/rgb2lab.ts
function rgb2lab(r, g, b) {
  const xyz = rgb2xyz(r, g, b);
  return xyz2lab(xyz.x, xyz.y, xyz.z);
}

// src/conversion/lab2xyz.ts
var refX2 = 0.95047;
var refY2 = 1;
var refZ2 = 1.08883;
function pivot2(n) {
  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
}
function lab2xyz(L, a, b) {
  const y2 = (L + 16) / 116;
  const x2 = a / 500 + y2;
  const z = y2 - b / 200;
  return {
    x: refX2 * pivot2(x2),
    y: refY2 * pivot2(y2),
    z: refZ2 * pivot2(z)
  };
}

// src/conversion/xyz2rgb.ts
function correctGamma2(n) {
  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
}
function xyz2rgb(x2, y2, z) {
  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
  return {
    r: inRange0to255Rounded(r * 255),
    g: inRange0to255Rounded(g * 255),
    b: inRange0to255Rounded(b * 255)
  };
}

// src/conversion/lab2rgb.ts
function lab2rgb(L, a, b) {
  const xyz = lab2xyz(L, a, b);
  return xyz2rgb(xyz.x, xyz.y, xyz.z);
}

// src/distance/index.ts
var distance_exports = {};
__export(distance_exports, {
  AbstractDistanceCalculator: () => AbstractDistanceCalculator,
  AbstractEuclidean: () => AbstractEuclidean,
  AbstractManhattan: () => AbstractManhattan,
  CIE94GraphicArts: () => CIE94GraphicArts,
  CIE94Textiles: () => CIE94Textiles,
  CIEDE2000: () => CIEDE2000,
  CMetric: () => CMetric,
  Euclidean: () => Euclidean,
  EuclideanBT709: () => EuclideanBT709,
  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
  Manhattan: () => Manhattan,
  ManhattanBT709: () => ManhattanBT709,
  ManhattanNommyde: () => ManhattanNommyde,
  PNGQuant: () => PNGQuant
});

// src/distance/distanceCalculator.ts
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField(this, "_maxDistance");
    __publicField(this, "_whitePoint");
    this._setDefaults();
    this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(r, g, b, a) {
    this._whitePoint = {
      r: r > 0 ? 255 / r : 0,
      g: g > 0 ? 255 / g : 0,
      b: b > 0 ? 255 / b : 0,
      a: a > 0 ? 255 / a : 0
    };
    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
  }
  calculateNormalized(colorA, colorB) {
    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
  }
};

// src/distance/cie94.ts
var AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dL = lab1.L - lab2.L;
    const dA = lab1.a - lab2.a;
    const dB = lab1.b - lab2.b;
    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
    const dC = c1 - c2;
    let deltaH = dA * dA + dB * dB - dC * dC;
    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
  }
};
var CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2;
    this._K1 = 0.048;
    this._K2 = 0.014;
    this._kA = 0.25 * 50 / 255;
  }
};
var CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1;
    this._K1 = 0.045;
    this._K2 = 0.015;
    this._kA = 0.25 * 100 / 255;
  }
};

// src/distance/ciede2000.ts
var _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {
  }
  static _calculatehp(b, ap) {
    const hp = Math.atan2(b, ap);
    if (hp >= 0)
      return hp;
    return hp + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(ahp, aCp) {
    const aCp_to_7 = aCp ** 7;
    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * delta_theta) * R_C;
  }
  static _calculateT(ahp) {
    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
    const hpSum = h1p + h2p;
    if (C1pC2p === 0)
      return hpSum;
    if (h_bar <= _CIEDE2000._deg180InRad)
      return hpSum / 2;
    if (hpSum < _CIEDE2000._deg360InRad) {
      return (hpSum + _CIEDE2000._deg360InRad) / 2;
    }
    return (hpSum - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
    let dhp;
    if (C1pC2p === 0) {
      dhp = 0;
    } else if (h_bar <= _CIEDE2000._deg180InRad) {
      dhp = h2p - h1p;
    } else if (h2p <= h1p) {
      dhp = h2p - h1p + _CIEDE2000._deg360InRad;
    } else {
      dhp = h2p - h1p - _CIEDE2000._deg360InRad;
    }
    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
  }
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
    const dE2 = this.calculateRawInLab(lab1, lab2);
    return Math.sqrt(dE2 + dA * dA);
  }
  calculateRawInLab(Lab1, Lab2) {
    const L1 = Lab1.L;
    const a1 = Lab1.a;
    const b1 = Lab1.b;
    const L2 = Lab2.L;
    const a2 = Lab2.a;
    const b2 = Lab2.b;
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
    const a1p = (1 + G) * a1;
    const a2p = (1 + G) * a2;
    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
    const C2p = Math.sqrt(a2p * a2p + b2 * b2);
    const C1pC2p = C1p * C2p;
    const h1p = _CIEDE2000._calculatehp(b1, a1p);
    const h2p = _CIEDE2000._calculatehp(b2, a2p);
    const h_bar = Math.abs(h1p - h2p);
    const dLp = L2 - L1;
    const dCp = C2p - C1p;
    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
    const T = _CIEDE2000._calculateT(ahp);
    const aCp = (C1p + C2p) / 2;
    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
    const S_C = 1 + 0.045 * aCp;
    const S_H = 1 + 0.015 * T * aCp;
    const R_T = _CIEDE2000._calculateRT(ahp, aCp);
    const dLpSL = dLp / S_L;
    const dCpSC = dCp / S_C;
    const dHpSH = dHp / S_H;
    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
  }
};
var CIEDE2000 = _CIEDE2000;
__publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
__publicField(CIEDE2000, "_pow25to7", 25 ** 7);
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
__publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
__publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
__publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));

// src/distance/cmetric.ts
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const rmean = (r1 + r2) / 2 * this._whitePoint.r;
    const r = (r1 - r2) * this._whitePoint.r;
    const g = (g1 - g2) * this._whitePoint.g;
    const b = (b1 - b2) * this._whitePoint.b;
    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
    const dA = (a2 - a1) * this._whitePoint.a;
    return Math.sqrt(dE + dA * dA);
  }
  _setDefaults() {
  }
};

// src/distance/euclidean.ts
var AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const dR = r2 - r1;
    const dG = g2 - g1;
    const dB = b2 - b1;
    const dA = a2 - a1;
    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
  }
};
var Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126 /* RED */;
    this._kG = 0.7152 /* GREEN */;
    this._kB = 0.0722 /* BLUE */;
    this._kA = 1;
  }
};
var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126 /* RED */;
    this._kG = 0.7152 /* GREEN */;
    this._kB = 0.0722 /* BLUE */;
    this._kA = 0;
  }
};

// src/distance/manhattan.ts
var AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    let dR = r2 - r1;
    let dG = g2 - g1;
    let dB = b2 - b1;
    let dA = a2 - a1;
    if (dR < 0)
      dR = 0 - dR;
    if (dG < 0)
      dG = 0 - dG;
    if (dB < 0)
      dB = 0 - dB;
    if (dA < 0)
      dA = 0 - dA;
    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
  }
};
var Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1;
    this._kG = 1;
    this._kB = 1;
    this._kA = 1;
  }
};
var ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984;
    this._kG = 0.8625;
    this._kB = 0.2979;
    this._kA = 1;
  }
};
var ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126 /* RED */;
    this._kG = 0.7152 /* GREEN */;
    this._kB = 0.0722 /* BLUE */;
    this._kA = 1;
  }
};

// src/distance/pngQuant.ts
var PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
    const alphas = (a2 - a1) * this._whitePoint.a;
    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
  }
  _colordifferenceCh(x2, y2, alphas) {
    const black = x2 - y2;
    const white = black + alphas;
    return black * black + white * white;
  }
  _setDefaults() {
  }
};

// src/palette/index.ts
var palette_exports = {};
__export(palette_exports, {
  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
  ColorHistogram: () => ColorHistogram,
  NeuQuant: () => NeuQuant,
  NeuQuantFloat: () => NeuQuantFloat,
  RGBQuant: () => RGBQuant,
  WuColorCube: () => WuColorCube,
  WuQuant: () => WuQuant
});

// src/palette/paletteQuantizer.ts
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const value of this.quantize()) {
      if (value.palette) {
        return value.palette;
      }
    }
    throw new Error("unreachable");
  }
};

// src/utils/point.ts
var Point = class {
  constructor() {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    __publicField(this, "uint32");
    __publicField(this, "rgba");
    this.uint32 = -1 >>> 0;
    this.r = this.g = this.b = this.a = 0;
    this.rgba = new Array(4);
    this.rgba[0] = 0;
    this.rgba[1] = 0;
    this.rgba[2] = 0;
    this.rgba[3] = 0;
  }
  static createByQuadruplet(quadruplet) {
    const point = new Point();
    point.r = quadruplet[0] | 0;
    point.g = quadruplet[1] | 0;
    point.b = quadruplet[2] | 0;
    point.a = quadruplet[3] | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByRGBA(red, green, blue, alpha) {
    const point = new Point();
    point.r = red | 0;
    point.g = green | 0;
    point.b = blue | 0;
    point.a = alpha | 0;
    point._loadUINT32();
    point._loadQuadruplet();
    return point;
  }
  static createByUint32(uint32) {
    const point = new Point();
    point.uint32 = uint32 >>> 0;
    point._loadRGBA();
    point._loadQuadruplet();
    return point;
  }
  from(point) {
    this.r = point.r;
    this.g = point.g;
    this.b = point.b;
    this.a = point.a;
    this.uint32 = point.uint32;
    this.rgba[0] = point.r;
    this.rgba[1] = point.g;
    this.rgba[2] = point.b;
    this.rgba[3] = point.a;
  }
  getLuminosity(useAlphaChannel) {
    let r = this.r;
    let g = this.g;
    let b = this.b;
    if (useAlphaChannel) {
      r = Math.min(255, 255 - this.a + this.a * r / 255);
      g = Math.min(255, 255 - this.a + this.a * g / 255);
      b = Math.min(255, 255 - this.a + this.a * b / 255);
    }
    return r * 0.2126 /* RED */ + g * 0.7152 /* GREEN */ + b * 0.0722 /* BLUE */;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = this.uint32 & 255;
    this.g = this.uint32 >>> 8 & 255;
    this.b = this.uint32 >>> 16 & 255;
    this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r;
    this.rgba[1] = this.g;
    this.rgba[2] = this.b;
    this.rgba[3] = this.a;
  }
};

// src/utils/pointContainer.ts
var PointContainer = class {
  constructor() {
    __publicField(this, "_pointArray");
    __publicField(this, "_width");
    __publicField(this, "_height");
    this._width = 0;
    this._height = 0;
    this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(width) {
    this._width = width;
  }
  setHeight(height) {
    this._height = height;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const clone = new PointContainer();
    clone._width = this._width;
    clone._height = this._height;
    for (let i = 0, l = this._pointArray.length; i < l; i++) {
      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);
    }
    return clone;
  }
  toUint32Array() {
    const l = this._pointArray.length;
    const uint32Array = new Uint32Array(l);
    for (let i = 0; i < l; i++) {
      uint32Array[i] = this._pointArray[i].uint32;
    }
    return uint32Array;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(img) {
    const width = img.naturalWidth;
    const height = img.naturalHeight;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
    return PointContainer.fromHTMLCanvasElement(canvas);
  }
  static fromHTMLCanvasElement(canvas) {
    const width = canvas.width;
    const height = canvas.height;
    const ctx = canvas.getContext("2d");
    const imgData = ctx.getImageData(0, 0, width, height);
    return PointContainer.fromImageData(imgData);
  }
  static fromImageData(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    return PointContainer.fromUint8Array(imageData.data, width, height);
  }
  static fromUint8Array(uint8Array, width, height) {
    switch (Object.prototype.toString.call(uint8Array)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        uint8Array = new Uint8Array(uint8Array);
    }
    const uint32Array = new Uint32Array(uint8Array.buffer);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
  static fromUint32Array(uint32Array, width, height) {
    const container = new PointContainer();
    container._width = width;
    container._height = height;
    for (let i = 0, l = uint32Array.length; i < l; i++) {
      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);
    }
    return container;
  }
  static fromBuffer(buffer, width, height) {
    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(uint32Array, width, height);
  }
};

// src/utils/palette.ts
var hueGroups = 10;
function hueGroup(hue, segmentsNumber) {
  const maxHue = 360;
  const seg = maxHue / segmentsNumber;
  const half = seg / 2;
  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
    if (hue >= mid && hue < mid + seg)
      return i;
  }
  return 0;
}
var Palette = class {
  constructor() {
    __publicField(this, "_pointContainer");
    __publicField(this, "_pointArray", []);
    __publicField(this, "_i32idx", {});
    this._pointContainer = new PointContainer();
    this._pointContainer.setHeight(1);
    this._pointArray = this._pointContainer.getPointArray();
  }
  add(color) {
    this._pointArray.push(color);
    this._pointContainer.setWidth(this._pointArray.length);
  }
  has(color) {
    for (let i = this._pointArray.length - 1; i >= 0; i--) {
      if (color.uint32 === this._pointArray[i].uint32)
        return true;
    }
    return false;
  }
  getNearestColor(colorDistanceCalculator, color) {
    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(key) {
    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
  }
  _getNearestIndex(colorDistanceCalculator, point) {
    let idx = this._nearestPointFromCache("" + point.uint32);
    if (idx >= 0)
      return idx;
    let minimalDistance = Number.MAX_VALUE;
    idx = 0;
    for (let i = 0, l = this._pointArray.length; i < l; i++) {
      const p = this._pointArray[i];
      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
      if (distance < minimalDistance) {
        minimalDistance = distance;
        idx = i;
      }
    }
    this._i32idx[point.uint32] = idx;
    return idx;
  }
  sort() {
    this._i32idx = {};
    this._pointArray.sort((a, b) => {
      const hslA = rgb2hsl(a.r, a.g, a.b);
      const hslB = rgb2hsl(b.r, b.g, b.b);
      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
      const hueDiff = hueB - hueA;
      if (hueDiff)
        return -hueDiff;
      const lA = a.getLuminosity(true);
      const lB = b.getLuminosity(true);
      if (lB - lA !== 0)
        return lB - lA;
      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
      if (satDiff)
        return -satDiff;
      return 0;
    });
  }
};

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  HueStatistics: () => HueStatistics,
  Palette: () => Palette,
  Point: () => Point,
  PointContainer: () => PointContainer,
  ProgressTracker: () => ProgressTracker,
  arithmetic: () => arithmetic_exports
});

// src/utils/hueStatistics.ts
var HueGroup = class {
  constructor() {
    __publicField(this, "num", 0);
    __publicField(this, "cols", []);
  }
};
var HueStatistics = class {
  constructor(numGroups, minCols) {
    __publicField(this, "_numGroups");
    __publicField(this, "_minCols");
    __publicField(this, "_stats");
    __publicField(this, "_groupsFull");
    this._numGroups = numGroups;
    this._minCols = minCols;
    this._stats = [];
    for (let i = 0; i <= numGroups; i++) {
      this._stats[i] = new HueGroup();
    }
    this._groupsFull = 0;
  }
  check(i32) {
    if (this._groupsFull === this._numGroups + 1) {
      this.check = () => {
      };
    }
    const r = i32 & 255;
    const g = i32 >>> 8 & 255;
    const b = i32 >>> 16 & 255;
    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
    const gr = this._stats[hg];
    const min = this._minCols;
    gr.num++;
    if (gr.num > min) {
      return;
    }
    if (gr.num === min) {
      this._groupsFull++;
    }
    if (gr.num <= min) {
      this._stats[hg].cols.push(i32);
    }
  }
  injectIntoDictionary(histG) {
    for (let i = 0; i <= this._numGroups; i++) {
      if (this._stats[i].num <= this._minCols) {
        this._stats[i].cols.forEach((col) => {
          if (!histG[col]) {
            histG[col] = 1;
          } else {
            histG[col]++;
          }
        });
      }
    }
  }
  injectIntoArray(histG) {
    for (let i = 0; i <= this._numGroups; i++) {
      if (this._stats[i].num <= this._minCols) {
        this._stats[i].cols.forEach((col) => {
          if (histG.indexOf(col) === -1) {
            histG.push(col);
          }
        });
      }
    }
  }
};

// src/utils/progressTracker.ts
var _ProgressTracker = class {
  constructor(valueRange, progressRange) {
    __publicField(this, "progress");
    __publicField(this, "_step");
    __publicField(this, "_range");
    __publicField(this, "_last");
    __publicField(this, "_progressRange");
    this._range = valueRange;
    this._progressRange = progressRange;
    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
    this._last = -this._step;
    this.progress = 0;
  }
  shouldNotify(current) {
    if (current - this._last >= this._step) {
      this._last = current;
      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
      return true;
    }
    return false;
  }
};
var ProgressTracker = _ProgressTracker;
__publicField(ProgressTracker, "steps", 100);

// src/palette/neuquant/neuquant.ts
var networkBiasShift = 3;
var Neuron = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(r, g, b, a) {
    this.r -= r | 0;
    this.g -= g | 0;
    this.b -= b | 0;
    this.a -= a | 0;
  }
};
var _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i = 0; i < this._networkSize; i++) {
      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;
      this._bias[i] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuant._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
    const pointsToSample = pointsNumber / sampleFactor | 0;
    let delta = pointsToSample / _NeuQuant._nCycles | 0;
    let alpha = _NeuQuant._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
    let rad = radius >> _NeuQuant._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i = 0; i < rad; i++) {
      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
    }
    let step;
    if (pointsNumber < _NeuQuant._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
      step = _NeuQuant._prime1;
    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
      step = _NeuQuant._prime2;
    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
      step = _NeuQuant._prime3;
    } else {
      step = _NeuQuant._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
      if (tracker.shouldNotify(i)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift;
      const g = point.g << networkBiasShift;
      const r = point.r << networkBiasShift;
      const a = point.a << networkBiasShift;
      const neuronIndex = this._contest(b, g, r, a);
      this._alterSingle(alpha, neuronIndex, b, g, r, a);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i++;
      if (delta === 0)
        delta = 1;
      if (i % delta === 0) {
        alpha -= alpha / alphadec | 0;
        radius -= radius / _NeuQuant._radiusDecrease | 0;
        rad = radius >> _NeuQuant._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0; j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        }
      }
    }
  }
  _buildPalette() {
    const palette = new Palette();
    this._network.forEach((neuron) => {
      palette.add(neuron.toPoint());
    });
    palette.sort();
    return palette;
  }
  _alterNeighbour(rad, i, b, g, r, al) {
    let lo = i - rad;
    if (lo < -1)
      lo = -1;
    let hi = i + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i + 1;
    let k = i - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i, b, g, r, a) {
    alpha /= _NeuQuant._initAlpha;
    const n = this._network[i];
    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
  }
  _contest(b, g, r, a) {
    const multiplier = 255 * 4 << networkBiasShift;
    let bestd = 2147483647;
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i = 0; i < this._networkSize; i++) {
      const n = this._network[i];
      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      const betafreq = this._freq[i] >> _NeuQuant._betaShift;
      this._freq[i] -= betafreq;
      this._bias[i] += betafreq << _NeuQuant._gammaShift;
    }
    this._freq[bestpos] += _NeuQuant._beta;
    this._bias[bestpos] -= _NeuQuant._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuant = _NeuQuant;
__publicField(NeuQuant, "_prime1", 499);
__publicField(NeuQuant, "_prime2", 491);
__publicField(NeuQuant, "_prime3", 487);
__publicField(NeuQuant, "_prime4", 503);
__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
__publicField(NeuQuant, "_nCycles", 100);
__publicField(NeuQuant, "_initialBiasShift", 16);
__publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
__publicField(NeuQuant, "_gammaShift", 10);
__publicField(NeuQuant, "_betaShift", 10);
__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
__publicField(NeuQuant, "_radiusBiasShift", 6);
__publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
__publicField(NeuQuant, "_radiusDecrease", 30);
__publicField(NeuQuant, "_alphaBiasShift", 10);
__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
__publicField(NeuQuant, "_radBiasShift", 8);
__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);

// src/palette/neuquant/neuquantFloat.ts
var networkBiasShift2 = 3;
var NeuronFloat = class {
  constructor(defaultValue) {
    __publicField(this, "r");
    __publicField(this, "g");
    __publicField(this, "b");
    __publicField(this, "a");
    this.r = this.g = this.b = this.a = defaultValue;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(r, g, b, a) {
    this.r -= r;
    this.g -= g;
    this.b -= b;
    this.a -= a;
  }
};
var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256) {
    super();
    __publicField(this, "_pointArray");
    __publicField(this, "_networkSize");
    __publicField(this, "_network");
    __publicField(this, "_sampleFactor");
    __publicField(this, "_radPower");
    __publicField(this, "_freq");
    __publicField(this, "_bias");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._pointArray = [];
    this._sampleFactor = 1;
    this._networkSize = colors;
    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(pointContainer) {
    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
  }
  *quantize() {
    this._init();
    yield* this._learn();
    yield {
      palette: this._buildPalette(),
      progress: 100
    };
  }
  _init() {
    this._freq = [];
    this._bias = [];
    this._radPower = [];
    this._network = [];
    for (let i = 0; i < this._networkSize; i++) {
      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);
      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;
      this._bias[i] = 0;
    }
  }
  *_learn() {
    let sampleFactor = this._sampleFactor;
    const pointsNumber = this._pointArray.length;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes)
      sampleFactor = 1;
    const alphadec = 30 + (sampleFactor - 1) / 3;
    const pointsToSample = pointsNumber / sampleFactor;
    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
    let alpha = _NeuQuantFloat._initAlpha;
    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
    let rad = radius >> _NeuQuantFloat._radiusBiasShift;
    if (rad <= 1)
      rad = 0;
    for (let i = 0; i < rad; i++) {
      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
    }
    let step;
    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
      step = 1;
    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
      step = _NeuQuantFloat._prime1;
    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
      step = _NeuQuantFloat._prime2;
    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
      step = _NeuQuantFloat._prime3;
    } else {
      step = _NeuQuantFloat._prime4;
    }
    const tracker = new ProgressTracker(pointsToSample, 99);
    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
      if (tracker.shouldNotify(i)) {
        yield {
          progress: tracker.progress
        };
      }
      const point = this._pointArray[pointIndex];
      const b = point.b << networkBiasShift2;
      const g = point.g << networkBiasShift2;
      const r = point.r << networkBiasShift2;
      const a = point.a << networkBiasShift2;
      const neuronIndex = this._contest(b, g, r, a);
      this._alterSingle(alpha, neuronIndex, b, g, r, a);
      if (rad !== 0)
        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
      pointIndex += step;
      if (pointIndex >= pointsNumber)
        pointIndex -= pointsNumber;
      i++;
      if (delta === 0)
        delta = 1;
      if (i % delta === 0) {
        alpha -= alpha / alphadec;
        radius -= radius / _NeuQuantFloat._radiusDecrease;
        rad = radius >> _NeuQuantFloat._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let j = 0; j < rad; j++) {
          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
        }
      }
    }
  }
  _buildPalette() {
    const palette = new Palette();
    this._network.forEach((neuron) => {
      palette.add(neuron.toPoint());
    });
    palette.sort();
    return palette;
  }
  _alterNeighbour(rad, i, b, g, r, al) {
    let lo = i - rad;
    if (lo < -1)
      lo = -1;
    let hi = i + rad;
    if (hi > this._networkSize)
      hi = this._networkSize;
    let j = i + 1;
    let k = i - 1;
    let m = 1;
    while (j < hi || k > lo) {
      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
      if (j < hi) {
        const p = this._network[j++];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
      if (k > lo) {
        const p = this._network[k--];
        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
      }
    }
  }
  _alterSingle(alpha, i, b, g, r, a) {
    alpha /= _NeuQuantFloat._initAlpha;
    const n = this._network[i];
    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
  }
  _contest(b, g, r, al) {
    const multiplier = 255 * 4 << networkBiasShift2;
    let bestd = 2147483647;
    let bestbiasd = bestd;
    let bestpos = -1;
    let bestbiaspos = bestpos;
    for (let i = 0; i < this._networkSize; i++) {
      const n = this._network[i];
      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
      this._freq[i] -= betafreq;
      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
    }
    this._freq[bestpos] += _NeuQuantFloat._beta;
    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
    return bestbiaspos;
  }
};
var NeuQuantFloat = _NeuQuantFloat;
__publicField(NeuQuantFloat, "_prime1", 499);
__publicField(NeuQuantFloat, "_prime2", 491);
__publicField(NeuQuantFloat, "_prime3", 487);
__publicField(NeuQuantFloat, "_prime4", 503);
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
__publicField(NeuQuantFloat, "_nCycles", 100);
__publicField(NeuQuantFloat, "_initialBiasShift", 16);
__publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
__publicField(NeuQuantFloat, "_gammaShift", 10);
__publicField(NeuQuantFloat, "_betaShift", 10);
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
__publicField(NeuQuantFloat, "_radiusBiasShift", 6);
__publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
__publicField(NeuQuantFloat, "_radiusDecrease", 30);
__publicField(NeuQuantFloat, "_alphaBiasShift", 10);
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
__publicField(NeuQuantFloat, "_radBiasShift", 8);
__publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);

// src/palette/rgbquant/colorHistogram.ts
var _ColorHistogram = class {
  constructor(method, colors) {
    __publicField(this, "_method");
    __publicField(this, "_hueStats");
    __publicField(this, "_histogram");
    __publicField(this, "_initColors");
    __publicField(this, "_minHueCols");
    this._method = method;
    this._minHueCols = colors << 2;
    this._initColors = colors << 2;
    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
    this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(pointContainer) {
    switch (this._method) {
      case 1:
        this._colorStats1D(pointContainer);
        break;
      case 2:
        this._colorStats2D(pointContainer);
        break;
    }
  }
  getImportanceSortedColorsIDXI32() {
    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
    if (sorted.length === 0) {
      return [];
    }
    let idxi32;
    switch (this._method) {
      case 1:
        const initialColorsLimit = Math.min(sorted.length, this._initColors);
        const last = sorted[initialColorsLimit - 1];
        const freq = this._histogram[last];
        idxi32 = sorted.slice(0, initialColorsLimit);
        let pos = initialColorsLimit;
        const len = sorted.length;
        while (pos < len && this._histogram[sorted[pos]] === freq) {
          idxi32.push(sorted[pos++]);
        }
        this._hueStats.injectIntoArray(idxi32);
        break;
      case 2:
        idxi32 = sorted;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return idxi32.map((v) => +v);
  }
  _colorStats1D(pointContainer) {
    const histG = this._histogram;
    const pointArray = pointContainer.getPointArray();
    const len = pointArray.length;
    for (let i = 0; i < len; i++) {
      const col = pointArray[i].uint32;
      this._hueStats.check(col);
      if (col in histG) {
        histG[col]++;
      } else {
        histG[col] = 1;
      }
    }
  }
  _colorStats2D(pointContainer) {
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const pointArray = pointContainer.getPointArray();
    const boxW = _ColorHistogram._boxSize[0];
    const boxH = _ColorHistogram._boxSize[1];
    const area = boxW * boxH;
    const boxes = this._makeBoxes(width, height, boxW, boxH);
    const histG = this._histogram;
    boxes.forEach((box) => {
      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
      if (effc < 2)
        effc = 2;
      const histL = {};
      this._iterateBox(box, width, (i) => {
        const col = pointArray[i].uint32;
        this._hueStats.check(col);
        if (col in histG) {
          histG[col]++;
        } else if (col in histL) {
          if (++histL[col] >= effc) {
            histG[col] = histL[col];
          }
        } else {
          histL[col] = 1;
        }
      });
    });
    this._hueStats.injectIntoDictionary(histG);
  }
  _iterateBox(bbox, wid, fn) {
    const b = bbox;
    const i0 = b.y * wid + b.x;
    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
    const incr = wid - b.w + 1;
    let cnt = 0;
    let i = i0;
    do {
      fn.call(this, i);
      i += ++cnt % b.w === 0 ? incr : 1;
    } while (i <= i1);
  }
  _makeBoxes(width, height, stepX, stepY) {
    const wrem = width % stepX;
    const hrem = height % stepY;
    const xend = width - wrem;
    const yend = height - hrem;
    const boxesArray = [];
    for (let y2 = 0; y2 < height; y2 += stepY) {
      for (let x2 = 0; x2 < width; x2 += stepX) {
        boxesArray.push({
          x: x2,
          y: y2,
          w: x2 === xend ? wrem : stepX,
          h: y2 === yend ? hrem : stepY
        });
      }
    }
    return boxesArray;
  }
};
var ColorHistogram = _ColorHistogram;
__publicField(ColorHistogram, "_boxSize", [64, 64]);
__publicField(ColorHistogram, "_boxPixels", 2);
__publicField(ColorHistogram, "_hueGroups", 10);

// src/palette/rgbquant/rgbquant.ts
var RemovedColor = class {
  constructor(index, color, distance) {
    __publicField(this, "index");
    __publicField(this, "color");
    __publicField(this, "distance");
    this.index = index;
    this.color = color;
    this.distance = distance;
  }
};
var RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, method = 2) {
    super();
    __publicField(this, "_colors");
    __publicField(this, "_initialDistance");
    __publicField(this, "_distanceIncrement");
    __publicField(this, "_histogram");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._colors = colors;
    this._histogram = new ColorHistogram(method, colors);
    this._initialDistance = 0.01;
    this._distanceIncrement = 5e-3;
  }
  sample(image) {
    this._histogram.sample(image);
  }
  *quantize() {
    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
    if (idxi32.length === 0) {
      throw new Error("No colors in image");
    }
    yield* this._buildPalette(idxi32);
  }
  *_buildPalette(idxi32) {
    const palette = new Palette();
    const colorArray = palette.getPointContainer().getPointArray();
    const usageArray = new Array(idxi32.length);
    for (let i = 0; i < idxi32.length; i++) {
      colorArray.push(Point.createByUint32(idxi32[i]));
      usageArray[i] = 1;
    }
    const len = colorArray.length;
    const memDist = [];
    let palLen = len;
    let thold = this._initialDistance;
    const tracker = new ProgressTracker(palLen - this._colors, 99);
    while (palLen > this._colors) {
      memDist.length = 0;
      for (let i = 0; i < len; i++) {
        if (tracker.shouldNotify(len - palLen)) {
          yield {
            progress: tracker.progress
          };
        }
        if (usageArray[i] === 0)
          continue;
        const pxi = colorArray[i];
        for (let j = i + 1; j < len; j++) {
          if (usageArray[j] === 0)
            continue;
          const pxj = colorArray[j];
          const dist = this._distance.calculateNormalized(pxi, pxj);
          if (dist < thold) {
            memDist.push(new RemovedColor(j, pxj, dist));
            usageArray[j] = 0;
            palLen--;
          }
        }
      }
      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
    }
    if (palLen < this._colors) {
      stableSort(memDist, (a, b) => b.distance - a.distance);
      let k = 0;
      while (palLen < this._colors && k < memDist.length) {
        const removedColor = memDist[k];
        usageArray[removedColor.index] = 1;
        palLen++;
        k++;
      }
    }
    let colors = colorArray.length;
    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
      if (usageArray[colorIndex] === 0) {
        if (colorIndex !== colors - 1) {
          colorArray[colorIndex] = colorArray[colors - 1];
        }
        --colors;
      }
    }
    colorArray.length = colors;
    palette.sort();
    yield {
      palette,
      progress: 100
    };
  }
};

// src/palette/wu/wuQuant.ts
function createArray1D(dimension1) {
  const a = [];
  for (let k = 0; k < dimension1; k++) {
    a[k] = 0;
  }
  return a;
}
function createArray4D(dimension1, dimension2, dimension3, dimension4) {
  const a = new Array(dimension1);
  for (let i = 0; i < dimension1; i++) {
    a[i] = new Array(dimension2);
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = new Array(dimension3);
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = new Array(dimension4);
        for (let l = 0; l < dimension4; l++) {
          a[i][j][k][l] = 0;
        }
      }
    }
  }
  return a;
}
function createArray3D(dimension1, dimension2, dimension3) {
  const a = new Array(dimension1);
  for (let i = 0; i < dimension1; i++) {
    a[i] = new Array(dimension2);
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = new Array(dimension3);
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = 0;
      }
    }
  }
  return a;
}
function fillArray3D(a, dimension1, dimension2, dimension3, value) {
  for (let i = 0; i < dimension1; i++) {
    a[i] = [];
    for (let j = 0; j < dimension2; j++) {
      a[i][j] = [];
      for (let k = 0; k < dimension3; k++) {
        a[i][j][k] = value;
      }
    }
  }
}
function fillArray1D(a, dimension1, value) {
  for (let i = 0; i < dimension1; i++) {
    a[i] = value;
  }
}
var WuColorCube = class {
  constructor() {
    __publicField(this, "redMinimum");
    __publicField(this, "redMaximum");
    __publicField(this, "greenMinimum");
    __publicField(this, "greenMaximum");
    __publicField(this, "blueMinimum");
    __publicField(this, "blueMaximum");
    __publicField(this, "volume");
    __publicField(this, "alphaMinimum");
    __publicField(this, "alphaMaximum");
  }
};
var _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
    super();
    __publicField(this, "_reds");
    __publicField(this, "_greens");
    __publicField(this, "_blues");
    __publicField(this, "_alphas");
    __publicField(this, "_sums");
    __publicField(this, "_weights");
    __publicField(this, "_momentsRed");
    __publicField(this, "_momentsGreen");
    __publicField(this, "_momentsBlue");
    __publicField(this, "_momentsAlpha");
    __publicField(this, "_moments");
    __publicField(this, "_table");
    __publicField(this, "_pixels");
    __publicField(this, "_cubes");
    __publicField(this, "_colors");
    __publicField(this, "_significantBitsPerChannel");
    __publicField(this, "_maxSideIndex");
    __publicField(this, "_alphaMaxSideIndex");
    __publicField(this, "_sideSize");
    __publicField(this, "_alphaSideSize");
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
    this._setQuality(significantBitsPerChannel);
    this._initialize(colors);
  }
  sample(image) {
    const pointArray = image.getPointArray();
    for (let i = 0, l = pointArray.length; i < l; i++) {
      this._addColor(pointArray[i]);
    }
    this._pixels = this._pixels.concat(pointArray);
  }
  *quantize() {
    yield* this._preparePalette();
    const palette = new Palette();
    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
      if (this._sums[paletteIndex] > 0) {
        const sum = this._sums[paletteIndex];
        const r = this._reds[paletteIndex] / sum;
        const g = this._greens[paletteIndex] / sum;
        const b = this._blues[paletteIndex] / sum;
        const a = this._alphas[paletteIndex] / sum;
        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
        palette.add(color);
      }
    }
    palette.sort();
    yield {
      palette,
      progress: 100
    };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let next = 0;
    const volumeVariance = createArray1D(this._colors);
    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
      } else {
        volumeVariance[next] = 0;
        cubeIndex--;
      }
      next = 0;
      let temp = volumeVariance[0];
      for (let index = 1; index <= cubeIndex; ++index) {
        if (volumeVariance[index] > temp) {
          temp = volumeVariance[index];
          next = index;
        }
      }
      if (temp <= 0) {
        this._colors = cubeIndex + 1;
        break;
      }
    }
    const lookupRed = [];
    const lookupGreen = [];
    const lookupBlue = [];
    const lookupAlpha = [];
    for (let k = 0; k < this._colors; ++k) {
      const weight = _WuQuant._volume(this._cubes[k], this._weights);
      if (weight > 0) {
        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
      } else {
        lookupRed[k] = 0;
        lookupGreen[k] = 0;
        lookupBlue[k] = 0;
        lookupAlpha[k] = 0;
      }
    }
    this._reds = createArray1D(this._colors + 1);
    this._greens = createArray1D(this._colors + 1);
    this._blues = createArray1D(this._colors + 1);
    this._alphas = createArray1D(this._colors + 1);
    this._sums = createArray1D(this._colors + 1);
    for (let index = 0, l = this._pixels.length; index < l; index++) {
      const color = this._pixels[index];
      const match = -1;
      let bestMatch = match;
      let bestDistance = Number.MAX_VALUE;
      for (let lookup = 0; lookup < this._colors; lookup++) {
        const foundRed = lookupRed[lookup];
        const foundGreen = lookupGreen[lookup];
        const foundBlue = lookupBlue[lookup];
        const foundAlpha = lookupAlpha[lookup];
        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
        if (distance < bestDistance) {
          bestDistance = distance;
          bestMatch = lookup;
        }
      }
      this._reds[bestMatch] += color.r;
      this._greens[bestMatch] += color.g;
      this._blues[bestMatch] += color.b;
      this._alphas[bestMatch] += color.a;
      this._sums[bestMatch]++;
    }
  }
  _addColor(color) {
    const bitsToRemove = 8 - this._significantBitsPerChannel;
    const indexRed = (color.r >> bitsToRemove) + 1;
    const indexGreen = (color.g >> bitsToRemove) + 1;
    const indexBlue = (color.b >> bitsToRemove) + 1;
    const indexAlpha = (color.a >> bitsToRemove) + 1;
    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
  }
  *_calculateMoments() {
    const area = [];
    const areaRed = [];
    const areaGreen = [];
    const areaBlue = [];
    const areaAlpha = [];
    const area2 = [];
    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let trackerProgress = 0;
    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
        if (tracker.shouldNotify(trackerProgress)) {
          yield {
            progress: tracker.progress
          };
        }
        fillArray1D(area, this._sideSize, 0);
        fillArray1D(areaRed, this._sideSize, 0);
        fillArray1D(areaGreen, this._sideSize, 0);
        fillArray1D(areaBlue, this._sideSize, 0);
        fillArray1D(areaAlpha, this._sideSize, 0);
        fillArray1D(area2, this._sideSize, 0);
        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
          let line = 0;
          let lineRed = 0;
          let lineGreen = 0;
          let lineBlue = 0;
          let lineAlpha = 0;
          let line2 = 0;
          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
            area[blueIndex] += line;
            areaRed[blueIndex] += lineRed;
            areaGreen[blueIndex] += lineGreen;
            areaBlue[blueIndex] += lineBlue;
            areaAlpha[blueIndex] += lineAlpha;
            area2[blueIndex] += line2;
            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
          }
        }
      }
    }
  }
  static _volumeFloat(cube, moment) {
    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
  }
  static _volume(cube, moment) {
    return _WuQuant._volumeFloat(cube, moment) | 0;
  }
  static _top(cube, direction, position, moment) {
    let result;
    switch (direction) {
      case _WuQuant._alpha:
        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._red:
        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
        break;
      case _WuQuant._green:
        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
        break;
      case _WuQuant._blue:
        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
        break;
      default:
        throw new Error("impossible");
    }
    return result | 0;
  }
  static _bottom(cube, direction, moment) {
    switch (direction) {
      case _WuQuant._alpha:
        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._red:
        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._green:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      case _WuQuant._blue:
        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(cube) {
    const volumeRed = _WuQuant._volume(cube, this._momentsRed);
    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
    const volumeWeight = _WuQuant._volume(cube, this._weights);
    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
    return volumeMoment - distance / volumeWeight;
  }
  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
    let result = 0;
    let cutPosition = -1;
    for (let position = first; position < last; ++position) {
      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
      if (halfWeight !== 0) {
        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
        let temp = halfDistance / halfWeight;
        halfRed = wholeRed - halfRed;
        halfGreen = wholeGreen - halfGreen;
        halfBlue = wholeBlue - halfBlue;
        halfAlpha = wholeAlpha - halfAlpha;
        halfWeight = wholeWeight - halfWeight;
        if (halfWeight !== 0) {
          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
          temp += halfDistance / halfWeight;
          if (temp > result) {
            result = temp;
            cutPosition = position;
          }
        }
      }
    }
    return { max: result, position: cutPosition };
  }
  _cut(first, second) {
    let direction;
    const wholeRed = _WuQuant._volume(first, this._momentsRed);
    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
    const wholeWeight = _WuQuant._volume(first, this._weights);
    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
      direction = _WuQuant._alpha;
      if (alpha.position < 0)
        return false;
    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
      direction = _WuQuant._red;
    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
      direction = _WuQuant._green;
    } else {
      direction = _WuQuant._blue;
    }
    second.redMaximum = first.redMaximum;
    second.greenMaximum = first.greenMaximum;
    second.blueMaximum = first.blueMaximum;
    second.alphaMaximum = first.alphaMaximum;
    switch (direction) {
      case _WuQuant._red:
        second.redMinimum = first.redMaximum = red.position;
        second.greenMinimum = first.greenMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._green:
        second.greenMinimum = first.greenMaximum = green.position;
        second.redMinimum = first.redMinimum;
        second.blueMinimum = first.blueMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._blue:
        second.blueMinimum = first.blueMaximum = blue.position;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        second.alphaMinimum = first.alphaMinimum;
        break;
      case _WuQuant._alpha:
        second.alphaMinimum = first.alphaMaximum = alpha.position;
        second.blueMinimum = first.blueMinimum;
        second.redMinimum = first.redMinimum;
        second.greenMinimum = first.greenMinimum;
        break;
    }
    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
    return true;
  }
  _initialize(colors) {
    this._colors = colors;
    this._cubes = [];
    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
      this._cubes[cubeIndex] = new WuColorCube();
    }
    this._cubes[0].redMinimum = 0;
    this._cubes[0].greenMinimum = 0;
    this._cubes[0].blueMinimum = 0;
    this._cubes[0].alphaMinimum = 0;
    this._cubes[0].redMaximum = this._maxSideIndex;
    this._cubes[0].greenMaximum = this._maxSideIndex;
    this._cubes[0].blueMaximum = this._maxSideIndex;
    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
    this._table = [];
    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
      this._table[tableIndex] = tableIndex * tableIndex;
    }
    this._pixels = [];
  }
  _setQuality(significantBitsPerChannel = 5) {
    this._significantBitsPerChannel = significantBitsPerChannel;
    this._maxSideIndex = 1 << this._significantBitsPerChannel;
    this._alphaMaxSideIndex = this._maxSideIndex;
    this._sideSize = this._maxSideIndex + 1;
    this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
};
var WuQuant = _WuQuant;
__publicField(WuQuant, "_alpha", 3);
__publicField(WuQuant, "_red", 2);
__publicField(WuQuant, "_green", 1);
__publicField(WuQuant, "_blue", 0);

// src/image/index.ts
var image_exports = {};
__export(image_exports, {
  AbstractImageQuantizer: () => AbstractImageQuantizer,
  ErrorDiffusionArray: () => ErrorDiffusionArray,
  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
  NearestColor: () => NearestColor
});

// src/image/imageQuantizer.ts
var AbstractImageQuantizer = class {
  quantizeSync(pointContainer, palette) {
    for (const value of this.quantize(pointContainer, palette)) {
      if (value.pointContainer) {
        return value.pointContainer;
      }
    }
    throw new Error("unreachable");
  }
};

// src/image/nearestColor.ts
var NearestColor = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator) {
    super();
    __publicField(this, "_distance");
    this._distance = colorDistanceCalculator;
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0; y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
        const point = pointArray[idx];
        point.from(palette.getNearestColor(this._distance, point));
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
};

// src/image/array.ts
var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
  return ErrorDiffusionArrayKernel2;
})(ErrorDiffusionArrayKernel || {});
var ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
    super();
    __publicField(this, "_minColorDistance");
    __publicField(this, "_serpentine");
    __publicField(this, "_kernel");
    __publicField(this, "_calculateErrorLikeGIMP");
    __publicField(this, "_distance");
    this._setKernel(kernel);
    this._distance = colorDistanceCalculator;
    this._minColorDistance = minimumColorDistanceToDither;
    this._serpentine = serpentine;
    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const originalPoint = new Point();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorLines = [];
    let dir = 1;
    let maxErrorLines = 1;
    for (const kernel of this._kernel) {
      const kernelErrorLines = kernel[2] + 1;
      if (maxErrorLines < kernelErrorLines)
        maxErrorLines = kernelErrorLines;
    }
    for (let i = 0; i < maxErrorLines; i++) {
      this._fillErrorLine(errorLines[i] = [], width);
    }
    const tracker = new ProgressTracker(height, 99);
    for (let y2 = 0; y2 < height; y2++) {
      if (tracker.shouldNotify(y2)) {
        yield {
          progress: tracker.progress
        };
      }
      if (this._serpentine)
        dir *= -1;
      const lni = y2 * width;
      const xStart = dir === 1 ? 0 : width - 1;
      const xEnd = dir === 1 ? width : -1;
      this._fillErrorLine(errorLines[0], width);
      errorLines.push(errorLines.shift());
      const errorLine = errorLines[0];
      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
        const point = pointArray[idx];
        const error = errorLine[x2];
        originalPoint.from(point);
        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);
        point.from(palettePoint);
        if (this._minColorDistance) {
          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
          if (dist < this._minColorDistance)
            continue;
        }
        let er;
        let eg;
        let eb;
        let ea;
        if (this._calculateErrorLikeGIMP) {
          er = correctedPoint.r - palettePoint.r;
          eg = correctedPoint.g - palettePoint.g;
          eb = correctedPoint.b - palettePoint.b;
          ea = correctedPoint.a - palettePoint.a;
        } else {
          er = originalPoint.r - palettePoint.r;
          eg = originalPoint.g - palettePoint.g;
          eb = originalPoint.b - palettePoint.b;
          ea = originalPoint.a - palettePoint.a;
        }
        const dStart = dir === 1 ? 0 : this._kernel.length - 1;
        const dEnd = dir === 1 ? this._kernel.length : -1;
        for (let i = dStart; i !== dEnd; i += dir) {
          const x1 = this._kernel[i][1] * dir;
          const y1 = this._kernel[i][2];
          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
            const d = this._kernel[i][0];
            const e = errorLines[y1][x1 + x2];
            e[0] += er * d;
            e[1] += eg * d;
            e[2] += eb * d;
            e[3] += ea * d;
          }
        }
      }
    }
    yield {
      pointContainer,
      progress: 100
    };
  }
  _fillErrorLine(errorLine, width) {
    if (errorLine.length > width) {
      errorLine.length = width;
    }
    const l = errorLine.length;
    for (let i = 0; i < l; i++) {
      const error = errorLine[i];
      error[0] = error[1] = error[2] = error[3] = 0;
    }
    for (let i = l; i < width; i++) {
      errorLine[i] = [0, 0, 0, 0];
    }
  }
  _setKernel(kernel) {
    switch (kernel) {
      case 0 /* FloydSteinberg */:
        this._kernel = [
          [7 / 16, 1, 0],
          [3 / 16, -1, 1],
          [5 / 16, 0, 1],
          [1 / 16, 1, 1]
        ];
        break;
      case 1 /* FalseFloydSteinberg */:
        this._kernel = [
          [3 / 8, 1, 0],
          [3 / 8, 0, 1],
          [2 / 8, 1, 1]
        ];
        break;
      case 2 /* Stucki */:
        this._kernel = [
          [8 / 42, 1, 0],
          [4 / 42, 2, 0],
          [2 / 42, -2, 1],
          [4 / 42, -1, 1],
          [8 / 42, 0, 1],
          [4 / 42, 1, 1],
          [2 / 42, 2, 1],
          [1 / 42, -2, 2],
          [2 / 42, -1, 2],
          [4 / 42, 0, 2],
          [2 / 42, 1, 2],
          [1 / 42, 2, 2]
        ];
        break;
      case 3 /* Atkinson */:
        this._kernel = [
          [1 / 8, 1, 0],
          [1 / 8, 2, 0],
          [1 / 8, -1, 1],
          [1 / 8, 0, 1],
          [1 / 8, 1, 1],
          [1 / 8, 0, 2]
        ];
        break;
      case 4 /* Jarvis */:
        this._kernel = [
          [7 / 48, 1, 0],
          [5 / 48, 2, 0],
          [3 / 48, -2, 1],
          [5 / 48, -1, 1],
          [7 / 48, 0, 1],
          [5 / 48, 1, 1],
          [3 / 48, 2, 1],
          [1 / 48, -2, 2],
          [3 / 48, -1, 2],
          [5 / 48, 0, 2],
          [3 / 48, 1, 2],
          [1 / 48, 2, 2]
        ];
        break;
      case 5 /* Burkes */:
        this._kernel = [
          [8 / 32, 1, 0],
          [4 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [8 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1]
        ];
        break;
      case 6 /* Sierra */:
        this._kernel = [
          [5 / 32, 1, 0],
          [3 / 32, 2, 0],
          [2 / 32, -2, 1],
          [4 / 32, -1, 1],
          [5 / 32, 0, 1],
          [4 / 32, 1, 1],
          [2 / 32, 2, 1],
          [2 / 32, -1, 2],
          [3 / 32, 0, 2],
          [2 / 32, 1, 2]
        ];
        break;
      case 7 /* TwoSierra */:
        this._kernel = [
          [4 / 16, 1, 0],
          [3 / 16, 2, 0],
          [1 / 16, -2, 1],
          [2 / 16, -1, 1],
          [3 / 16, 0, 1],
          [2 / 16, 1, 1],
          [1 / 16, 2, 1]
        ];
        break;
      case 8 /* SierraLite */:
        this._kernel = [
          [2 / 4, 1, 0],
          [1 / 4, -1, 1],
          [1 / 4, 0, 1]
        ];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
    }
  }
};

// src/image/spaceFillingCurves/hilbertCurve.ts
function* hilbertCurve(width, height, callback) {
  const maxBound = Math.max(width, height);
  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
  const tracker = new ProgressTracker(width * height, 99);
  const data = {
    width,
    height,
    level,
    callback,
    tracker,
    index: 0,
    x: 0,
    y: 0
  };
  yield* walkHilbert(data, 1 /* UP */);
  visit(data, 0 /* NONE */);
}
function* walkHilbert(data, direction) {
  if (data.level < 1)
    return;
  if (data.tracker.shouldNotify(data.index)) {
    yield { progress: data.tracker.progress };
  }
  data.level--;
  switch (direction) {
    case 2 /* LEFT */:
      yield* walkHilbert(data, 1 /* UP */);
      visit(data, 3 /* RIGHT */);
      yield* walkHilbert(data, 2 /* LEFT */);
      visit(data, 4 /* DOWN */);
      yield* walkHilbert(data, 2 /* LEFT */);
      visit(data, 2 /* LEFT */);
      yield* walkHilbert(data, 4 /* DOWN */);
      break;
    case 3 /* RIGHT */:
      yield* walkHilbert(data, 4 /* DOWN */);
      visit(data, 2 /* LEFT */);
      yield* walkHilbert(data, 3 /* RIGHT */);
      visit(data, 1 /* UP */);
      yield* walkHilbert(data, 3 /* RIGHT */);
      visit(data, 3 /* RIGHT */);
      yield* walkHilbert(data, 1 /* UP */);
      break;
    case 1 /* UP */:
      yield* walkHilbert(data, 2 /* LEFT */);
      visit(data, 4 /* DOWN */);
      yield* walkHilbert(data, 1 /* UP */);
      visit(data, 3 /* RIGHT */);
      yield* walkHilbert(data, 1 /* UP */);
      visit(data, 1 /* UP */);
      yield* walkHilbert(data, 3 /* RIGHT */);
      break;
    case 4 /* DOWN */:
      yield* walkHilbert(data, 3 /* RIGHT */);
      visit(data, 1 /* UP */);
      yield* walkHilbert(data, 4 /* DOWN */);
      visit(data, 2 /* LEFT */);
      yield* walkHilbert(data, 4 /* DOWN */);
      visit(data, 4 /* DOWN */);
      yield* walkHilbert(data, 2 /* LEFT */);
      break;
  }
  data.level++;
}
function visit(data, direction) {
  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
    data.callback(data.x, data.y);
    data.index++;
  }
  switch (direction) {
    case 2 /* LEFT */:
      data.x--;
      break;
    case 3 /* RIGHT */:
      data.x++;
      break;
    case 1 /* UP */:
      data.y--;
      break;
    case 4 /* DOWN */:
      data.y++;
      break;
  }
}

// src/image/riemersma.ts
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
    super();
    __publicField(this, "_distance");
    __publicField(this, "_weights");
    __publicField(this, "_errorQueueSize");
    this._distance = colorDistanceCalculator;
    this._errorQueueSize = errorQueueSize;
    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
  }
  *quantize(pointContainer, palette) {
    const pointArray = pointContainer.getPointArray();
    const width = pointContainer.getWidth();
    const height = pointContainer.getHeight();
    const errorQueue = [];
    let head = 0;
    for (let i = 0; i < this._errorQueueSize; i++) {
      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
    }
    yield* hilbertCurve(width, height, (x2, y2) => {
      const p = pointArray[x2 + y2 * width];
      let { r, g, b, a } = p;
      for (let i = 0; i < this._errorQueueSize; i++) {
        const weight = this._weights[i];
        const e = errorQueue[(i + head) % this._errorQueueSize];
        r += e.r * weight;
        g += e.g * weight;
        b += e.b * weight;
        a += e.a * weight;
      }
      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
      head = (head + 1) % this._errorQueueSize;
      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
      errorQueue[tail].r = p.r - quantizedPoint.r;
      errorQueue[tail].g = p.g - quantizedPoint.g;
      errorQueue[tail].b = p.b - quantizedPoint.b;
      errorQueue[tail].a = p.a - quantizedPoint.a;
      p.from(quantizedPoint);
    });
    yield {
      pointContainer,
      progress: 100
    };
  }
  static _createWeights(errorPropagation, errorQueueSize) {
    const weights = [];
    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
    for (let i = 0, next = 1; i < errorQueueSize; i++) {
      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
      next *= multiplier;
    }
    return weights;
  }
};

// src/quality/index.ts
var quality_exports = {};
__export(quality_exports, {
  ssim: () => ssim
});

// src/quality/ssim.ts
var K1 = 0.01;
var K2 = 0.03;
function ssim(image1, image2) {
  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
    throw new Error("Images have different sizes!");
  }
  const bitsPerComponent = 8;
  const L = (1 << bitsPerComponent) - 1;
  const c1 = (K1 * L) ** 2;
  const c2 = (K2 * L) ** 2;
  let numWindows = 0;
  let mssim = 0;
  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
    let sigxy = 0;
    let sigsqx = 0;
    let sigsqy = 0;
    for (let i = 0; i < lumaValues1.length; i++) {
      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;
      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;
      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
    }
    const numPixelsInWin = lumaValues1.length - 1;
    sigsqx /= numPixelsInWin;
    sigsqy /= numPixelsInWin;
    sigxy /= numPixelsInWin;
    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
    const ssim2 = numerator / denominator;
    mssim += ssim2;
    numWindows++;
  });
  return mssim / numWindows;
}
function iterate(image1, image2, callback) {
  const windowSize = 8;
  const width = image1.getWidth();
  const height = image1.getHeight();
  for (let y2 = 0; y2 < height; y2 += windowSize) {
    for (let x2 = 0; x2 < width; x2 += windowSize) {
      const windowWidth = Math.min(windowSize, width - x2);
      const windowHeight = Math.min(windowSize, height - y2);
      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
      const averageLuma1 = calculateAverageLuma(lumaValues1);
      const averageLuma2 = calculateAverageLuma(lumaValues2);
      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
    }
  }
}
function calculateLumaValuesForWindow(image, x2, y2, width, height) {
  const pointArray = image.getPointArray();
  const lumaValues = [];
  let counter = 0;
  for (let j = y2; j < y2 + height; j++) {
    const offset = j * image.getWidth();
    for (let i = x2; i < x2 + width; i++) {
      const point = pointArray[offset + i];
      lumaValues[counter] = point.r * 0.2126 /* RED */ + point.g * 0.7152 /* GREEN */ + point.b * 0.0722 /* BLUE */;
      counter++;
    }
  }
  return lumaValues;
}
function calculateAverageLuma(lumaValues) {
  let sumLuma = 0;
  for (const luma of lumaValues) {
    sumLuma += luma;
  }
  return sumLuma / lumaValues.length;
}

// src/basicAPI.ts
typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? void 0 : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
function buildPaletteSync(images, {
  colorDistanceFormula,
  paletteQuantization,
  colors
} = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
  images.forEach((image) => paletteQuantizer.sample(image));
  return paletteQuantizer.quantizeSync();
}
function applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {
  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
  return imageQuantizer.quantizeSync(image, palette);
}
function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
  switch (colorDistanceFormula) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
  }
}
function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
  switch (imageQuantization) {
    case "nearest":
      return new NearestColor(distanceCalculator);
    case "riemersma":
      return new ErrorDiffusionRiemersma(distanceCalculator);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(distanceCalculator, 0 /* FloydSteinberg */);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(distanceCalculator, 1 /* FalseFloydSteinberg */);
    case "stucki":
      return new ErrorDiffusionArray(distanceCalculator, 2 /* Stucki */);
    case "atkinson":
      return new ErrorDiffusionArray(distanceCalculator, 3 /* Atkinson */);
    case "jarvis":
      return new ErrorDiffusionArray(distanceCalculator, 4 /* Jarvis */);
    case "burkes":
      return new ErrorDiffusionArray(distanceCalculator, 5 /* Burkes */);
    case "sierra":
      return new ErrorDiffusionArray(distanceCalculator, 6 /* Sierra */);
    case "two-sierra":
      return new ErrorDiffusionArray(distanceCalculator, 7 /* TwoSierra */);
    case "sierra-lite":
      return new ErrorDiffusionArray(distanceCalculator, 8 /* SierraLite */);
    default:
      throw new Error(`Unknown imageQuantization ${imageQuantization}`);
  }
}
function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
  switch (paletteQuantization) {
    case "neuquant":
      return new NeuQuant(distanceCalculator, colors);
    case "rgbquant":
      return new RGBQuant(distanceCalculator, colors);
    case "wuquant":
      return new WuQuant(distanceCalculator, colors);
    case "neuquant-float":
      return new NeuQuantFloat(distanceCalculator, colors);
    default:
      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
  }
}
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * common.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ditherErrorDiffusionArray.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * helper.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * nearestColor.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * MIT License
 *
 * Copyright 2015-2018 Igor Bezkrovnyi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * riemersma.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2018 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */

const QuantizeOptionsSchema = z.object({
    colors: z.number().optional(),
    colorDistanceFormula: z
        .union([
        z.literal("cie94-textiles"),
        z.literal("cie94-graphic-arts"),
        z.literal("ciede2000"),
        z.literal("color-metric"),
        z.literal("euclidean"),
        z.literal("euclidean-bt709-noalpha"),
        z.literal("euclidean-bt709"),
        z.literal("manhattan"),
        z.literal("manhattan-bt709"),
        z.literal("manhattan-nommyde"),
        z.literal("pngquant"),
    ])
        .optional(),
    paletteQuantization: z
        .union([
        z.literal("neuquant"),
        z.literal("neuquant-float"),
        z.literal("rgbquant"),
        z.literal("wuquant"),
    ])
        .optional(),
    imageQuantization: z
        .union([
        z.literal("nearest"),
        z.literal("riemersma"),
        z.literal("floyd-steinberg"),
        z.literal("false-floyd-steinberg"),
        z.literal("stucki"),
        z.literal("atkinson"),
        z.literal("jarvis"),
        z.literal("burkes"),
        z.literal("sierra"),
        z.literal("two-sierra"),
        z.literal("sierra-lite"),
    ])
        .optional(),
});
const methods = {
    /**
     * Image color number reduction.
     */
    quantize(image, options) {
        const { colors, colorDistanceFormula, paletteQuantization, imageQuantization, } = QuantizeOptionsSchema.parse(options);
        const inPointContainer = utils_exports.PointContainer.fromUint8Array(image.bitmap.data, image.bitmap.width, image.bitmap.height);
        const palette = buildPaletteSync([inPointContainer], {
            colors,
            colorDistanceFormula,
            paletteQuantization,
        });
        const outPointContainer = applyPaletteSync(inPointContainer, palette, {
            colorDistanceFormula,
            imageQuantization,
        });
        image.bitmap.data = Buffer.from(outPointContainer.toUint8Array());
        return image;
    },
};

/**
 * @module jimp
 */
// import { Jimp } from "@jimp/core";
const defaultPlugins = [
    methods$h,
    methods$g,
    methods$f,
    methods$e,
    methods$c,
    methods$a,
    methods$b,
    methods$9,
    methods$8,
    methods$7,
    methods$6,
    methods$5,
    methods$4,
    methods$3,
    methods$d,
    methods$2,
    methods$1,
    methods,
];
const defaultFormats = [bmp, msBmp, gif, jpeg$1, png, tiff];
/** Convenience object for getting the MIME types of the default formats */
({
    bmp: bmp().mime,
    gif: gif().mime,
    jpeg: jpeg$1().mime,
    png: png().mime,
    tiff: tiff().mime,
});
// TODO: This doesn't document the constructor of the class
/**
 * @class
 *
 * A `Jimp` class enables you to:class
 *
 * - Read an image into a "bit map" (a collection of pixels)
 * - Modify the bit map through methods that change the pixels
 * - Write the bit map back to an image buffer
 *
 * @example
 *
 * #### Basic
 *
 * You can use the Jimp class to make empty images.
 * This is useful for when you want to create an image that composed of other images on top of a background.
 *
 * ```ts
 * import { Jimp } from "jimp";
 *
 * const image = new Jimp({ width: 256, height: 256, color: 0xffffffff });
 * const image2 = new Jimp({ width: 100, height: 100, color: 0xff0000ff });
 *
 * image.composite(image2, 50, 50);
 * ```
 *
 * #### Node
 *
 * You can use jimp in Node.js.
 * For example you can read an image from a file and resize it and
 * then write it back to a file.
 *
 * ```ts
 * import { Jimp } from "jimp";
 * import { promises as fs } from "fs";
 *
 * const image = await Jimp.read("test/image.png");
 *
 * image.resize(256, 100);
 * image.greyscale();
 *
 * await image.write('test/output.png');
 * ```
 *
 * #### Browser
 *
 * You can use jimp in the browser by reading files from URLs
 *
 * ```ts
 * import { Jimp } from "jimp";
 *
 * const image = await Jimp.read("https://upload.wikimedia.org/wikipedia/commons/0/01/Bot-Test.jpg");
 *
 * image.resize(256, 100);
 * image.greyscale();
 *
 * const output = await image.getBuffer("test/image.png");
 *
 * const canvas = document.createElement("canvas");
 *
 * canvas.width = image.bitmap.width;
 * canvas.height = image.bitmap.height;
 *
 * const ctx = canvas.getContext("2d");
 * ctx.putImageData(image.bitmap, 0, 0);
 *
 * document.body.appendChild(canvas);
 * ```
 */
const Jimp = createJimp({
    formats: defaultFormats,
    plugins: defaultPlugins,
});

var web_spf = {exports: {}};

var hasRequiredWeb_spf;

function requireWeb_spf () {
	if (hasRequiredWeb_spf) return web_spf.exports;
	hasRequiredWeb_spf = 1;
	(function (module) {
		let imports = {};
		imports['__wbindgen_placeholder__'] = module.exports;
		let wasm;
		const { TextEncoder, TextDecoder } = require$$0$1;

		function addToExternrefTable0(obj) {
		    const idx = wasm.__externref_table_alloc();
		    wasm.__wbindgen_export_2.set(idx, obj);
		    return idx;
		}

		function handleError(f, args) {
		    try {
		        return f.apply(this, args);
		    } catch (e) {
		        const idx = addToExternrefTable0(e);
		        wasm.__wbindgen_exn_store(idx);
		    }
		}

		function debugString(val) {
		    // primitive types
		    const type = typeof val;
		    if (type == 'number' || type == 'boolean' || val == null) {
		        return  `${val}`;
		    }
		    if (type == 'string') {
		        return `"${val}"`;
		    }
		    if (type == 'symbol') {
		        const description = val.description;
		        if (description == null) {
		            return 'Symbol';
		        } else {
		            return `Symbol(${description})`;
		        }
		    }
		    if (type == 'function') {
		        const name = val.name;
		        if (typeof name == 'string' && name.length > 0) {
		            return `Function(${name})`;
		        } else {
		            return 'Function';
		        }
		    }
		    // objects
		    if (Array.isArray(val)) {
		        const length = val.length;
		        let debug = '[';
		        if (length > 0) {
		            debug += debugString(val[0]);
		        }
		        for(let i = 1; i < length; i++) {
		            debug += ', ' + debugString(val[i]);
		        }
		        debug += ']';
		        return debug;
		    }
		    // Test for built-in
		    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
		    let className;
		    if (builtInMatches && builtInMatches.length > 1) {
		        className = builtInMatches[1];
		    } else {
		        // Failed to match the standard '[object ClassName]'
		        return toString.call(val);
		    }
		    if (className == 'Object') {
		        // we're a user defined class or Object
		        // JSON.stringify avoids problems with cycles, and is generally much
		        // easier than looping through ownProperties of `val`.
		        try {
		            return 'Object(' + JSON.stringify(val) + ')';
		        } catch (_) {
		            return 'Object';
		        }
		    }
		    // errors
		    if (val instanceof Error) {
		        return `${val.name}: ${val.message}\n${val.stack}`;
		    }
		    // TODO we could test for more things here, like `Set`s and `Map`s.
		    return className;
		}

		let WASM_VECTOR_LEN = 0;

		let cachedUint8ArrayMemory0 = null;

		function getUint8ArrayMemory0() {
		    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
		        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
		    }
		    return cachedUint8ArrayMemory0;
		}

		let cachedTextEncoder = new TextEncoder('utf-8');

		const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
		    ? function (arg, view) {
		    return cachedTextEncoder.encodeInto(arg, view);
		}
		    : function (arg, view) {
		    const buf = cachedTextEncoder.encode(arg);
		    view.set(buf);
		    return {
		        read: arg.length,
		        written: buf.length
		    };
		});

		function passStringToWasm0(arg, malloc, realloc) {

		    if (realloc === undefined) {
		        const buf = cachedTextEncoder.encode(arg);
		        const ptr = malloc(buf.length, 1) >>> 0;
		        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
		        WASM_VECTOR_LEN = buf.length;
		        return ptr;
		    }

		    let len = arg.length;
		    let ptr = malloc(len, 1) >>> 0;

		    const mem = getUint8ArrayMemory0();

		    let offset = 0;

		    for (; offset < len; offset++) {
		        const code = arg.charCodeAt(offset);
		        if (code > 0x7F) break;
		        mem[ptr + offset] = code;
		    }

		    if (offset !== len) {
		        if (offset !== 0) {
		            arg = arg.slice(offset);
		        }
		        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
		        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
		        const ret = encodeString(arg, view);

		        offset += ret.written;
		        ptr = realloc(ptr, len, offset, 1) >>> 0;
		    }

		    WASM_VECTOR_LEN = offset;
		    return ptr;
		}

		let cachedDataViewMemory0 = null;

		function getDataViewMemory0() {
		    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
		        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
		    }
		    return cachedDataViewMemory0;
		}

		function isLikeNone(x) {
		    return x === undefined || x === null;
		}

		let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

		cachedTextDecoder.decode();

		function getStringFromWasm0(ptr, len) {
		    ptr = ptr >>> 0;
		    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
		}

		function _assertClass(instance, klass) {
		    if (!(instance instanceof klass)) {
		        throw new Error(`expected instance of ${klass.name}`);
		    }
		}
		/**
		 * @param {PrintSocket} socket
		 * @returns {Texture}
		 */
		module.exports.print_text = function(socket) {
		    _assertClass(socket, PrintSocket);
		    var ptr0 = socket.__destroy_into_raw();
		    const ret = wasm.print_text(ptr0);
		    return Texture.__wrap(ret);
		};

		/**
		 * @returns {boolean}
		 */
		module.exports.loaded = function() {
		    const ret = wasm.loaded();
		    return ret !== 0;
		};

		function passArray8ToWasm0(arg, malloc) {
		    const ptr = malloc(arg.length * 1, 1) >>> 0;
		    getUint8ArrayMemory0().set(arg, ptr / 1);
		    WASM_VECTOR_LEN = arg.length;
		    return ptr;
		}

		function takeFromExternrefTable0(idx) {
		    const value = wasm.__wbindgen_export_2.get(idx);
		    wasm.__externref_table_dealloc(idx);
		    return value;
		}
		/**
		 * @param {string} layout_name
		 * @param {Uint8Array} layout_bytes
		 * @param {boolean} _default
		 * @returns {string}
		 */
		module.exports.load_layout_from_file = function(layout_name, layout_bytes, _default) {
		    let deferred4_0;
		    let deferred4_1;
		    try {
		        const ptr0 = passStringToWasm0(layout_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
		        const len0 = WASM_VECTOR_LEN;
		        const ptr1 = passArray8ToWasm0(layout_bytes, wasm.__wbindgen_malloc);
		        const len1 = WASM_VECTOR_LEN;
		        const ret = wasm.load_layout_from_file(ptr0, len0, ptr1, len1, _default);
		        var ptr3 = ret[0];
		        var len3 = ret[1];
		        if (ret[3]) {
		            ptr3 = 0; len3 = 0;
		            throw takeFromExternrefTable0(ret[2]);
		        }
		        deferred4_0 = ptr3;
		        deferred4_1 = len3;
		        return getStringFromWasm0(ptr3, len3);
		    } finally {
		        wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);
		    }
		};

		function getArrayU8FromWasm0(ptr, len) {
		    ptr = ptr >>> 0;
		    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
		}
		/**
		 * @param {BadgeSocket} socket
		 * @returns {Texture}
		 */
		module.exports.print_badge = function(socket) {
		    _assertClass(socket, BadgeSocket);
		    var ptr0 = socket.__destroy_into_raw();
		    const ret = wasm.print_badge(ptr0);
		    return Texture.__wrap(ret);
		};

		const BadgeSocketFinalization = (typeof FinalizationRegistry === 'undefined')
		    ? { register: () => {}, unregister: () => {} }
		    : new FinalizationRegistry(ptr => wasm.__wbg_badgesocket_free(ptr >>> 0, 1));

		class BadgeSocket {

		    __destroy_into_raw() {
		        const ptr = this.__wbg_ptr;
		        this.__wbg_ptr = 0;
		        BadgeSocketFinalization.unregister(this);
		        return ptr;
		    }

		    free() {
		        const ptr = this.__destroy_into_raw();
		        wasm.__wbg_badgesocket_free(ptr, 0);
		    }
		    constructor() {
		        const ret = wasm.badgesocket_new();
		        this.__wbg_ptr = ret >>> 0;
		        BadgeSocketFinalization.register(this, this.__wbg_ptr, this);
		        return this;
		    }
		    /**
		     * @param {PrintSocket} socket
		     */
		    set label(socket) {
		        _assertClass(socket, PrintSocket);
		        var ptr0 = socket.__destroy_into_raw();
		        wasm.badgesocket_set_label(this.__wbg_ptr, ptr0);
		    }
		    /**
		     * @param {PrintSocket} socket
		     */
		    set message(socket) {
		        _assertClass(socket, PrintSocket);
		        var ptr0 = socket.__destroy_into_raw();
		        wasm.badgesocket_set_message(this.__wbg_ptr, ptr0);
		    }
		    /**
		     * @param {string} label_color
		     */
		    set label_color(label_color) {
		        const ptr0 = passStringToWasm0(label_color, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
		        const len0 = WASM_VECTOR_LEN;
		        wasm.badgesocket_set_label_color(this.__wbg_ptr, ptr0, len0);
		    }
		    /**
		     * @param {string} color
		     */
		    set color(color) {
		        const ptr0 = passStringToWasm0(color, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
		        const len0 = WASM_VECTOR_LEN;
		        wasm.badgesocket_set_color(this.__wbg_ptr, ptr0, len0);
		    }
		    /**
		     * @param {Texture} logo
		     */
		    set logo(logo) {
		        _assertClass(logo, Texture);
		        var ptr0 = logo.__destroy_into_raw();
		        wasm.badgesocket_set_logo(this.__wbg_ptr, ptr0);
		    }
		}
		module.exports.BadgeSocket = BadgeSocket;

		const PrintSocketFinalization = (typeof FinalizationRegistry === 'undefined')
		    ? { register: () => {}, unregister: () => {} }
		    : new FinalizationRegistry(ptr => wasm.__wbg_printsocket_free(ptr >>> 0, 1));

		class PrintSocket {

		    __destroy_into_raw() {
		        const ptr = this.__wbg_ptr;
		        this.__wbg_ptr = 0;
		        PrintSocketFinalization.unregister(this);
		        return ptr;
		    }

		    free() {
		        const ptr = this.__destroy_into_raw();
		        wasm.__wbg_printsocket_free(ptr, 0);
		    }
		    constructor() {
		        const ret = wasm.printsocket_new();
		        this.__wbg_ptr = ret >>> 0;
		        PrintSocketFinalization.register(this, this.__wbg_ptr, this);
		        return this;
		    }
		    /**
		     * @param {string} text
		     */
		    set text(text) {
		        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
		        const len0 = WASM_VECTOR_LEN;
		        wasm.printsocket_set_text(this.__wbg_ptr, ptr0, len0);
		    }
		    /**
		     * @param {number} letter_spacing
		     */
		    set letter_spacing(letter_spacing) {
		        wasm.printsocket_set_letter_spacing(this.__wbg_ptr, letter_spacing);
		    }
		    /**
		     * @param {Function} processor
		     */
		    set processor(processor) {
		        wasm.printsocket_set_processor(this.__wbg_ptr, processor);
		    }
		}
		module.exports.PrintSocket = PrintSocket;

		const TextureFinalization = (typeof FinalizationRegistry === 'undefined')
		    ? { register: () => {}, unregister: () => {} }
		    : new FinalizationRegistry(ptr => wasm.__wbg_texture_free(ptr >>> 0, 1));

		class Texture {

		    static __wrap(ptr) {
		        ptr = ptr >>> 0;
		        const obj = Object.create(Texture.prototype);
		        obj.__wbg_ptr = ptr;
		        TextureFinalization.register(obj, obj.__wbg_ptr, obj);
		        return obj;
		    }

		    __destroy_into_raw() {
		        const ptr = this.__wbg_ptr;
		        this.__wbg_ptr = 0;
		        TextureFinalization.unregister(this);
		        return ptr;
		    }

		    free() {
		        const ptr = this.__destroy_into_raw();
		        wasm.__wbg_texture_free(ptr, 0);
		    }
		    constructor() {
		        const ret = wasm.texture_new();
		        this.__wbg_ptr = ret >>> 0;
		        TextureFinalization.register(this, this.__wbg_ptr, this);
		        return this;
		    }
		    /**
		     * @returns {number}
		     */
		    get width() {
		        const ret = wasm.texture_width(this.__wbg_ptr);
		        return ret >>> 0;
		    }
		    /**
		     * @returns {number}
		     */
		    get height() {
		        const ret = wasm.texture_height(this.__wbg_ptr);
		        return ret >>> 0;
		    }
		    /**
		     * @returns {Uint8Array}
		     */
		    get texture_data() {
		        const ret = wasm.texture_texture_data(this.__wbg_ptr);
		        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
		        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
		        return v1;
		    }
		    /**
		     * @param {number} width
		     */
		    set width(width) {
		        wasm.texture_set_width(this.__wbg_ptr, width);
		    }
		    /**
		     * @param {number} height
		     */
		    set height(height) {
		        wasm.texture_set_height(this.__wbg_ptr, height);
		    }
		    /**
		     * @param {Uint8Array} texture_data
		     */
		    set texture_data(texture_data) {
		        const ptr0 = passArray8ToWasm0(texture_data, wasm.__wbindgen_malloc);
		        const len0 = WASM_VECTOR_LEN;
		        wasm.texture_set_texture_data(this.__wbg_ptr, ptr0, len0);
		    }
		}
		module.exports.Texture = Texture;

		module.exports.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {
		    const ret = arg0.call(arg1, arg2);
		    return ret;
		}, arguments) };

		module.exports.__wbg_from_2a5d3e218e67aa85 = function(arg0) {
		    const ret = Array.from(arg0);
		    return ret;
		};

		module.exports.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {
		    const ret = arg0[arg1 >>> 0];
		    return ret;
		};

		module.exports.__wbg_new_78feb108b6472713 = function() {
		    const ret = new Array();
		    return ret;
		};

		module.exports.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {
		    const ret = arg0.push(arg1);
		    return ret;
		};

		module.exports.__wbindgen_debug_string = function(arg0, arg1) {
		    const ret = debugString(arg1);
		    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
		    const len1 = WASM_VECTOR_LEN;
		    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
		    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
		};

		module.exports.__wbindgen_init_externref_table = function() {
		    const table = wasm.__wbindgen_export_2;
		    const offset = table.grow(4);
		    table.set(0, undefined);
		    table.set(offset + 0, undefined);
		    table.set(offset + 1, null);
		    table.set(offset + 2, true);
		    table.set(offset + 3, false);
		};

		module.exports.__wbindgen_number_get = function(arg0, arg1) {
		    const obj = arg1;
		    const ret = typeof(obj) === 'number' ? obj : undefined;
		    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
		    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
		};

		module.exports.__wbindgen_number_new = function(arg0) {
		    const ret = arg0;
		    return ret;
		};

		module.exports.__wbindgen_throw = function(arg0, arg1) {
		    throw new Error(getStringFromWasm0(arg0, arg1));
		};

		const path = require$$1$2.join(__dirname, 'web_spf_bg.wasm');
		const bytes = require$$0.readFileSync(path);

		const wasmModule = new WebAssembly.Module(bytes);
		const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
		wasm = wasmInstance.exports;
		module.exports.__wasm = wasm;

		wasm.__wbindgen_start(); 
	} (web_spf));
	return web_spf.exports;
}

var web_spfExports = requireWeb_spf();

var core = {};

var command = {};

var utils$3 = {};

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1;
	// We use any as a valid input type
	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(utils$3, "__esModule", { value: true });
	utils$3.toCommandProperties = utils$3.toCommandValue = void 0;
	/**
	 * Sanitizes an input into a string so it can be passed into issueCommand safely
	 * @param input input to sanitize into a string
	 */
	function toCommandValue(input) {
	    if (input === null || input === undefined) {
	        return '';
	    }
	    else if (typeof input === 'string' || input instanceof String) {
	        return input;
	    }
	    return JSON.stringify(input);
	}
	utils$3.toCommandValue = toCommandValue;
	/**
	 *
	 * @param annotationProperties
	 * @returns The command properties to send with the actual annotation command
	 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	 */
	function toCommandProperties(annotationProperties) {
	    if (!Object.keys(annotationProperties).length) {
	        return {};
	    }
	    return {
	        title: annotationProperties.title,
	        file: annotationProperties.file,
	        line: annotationProperties.startLine,
	        endLine: annotationProperties.endLine,
	        col: annotationProperties.startColumn,
	        endColumn: annotationProperties.endColumn
	    };
	}
	utils$3.toCommandProperties = toCommandProperties;
	
	return utils$3;
}

var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	var __createBinding = (command && command.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (command && command.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (command && command.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(command, "__esModule", { value: true });
	command.issue = command.issueCommand = void 0;
	const os = __importStar(require$$0$3);
	const utils_1 = requireUtils$3();
	/**
	 * Commands
	 *
	 * Command Format:
	 *   ::name key=value,key=value::message
	 *
	 * Examples:
	 *   ::warning::This is the message
	 *   ::set-env name=MY_VAR::some value
	 */
	function issueCommand(command, properties, message) {
	    const cmd = new Command(command, properties, message);
	    process.stdout.write(cmd.toString() + os.EOL);
	}
	command.issueCommand = issueCommand;
	function issue(name, message = '') {
	    issueCommand(name, {}, message);
	}
	command.issue = issue;
	const CMD_STRING = '::';
	class Command {
	    constructor(command, properties, message) {
	        if (!command) {
	            command = 'missing.command';
	        }
	        this.command = command;
	        this.properties = properties;
	        this.message = message;
	    }
	    toString() {
	        let cmdStr = CMD_STRING + this.command;
	        if (this.properties && Object.keys(this.properties).length > 0) {
	            cmdStr += ' ';
	            let first = true;
	            for (const key in this.properties) {
	                if (this.properties.hasOwnProperty(key)) {
	                    const val = this.properties[key];
	                    if (val) {
	                        if (first) {
	                            first = false;
	                        }
	                        else {
	                            cmdStr += ',';
	                        }
	                        cmdStr += `${key}=${escapeProperty(val)}`;
	                    }
	                }
	            }
	        }
	        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
	        return cmdStr;
	    }
	}
	function escapeData(s) {
	    return (0, utils_1.toCommandValue)(s)
	        .replace(/%/g, '%25')
	        .replace(/\r/g, '%0D')
	        .replace(/\n/g, '%0A');
	}
	function escapeProperty(s) {
	    return (0, utils_1.toCommandValue)(s)
	        .replace(/%/g, '%25')
	        .replace(/\r/g, '%0D')
	        .replace(/\n/g, '%0A')
	        .replace(/:/g, '%3A')
	        .replace(/,/g, '%2C');
	}
	
	return command;
}

var fileCommand = {};

var hasRequiredFileCommand;

function requireFileCommand () {
	if (hasRequiredFileCommand) return fileCommand;
	hasRequiredFileCommand = 1;
	// For internal use, subject to change.
	var __createBinding = (fileCommand && fileCommand.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (fileCommand && fileCommand.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (fileCommand && fileCommand.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(fileCommand, "__esModule", { value: true });
	fileCommand.prepareKeyValueMessage = fileCommand.issueFileCommand = void 0;
	// We use any as a valid input type
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const crypto = __importStar(require$$0$4);
	const fs = __importStar(require$$0);
	const os = __importStar(require$$0$3);
	const utils_1 = requireUtils$3();
	function issueFileCommand(command, message) {
	    const filePath = process.env[`GITHUB_${command}`];
	    if (!filePath) {
	        throw new Error(`Unable to find environment variable for file command ${command}`);
	    }
	    if (!fs.existsSync(filePath)) {
	        throw new Error(`Missing file at path: ${filePath}`);
	    }
	    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
	        encoding: 'utf8'
	    });
	}
	fileCommand.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
	    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
	    const convertedValue = (0, utils_1.toCommandValue)(value);
	    // These should realistically never happen, but just in case someone finds a
	    // way to exploit uuid generation let's not allow keys or values that contain
	    // the delimiter.
	    if (key.includes(delimiter)) {
	        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
	    }
	    if (convertedValue.includes(delimiter)) {
	        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
	    }
	    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
	}
	fileCommand.prepareKeyValueMessage = prepareKeyValueMessage;
	
	return fileCommand;
}

var oidcUtils = {};

var lib = {};

var proxy = {};

var hasRequiredProxy;

function requireProxy () {
	if (hasRequiredProxy) return proxy;
	hasRequiredProxy = 1;
	Object.defineProperty(proxy, "__esModule", { value: true });
	proxy.checkBypass = proxy.getProxyUrl = void 0;
	function getProxyUrl(reqUrl) {
	    const usingSsl = reqUrl.protocol === 'https:';
	    if (checkBypass(reqUrl)) {
	        return undefined;
	    }
	    const proxyVar = (() => {
	        if (usingSsl) {
	            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
	        }
	        else {
	            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
	        }
	    })();
	    if (proxyVar) {
	        try {
	            return new DecodedURL(proxyVar);
	        }
	        catch (_a) {
	            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
	                return new DecodedURL(`http://${proxyVar}`);
	        }
	    }
	    else {
	        return undefined;
	    }
	}
	proxy.getProxyUrl = getProxyUrl;
	function checkBypass(reqUrl) {
	    if (!reqUrl.hostname) {
	        return false;
	    }
	    const reqHost = reqUrl.hostname;
	    if (isLoopbackAddress(reqHost)) {
	        return true;
	    }
	    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
	    if (!noProxy) {
	        return false;
	    }
	    // Determine the request port
	    let reqPort;
	    if (reqUrl.port) {
	        reqPort = Number(reqUrl.port);
	    }
	    else if (reqUrl.protocol === 'http:') {
	        reqPort = 80;
	    }
	    else if (reqUrl.protocol === 'https:') {
	        reqPort = 443;
	    }
	    // Format the request hostname and hostname with port
	    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
	    if (typeof reqPort === 'number') {
	        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
	    }
	    // Compare request host against noproxy
	    for (const upperNoProxyItem of noProxy
	        .split(',')
	        .map(x => x.trim().toUpperCase())
	        .filter(x => x)) {
	        if (upperNoProxyItem === '*' ||
	            upperReqHosts.some(x => x === upperNoProxyItem ||
	                x.endsWith(`.${upperNoProxyItem}`) ||
	                (upperNoProxyItem.startsWith('.') &&
	                    x.endsWith(`${upperNoProxyItem}`)))) {
	            return true;
	        }
	    }
	    return false;
	}
	proxy.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
	    const hostLower = host.toLowerCase();
	    return (hostLower === 'localhost' ||
	        hostLower.startsWith('127.') ||
	        hostLower.startsWith('[::1]') ||
	        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
	}
	class DecodedURL extends URL {
	    constructor(url, base) {
	        super(url, base);
	        this._decodedUsername = decodeURIComponent(super.username);
	        this._decodedPassword = decodeURIComponent(super.password);
	    }
	    get username() {
	        return this._decodedUsername;
	    }
	    get password() {
	        return this._decodedPassword;
	    }
	}
	
	return proxy;
}

var tunnel$1 = {};

var hasRequiredTunnel$1;

function requireTunnel$1 () {
	if (hasRequiredTunnel$1) return tunnel$1;
	hasRequiredTunnel$1 = 1;
	var tls = require$$1$3;
	var http = require$$2$1;
	var https = require$$3$1;
	var events = require$$4$1;
	var util = require$$0$1;


	tunnel$1.httpOverHttp = httpOverHttp;
	tunnel$1.httpsOverHttp = httpsOverHttp;
	tunnel$1.httpOverHttps = httpOverHttps;
	tunnel$1.httpsOverHttps = httpsOverHttps;


	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  return agent;
	}

	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent;
	}

	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  return agent;
	}

	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent;
	}


	function TunnelingAgent(options) {
	  var self = this;
	  self.options = options || {};
	  self.proxyOptions = self.options.proxy || {};
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
	  self.requests = [];
	  self.sockets = [];

	  self.on('free', function onFree(socket, host, port, localAddress) {
	    var options = toOptions(host, port, localAddress);
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i];
	      if (pending.host === options.host && pending.port === options.port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1);
	        pending.request.onSocket(socket);
	        return;
	      }
	    }
	    socket.destroy();
	    self.removeSocket(socket);
	  });
	}
	util.inherits(TunnelingAgent, events.EventEmitter);

	TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
	  var self = this;
	  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push(options);
	    return;
	  }

	  // If we are under maxSockets create a new one.
	  self.createSocket(options, function(socket) {
	    socket.on('free', onFree);
	    socket.on('close', onCloseOrRemove);
	    socket.on('agentRemove', onCloseOrRemove);
	    req.onSocket(socket);

	    function onFree() {
	      self.emit('free', socket, options);
	    }

	    function onCloseOrRemove(err) {
	      self.removeSocket(socket);
	      socket.removeListener('free', onFree);
	      socket.removeListener('close', onCloseOrRemove);
	      socket.removeListener('agentRemove', onCloseOrRemove);
	    }
	  });
	};

	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this;
	  var placeholder = {};
	  self.sockets.push(placeholder);

	  var connectOptions = mergeOptions({}, self.proxyOptions, {
	    method: 'CONNECT',
	    path: options.host + ':' + options.port,
	    agent: false,
	    headers: {
	      host: options.host + ':' + options.port
	    }
	  });
	  if (options.localAddress) {
	    connectOptions.localAddress = options.localAddress;
	  }
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {};
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        new Buffer(connectOptions.proxyAuth).toString('base64');
	  }

	  debug('making CONNECT request');
	  var connectReq = self.request(connectOptions);
	  connectReq.useChunkedEncodingByDefault = false; // for v0.6
	  connectReq.once('response', onResponse); // for v0.6
	  connectReq.once('upgrade', onUpgrade);   // for v0.6
	  connectReq.once('connect', onConnect);   // for v0.7 or later
	  connectReq.once('error', onError);
	  connectReq.end();

	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true;
	  }

	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head);
	    });
	  }

	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners();
	    socket.removeAllListeners();

	    if (res.statusCode !== 200) {
	      debug('tunneling socket could not be established, statusCode=%d',
	        res.statusCode);
	      socket.destroy();
	      var error = new Error('tunneling socket could not be established, ' +
	        'statusCode=' + res.statusCode);
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	      return;
	    }
	    if (head.length > 0) {
	      debug('got illegal response body from proxy');
	      socket.destroy();
	      var error = new Error('got illegal response body from proxy');
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	      return;
	    }
	    debug('tunneling connection has established');
	    self.sockets[self.sockets.indexOf(placeholder)] = socket;
	    return cb(socket);
	  }

	  function onError(cause) {
	    connectReq.removeAllListeners();

	    debug('tunneling socket could not be established, cause=%s\n',
	          cause.message, cause.stack);
	    var error = new Error('tunneling socket could not be established, ' +
	                          'cause=' + cause.message);
	    error.code = 'ECONNRESET';
	    options.request.emit('error', error);
	    self.removeSocket(placeholder);
	  }
	};

	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket);
	  if (pos === -1) {
	    return;
	  }
	  this.sockets.splice(pos, 1);

	  var pending = this.requests.shift();
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createSocket(pending, function(socket) {
	      pending.request.onSocket(socket);
	    });
	  }
	};

	function createSecureSocket(options, cb) {
	  var self = this;
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    var hostHeader = options.request.getHeader('host');
	    var tlsOptions = mergeOptions({}, self.options, {
	      socket: socket,
	      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
	    });

	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, tlsOptions);
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
	    cb(secureSocket);
	  });
	}


	function toOptions(host, port, localAddress) {
	  if (typeof host === 'string') { // since v0.10
	    return {
	      host: host,
	      port: port,
	      localAddress: localAddress
	    };
	  }
	  return host; // for v0.11 or later
	}

	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i];
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides);
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j];
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k];
	        }
	      }
	    }
	  }
	  return target;
	}


	var debug;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments);
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0];
	    } else {
	      args.unshift('TUNNEL:');
	    }
	    console.error.apply(console, args);
	  };
	} else {
	  debug = function() {};
	}
	tunnel$1.debug = debug; // for test
	return tunnel$1;
}

var tunnel;
var hasRequiredTunnel;

function requireTunnel () {
	if (hasRequiredTunnel) return tunnel;
	hasRequiredTunnel = 1;
	tunnel = requireTunnel$1();
	return tunnel;
}

var undici = {};

var symbols$4;
var hasRequiredSymbols$4;

function requireSymbols$4 () {
	if (hasRequiredSymbols$4) return symbols$4;
	hasRequiredSymbols$4 = 1;
	symbols$4 = {
	  kClose: Symbol('close'),
	  kDestroy: Symbol('destroy'),
	  kDispatch: Symbol('dispatch'),
	  kUrl: Symbol('url'),
	  kWriting: Symbol('writing'),
	  kResuming: Symbol('resuming'),
	  kQueue: Symbol('queue'),
	  kConnect: Symbol('connect'),
	  kConnecting: Symbol('connecting'),
	  kHeadersList: Symbol('headers list'),
	  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
	  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
	  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
	  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
	  kKeepAlive: Symbol('keep alive'),
	  kHeadersTimeout: Symbol('headers timeout'),
	  kBodyTimeout: Symbol('body timeout'),
	  kServerName: Symbol('server name'),
	  kLocalAddress: Symbol('local address'),
	  kHost: Symbol('host'),
	  kNoRef: Symbol('no ref'),
	  kBodyUsed: Symbol('used'),
	  kRunning: Symbol('running'),
	  kBlocking: Symbol('blocking'),
	  kPending: Symbol('pending'),
	  kSize: Symbol('size'),
	  kBusy: Symbol('busy'),
	  kQueued: Symbol('queued'),
	  kFree: Symbol('free'),
	  kConnected: Symbol('connected'),
	  kClosed: Symbol('closed'),
	  kNeedDrain: Symbol('need drain'),
	  kReset: Symbol('reset'),
	  kDestroyed: Symbol.for('nodejs.stream.destroyed'),
	  kMaxHeadersSize: Symbol('max headers size'),
	  kRunningIdx: Symbol('running index'),
	  kPendingIdx: Symbol('pending index'),
	  kError: Symbol('error'),
	  kClients: Symbol('clients'),
	  kClient: Symbol('client'),
	  kParser: Symbol('parser'),
	  kOnDestroyed: Symbol('destroy callbacks'),
	  kPipelining: Symbol('pipelining'),
	  kSocket: Symbol('socket'),
	  kHostHeader: Symbol('host header'),
	  kConnector: Symbol('connector'),
	  kStrictContentLength: Symbol('strict content length'),
	  kMaxRedirections: Symbol('maxRedirections'),
	  kMaxRequests: Symbol('maxRequestsPerClient'),
	  kProxy: Symbol('proxy agent options'),
	  kCounter: Symbol('socket request counter'),
	  kInterceptors: Symbol('dispatch interceptors'),
	  kMaxResponseSize: Symbol('max response size'),
	  kHTTP2Session: Symbol('http2Session'),
	  kHTTP2SessionState: Symbol('http2Session state'),
	  kHTTP2BuildRequest: Symbol('http2 build request'),
	  kHTTP1BuildRequest: Symbol('http1 build request'),
	  kHTTP2CopyHeaders: Symbol('http2 copy headers'),
	  kHTTPConnVersion: Symbol('http connection version'),
	  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
	  kConstruct: Symbol('constructable')
	};
	return symbols$4;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	class UndiciError extends Error {
	  constructor (message) {
	    super(message);
	    this.name = 'UndiciError';
	    this.code = 'UND_ERR';
	  }
	}

	class ConnectTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ConnectTimeoutError);
	    this.name = 'ConnectTimeoutError';
	    this.message = message || 'Connect Timeout Error';
	    this.code = 'UND_ERR_CONNECT_TIMEOUT';
	  }
	}

	class HeadersTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, HeadersTimeoutError);
	    this.name = 'HeadersTimeoutError';
	    this.message = message || 'Headers Timeout Error';
	    this.code = 'UND_ERR_HEADERS_TIMEOUT';
	  }
	}

	class HeadersOverflowError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, HeadersOverflowError);
	    this.name = 'HeadersOverflowError';
	    this.message = message || 'Headers Overflow Error';
	    this.code = 'UND_ERR_HEADERS_OVERFLOW';
	  }
	}

	class BodyTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, BodyTimeoutError);
	    this.name = 'BodyTimeoutError';
	    this.message = message || 'Body Timeout Error';
	    this.code = 'UND_ERR_BODY_TIMEOUT';
	  }
	}

	class ResponseStatusCodeError extends UndiciError {
	  constructor (message, statusCode, headers, body) {
	    super(message);
	    Error.captureStackTrace(this, ResponseStatusCodeError);
	    this.name = 'ResponseStatusCodeError';
	    this.message = message || 'Response Status Code Error';
	    this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
	    this.body = body;
	    this.status = statusCode;
	    this.statusCode = statusCode;
	    this.headers = headers;
	  }
	}

	class InvalidArgumentError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InvalidArgumentError);
	    this.name = 'InvalidArgumentError';
	    this.message = message || 'Invalid Argument Error';
	    this.code = 'UND_ERR_INVALID_ARG';
	  }
	}

	class InvalidReturnValueError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InvalidReturnValueError);
	    this.name = 'InvalidReturnValueError';
	    this.message = message || 'Invalid Return Value Error';
	    this.code = 'UND_ERR_INVALID_RETURN_VALUE';
	  }
	}

	class RequestAbortedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, RequestAbortedError);
	    this.name = 'AbortError';
	    this.message = message || 'Request aborted';
	    this.code = 'UND_ERR_ABORTED';
	  }
	}

	class InformationalError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InformationalError);
	    this.name = 'InformationalError';
	    this.message = message || 'Request information';
	    this.code = 'UND_ERR_INFO';
	  }
	}

	class RequestContentLengthMismatchError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, RequestContentLengthMismatchError);
	    this.name = 'RequestContentLengthMismatchError';
	    this.message = message || 'Request body length does not match content-length header';
	    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
	  }
	}

	class ResponseContentLengthMismatchError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ResponseContentLengthMismatchError);
	    this.name = 'ResponseContentLengthMismatchError';
	    this.message = message || 'Response body length does not match content-length header';
	    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
	  }
	}

	class ClientDestroyedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ClientDestroyedError);
	    this.name = 'ClientDestroyedError';
	    this.message = message || 'The client is destroyed';
	    this.code = 'UND_ERR_DESTROYED';
	  }
	}

	class ClientClosedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ClientClosedError);
	    this.name = 'ClientClosedError';
	    this.message = message || 'The client is closed';
	    this.code = 'UND_ERR_CLOSED';
	  }
	}

	class SocketError extends UndiciError {
	  constructor (message, socket) {
	    super(message);
	    Error.captureStackTrace(this, SocketError);
	    this.name = 'SocketError';
	    this.message = message || 'Socket error';
	    this.code = 'UND_ERR_SOCKET';
	    this.socket = socket;
	  }
	}

	class NotSupportedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, NotSupportedError);
	    this.name = 'NotSupportedError';
	    this.message = message || 'Not supported error';
	    this.code = 'UND_ERR_NOT_SUPPORTED';
	  }
	}

	class BalancedPoolMissingUpstreamError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, NotSupportedError);
	    this.name = 'MissingUpstreamError';
	    this.message = message || 'No upstream has been added to the BalancedPool';
	    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
	  }
	}

	class HTTPParserError extends Error {
	  constructor (message, code, data) {
	    super(message);
	    Error.captureStackTrace(this, HTTPParserError);
	    this.name = 'HTTPParserError';
	    this.code = code ? `HPE_${code}` : undefined;
	    this.data = data ? data.toString() : undefined;
	  }
	}

	class ResponseExceededMaxSizeError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ResponseExceededMaxSizeError);
	    this.name = 'ResponseExceededMaxSizeError';
	    this.message = message || 'Response content exceeded max size';
	    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
	  }
	}

	class RequestRetryError extends UndiciError {
	  constructor (message, code, { headers, data }) {
	    super(message);
	    Error.captureStackTrace(this, RequestRetryError);
	    this.name = 'RequestRetryError';
	    this.message = message || 'Request retry error';
	    this.code = 'UND_ERR_REQ_RETRY';
	    this.statusCode = code;
	    this.data = data;
	    this.headers = headers;
	  }
	}

	errors = {
	  HTTPParserError,
	  UndiciError,
	  HeadersTimeoutError,
	  HeadersOverflowError,
	  BodyTimeoutError,
	  RequestContentLengthMismatchError,
	  ConnectTimeoutError,
	  ResponseStatusCodeError,
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError,
	  ClientDestroyedError,
	  ClientClosedError,
	  InformationalError,
	  SocketError,
	  NotSupportedError,
	  ResponseContentLengthMismatchError,
	  BalancedPoolMissingUpstreamError,
	  ResponseExceededMaxSizeError,
	  RequestRetryError
	};
	return errors;
}

var constants$4;
var hasRequiredConstants$4;

function requireConstants$4 () {
	if (hasRequiredConstants$4) return constants$4;
	hasRequiredConstants$4 = 1;

	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord = {};

	// https://developer.mozilla.org/docs/Web/HTTP/Headers
	const wellknownHeaderNames = [
	  'Accept',
	  'Accept-Encoding',
	  'Accept-Language',
	  'Accept-Ranges',
	  'Access-Control-Allow-Credentials',
	  'Access-Control-Allow-Headers',
	  'Access-Control-Allow-Methods',
	  'Access-Control-Allow-Origin',
	  'Access-Control-Expose-Headers',
	  'Access-Control-Max-Age',
	  'Access-Control-Request-Headers',
	  'Access-Control-Request-Method',
	  'Age',
	  'Allow',
	  'Alt-Svc',
	  'Alt-Used',
	  'Authorization',
	  'Cache-Control',
	  'Clear-Site-Data',
	  'Connection',
	  'Content-Disposition',
	  'Content-Encoding',
	  'Content-Language',
	  'Content-Length',
	  'Content-Location',
	  'Content-Range',
	  'Content-Security-Policy',
	  'Content-Security-Policy-Report-Only',
	  'Content-Type',
	  'Cookie',
	  'Cross-Origin-Embedder-Policy',
	  'Cross-Origin-Opener-Policy',
	  'Cross-Origin-Resource-Policy',
	  'Date',
	  'Device-Memory',
	  'Downlink',
	  'ECT',
	  'ETag',
	  'Expect',
	  'Expect-CT',
	  'Expires',
	  'Forwarded',
	  'From',
	  'Host',
	  'If-Match',
	  'If-Modified-Since',
	  'If-None-Match',
	  'If-Range',
	  'If-Unmodified-Since',
	  'Keep-Alive',
	  'Last-Modified',
	  'Link',
	  'Location',
	  'Max-Forwards',
	  'Origin',
	  'Permissions-Policy',
	  'Pragma',
	  'Proxy-Authenticate',
	  'Proxy-Authorization',
	  'RTT',
	  'Range',
	  'Referer',
	  'Referrer-Policy',
	  'Refresh',
	  'Retry-After',
	  'Sec-WebSocket-Accept',
	  'Sec-WebSocket-Extensions',
	  'Sec-WebSocket-Key',
	  'Sec-WebSocket-Protocol',
	  'Sec-WebSocket-Version',
	  'Server',
	  'Server-Timing',
	  'Service-Worker-Allowed',
	  'Service-Worker-Navigation-Preload',
	  'Set-Cookie',
	  'SourceMap',
	  'Strict-Transport-Security',
	  'Supports-Loading-Mode',
	  'TE',
	  'Timing-Allow-Origin',
	  'Trailer',
	  'Transfer-Encoding',
	  'Upgrade',
	  'Upgrade-Insecure-Requests',
	  'User-Agent',
	  'Vary',
	  'Via',
	  'WWW-Authenticate',
	  'X-Content-Type-Options',
	  'X-DNS-Prefetch-Control',
	  'X-Frame-Options',
	  'X-Permitted-Cross-Domain-Policies',
	  'X-Powered-By',
	  'X-Requested-With',
	  'X-XSS-Protection'
	];

	for (let i = 0; i < wellknownHeaderNames.length; ++i) {
	  const key = wellknownHeaderNames[i];
	  const lowerCasedKey = key.toLowerCase();
	  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =
	    lowerCasedKey;
	}

	// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
	Object.setPrototypeOf(headerNameLowerCasedRecord, null);

	constants$4 = {
	  wellknownHeaderNames,
	  headerNameLowerCasedRecord
	};
	return constants$4;
}

var util$6;
var hasRequiredUtil$6;

function requireUtil$6 () {
	if (hasRequiredUtil$6) return util$6;
	hasRequiredUtil$6 = 1;

	const assert = require$$0$2;
	const { kDestroyed, kBodyUsed } = requireSymbols$4();
	const { IncomingMessage } = require$$2$1;
	const stream = require$$1;
	const net = require$$0$5;
	const { InvalidArgumentError } = requireErrors();
	const { Blob } = require$$7;
	const nodeUtil = require$$0$1;
	const { stringify } = require$$8;
	const { headerNameLowerCasedRecord } = requireConstants$4();

	const [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v));

	function nop () {}

	function isStream (obj) {
	  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'
	}

	// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
	function isBlobLike (object) {
	  return (Blob && object instanceof Blob) || (
	    object &&
	    typeof object === 'object' &&
	    (typeof object.stream === 'function' ||
	      typeof object.arrayBuffer === 'function') &&
	    /^(Blob|File)$/.test(object[Symbol.toStringTag])
	  )
	}

	function buildURL (url, queryParams) {
	  if (url.includes('?') || url.includes('#')) {
	    throw new Error('Query params cannot be passed when url already contains "?" or "#".')
	  }

	  const stringified = stringify(queryParams);

	  if (stringified) {
	    url += '?' + stringified;
	  }

	  return url
	}

	function parseURL (url) {
	  if (typeof url === 'string') {
	    url = new URL(url);

	    if (!/^https?:/.test(url.origin || url.protocol)) {
	      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
	    }

	    return url
	  }

	  if (!url || typeof url !== 'object') {
	    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')
	  }

	  if (!/^https?:/.test(url.origin || url.protocol)) {
	    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
	  }

	  if (!(url instanceof URL)) {
	    if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
	      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')
	    }

	    if (url.path != null && typeof url.path !== 'string') {
	      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')
	    }

	    if (url.pathname != null && typeof url.pathname !== 'string') {
	      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')
	    }

	    if (url.hostname != null && typeof url.hostname !== 'string') {
	      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')
	    }

	    if (url.origin != null && typeof url.origin !== 'string') {
	      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')
	    }

	    const port = url.port != null
	      ? url.port
	      : (url.protocol === 'https:' ? 443 : 80);
	    let origin = url.origin != null
	      ? url.origin
	      : `${url.protocol}//${url.hostname}:${port}`;
	    let path = url.path != null
	      ? url.path
	      : `${url.pathname || ''}${url.search || ''}`;

	    if (origin.endsWith('/')) {
	      origin = origin.substring(0, origin.length - 1);
	    }

	    if (path && !path.startsWith('/')) {
	      path = `/${path}`;
	    }
	    // new URL(path, origin) is unsafe when `path` contains an absolute URL
	    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:
	    // If first parameter is a relative URL, second param is required, and will be used as the base URL.
	    // If first parameter is an absolute URL, a given second param will be ignored.
	    url = new URL(origin + path);
	  }

	  return url
	}

	function parseOrigin (url) {
	  url = parseURL(url);

	  if (url.pathname !== '/' || url.search || url.hash) {
	    throw new InvalidArgumentError('invalid url')
	  }

	  return url
	}

	function getHostname (host) {
	  if (host[0] === '[') {
	    const idx = host.indexOf(']');

	    assert(idx !== -1);
	    return host.substring(1, idx)
	  }

	  const idx = host.indexOf(':');
	  if (idx === -1) return host

	  return host.substring(0, idx)
	}

	// IP addresses are not valid server names per RFC6066
	// > Currently, the only server names supported are DNS hostnames
	function getServerName (host) {
	  if (!host) {
	    return null
	  }

	  assert.strictEqual(typeof host, 'string');

	  const servername = getHostname(host);
	  if (net.isIP(servername)) {
	    return ''
	  }

	  return servername
	}

	function deepClone (obj) {
	  return JSON.parse(JSON.stringify(obj))
	}

	function isAsyncIterable (obj) {
	  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')
	}

	function isIterable (obj) {
	  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))
	}

	function bodyLength (body) {
	  if (body == null) {
	    return 0
	  } else if (isStream(body)) {
	    const state = body._readableState;
	    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)
	      ? state.length
	      : null
	  } else if (isBlobLike(body)) {
	    return body.size != null ? body.size : null
	  } else if (isBuffer(body)) {
	    return body.byteLength
	  }

	  return null
	}

	function isDestroyed (stream) {
	  return !stream || !!(stream.destroyed || stream[kDestroyed])
	}

	function isReadableAborted (stream) {
	  const state = stream && stream._readableState;
	  return isDestroyed(stream) && state && !state.endEmitted
	}

	function destroy (stream, err) {
	  if (stream == null || !isStream(stream) || isDestroyed(stream)) {
	    return
	  }

	  if (typeof stream.destroy === 'function') {
	    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
	      // See: https://github.com/nodejs/node/pull/38505/files
	      stream.socket = null;
	    }

	    stream.destroy(err);
	  } else if (err) {
	    process.nextTick((stream, err) => {
	      stream.emit('error', err);
	    }, stream, err);
	  }

	  if (stream.destroyed !== true) {
	    stream[kDestroyed] = true;
	  }
	}

	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout (val) {
	  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
	  return m ? parseInt(m[1], 10) * 1000 : null
	}

	/**
	 * Retrieves a header name and returns its lowercase value.
	 * @param {string | Buffer} value Header name
	 * @returns {string}
	 */
	function headerNameToString (value) {
	  return headerNameLowerCasedRecord[value] || value.toLowerCase()
	}

	function parseHeaders (headers, obj = {}) {
	  // For H2 support
	  if (!Array.isArray(headers)) return headers

	  for (let i = 0; i < headers.length; i += 2) {
	    const key = headers[i].toString().toLowerCase();
	    let val = obj[key];

	    if (!val) {
	      if (Array.isArray(headers[i + 1])) {
	        obj[key] = headers[i + 1].map(x => x.toString('utf8'));
	      } else {
	        obj[key] = headers[i + 1].toString('utf8');
	      }
	    } else {
	      if (!Array.isArray(val)) {
	        val = [val];
	        obj[key] = val;
	      }
	      val.push(headers[i + 1].toString('utf8'));
	    }
	  }

	  // See https://github.com/nodejs/node/pull/46528
	  if ('content-length' in obj && 'content-disposition' in obj) {
	    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');
	  }

	  return obj
	}

	function parseRawHeaders (headers) {
	  const ret = [];
	  let hasContentLength = false;
	  let contentDispositionIdx = -1;

	  for (let n = 0; n < headers.length; n += 2) {
	    const key = headers[n + 0].toString();
	    const val = headers[n + 1].toString('utf8');

	    if (key.length === 14 && (key === 'content-length' || key.toLowerCase() === 'content-length')) {
	      ret.push(key, val);
	      hasContentLength = true;
	    } else if (key.length === 19 && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {
	      contentDispositionIdx = ret.push(key, val) - 1;
	    } else {
	      ret.push(key, val);
	    }
	  }

	  // See https://github.com/nodejs/node/pull/46528
	  if (hasContentLength && contentDispositionIdx !== -1) {
	    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');
	  }

	  return ret
	}

	function isBuffer (buffer) {
	  // See, https://github.com/mcollina/undici/pull/319
	  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)
	}

	function validateHandler (handler, method, upgrade) {
	  if (!handler || typeof handler !== 'object') {
	    throw new InvalidArgumentError('handler must be an object')
	  }

	  if (typeof handler.onConnect !== 'function') {
	    throw new InvalidArgumentError('invalid onConnect method')
	  }

	  if (typeof handler.onError !== 'function') {
	    throw new InvalidArgumentError('invalid onError method')
	  }

	  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {
	    throw new InvalidArgumentError('invalid onBodySent method')
	  }

	  if (upgrade || method === 'CONNECT') {
	    if (typeof handler.onUpgrade !== 'function') {
	      throw new InvalidArgumentError('invalid onUpgrade method')
	    }
	  } else {
	    if (typeof handler.onHeaders !== 'function') {
	      throw new InvalidArgumentError('invalid onHeaders method')
	    }

	    if (typeof handler.onData !== 'function') {
	      throw new InvalidArgumentError('invalid onData method')
	    }

	    if (typeof handler.onComplete !== 'function') {
	      throw new InvalidArgumentError('invalid onComplete method')
	    }
	  }
	}

	// A body is disturbed if it has been read from and it cannot
	// be re-used without losing state or data.
	function isDisturbed (body) {
	  return !!(body && (
	    stream.isDisturbed
	      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?
	      : body[kBodyUsed] ||
	        body.readableDidRead ||
	        (body._readableState && body._readableState.dataEmitted) ||
	        isReadableAborted(body)
	  ))
	}

	function isErrored (body) {
	  return !!(body && (
	    stream.isErrored
	      ? stream.isErrored(body)
	      : /state: 'errored'/.test(nodeUtil.inspect(body)
	      )))
	}

	function isReadable (body) {
	  return !!(body && (
	    stream.isReadable
	      ? stream.isReadable(body)
	      : /state: 'readable'/.test(nodeUtil.inspect(body)
	      )))
	}

	function getSocketInfo (socket) {
	  return {
	    localAddress: socket.localAddress,
	    localPort: socket.localPort,
	    remoteAddress: socket.remoteAddress,
	    remotePort: socket.remotePort,
	    remoteFamily: socket.remoteFamily,
	    timeout: socket.timeout,
	    bytesWritten: socket.bytesWritten,
	    bytesRead: socket.bytesRead
	  }
	}

	async function * convertIterableToBuffer (iterable) {
	  for await (const chunk of iterable) {
	    yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	  }
	}

	let ReadableStream;
	function ReadableStreamFrom (iterable) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  if (ReadableStream.from) {
	    return ReadableStream.from(convertIterableToBuffer(iterable))
	  }

	  let iterator;
	  return new ReadableStream(
	    {
	      async start () {
	        iterator = iterable[Symbol.asyncIterator]();
	      },
	      async pull (controller) {
	        const { done, value } = await iterator.next();
	        if (done) {
	          queueMicrotask(() => {
	            controller.close();
	          });
	        } else {
	          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
	          controller.enqueue(new Uint8Array(buf));
	        }
	        return controller.desiredSize > 0
	      },
	      async cancel (reason) {
	        await iterator.return();
	      }
	    },
	    0
	  )
	}

	// The chunk should be a FormData instance and contains
	// all the required methods.
	function isFormDataLike (object) {
	  return (
	    object &&
	    typeof object === 'object' &&
	    typeof object.append === 'function' &&
	    typeof object.delete === 'function' &&
	    typeof object.get === 'function' &&
	    typeof object.getAll === 'function' &&
	    typeof object.has === 'function' &&
	    typeof object.set === 'function' &&
	    object[Symbol.toStringTag] === 'FormData'
	  )
	}

	function throwIfAborted (signal) {
	  if (!signal) { return }
	  if (typeof signal.throwIfAborted === 'function') {
	    signal.throwIfAborted();
	  } else {
	    if (signal.aborted) {
	      // DOMException not available < v17.0.0
	      const err = new Error('The operation was aborted');
	      err.name = 'AbortError';
	      throw err
	    }
	  }
	}

	function addAbortListener (signal, listener) {
	  if ('addEventListener' in signal) {
	    signal.addEventListener('abort', listener, { once: true });
	    return () => signal.removeEventListener('abort', listener)
	  }
	  signal.addListener('abort', listener);
	  return () => signal.removeListener('abort', listener)
	}

	const hasToWellFormed = !!String.prototype.toWellFormed;

	/**
	 * @param {string} val
	 */
	function toUSVString (val) {
	  if (hasToWellFormed) {
	    return `${val}`.toWellFormed()
	  } else if (nodeUtil.toUSVString) {
	    return nodeUtil.toUSVString(val)
	  }

	  return `${val}`
	}

	// Parsed accordingly to RFC 9110
	// https://www.rfc-editor.org/rfc/rfc9110#field.content-range
	function parseRangeHeader (range) {
	  if (range == null || range === '') return { start: 0, end: null, size: null }

	  const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
	  return m
	    ? {
	        start: parseInt(m[1]),
	        end: m[2] ? parseInt(m[2]) : null,
	        size: m[3] ? parseInt(m[3]) : null
	      }
	    : null
	}

	const kEnumerableProperty = Object.create(null);
	kEnumerableProperty.enumerable = true;

	util$6 = {
	  kEnumerableProperty,
	  nop,
	  isDisturbed,
	  isErrored,
	  isReadable,
	  toUSVString,
	  isReadableAborted,
	  isBlobLike,
	  parseOrigin,
	  parseURL,
	  getServerName,
	  isStream,
	  isIterable,
	  isAsyncIterable,
	  isDestroyed,
	  headerNameToString,
	  parseRawHeaders,
	  parseHeaders,
	  parseKeepAliveTimeout,
	  destroy,
	  bodyLength,
	  deepClone,
	  ReadableStreamFrom,
	  isBuffer,
	  validateHandler,
	  getSocketInfo,
	  isFormDataLike,
	  buildURL,
	  throwIfAborted,
	  addAbortListener,
	  parseRangeHeader,
	  nodeMajor,
	  nodeMinor,
	  nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
	  safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE']
	};
	return util$6;
}

var timers;
var hasRequiredTimers;

function requireTimers () {
	if (hasRequiredTimers) return timers;
	hasRequiredTimers = 1;

	let fastNow = Date.now();
	let fastNowTimeout;

	const fastTimers = [];

	function onTimeout () {
	  fastNow = Date.now();

	  let len = fastTimers.length;
	  let idx = 0;
	  while (idx < len) {
	    const timer = fastTimers[idx];

	    if (timer.state === 0) {
	      timer.state = fastNow + timer.delay;
	    } else if (timer.state > 0 && fastNow >= timer.state) {
	      timer.state = -1;
	      timer.callback(timer.opaque);
	    }

	    if (timer.state === -1) {
	      timer.state = -2;
	      if (idx !== len - 1) {
	        fastTimers[idx] = fastTimers.pop();
	      } else {
	        fastTimers.pop();
	      }
	      len -= 1;
	    } else {
	      idx += 1;
	    }
	  }

	  if (fastTimers.length > 0) {
	    refreshTimeout();
	  }
	}

	function refreshTimeout () {
	  if (fastNowTimeout && fastNowTimeout.refresh) {
	    fastNowTimeout.refresh();
	  } else {
	    clearTimeout(fastNowTimeout);
	    fastNowTimeout = setTimeout(onTimeout, 1e3);
	    if (fastNowTimeout.unref) {
	      fastNowTimeout.unref();
	    }
	  }
	}

	class Timeout {
	  constructor (callback, delay, opaque) {
	    this.callback = callback;
	    this.delay = delay;
	    this.opaque = opaque;

	    //  -2 not in timer list
	    //  -1 in timer list but inactive
	    //   0 in timer list waiting for time
	    // > 0 in timer list waiting for time to expire
	    this.state = -2;

	    this.refresh();
	  }

	  refresh () {
	    if (this.state === -2) {
	      fastTimers.push(this);
	      if (!fastNowTimeout || fastTimers.length === 1) {
	        refreshTimeout();
	      }
	    }

	    this.state = 0;
	  }

	  clear () {
	    this.state = -1;
	  }
	}

	timers = {
	  setTimeout (callback, delay, opaque) {
	    return delay < 1e3
	      ? setTimeout(callback, delay, opaque)
	      : new Timeout(callback, delay, opaque)
	  },
	  clearTimeout (timeout) {
	    if (timeout instanceof Timeout) {
	      timeout.clear();
	    } else {
	      clearTimeout(timeout);
	    }
	  }
	};
	return timers;
}

var main = {exports: {}};

var sbmh;
var hasRequiredSbmh;

function requireSbmh () {
	if (hasRequiredSbmh) return sbmh;
	hasRequiredSbmh = 1;

	/**
	 * Copyright Brian White. All rights reserved.
	 *
	 * @see https://github.com/mscdex/streamsearch
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 *
	 * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	 * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	 */
	const EventEmitter = require$$0$6.EventEmitter;
	const inherits = require$$1$4.inherits;

	function SBMH (needle) {
	  if (typeof needle === 'string') {
	    needle = Buffer.from(needle);
	  }

	  if (!Buffer.isBuffer(needle)) {
	    throw new TypeError('The needle has to be a String or a Buffer.')
	  }

	  const needleLength = needle.length;

	  if (needleLength === 0) {
	    throw new Error('The needle cannot be an empty String/Buffer.')
	  }

	  if (needleLength > 256) {
	    throw new Error('The needle cannot have a length bigger than 256.')
	  }

	  this.maxMatches = Infinity;
	  this.matches = 0;

	  this._occ = new Array(256)
	    .fill(needleLength); // Initialize occurrence table.
	  this._lookbehind_size = 0;
	  this._needle = needle;
	  this._bufpos = 0;

	  this._lookbehind = Buffer.alloc(needleLength);

	  // Populate occurrence table with analysis of the needle,
	  // ignoring last letter.
	  for (var i = 0; i < needleLength - 1; ++i) { // eslint-disable-line no-var
	    this._occ[needle[i]] = needleLength - 1 - i;
	  }
	}
	inherits(SBMH, EventEmitter);

	SBMH.prototype.reset = function () {
	  this._lookbehind_size = 0;
	  this.matches = 0;
	  this._bufpos = 0;
	};

	SBMH.prototype.push = function (chunk, pos) {
	  if (!Buffer.isBuffer(chunk)) {
	    chunk = Buffer.from(chunk, 'binary');
	  }
	  const chlen = chunk.length;
	  this._bufpos = pos || 0;
	  let r;
	  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk); }
	  return r
	};

	SBMH.prototype._sbmh_feed = function (data) {
	  const len = data.length;
	  const needle = this._needle;
	  const needleLength = needle.length;
	  const lastNeedleChar = needle[needleLength - 1];

	  // Positive: points to a position in `data`
	  //           pos == 3 points to data[3]
	  // Negative: points to a position in the lookbehind buffer
	  //           pos == -2 points to lookbehind[lookbehind_size - 2]
	  let pos = -this._lookbehind_size;
	  let ch;

	  if (pos < 0) {
	    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
	    // search with character lookup code that considers both the
	    // lookbehind buffer and the current round's haystack data.
	    //
	    // Loop until
	    //   there is a match.
	    // or until
	    //   we've moved past the position that requires the
	    //   lookbehind buffer. In this case we switch to the
	    //   optimized loop.
	    // or until
	    //   the character to look at lies outside the haystack.
	    while (pos < 0 && pos <= len - needleLength) {
	      ch = this._sbmh_lookup_char(data, pos + needleLength - 1);

	      if (
	        ch === lastNeedleChar &&
	        this._sbmh_memcmp(data, pos, needleLength - 1)
	      ) {
	        this._lookbehind_size = 0;
	        ++this.matches;
	        this.emit('info', true);

	        return (this._bufpos = pos + needleLength)
	      }
	      pos += this._occ[ch];
	    }

	    // No match.

	    if (pos < 0) {
	      // There's too few data for Boyer-Moore-Horspool to run,
	      // so let's use a different algorithm to skip as much as
	      // we can.
	      // Forward pos until
	      //   the trailing part of lookbehind + data
	      //   looks like the beginning of the needle
	      // or until
	      //   pos == 0
	      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) { ++pos; }
	    }

	    if (pos >= 0) {
	      // Discard lookbehind buffer.
	      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);
	      this._lookbehind_size = 0;
	    } else {
	      // Cut off part of the lookbehind buffer that has
	      // been processed and append the entire haystack
	      // into it.
	      const bytesToCutOff = this._lookbehind_size + pos;
	      if (bytesToCutOff > 0) {
	        // The cut off data is guaranteed not to contain the needle.
	        this.emit('info', false, this._lookbehind, 0, bytesToCutOff);
	      }

	      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff,
	        this._lookbehind_size - bytesToCutOff);
	      this._lookbehind_size -= bytesToCutOff;

	      data.copy(this._lookbehind, this._lookbehind_size);
	      this._lookbehind_size += len;

	      this._bufpos = len;
	      return len
	    }
	  }

	  pos += (pos >= 0) * this._bufpos;

	  // Lookbehind buffer is now empty. We only need to check if the
	  // needle is in the haystack.
	  if (data.indexOf(needle, pos) !== -1) {
	    pos = data.indexOf(needle, pos);
	    ++this.matches;
	    if (pos > 0) { this.emit('info', true, data, this._bufpos, pos); } else { this.emit('info', true); }

	    return (this._bufpos = pos + needleLength)
	  } else {
	    pos = len - needleLength;
	  }

	  // There was no match. If there's trailing haystack data that we cannot
	  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
	  // data is less than the needle size) then match using a modified
	  // algorithm that starts matching from the beginning instead of the end.
	  // Whatever trailing data is left after running this algorithm is added to
	  // the lookbehind buffer.
	  while (
	    pos < len &&
	    (
	      data[pos] !== needle[0] ||
	      (
	        (Buffer.compare(
	          data.subarray(pos, pos + len - pos),
	          needle.subarray(0, len - pos)
	        ) !== 0)
	      )
	    )
	  ) {
	    ++pos;
	  }
	  if (pos < len) {
	    data.copy(this._lookbehind, 0, pos, pos + (len - pos));
	    this._lookbehind_size = len - pos;
	  }

	  // Everything until pos is guaranteed not to contain needle data.
	  if (pos > 0) { this.emit('info', false, data, this._bufpos, pos < len ? pos : len); }

	  this._bufpos = len;
	  return len
	};

	SBMH.prototype._sbmh_lookup_char = function (data, pos) {
	  return (pos < 0)
	    ? this._lookbehind[this._lookbehind_size + pos]
	    : data[pos]
	};

	SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }
	  }
	  return true
	};

	sbmh = SBMH;
	return sbmh;
}

var PartStream_1;
var hasRequiredPartStream;

function requirePartStream () {
	if (hasRequiredPartStream) return PartStream_1;
	hasRequiredPartStream = 1;

	const inherits = require$$1$4.inherits;
	const ReadableStream = require$$0$7.Readable;

	function PartStream (opts) {
	  ReadableStream.call(this, opts);
	}
	inherits(PartStream, ReadableStream);

	PartStream.prototype._read = function (n) {};

	PartStream_1 = PartStream;
	return PartStream_1;
}

var getLimit;
var hasRequiredGetLimit;

function requireGetLimit () {
	if (hasRequiredGetLimit) return getLimit;
	hasRequiredGetLimit = 1;

	getLimit = function getLimit (limits, name, defaultLimit) {
	  if (
	    !limits ||
	    limits[name] === undefined ||
	    limits[name] === null
	  ) { return defaultLimit }

	  if (
	    typeof limits[name] !== 'number' ||
	    isNaN(limits[name])
	  ) { throw new TypeError('Limit ' + name + ' is not a valid number') }

	  return limits[name]
	};
	return getLimit;
}

var HeaderParser_1;
var hasRequiredHeaderParser;

function requireHeaderParser () {
	if (hasRequiredHeaderParser) return HeaderParser_1;
	hasRequiredHeaderParser = 1;

	const EventEmitter = require$$0$6.EventEmitter;
	const inherits = require$$1$4.inherits;
	const getLimit = requireGetLimit();

	const StreamSearch = requireSbmh();

	const B_DCRLF = Buffer.from('\r\n\r\n');
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/; // eslint-disable-line no-control-regex

	function HeaderParser (cfg) {
	  EventEmitter.call(this);

	  cfg = cfg || {};
	  const self = this;
	  this.nread = 0;
	  this.maxed = false;
	  this.npairs = 0;
	  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000);
	  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024);
	  this.buffer = '';
	  this.header = {};
	  this.finished = false;
	  this.ss = new StreamSearch(B_DCRLF);
	  this.ss.on('info', function (isMatch, data, start, end) {
	    if (data && !self.maxed) {
	      if (self.nread + end - start >= self.maxHeaderSize) {
	        end = self.maxHeaderSize - self.nread + start;
	        self.nread = self.maxHeaderSize;
	        self.maxed = true;
	      } else { self.nread += (end - start); }

	      self.buffer += data.toString('binary', start, end);
	    }
	    if (isMatch) { self._finish(); }
	  });
	}
	inherits(HeaderParser, EventEmitter);

	HeaderParser.prototype.push = function (data) {
	  const r = this.ss.push(data);
	  if (this.finished) { return r }
	};

	HeaderParser.prototype.reset = function () {
	  this.finished = false;
	  this.buffer = '';
	  this.header = {};
	  this.ss.reset();
	};

	HeaderParser.prototype._finish = function () {
	  if (this.buffer) { this._parseHeader(); }
	  this.ss.matches = this.ss.maxMatches;
	  const header = this.header;
	  this.header = {};
	  this.buffer = '';
	  this.finished = true;
	  this.nread = this.npairs = 0;
	  this.maxed = false;
	  this.emit('header', header);
	};

	HeaderParser.prototype._parseHeader = function () {
	  if (this.npairs === this.maxHeaderPairs) { return }

	  const lines = this.buffer.split(RE_CRLF);
	  const len = lines.length;
	  let m, h;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (lines[i].length === 0) { continue }
	    if (lines[i][0] === '\t' || lines[i][0] === ' ') {
	      // folded header content
	      // RFC2822 says to just remove the CRLF and not the whitespace following
	      // it, so we follow the RFC and include the leading whitespace ...
	      if (h) {
	        this.header[h][this.header[h].length - 1] += lines[i];
	        continue
	      }
	    }

	    const posColon = lines[i].indexOf(':');
	    if (
	      posColon === -1 ||
	      posColon === 0
	    ) {
	      return
	    }
	    m = RE_HDR.exec(lines[i]);
	    h = m[1].toLowerCase();
	    this.header[h] = this.header[h] || [];
	    this.header[h].push((m[2] || ''));
	    if (++this.npairs === this.maxHeaderPairs) { break }
	  }
	};

	HeaderParser_1 = HeaderParser;
	return HeaderParser_1;
}

var Dicer_1;
var hasRequiredDicer;

function requireDicer () {
	if (hasRequiredDicer) return Dicer_1;
	hasRequiredDicer = 1;

	const WritableStream = require$$0$7.Writable;
	const inherits = require$$1$4.inherits;

	const StreamSearch = requireSbmh();

	const PartStream = requirePartStream();
	const HeaderParser = requireHeaderParser();

	const DASH = 45;
	const B_ONEDASH = Buffer.from('-');
	const B_CRLF = Buffer.from('\r\n');
	const EMPTY_FN = function () {};

	function Dicer (cfg) {
	  if (!(this instanceof Dicer)) { return new Dicer(cfg) }
	  WritableStream.call(this, cfg);

	  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) { throw new TypeError('Boundary required') }

	  if (typeof cfg.boundary === 'string') { this.setBoundary(cfg.boundary); } else { this._bparser = undefined; }

	  this._headerFirst = cfg.headerFirst;

	  this._dashes = 0;
	  this._parts = 0;
	  this._finished = false;
	  this._realFinish = false;
	  this._isPreamble = true;
	  this._justMatched = false;
	  this._firstWrite = true;
	  this._inHeader = true;
	  this._part = undefined;
	  this._cb = undefined;
	  this._ignoreData = false;
	  this._partOpts = { highWaterMark: cfg.partHwm };
	  this._pause = false;

	  const self = this;
	  this._hparser = new HeaderParser(cfg);
	  this._hparser.on('header', function (header) {
	    self._inHeader = false;
	    self._part.emit('header', header);
	  });
	}
	inherits(Dicer, WritableStream);

	Dicer.prototype.emit = function (ev) {
	  if (ev === 'finish' && !this._realFinish) {
	    if (!this._finished) {
	      const self = this;
	      process.nextTick(function () {
	        self.emit('error', new Error('Unexpected end of multipart data'));
	        if (self._part && !self._ignoreData) {
	          const type = (self._isPreamble ? 'Preamble' : 'Part');
	          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));
	          self._part.push(null);
	          process.nextTick(function () {
	            self._realFinish = true;
	            self.emit('finish');
	            self._realFinish = false;
	          });
	          return
	        }
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      });
	    }
	  } else { WritableStream.prototype.emit.apply(this, arguments); }
	};

	Dicer.prototype._write = function (data, encoding, cb) {
	  // ignore unexpected data (e.g. extra trailer data after finished)
	  if (!this._hparser && !this._bparser) { return cb() }

	  if (this._headerFirst && this._isPreamble) {
	    if (!this._part) {
	      this._part = new PartStream(this._partOpts);
	      if (this.listenerCount('preamble') !== 0) { this.emit('preamble', this._part); } else { this._ignore(); }
	    }
	    const r = this._hparser.push(data);
	    if (!this._inHeader && r !== undefined && r < data.length) { data = data.slice(r); } else { return cb() }
	  }

	  // allows for "easier" testing
	  if (this._firstWrite) {
	    this._bparser.push(B_CRLF);
	    this._firstWrite = false;
	  }

	  this._bparser.push(data);

	  if (this._pause) { this._cb = cb; } else { cb(); }
	};

	Dicer.prototype.reset = function () {
	  this._part = undefined;
	  this._bparser = undefined;
	  this._hparser = undefined;
	};

	Dicer.prototype.setBoundary = function (boundary) {
	  const self = this;
	  this._bparser = new StreamSearch('\r\n--' + boundary);
	  this._bparser.on('info', function (isMatch, data, start, end) {
	    self._oninfo(isMatch, data, start, end);
	  });
	};

	Dicer.prototype._ignore = function () {
	  if (this._part && !this._ignoreData) {
	    this._ignoreData = true;
	    this._part.on('error', EMPTY_FN);
	    // we must perform some kind of read on the stream even though we are
	    // ignoring the data, otherwise node's Readable stream will not emit 'end'
	    // after pushing null to the stream
	    this._part.resume();
	  }
	};

	Dicer.prototype._oninfo = function (isMatch, data, start, end) {
	  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true;

	  if (!this._part && this._justMatched && data) {
	    while (this._dashes < 2 && (start + i) < end) {
	      if (data[start + i] === DASH) {
	        ++i;
	        ++this._dashes;
	      } else {
	        if (this._dashes) { buf = B_ONEDASH; }
	        this._dashes = 0;
	        break
	      }
	    }
	    if (this._dashes === 2) {
	      if ((start + i) < end && this.listenerCount('trailer') !== 0) { this.emit('trailer', data.slice(start + i, end)); }
	      this.reset();
	      this._finished = true;
	      // no more parts will be added
	      if (self._parts === 0) {
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      }
	    }
	    if (this._dashes) { return }
	  }
	  if (this._justMatched) { this._justMatched = false; }
	  if (!this._part) {
	    this._part = new PartStream(this._partOpts);
	    this._part._read = function (n) {
	      self._unpause();
	    };
	    if (this._isPreamble && this.listenerCount('preamble') !== 0) {
	      this.emit('preamble', this._part);
	    } else if (this._isPreamble !== true && this.listenerCount('part') !== 0) {
	      this.emit('part', this._part);
	    } else {
	      this._ignore();
	    }
	    if (!this._isPreamble) { this._inHeader = true; }
	  }
	  if (data && start < end && !this._ignoreData) {
	    if (this._isPreamble || !this._inHeader) {
	      if (buf) { shouldWriteMore = this._part.push(buf); }
	      shouldWriteMore = this._part.push(data.slice(start, end));
	      if (!shouldWriteMore) { this._pause = true; }
	    } else if (!this._isPreamble && this._inHeader) {
	      if (buf) { this._hparser.push(buf); }
	      r = this._hparser.push(data.slice(start, end));
	      if (!this._inHeader && r !== undefined && r < end) { this._oninfo(false, data, start + r, end); }
	    }
	  }
	  if (isMatch) {
	    this._hparser.reset();
	    if (this._isPreamble) { this._isPreamble = false; } else {
	      if (start !== end) {
	        ++this._parts;
	        this._part.on('end', function () {
	          if (--self._parts === 0) {
	            if (self._finished) {
	              self._realFinish = true;
	              self.emit('finish');
	              self._realFinish = false;
	            } else {
	              self._unpause();
	            }
	          }
	        });
	      }
	    }
	    this._part.push(null);
	    this._part = undefined;
	    this._ignoreData = false;
	    this._justMatched = true;
	    this._dashes = 0;
	  }
	};

	Dicer.prototype._unpause = function () {
	  if (!this._pause) { return }

	  this._pause = false;
	  if (this._cb) {
	    const cb = this._cb;
	    this._cb = undefined;
	    cb();
	  }
	};

	Dicer_1 = Dicer;
	return Dicer_1;
}

var decodeText_1;
var hasRequiredDecodeText;

function requireDecodeText () {
	if (hasRequiredDecodeText) return decodeText_1;
	hasRequiredDecodeText = 1;

	// Node has always utf-8
	const utf8Decoder = new TextDecoder('utf-8');
	const textDecoders = new Map([
	  ['utf-8', utf8Decoder],
	  ['utf8', utf8Decoder]
	]);

	function getDecoder (charset) {
	  let lc;
	  while (true) {
	    switch (charset) {
	      case 'utf-8':
	      case 'utf8':
	        return decoders.utf8
	      case 'latin1':
	      case 'ascii': // TODO: Make these a separate, strict decoder?
	      case 'us-ascii':
	      case 'iso-8859-1':
	      case 'iso8859-1':
	      case 'iso88591':
	      case 'iso_8859-1':
	      case 'windows-1252':
	      case 'iso_8859-1:1987':
	      case 'cp1252':
	      case 'x-cp1252':
	        return decoders.latin1
	      case 'utf16le':
	      case 'utf-16le':
	      case 'ucs2':
	      case 'ucs-2':
	        return decoders.utf16le
	      case 'base64':
	        return decoders.base64
	      default:
	        if (lc === undefined) {
	          lc = true;
	          charset = charset.toLowerCase();
	          continue
	        }
	        return decoders.other.bind(charset)
	    }
	  }
	}

	const decoders = {
	  utf8: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.utf8Slice(0, data.length)
	  },

	  latin1: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      return data
	    }
	    return data.latin1Slice(0, data.length)
	  },

	  utf16le: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.ucs2Slice(0, data.length)
	  },

	  base64: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.base64Slice(0, data.length)
	  },

	  other: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }

	    if (textDecoders.has(this.toString())) {
	      try {
	        return textDecoders.get(this).decode(data)
	      } catch {}
	    }
	    return typeof data === 'string'
	      ? data
	      : data.toString()
	  }
	};

	function decodeText (text, sourceEncoding, destEncoding) {
	  if (text) {
	    return getDecoder(destEncoding)(text, sourceEncoding)
	  }
	  return text
	}

	decodeText_1 = decodeText;
	return decodeText_1;
}

/* eslint-disable object-property-newline */

var parseParams_1;
var hasRequiredParseParams;

function requireParseParams () {
	if (hasRequiredParseParams) return parseParams_1;
	hasRequiredParseParams = 1;

	const decodeText = requireDecodeText();

	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;

	const EncodedLookup = {
	  '%00': '\x00', '%01': '\x01', '%02': '\x02', '%03': '\x03', '%04': '\x04',
	  '%05': '\x05', '%06': '\x06', '%07': '\x07', '%08': '\x08', '%09': '\x09',
	  '%0a': '\x0a', '%0A': '\x0a', '%0b': '\x0b', '%0B': '\x0b', '%0c': '\x0c',
	  '%0C': '\x0c', '%0d': '\x0d', '%0D': '\x0d', '%0e': '\x0e', '%0E': '\x0e',
	  '%0f': '\x0f', '%0F': '\x0f', '%10': '\x10', '%11': '\x11', '%12': '\x12',
	  '%13': '\x13', '%14': '\x14', '%15': '\x15', '%16': '\x16', '%17': '\x17',
	  '%18': '\x18', '%19': '\x19', '%1a': '\x1a', '%1A': '\x1a', '%1b': '\x1b',
	  '%1B': '\x1b', '%1c': '\x1c', '%1C': '\x1c', '%1d': '\x1d', '%1D': '\x1d',
	  '%1e': '\x1e', '%1E': '\x1e', '%1f': '\x1f', '%1F': '\x1f', '%20': '\x20',
	  '%21': '\x21', '%22': '\x22', '%23': '\x23', '%24': '\x24', '%25': '\x25',
	  '%26': '\x26', '%27': '\x27', '%28': '\x28', '%29': '\x29', '%2a': '\x2a',
	  '%2A': '\x2a', '%2b': '\x2b', '%2B': '\x2b', '%2c': '\x2c', '%2C': '\x2c',
	  '%2d': '\x2d', '%2D': '\x2d', '%2e': '\x2e', '%2E': '\x2e', '%2f': '\x2f',
	  '%2F': '\x2f', '%30': '\x30', '%31': '\x31', '%32': '\x32', '%33': '\x33',
	  '%34': '\x34', '%35': '\x35', '%36': '\x36', '%37': '\x37', '%38': '\x38',
	  '%39': '\x39', '%3a': '\x3a', '%3A': '\x3a', '%3b': '\x3b', '%3B': '\x3b',
	  '%3c': '\x3c', '%3C': '\x3c', '%3d': '\x3d', '%3D': '\x3d', '%3e': '\x3e',
	  '%3E': '\x3e', '%3f': '\x3f', '%3F': '\x3f', '%40': '\x40', '%41': '\x41',
	  '%42': '\x42', '%43': '\x43', '%44': '\x44', '%45': '\x45', '%46': '\x46',
	  '%47': '\x47', '%48': '\x48', '%49': '\x49', '%4a': '\x4a', '%4A': '\x4a',
	  '%4b': '\x4b', '%4B': '\x4b', '%4c': '\x4c', '%4C': '\x4c', '%4d': '\x4d',
	  '%4D': '\x4d', '%4e': '\x4e', '%4E': '\x4e', '%4f': '\x4f', '%4F': '\x4f',
	  '%50': '\x50', '%51': '\x51', '%52': '\x52', '%53': '\x53', '%54': '\x54',
	  '%55': '\x55', '%56': '\x56', '%57': '\x57', '%58': '\x58', '%59': '\x59',
	  '%5a': '\x5a', '%5A': '\x5a', '%5b': '\x5b', '%5B': '\x5b', '%5c': '\x5c',
	  '%5C': '\x5c', '%5d': '\x5d', '%5D': '\x5d', '%5e': '\x5e', '%5E': '\x5e',
	  '%5f': '\x5f', '%5F': '\x5f', '%60': '\x60', '%61': '\x61', '%62': '\x62',
	  '%63': '\x63', '%64': '\x64', '%65': '\x65', '%66': '\x66', '%67': '\x67',
	  '%68': '\x68', '%69': '\x69', '%6a': '\x6a', '%6A': '\x6a', '%6b': '\x6b',
	  '%6B': '\x6b', '%6c': '\x6c', '%6C': '\x6c', '%6d': '\x6d', '%6D': '\x6d',
	  '%6e': '\x6e', '%6E': '\x6e', '%6f': '\x6f', '%6F': '\x6f', '%70': '\x70',
	  '%71': '\x71', '%72': '\x72', '%73': '\x73', '%74': '\x74', '%75': '\x75',
	  '%76': '\x76', '%77': '\x77', '%78': '\x78', '%79': '\x79', '%7a': '\x7a',
	  '%7A': '\x7a', '%7b': '\x7b', '%7B': '\x7b', '%7c': '\x7c', '%7C': '\x7c',
	  '%7d': '\x7d', '%7D': '\x7d', '%7e': '\x7e', '%7E': '\x7e', '%7f': '\x7f',
	  '%7F': '\x7f', '%80': '\x80', '%81': '\x81', '%82': '\x82', '%83': '\x83',
	  '%84': '\x84', '%85': '\x85', '%86': '\x86', '%87': '\x87', '%88': '\x88',
	  '%89': '\x89', '%8a': '\x8a', '%8A': '\x8a', '%8b': '\x8b', '%8B': '\x8b',
	  '%8c': '\x8c', '%8C': '\x8c', '%8d': '\x8d', '%8D': '\x8d', '%8e': '\x8e',
	  '%8E': '\x8e', '%8f': '\x8f', '%8F': '\x8f', '%90': '\x90', '%91': '\x91',
	  '%92': '\x92', '%93': '\x93', '%94': '\x94', '%95': '\x95', '%96': '\x96',
	  '%97': '\x97', '%98': '\x98', '%99': '\x99', '%9a': '\x9a', '%9A': '\x9a',
	  '%9b': '\x9b', '%9B': '\x9b', '%9c': '\x9c', '%9C': '\x9c', '%9d': '\x9d',
	  '%9D': '\x9d', '%9e': '\x9e', '%9E': '\x9e', '%9f': '\x9f', '%9F': '\x9f',
	  '%a0': '\xa0', '%A0': '\xa0', '%a1': '\xa1', '%A1': '\xa1', '%a2': '\xa2',
	  '%A2': '\xa2', '%a3': '\xa3', '%A3': '\xa3', '%a4': '\xa4', '%A4': '\xa4',
	  '%a5': '\xa5', '%A5': '\xa5', '%a6': '\xa6', '%A6': '\xa6', '%a7': '\xa7',
	  '%A7': '\xa7', '%a8': '\xa8', '%A8': '\xa8', '%a9': '\xa9', '%A9': '\xa9',
	  '%aa': '\xaa', '%Aa': '\xaa', '%aA': '\xaa', '%AA': '\xaa', '%ab': '\xab',
	  '%Ab': '\xab', '%aB': '\xab', '%AB': '\xab', '%ac': '\xac', '%Ac': '\xac',
	  '%aC': '\xac', '%AC': '\xac', '%ad': '\xad', '%Ad': '\xad', '%aD': '\xad',
	  '%AD': '\xad', '%ae': '\xae', '%Ae': '\xae', '%aE': '\xae', '%AE': '\xae',
	  '%af': '\xaf', '%Af': '\xaf', '%aF': '\xaf', '%AF': '\xaf', '%b0': '\xb0',
	  '%B0': '\xb0', '%b1': '\xb1', '%B1': '\xb1', '%b2': '\xb2', '%B2': '\xb2',
	  '%b3': '\xb3', '%B3': '\xb3', '%b4': '\xb4', '%B4': '\xb4', '%b5': '\xb5',
	  '%B5': '\xb5', '%b6': '\xb6', '%B6': '\xb6', '%b7': '\xb7', '%B7': '\xb7',
	  '%b8': '\xb8', '%B8': '\xb8', '%b9': '\xb9', '%B9': '\xb9', '%ba': '\xba',
	  '%Ba': '\xba', '%bA': '\xba', '%BA': '\xba', '%bb': '\xbb', '%Bb': '\xbb',
	  '%bB': '\xbb', '%BB': '\xbb', '%bc': '\xbc', '%Bc': '\xbc', '%bC': '\xbc',
	  '%BC': '\xbc', '%bd': '\xbd', '%Bd': '\xbd', '%bD': '\xbd', '%BD': '\xbd',
	  '%be': '\xbe', '%Be': '\xbe', '%bE': '\xbe', '%BE': '\xbe', '%bf': '\xbf',
	  '%Bf': '\xbf', '%bF': '\xbf', '%BF': '\xbf', '%c0': '\xc0', '%C0': '\xc0',
	  '%c1': '\xc1', '%C1': '\xc1', '%c2': '\xc2', '%C2': '\xc2', '%c3': '\xc3',
	  '%C3': '\xc3', '%c4': '\xc4', '%C4': '\xc4', '%c5': '\xc5', '%C5': '\xc5',
	  '%c6': '\xc6', '%C6': '\xc6', '%c7': '\xc7', '%C7': '\xc7', '%c8': '\xc8',
	  '%C8': '\xc8', '%c9': '\xc9', '%C9': '\xc9', '%ca': '\xca', '%Ca': '\xca',
	  '%cA': '\xca', '%CA': '\xca', '%cb': '\xcb', '%Cb': '\xcb', '%cB': '\xcb',
	  '%CB': '\xcb', '%cc': '\xcc', '%Cc': '\xcc', '%cC': '\xcc', '%CC': '\xcc',
	  '%cd': '\xcd', '%Cd': '\xcd', '%cD': '\xcd', '%CD': '\xcd', '%ce': '\xce',
	  '%Ce': '\xce', '%cE': '\xce', '%CE': '\xce', '%cf': '\xcf', '%Cf': '\xcf',
	  '%cF': '\xcf', '%CF': '\xcf', '%d0': '\xd0', '%D0': '\xd0', '%d1': '\xd1',
	  '%D1': '\xd1', '%d2': '\xd2', '%D2': '\xd2', '%d3': '\xd3', '%D3': '\xd3',
	  '%d4': '\xd4', '%D4': '\xd4', '%d5': '\xd5', '%D5': '\xd5', '%d6': '\xd6',
	  '%D6': '\xd6', '%d7': '\xd7', '%D7': '\xd7', '%d8': '\xd8', '%D8': '\xd8',
	  '%d9': '\xd9', '%D9': '\xd9', '%da': '\xda', '%Da': '\xda', '%dA': '\xda',
	  '%DA': '\xda', '%db': '\xdb', '%Db': '\xdb', '%dB': '\xdb', '%DB': '\xdb',
	  '%dc': '\xdc', '%Dc': '\xdc', '%dC': '\xdc', '%DC': '\xdc', '%dd': '\xdd',
	  '%Dd': '\xdd', '%dD': '\xdd', '%DD': '\xdd', '%de': '\xde', '%De': '\xde',
	  '%dE': '\xde', '%DE': '\xde', '%df': '\xdf', '%Df': '\xdf', '%dF': '\xdf',
	  '%DF': '\xdf', '%e0': '\xe0', '%E0': '\xe0', '%e1': '\xe1', '%E1': '\xe1',
	  '%e2': '\xe2', '%E2': '\xe2', '%e3': '\xe3', '%E3': '\xe3', '%e4': '\xe4',
	  '%E4': '\xe4', '%e5': '\xe5', '%E5': '\xe5', '%e6': '\xe6', '%E6': '\xe6',
	  '%e7': '\xe7', '%E7': '\xe7', '%e8': '\xe8', '%E8': '\xe8', '%e9': '\xe9',
	  '%E9': '\xe9', '%ea': '\xea', '%Ea': '\xea', '%eA': '\xea', '%EA': '\xea',
	  '%eb': '\xeb', '%Eb': '\xeb', '%eB': '\xeb', '%EB': '\xeb', '%ec': '\xec',
	  '%Ec': '\xec', '%eC': '\xec', '%EC': '\xec', '%ed': '\xed', '%Ed': '\xed',
	  '%eD': '\xed', '%ED': '\xed', '%ee': '\xee', '%Ee': '\xee', '%eE': '\xee',
	  '%EE': '\xee', '%ef': '\xef', '%Ef': '\xef', '%eF': '\xef', '%EF': '\xef',
	  '%f0': '\xf0', '%F0': '\xf0', '%f1': '\xf1', '%F1': '\xf1', '%f2': '\xf2',
	  '%F2': '\xf2', '%f3': '\xf3', '%F3': '\xf3', '%f4': '\xf4', '%F4': '\xf4',
	  '%f5': '\xf5', '%F5': '\xf5', '%f6': '\xf6', '%F6': '\xf6', '%f7': '\xf7',
	  '%F7': '\xf7', '%f8': '\xf8', '%F8': '\xf8', '%f9': '\xf9', '%F9': '\xf9',
	  '%fa': '\xfa', '%Fa': '\xfa', '%fA': '\xfa', '%FA': '\xfa', '%fb': '\xfb',
	  '%Fb': '\xfb', '%fB': '\xfb', '%FB': '\xfb', '%fc': '\xfc', '%Fc': '\xfc',
	  '%fC': '\xfc', '%FC': '\xfc', '%fd': '\xfd', '%Fd': '\xfd', '%fD': '\xfd',
	  '%FD': '\xfd', '%fe': '\xfe', '%Fe': '\xfe', '%fE': '\xfe', '%FE': '\xfe',
	  '%ff': '\xff', '%Ff': '\xff', '%fF': '\xff', '%FF': '\xff'
	};

	function encodedReplacer (match) {
	  return EncodedLookup[match]
	}

	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;

	function parseParams (str) {
	  const res = [];
	  let state = STATE_KEY;
	  let charset = '';
	  let inquote = false;
	  let escaping = false;
	  let p = 0;
	  let tmp = '';
	  const len = str.length;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    const char = str[i];
	    if (char === '\\' && inquote) {
	      if (escaping) { escaping = false; } else {
	        escaping = true;
	        continue
	      }
	    } else if (char === '"') {
	      if (!escaping) {
	        if (inquote) {
	          inquote = false;
	          state = STATE_KEY;
	        } else { inquote = true; }
	        continue
	      } else { escaping = false; }
	    } else {
	      if (escaping && inquote) { tmp += '\\'; }
	      escaping = false;
	      if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
	        if (state === STATE_CHARSET) {
	          state = STATE_LANG;
	          charset = tmp.substring(1);
	        } else { state = STATE_VALUE; }
	        tmp = '';
	        continue
	      } else if (state === STATE_KEY &&
	        (char === '*' || char === '=') &&
	        res.length) {
	        state = char === '*'
	          ? STATE_CHARSET
	          : STATE_VALUE;
	        res[p] = [tmp, undefined];
	        tmp = '';
	        continue
	      } else if (!inquote && char === ';') {
	        state = STATE_KEY;
	        if (charset) {
	          if (tmp.length) {
	            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	              'binary',
	              charset);
	          }
	          charset = '';
	        } else if (tmp.length) {
	          tmp = decodeText(tmp, 'binary', 'utf8');
	        }
	        if (res[p] === undefined) { res[p] = tmp; } else { res[p][1] = tmp; }
	        tmp = '';
	        ++p;
	        continue
	      } else if (!inquote && (char === ' ' || char === '\t')) { continue }
	    }
	    tmp += char;
	  }
	  if (charset && tmp.length) {
	    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	      'binary',
	      charset);
	  } else if (tmp) {
	    tmp = decodeText(tmp, 'binary', 'utf8');
	  }

	  if (res[p] === undefined) {
	    if (tmp) { res[p] = tmp; }
	  } else { res[p][1] = tmp; }

	  return res
	}

	parseParams_1 = parseParams;
	return parseParams_1;
}

var basename;
var hasRequiredBasename;

function requireBasename () {
	if (hasRequiredBasename) return basename;
	hasRequiredBasename = 1;

	basename = function basename (path) {
	  if (typeof path !== 'string') { return '' }
	  for (var i = path.length - 1; i >= 0; --i) { // eslint-disable-line no-var
	    switch (path.charCodeAt(i)) {
	      case 0x2F: // '/'
	      case 0x5C: // '\'
	        path = path.slice(i + 1);
	        return (path === '..' || path === '.' ? '' : path)
	    }
	  }
	  return (path === '..' || path === '.' ? '' : path)
	};
	return basename;
}

var multipart;
var hasRequiredMultipart;

function requireMultipart () {
	if (hasRequiredMultipart) return multipart;
	hasRequiredMultipart = 1;

	// TODO:
	//  * support 1 nested multipart level
	//    (see second multipart example here:
	//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
	//  * support limits.fieldNameSize
	//     -- this will require modifications to utils.parseParams

	const { Readable } = require$$0$7;
	const { inherits } = require$$1$4;

	const Dicer = requireDicer();

	const parseParams = requireParseParams();
	const decodeText = requireDecodeText();
	const basename = requireBasename();
	const getLimit = requireGetLimit();

	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;

	Multipart.detect = /^multipart\/form-data/i;
	function Multipart (boy, cfg) {
	  let i;
	  let len;
	  const self = this;
	  let boundary;
	  const limits = cfg.limits;
	  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined));
	  const parsedConType = cfg.parsedConType || [];
	  const defCharset = cfg.defCharset || 'utf8';
	  const preservePath = cfg.preservePath;
	  const fileOpts = { highWaterMark: cfg.fileHwm };

	  for (i = 0, len = parsedConType.length; i < len; ++i) {
	    if (Array.isArray(parsedConType[i]) &&
	      RE_BOUNDARY.test(parsedConType[i][0])) {
	      boundary = parsedConType[i][1];
	      break
	    }
	  }

	  function checkFinished () {
	    if (nends === 0 && finished && !boy._done) {
	      finished = false;
	      self.end();
	    }
	  }

	  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }

	  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);
	  const filesLimit = getLimit(limits, 'files', Infinity);
	  const fieldsLimit = getLimit(limits, 'fields', Infinity);
	  const partsLimit = getLimit(limits, 'parts', Infinity);
	  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);
	  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);

	  let nfiles = 0;
	  let nfields = 0;
	  let nends = 0;
	  let curFile;
	  let curField;
	  let finished = false;

	  this._needDrain = false;
	  this._pause = false;
	  this._cb = undefined;
	  this._nparts = 0;
	  this._boy = boy;

	  const parserCfg = {
	    boundary,
	    maxHeaderPairs: headerPairsLimit,
	    maxHeaderSize: headerSizeLimit,
	    partHwm: fileOpts.highWaterMark,
	    highWaterMark: cfg.highWaterMark
	  };

	  this.parser = new Dicer(parserCfg);
	  this.parser.on('drain', function () {
	    self._needDrain = false;
	    if (self._cb && !self._pause) {
	      const cb = self._cb;
	      self._cb = undefined;
	      cb();
	    }
	  }).on('part', function onPart (part) {
	    if (++self._nparts > partsLimit) {
	      self.parser.removeListener('part', onPart);
	      self.parser.on('part', skipPart);
	      boy.hitPartsLimit = true;
	      boy.emit('partsLimit');
	      return skipPart(part)
	    }

	    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
	    // us emit 'end' early since we know the part has ended if we are already
	    // seeing the next part
	    if (curField) {
	      const field = curField;
	      field.emit('end');
	      field.removeAllListeners('end');
	    }

	    part.on('header', function (header) {
	      let contype;
	      let fieldname;
	      let parsed;
	      let charset;
	      let encoding;
	      let filename;
	      let nsize = 0;

	      if (header['content-type']) {
	        parsed = parseParams(header['content-type'][0]);
	        if (parsed[0]) {
	          contype = parsed[0].toLowerCase();
	          for (i = 0, len = parsed.length; i < len; ++i) {
	            if (RE_CHARSET.test(parsed[i][0])) {
	              charset = parsed[i][1].toLowerCase();
	              break
	            }
	          }
	        }
	      }

	      if (contype === undefined) { contype = 'text/plain'; }
	      if (charset === undefined) { charset = defCharset; }

	      if (header['content-disposition']) {
	        parsed = parseParams(header['content-disposition'][0]);
	        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }
	        for (i = 0, len = parsed.length; i < len; ++i) {
	          if (RE_NAME.test(parsed[i][0])) {
	            fieldname = parsed[i][1];
	          } else if (RE_FILENAME.test(parsed[i][0])) {
	            filename = parsed[i][1];
	            if (!preservePath) { filename = basename(filename); }
	          }
	        }
	      } else { return skipPart(part) }

	      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase(); } else { encoding = '7bit'; }

	      let onData,
	        onEnd;

	      if (isPartAFile(fieldname, contype, filename)) {
	        // file/binary field
	        if (nfiles === filesLimit) {
	          if (!boy.hitFilesLimit) {
	            boy.hitFilesLimit = true;
	            boy.emit('filesLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfiles;

	        if (boy.listenerCount('file') === 0) {
	          self.parser._ignore();
	          return
	        }

	        ++nends;
	        const file = new FileStream(fileOpts);
	        curFile = file;
	        file.on('end', function () {
	          --nends;
	          self._pause = false;
	          checkFinished();
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        });
	        file._read = function (n) {
	          if (!self._pause) { return }
	          self._pause = false;
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        };
	        boy.emit('file', fieldname, file, filename, encoding, contype);

	        onData = function (data) {
	          if ((nsize += data.length) > fileSizeLimit) {
	            const extralen = fileSizeLimit - nsize + data.length;
	            if (extralen > 0) { file.push(data.slice(0, extralen)); }
	            file.truncated = true;
	            file.bytesRead = fileSizeLimit;
	            part.removeAllListeners('data');
	            file.emit('limit');
	            return
	          } else if (!file.push(data)) { self._pause = true; }

	          file.bytesRead = nsize;
	        };

	        onEnd = function () {
	          curFile = undefined;
	          file.push(null);
	        };
	      } else {
	        // non-file field
	        if (nfields === fieldsLimit) {
	          if (!boy.hitFieldsLimit) {
	            boy.hitFieldsLimit = true;
	            boy.emit('fieldsLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfields;
	        ++nends;
	        let buffer = '';
	        let truncated = false;
	        curField = part;

	        onData = function (data) {
	          if ((nsize += data.length) > fieldSizeLimit) {
	            const extralen = (fieldSizeLimit - (nsize - data.length));
	            buffer += data.toString('binary', 0, extralen);
	            truncated = true;
	            part.removeAllListeners('data');
	          } else { buffer += data.toString('binary'); }
	        };

	        onEnd = function () {
	          curField = undefined;
	          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset); }
	          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);
	          --nends;
	          checkFinished();
	        };
	      }

	      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
	         broken. Streams2/streams3 is a huge black box of confusion, but
	         somehow overriding the sync state seems to fix things again (and still
	         seems to work for previous node versions).
	      */
	      part._readableState.sync = false;

	      part.on('data', onData);
	      part.on('end', onEnd);
	    }).on('error', function (err) {
	      if (curFile) { curFile.emit('error', err); }
	    });
	  }).on('error', function (err) {
	    boy.emit('error', err);
	  }).on('finish', function () {
	    finished = true;
	    checkFinished();
	  });
	}

	Multipart.prototype.write = function (chunk, cb) {
	  const r = this.parser.write(chunk);
	  if (r && !this._pause) {
	    cb();
	  } else {
	    this._needDrain = !r;
	    this._cb = cb;
	  }
	};

	Multipart.prototype.end = function () {
	  const self = this;

	  if (self.parser.writable) {
	    self.parser.end();
	  } else if (!self._boy._done) {
	    process.nextTick(function () {
	      self._boy._done = true;
	      self._boy.emit('finish');
	    });
	  }
	};

	function skipPart (part) {
	  part.resume();
	}

	function FileStream (opts) {
	  Readable.call(this, opts);

	  this.bytesRead = 0;

	  this.truncated = false;
	}

	inherits(FileStream, Readable);

	FileStream.prototype._read = function (n) {};

	multipart = Multipart;
	return multipart;
}

var Decoder_1;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return Decoder_1;
	hasRequiredDecoder = 1;

	const RE_PLUS = /\+/g;

	const HEX = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	];

	function Decoder () {
	  this.buffer = undefined;
	}
	Decoder.prototype.write = function (str) {
	  // Replace '+' with ' ' before decoding
	  str = str.replace(RE_PLUS, ' ');
	  let res = '';
	  let i = 0; let p = 0; const len = str.length;
	  for (; i < len; ++i) {
	    if (this.buffer !== undefined) {
	      if (!HEX[str.charCodeAt(i)]) {
	        res += '%' + this.buffer;
	        this.buffer = undefined;
	        --i; // retry character
	      } else {
	        this.buffer += str[i];
	        ++p;
	        if (this.buffer.length === 2) {
	          res += String.fromCharCode(parseInt(this.buffer, 16));
	          this.buffer = undefined;
	        }
	      }
	    } else if (str[i] === '%') {
	      if (i > p) {
	        res += str.substring(p, i);
	        p = i;
	      }
	      this.buffer = '';
	      ++p;
	    }
	  }
	  if (p < len && this.buffer === undefined) { res += str.substring(p); }
	  return res
	};
	Decoder.prototype.reset = function () {
	  this.buffer = undefined;
	};

	Decoder_1 = Decoder;
	return Decoder_1;
}

var urlencoded;
var hasRequiredUrlencoded;

function requireUrlencoded () {
	if (hasRequiredUrlencoded) return urlencoded;
	hasRequiredUrlencoded = 1;

	const Decoder = requireDecoder();
	const decodeText = requireDecodeText();
	const getLimit = requireGetLimit();

	const RE_CHARSET = /^charset$/i;

	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded (boy, cfg) {
	  const limits = cfg.limits;
	  const parsedConType = cfg.parsedConType;
	  this.boy = boy;

	  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100);
	  this.fieldsLimit = getLimit(limits, 'fields', Infinity);

	  let charset;
	  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var
	    if (Array.isArray(parsedConType[i]) &&
	        RE_CHARSET.test(parsedConType[i][0])) {
	      charset = parsedConType[i][1].toLowerCase();
	      break
	    }
	  }

	  if (charset === undefined) { charset = cfg.defCharset || 'utf8'; }

	  this.decoder = new Decoder();
	  this.charset = charset;
	  this._fields = 0;
	  this._state = 'key';
	  this._checkingBytes = true;
	  this._bytesKey = 0;
	  this._bytesVal = 0;
	  this._key = '';
	  this._val = '';
	  this._keyTrunc = false;
	  this._valTrunc = false;
	  this._hitLimit = false;
	}

	UrlEncoded.prototype.write = function (data, cb) {
	  if (this._fields === this.fieldsLimit) {
	    if (!this.boy.hitFieldsLimit) {
	      this.boy.hitFieldsLimit = true;
	      this.boy.emit('fieldsLimit');
	    }
	    return cb()
	  }

	  let idxeq; let idxamp; let i; let p = 0; const len = data.length;

	  while (p < len) {
	    if (this._state === 'key') {
	      idxeq = idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x3D/* = */) {
	          idxeq = i;
	          break
	        } else if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesKey; }
	      }

	      if (idxeq !== undefined) {
	        // key with assignment
	        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)); }
	        this._state = 'val';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._val = '';
	        this._bytesVal = 0;
	        this._valTrunc = false;
	        this.decoder.reset();

	        p = idxeq + 1;
	      } else if (idxamp !== undefined) {
	        // key with no assignment
	        ++this._fields;
	        let key; const keyTrunc = this._keyTrunc;
	        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))); } else { key = this._key; }

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        if (key.length) {
	          this.boy.emit('field', decodeText(key, 'binary', this.charset),
	            '',
	            keyTrunc,
	            false);
	        }

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._keyTrunc = true;
	        }
	      } else {
	        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    } else {
	      idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesVal; }
	      }

	      if (idxamp !== undefined) {
	        ++this._fields;
	        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)); }
	        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	          decodeText(this._val, 'binary', this.charset),
	          this._keyTrunc,
	          this._valTrunc);
	        this._state = 'key';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._val === '' && this.fieldSizeLimit === 0) ||
	            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._valTrunc = true;
	        }
	      } else {
	        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    }
	  }
	  cb();
	};

	UrlEncoded.prototype.end = function () {
	  if (this.boy._done) { return }

	  if (this._state === 'key' && this._key.length > 0) {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      '',
	      this._keyTrunc,
	      false);
	  } else if (this._state === 'val') {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      decodeText(this._val, 'binary', this.charset),
	      this._keyTrunc,
	      this._valTrunc);
	  }
	  this.boy._done = true;
	  this.boy.emit('finish');
	};

	urlencoded = UrlEncoded;
	return urlencoded;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main.exports;
	hasRequiredMain = 1;

	const WritableStream = require$$0$7.Writable;
	const { inherits } = require$$1$4;
	const Dicer = requireDicer();

	const MultipartParser = requireMultipart();
	const UrlencodedParser = requireUrlencoded();
	const parseParams = requireParseParams();

	function Busboy (opts) {
	  if (!(this instanceof Busboy)) { return new Busboy(opts) }

	  if (typeof opts !== 'object') {
	    throw new TypeError('Busboy expected an options-Object.')
	  }
	  if (typeof opts.headers !== 'object') {
	    throw new TypeError('Busboy expected an options-Object with headers-attribute.')
	  }
	  if (typeof opts.headers['content-type'] !== 'string') {
	    throw new TypeError('Missing Content-Type-header.')
	  }

	  const {
	    headers,
	    ...streamOptions
	  } = opts;

	  this.opts = {
	    autoDestroy: false,
	    ...streamOptions
	  };
	  WritableStream.call(this, this.opts);

	  this._done = false;
	  this._parser = this.getParserByHeaders(headers);
	  this._finished = false;
	}
	inherits(Busboy, WritableStream);

	Busboy.prototype.emit = function (ev) {
	  if (ev === 'finish') {
	    if (!this._done) {
	      this._parser?.end();
	      return
	    } else if (this._finished) {
	      return
	    }
	    this._finished = true;
	  }
	  WritableStream.prototype.emit.apply(this, arguments);
	};

	Busboy.prototype.getParserByHeaders = function (headers) {
	  const parsed = parseParams(headers['content-type']);

	  const cfg = {
	    defCharset: this.opts.defCharset,
	    fileHwm: this.opts.fileHwm,
	    headers,
	    highWaterMark: this.opts.highWaterMark,
	    isPartAFile: this.opts.isPartAFile,
	    limits: this.opts.limits,
	    parsedConType: parsed,
	    preservePath: this.opts.preservePath
	  };

	  if (MultipartParser.detect.test(parsed[0])) {
	    return new MultipartParser(this, cfg)
	  }
	  if (UrlencodedParser.detect.test(parsed[0])) {
	    return new UrlencodedParser(this, cfg)
	  }
	  throw new Error('Unsupported Content-Type.')
	};

	Busboy.prototype._write = function (chunk, encoding, cb) {
	  this._parser.write(chunk, cb);
	};

	main.exports = Busboy;
	main.exports.default = Busboy;
	main.exports.Busboy = Busboy;

	main.exports.Dicer = Dicer;
	return main.exports;
}

var constants$3;
var hasRequiredConstants$3;

function requireConstants$3 () {
	if (hasRequiredConstants$3) return constants$3;
	hasRequiredConstants$3 = 1;

	const { MessageChannel, receiveMessageOnPort } = require$$0$8;

	const corsSafeListedMethods = ['GET', 'HEAD', 'POST'];
	const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);

	const nullBodyStatus = [101, 204, 205, 304];

	const redirectStatus = [301, 302, 303, 307, 308];
	const redirectStatusSet = new Set(redirectStatus);

	// https://fetch.spec.whatwg.org/#block-bad-port
	const badPorts = [
	  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',
	  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',
	  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',
	  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',
	  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',
	  '10080'
	];

	const badPortsSet = new Set(badPorts);

	// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies
	const referrerPolicy = [
	  '',
	  'no-referrer',
	  'no-referrer-when-downgrade',
	  'same-origin',
	  'origin',
	  'strict-origin',
	  'origin-when-cross-origin',
	  'strict-origin-when-cross-origin',
	  'unsafe-url'
	];
	const referrerPolicySet = new Set(referrerPolicy);

	const requestRedirect = ['follow', 'manual', 'error'];

	const safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE'];
	const safeMethodsSet = new Set(safeMethods);

	const requestMode = ['navigate', 'same-origin', 'no-cors', 'cors'];

	const requestCredentials = ['omit', 'same-origin', 'include'];

	const requestCache = [
	  'default',
	  'no-store',
	  'reload',
	  'no-cache',
	  'force-cache',
	  'only-if-cached'
	];

	// https://fetch.spec.whatwg.org/#request-body-header-name
	const requestBodyHeader = [
	  'content-encoding',
	  'content-language',
	  'content-location',
	  'content-type',
	  // See https://github.com/nodejs/undici/issues/2021
	  // 'Content-Length' is a forbidden header name, which is typically
	  // removed in the Headers implementation. However, undici doesn't
	  // filter out headers, so we add it here.
	  'content-length'
	];

	// https://fetch.spec.whatwg.org/#enumdef-requestduplex
	const requestDuplex = [
	  'half'
	];

	// http://fetch.spec.whatwg.org/#forbidden-method
	const forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK'];
	const forbiddenMethodsSet = new Set(forbiddenMethods);

	const subresource = [
	  'audio',
	  'audioworklet',
	  'font',
	  'image',
	  'manifest',
	  'paintworklet',
	  'script',
	  'style',
	  'track',
	  'video',
	  'xslt',
	  ''
	];
	const subresourceSet = new Set(subresource);

	/** @type {globalThis['DOMException']} */
	const DOMException = globalThis.DOMException ?? (() => {
	  // DOMException was only made a global in Node v17.0.0,
	  // but fetch supports >= v16.8.
	  try {
	    atob('~');
	  } catch (err) {
	    return Object.getPrototypeOf(err).constructor
	  }
	})();

	let channel;

	/** @type {globalThis['structuredClone']} */
	const structuredClone =
	  globalThis.structuredClone ??
	  // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
	  // structuredClone was added in v17.0.0, but fetch supports v16.8
	  function structuredClone (value, options = undefined) {
	    if (arguments.length === 0) {
	      throw new TypeError('missing argument')
	    }

	    if (!channel) {
	      channel = new MessageChannel();
	    }
	    channel.port1.unref();
	    channel.port2.unref();
	    channel.port1.postMessage(value, options?.transfer);
	    return receiveMessageOnPort(channel.port2).message
	  };

	constants$3 = {
	  DOMException,
	  structuredClone,
	  subresource,
	  forbiddenMethods,
	  requestBodyHeader,
	  referrerPolicy,
	  requestRedirect,
	  requestMode,
	  requestCredentials,
	  requestCache,
	  redirectStatus,
	  corsSafeListedMethods,
	  nullBodyStatus,
	  safeMethods,
	  badPorts,
	  requestDuplex,
	  subresourceSet,
	  badPortsSet,
	  redirectStatusSet,
	  corsSafeListedMethodsSet,
	  safeMethodsSet,
	  forbiddenMethodsSet,
	  referrerPolicySet
	};
	return constants$3;
}

var global$2;
var hasRequiredGlobal$1;

function requireGlobal$1 () {
	if (hasRequiredGlobal$1) return global$2;
	hasRequiredGlobal$1 = 1;

	// In case of breaking changes, increase the version
	// number to avoid conflicts.
	const globalOrigin = Symbol.for('undici.globalOrigin.1');

	function getGlobalOrigin () {
	  return globalThis[globalOrigin]
	}

	function setGlobalOrigin (newOrigin) {
	  if (newOrigin === undefined) {
	    Object.defineProperty(globalThis, globalOrigin, {
	      value: undefined,
	      writable: true,
	      enumerable: false,
	      configurable: false
	    });

	    return
	  }

	  const parsedURL = new URL(newOrigin);

	  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {
	    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)
	  }

	  Object.defineProperty(globalThis, globalOrigin, {
	    value: parsedURL,
	    writable: true,
	    enumerable: false,
	    configurable: false
	  });
	}

	global$2 = {
	  getGlobalOrigin,
	  setGlobalOrigin
	};
	return global$2;
}

var util$5;
var hasRequiredUtil$5;

function requireUtil$5 () {
	if (hasRequiredUtil$5) return util$5;
	hasRequiredUtil$5 = 1;

	const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = requireConstants$3();
	const { getGlobalOrigin } = requireGlobal$1();
	const { performance } = require$$2$2;
	const { isBlobLike, toUSVString, ReadableStreamFrom } = requireUtil$6();
	const assert = require$$0$2;
	const { isUint8Array } = require$$5;

	let supportedHashes = [];

	// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable
	/** @type {import('crypto')|undefined} */
	let crypto;

	try {
	  crypto = require('crypto');
	  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512'];
	  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	/* c8 ignore next 3 */
	} catch {
	}

	function responseURL (response) {
	  // https://fetch.spec.whatwg.org/#responses
	  // A response has an associated URL. It is a pointer to the last URL
	  // in responses URL list and null if responses URL list is empty.
	  const urlList = response.urlList;
	  const length = urlList.length;
	  return length === 0 ? null : urlList[length - 1].toString()
	}

	// https://fetch.spec.whatwg.org/#concept-response-location-url
	function responseLocationURL (response, requestFragment) {
	  // 1. If responses status is not a redirect status, then return null.
	  if (!redirectStatusSet.has(response.status)) {
	    return null
	  }

	  // 2. Let location be the result of extracting header list values given
	  // `Location` and responses header list.
	  let location = response.headersList.get('location');

	  // 3. If location is a header value, then set location to the result of
	  //    parsing location with responses URL.
	  if (location !== null && isValidHeaderValue(location)) {
	    location = new URL(location, responseURL(response));
	  }

	  // 4. If location is a URL whose fragment is null, then set locations
	  // fragment to requestFragment.
	  if (location && !location.hash) {
	    location.hash = requestFragment;
	  }

	  // 5. Return location.
	  return location
	}

	/** @returns {URL} */
	function requestCurrentURL (request) {
	  return request.urlList[request.urlList.length - 1]
	}

	function requestBadPort (request) {
	  // 1. Let url be requests current URL.
	  const url = requestCurrentURL(request);

	  // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,
	  // then return blocked.
	  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
	    return 'blocked'
	  }

	  // 3. Return allowed.
	  return 'allowed'
	}

	function isErrorLike (object) {
	  return object instanceof Error || (
	    object?.constructor?.name === 'Error' ||
	    object?.constructor?.name === 'DOMException'
	  )
	}

	// Check whether |statusText| is a ByteString and
	// matches the Reason-Phrase token production.
	// RFC 2616: https://tools.ietf.org/html/rfc2616
	// RFC 7230: https://tools.ietf.org/html/rfc7230
	// "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
	// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
	function isValidReasonPhrase (statusText) {
	  for (let i = 0; i < statusText.length; ++i) {
	    const c = statusText.charCodeAt(i);
	    if (
	      !(
	        (
	          c === 0x09 || // HTAB
	          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR
	          (c >= 0x80 && c <= 0xff)
	        ) // obs-text
	      )
	    ) {
	      return false
	    }
	  }
	  return true
	}

	/**
	 * @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	 * @param {number} c
	 */
	function isTokenCharCode (c) {
	  switch (c) {
	    case 0x22:
	    case 0x28:
	    case 0x29:
	    case 0x2c:
	    case 0x2f:
	    case 0x3a:
	    case 0x3b:
	    case 0x3c:
	    case 0x3d:
	    case 0x3e:
	    case 0x3f:
	    case 0x40:
	    case 0x5b:
	    case 0x5c:
	    case 0x5d:
	    case 0x7b:
	    case 0x7d:
	      // DQUOTE and "(),/:;<=>?@[\]{}"
	      return false
	    default:
	      // VCHAR %x21-7E
	      return c >= 0x21 && c <= 0x7e
	  }
	}

	/**
	 * @param {string} characters
	 */
	function isValidHTTPToken (characters) {
	  if (characters.length === 0) {
	    return false
	  }
	  for (let i = 0; i < characters.length; ++i) {
	    if (!isTokenCharCode(characters.charCodeAt(i))) {
	      return false
	    }
	  }
	  return true
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#header-name
	 * @param {string} potentialValue
	 */
	function isValidHeaderName (potentialValue) {
	  return isValidHTTPToken(potentialValue)
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#header-value
	 * @param {string} potentialValue
	 */
	function isValidHeaderValue (potentialValue) {
	  // - Has no leading or trailing HTTP tab or space bytes.
	  // - Contains no 0x00 (NUL) or HTTP newline bytes.
	  if (
	    potentialValue.startsWith('\t') ||
	    potentialValue.startsWith(' ') ||
	    potentialValue.endsWith('\t') ||
	    potentialValue.endsWith(' ')
	  ) {
	    return false
	  }

	  if (
	    potentialValue.includes('\0') ||
	    potentialValue.includes('\r') ||
	    potentialValue.includes('\n')
	  ) {
	    return false
	  }

	  return true
	}

	// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
	function setRequestReferrerPolicyOnRedirect (request, actualResponse) {
	  //  Given a request request and a response actualResponse, this algorithm
	  //  updates requests referrer policy according to the Referrer-Policy
	  //  header (if any) in actualResponse.

	  // 1. Let policy be the result of executing  8.1 Parse a referrer policy
	  // from a Referrer-Policy header on actualResponse.

	  // 8.1 Parse a referrer policy from a Referrer-Policy header
	  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.
	  const { headersList } = actualResponse;
	  // 2. Let policy be the empty string.
	  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.
	  // 4. Return policy.
	  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');

	  // Note: As the referrer-policy can contain multiple policies
	  // separated by comma, we need to loop through all of them
	  // and pick the first valid one.
	  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy
	  let policy = '';
	  if (policyHeader.length > 0) {
	    // The right-most policy takes precedence.
	    // The left-most policy is the fallback.
	    for (let i = policyHeader.length; i !== 0; i--) {
	      const token = policyHeader[i - 1].trim();
	      if (referrerPolicyTokens.has(token)) {
	        policy = token;
	        break
	      }
	    }
	  }

	  // 2. If policy is not the empty string, then set requests referrer policy to policy.
	  if (policy !== '') {
	    request.referrerPolicy = policy;
	  }
	}

	// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
	function crossOriginResourcePolicyCheck () {
	  // TODO
	  return 'allowed'
	}

	// https://fetch.spec.whatwg.org/#concept-cors-check
	function corsCheck () {
	  // TODO
	  return 'success'
	}

	// https://fetch.spec.whatwg.org/#concept-tao-check
	function TAOCheck () {
	  // TODO
	  return 'success'
	}

	function appendFetchMetadata (httpRequest) {
	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
	  //  TODO

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

	  //  1. Assert: rs url is a potentially trustworthy URL.
	  //  TODO

	  //  2. Let header be a Structured Header whose value is a token.
	  let header = null;

	  //  3. Set headers value to rs mode.
	  header = httpRequest.mode;

	  //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.
	  httpRequest.headersList.set('sec-fetch-mode', header);

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
	  //  TODO

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
	  //  TODO
	}

	// https://fetch.spec.whatwg.org/#append-a-request-origin-header
	function appendRequestOriginHeader (request) {
	  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
	  let serializedOrigin = request.origin;

	  // 2. If requests response tainting is "cors" or requests mode is "websocket", then append (`Origin`, serializedOrigin) to requests header list.
	  if (request.responseTainting === 'cors' || request.mode === 'websocket') {
	    if (serializedOrigin) {
	      request.headersList.append('origin', serializedOrigin);
	    }

	  // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:
	  } else if (request.method !== 'GET' && request.method !== 'HEAD') {
	    // 1. Switch on requests referrer policy:
	    switch (request.referrerPolicy) {
	      case 'no-referrer':
	        // Set serializedOrigin to `null`.
	        serializedOrigin = null;
	        break
	      case 'no-referrer-when-downgrade':
	      case 'strict-origin':
	      case 'strict-origin-when-cross-origin':
	        // If requests origin is a tuple origin, its scheme is "https", and requests current URLs scheme is not "https", then set serializedOrigin to `null`.
	        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
	          serializedOrigin = null;
	        }
	        break
	      case 'same-origin':
	        // If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.
	        if (!sameOrigin(request, requestCurrentURL(request))) {
	          serializedOrigin = null;
	        }
	        break
	        // Do nothing.
	    }

	    if (serializedOrigin) {
	      // 2. Append (`Origin`, serializedOrigin) to requests header list.
	      request.headersList.append('origin', serializedOrigin);
	    }
	  }
	}

	function coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {
	  // TODO
	  return performance.now()
	}

	// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
	function createOpaqueTimingInfo (timingInfo) {
	  return {
	    startTime: timingInfo.startTime ?? 0,
	    redirectStartTime: 0,
	    redirectEndTime: 0,
	    postRedirectStartTime: timingInfo.startTime ?? 0,
	    finalServiceWorkerStartTime: 0,
	    finalNetworkResponseStartTime: 0,
	    finalNetworkRequestStartTime: 0,
	    endTime: 0,
	    encodedBodySize: 0,
	    decodedBodySize: 0,
	    finalConnectionTimingInfo: null
	  }
	}

	// https://html.spec.whatwg.org/multipage/origin.html#policy-container
	function makePolicyContainer () {
	  // Note: the fetch spec doesn't make use of embedder policy or CSP list
	  return {
	    referrerPolicy: 'strict-origin-when-cross-origin'
	  }
	}

	// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
	function clonePolicyContainer (policyContainer) {
	  return {
	    referrerPolicy: policyContainer.referrerPolicy
	  }
	}

	// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
	function determineRequestsReferrer (request) {
	  // 1. Let policy be request's referrer policy.
	  const policy = request.referrerPolicy;

	  // Note: policy cannot (shouldn't) be null or an empty string.
	  assert(policy);

	  // 2. Let environment be requests client.

	  let referrerSource = null;

	  // 3. Switch on requests referrer:
	  if (request.referrer === 'client') {
	    // Note: node isn't a browser and doesn't implement document/iframes,
	    // so we bypass this step and replace it with our own.

	    const globalOrigin = getGlobalOrigin();

	    if (!globalOrigin || globalOrigin.origin === 'null') {
	      return 'no-referrer'
	    }

	    // note: we need to clone it as it's mutated
	    referrerSource = new URL(globalOrigin);
	  } else if (request.referrer instanceof URL) {
	    // Let referrerSource be requests referrer.
	    referrerSource = request.referrer;
	  }

	  // 4. Let requests referrerURL be the result of stripping referrerSource for
	  //    use as a referrer.
	  let referrerURL = stripURLForReferrer(referrerSource);

	  // 5. Let referrerOrigin be the result of stripping referrerSource for use as
	  //    a referrer, with the origin-only flag set to true.
	  const referrerOrigin = stripURLForReferrer(referrerSource, true);

	  // 6. If the result of serializing referrerURL is a string whose length is
	  //    greater than 4096, set referrerURL to referrerOrigin.
	  if (referrerURL.toString().length > 4096) {
	    referrerURL = referrerOrigin;
	  }

	  const areSameOrigin = sameOrigin(request, referrerURL);
	  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&
	    !isURLPotentiallyTrustworthy(request.url);

	  // 8. Execute the switch statements corresponding to the value of policy:
	  switch (policy) {
	    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)
	    case 'unsafe-url': return referrerURL
	    case 'same-origin':
	      return areSameOrigin ? referrerOrigin : 'no-referrer'
	    case 'origin-when-cross-origin':
	      return areSameOrigin ? referrerURL : referrerOrigin
	    case 'strict-origin-when-cross-origin': {
	      const currentURL = requestCurrentURL(request);

	      // 1. If the origin of referrerURL and the origin of requests current
	      //    URL are the same, then return referrerURL.
	      if (sameOrigin(referrerURL, currentURL)) {
	        return referrerURL
	      }

	      // 2. If referrerURL is a potentially trustworthy URL and requests
	      //    current URL is not a potentially trustworthy URL, then return no
	      //    referrer.
	      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
	        return 'no-referrer'
	      }

	      // 3. Return referrerOrigin.
	      return referrerOrigin
	    }
	    case 'strict-origin': // eslint-disable-line
	      /**
	         * 1. If referrerURL is a potentially trustworthy URL and
	         * requests current URL is not a potentially trustworthy URL,
	         * then return no referrer.
	         * 2. Return referrerOrigin
	        */
	    case 'no-referrer-when-downgrade': // eslint-disable-line
	      /**
	       * 1. If referrerURL is a potentially trustworthy URL and
	       * requests current URL is not a potentially trustworthy URL,
	       * then return no referrer.
	       * 2. Return referrerOrigin
	      */

	    default: // eslint-disable-line
	      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin
	  }
	}

	/**
	 * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	 * @param {URL} url
	 * @param {boolean|undefined} originOnly
	 */
	function stripURLForReferrer (url, originOnly) {
	  // 1. Assert: url is a URL.
	  assert(url instanceof URL);

	  // 2. If urls scheme is a local scheme, then return no referrer.
	  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {
	    return 'no-referrer'
	  }

	  // 3. Set urls username to the empty string.
	  url.username = '';

	  // 4. Set urls password to the empty string.
	  url.password = '';

	  // 5. Set urls fragment to null.
	  url.hash = '';

	  // 6. If the origin-only flag is true, then:
	  if (originOnly) {
	    // 1. Set urls path to  the empty string .
	    url.pathname = '';

	    // 2. Set urls query to null.
	    url.search = '';
	  }

	  // 7. Return url.
	  return url
	}

	function isURLPotentiallyTrustworthy (url) {
	  if (!(url instanceof URL)) {
	    return false
	  }

	  // If child of about, return true
	  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {
	    return true
	  }

	  // If scheme is data, return true
	  if (url.protocol === 'data:') return true

	  // If file, return true
	  if (url.protocol === 'file:') return true

	  return isOriginPotentiallyTrustworthy(url.origin)

	  function isOriginPotentiallyTrustworthy (origin) {
	    // If origin is explicitly null, return false
	    if (origin == null || origin === 'null') return false

	    const originAsURL = new URL(origin);

	    // If secure, return true
	    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {
	      return true
	    }

	    // If localhost or variants, return true
	    if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) ||
	     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||
	     (originAsURL.hostname.endsWith('.localhost'))) {
	      return true
	    }

	    // If any other, return false
	    return false
	  }
	}

	/**
	 * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	 * @param {Uint8Array} bytes
	 * @param {string} metadataList
	 */
	function bytesMatch (bytes, metadataList) {
	  // If node is not built with OpenSSL support, we cannot check
	  // a request's integrity, so allow it by default (the spec will
	  // allow requests if an invalid hash is given, as precedence).
	  /* istanbul ignore if: only if node is built with --without-ssl */
	  if (crypto === undefined) {
	    return true
	  }

	  // 1. Let parsedMetadata be the result of parsing metadataList.
	  const parsedMetadata = parseMetadata(metadataList);

	  // 2. If parsedMetadata is no metadata, return true.
	  if (parsedMetadata === 'no metadata') {
	    return true
	  }

	  // 3. If response is not eligible for integrity validation, return false.
	  // TODO

	  // 4. If parsedMetadata is the empty set, return true.
	  if (parsedMetadata.length === 0) {
	    return true
	  }

	  // 5. Let metadata be the result of getting the strongest
	  //    metadata from parsedMetadata.
	  const strongest = getStrongestMetadata(parsedMetadata);
	  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);

	  // 6. For each item in metadata:
	  for (const item of metadata) {
	    // 1. Let algorithm be the alg component of item.
	    const algorithm = item.algo;

	    // 2. Let expectedValue be the val component of item.
	    const expectedValue = item.hash;

	    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e
	    // "be liberal with padding". This is annoying, and it's not even in the spec.

	    // 3. Let actualValue be the result of applying algorithm to bytes.
	    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');

	    if (actualValue[actualValue.length - 1] === '=') {
	      if (actualValue[actualValue.length - 2] === '=') {
	        actualValue = actualValue.slice(0, -2);
	      } else {
	        actualValue = actualValue.slice(0, -1);
	      }
	    }

	    // 4. If actualValue is a case-sensitive match for expectedValue,
	    //    return true.
	    if (compareBase64Mixed(actualValue, expectedValue)) {
	      return true
	    }
	  }

	  // 7. Return false.
	  return false
	}

	// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options
	// https://www.w3.org/TR/CSP2/#source-list-syntax
	// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;

	/**
	 * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	 * @param {string} metadata
	 */
	function parseMetadata (metadata) {
	  // 1. Let result be the empty set.
	  /** @type {{ algo: string, hash: string }[]} */
	  const result = [];

	  // 2. Let empty be equal to true.
	  let empty = true;

	  // 3. For each token returned by splitting metadata on spaces:
	  for (const token of metadata.split(' ')) {
	    // 1. Set empty to false.
	    empty = false;

	    // 2. Parse token as a hash-with-options.
	    const parsedToken = parseHashWithOptions.exec(token);

	    // 3. If token does not parse, continue to the next token.
	    if (
	      parsedToken === null ||
	      parsedToken.groups === undefined ||
	      parsedToken.groups.algo === undefined
	    ) {
	      // Note: Chromium blocks the request at this point, but Firefox
	      // gives a warning that an invalid integrity was given. The
	      // correct behavior is to ignore these, and subsequently not
	      // check the integrity of the resource.
	      continue
	    }

	    // 4. Let algorithm be the hash-algo component of token.
	    const algorithm = parsedToken.groups.algo.toLowerCase();

	    // 5. If algorithm is a hash function recognized by the user
	    //    agent, add the parsed token to result.
	    if (supportedHashes.includes(algorithm)) {
	      result.push(parsedToken.groups);
	    }
	  }

	  // 4. Return no metadata if empty is true, otherwise return result.
	  if (empty === true) {
	    return 'no metadata'
	  }

	  return result
	}

	/**
	 * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	 */
	function getStrongestMetadata (metadataList) {
	  // Let algorithm be the algo component of the first item in metadataList.
	  // Can be sha256
	  let algorithm = metadataList[0].algo;
	  // If the algorithm is sha512, then it is the strongest
	  // and we can return immediately
	  if (algorithm[3] === '5') {
	    return algorithm
	  }

	  for (let i = 1; i < metadataList.length; ++i) {
	    const metadata = metadataList[i];
	    // If the algorithm is sha512, then it is the strongest
	    // and we can break the loop immediately
	    if (metadata.algo[3] === '5') {
	      algorithm = 'sha512';
	      break
	    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored
	    } else if (algorithm[3] === '3') {
	      continue
	    // algorithm is sha256, check if algorithm is sha384 and if so, set it as
	    // the strongest
	    } else if (metadata.algo[3] === '3') {
	      algorithm = 'sha384';
	    }
	  }
	  return algorithm
	}

	function filterMetadataListByAlgorithm (metadataList, algorithm) {
	  if (metadataList.length === 1) {
	    return metadataList
	  }

	  let pos = 0;
	  for (let i = 0; i < metadataList.length; ++i) {
	    if (metadataList[i].algo === algorithm) {
	      metadataList[pos++] = metadataList[i];
	    }
	  }

	  metadataList.length = pos;

	  return metadataList
	}

	/**
	 * Compares two base64 strings, allowing for base64url
	 * in the second string.
	 *
	* @param {string} actualValue always base64
	 * @param {string} expectedValue base64 or base64url
	 * @returns {boolean}
	 */
	function compareBase64Mixed (actualValue, expectedValue) {
	  if (actualValue.length !== expectedValue.length) {
	    return false
	  }
	  for (let i = 0; i < actualValue.length; ++i) {
	    if (actualValue[i] !== expectedValue[i]) {
	      if (
	        (actualValue[i] === '+' && expectedValue[i] === '-') ||
	        (actualValue[i] === '/' && expectedValue[i] === '_')
	      ) {
	        continue
	      }
	      return false
	    }
	  }

	  return true
	}

	// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
	function tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {
	  // TODO
	}

	/**
	 * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	 * @param {URL} A
	 * @param {URL} B
	 */
	function sameOrigin (A, B) {
	  // 1. If A and B are the same opaque origin, then return true.
	  if (A.origin === B.origin && A.origin === 'null') {
	    return true
	  }

	  // 2. If A and B are both tuple origins and their schemes,
	  //    hosts, and port are identical, then return true.
	  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
	    return true
	  }

	  // 3. Return false.
	  return false
	}

	function createDeferredPromise () {
	  let res;
	  let rej;
	  const promise = new Promise((resolve, reject) => {
	    res = resolve;
	    rej = reject;
	  });

	  return { promise, resolve: res, reject: rej }
	}

	function isAborted (fetchParams) {
	  return fetchParams.controller.state === 'aborted'
	}

	function isCancelled (fetchParams) {
	  return fetchParams.controller.state === 'aborted' ||
	    fetchParams.controller.state === 'terminated'
	}

	const normalizeMethodRecord = {
	  delete: 'DELETE',
	  DELETE: 'DELETE',
	  get: 'GET',
	  GET: 'GET',
	  head: 'HEAD',
	  HEAD: 'HEAD',
	  options: 'OPTIONS',
	  OPTIONS: 'OPTIONS',
	  post: 'POST',
	  POST: 'POST',
	  put: 'PUT',
	  PUT: 'PUT'
	};

	// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
	Object.setPrototypeOf(normalizeMethodRecord, null);

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-method-normalize
	 * @param {string} method
	 */
	function normalizeMethod (method) {
	  return normalizeMethodRecord[method.toLowerCase()] ?? method
	}

	// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
	function serializeJavascriptValueToJSONString (value) {
	  // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).
	  const result = JSON.stringify(value);

	  // 2. If result is undefined, then throw a TypeError.
	  if (result === undefined) {
	    throw new TypeError('Value is not JSON serializable')
	  }

	  // 3. Assert: result is a string.
	  assert(typeof result === 'string');

	  // 4. Return result.
	  return result
	}

	// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));

	/**
	 * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	 * @param {() => unknown[]} iterator
	 * @param {string} name name of the instance
	 * @param {'key'|'value'|'key+value'} kind
	 */
	function makeIterator (iterator, name, kind) {
	  const object = {
	    index: 0,
	    kind,
	    target: iterator
	  };

	  const i = {
	    next () {
	      // 1. Let interface be the interface for which the iterator prototype object exists.

	      // 2. Let thisValue be the this value.

	      // 3. Let object be ? ToObject(thisValue).

	      // 4. If object is a platform object, then perform a security
	      //    check, passing:

	      // 5. If object is not a default iterator object for interface,
	      //    then throw a TypeError.
	      if (Object.getPrototypeOf(this) !== i) {
	        throw new TypeError(
	          `'next' called on an object that does not implement interface ${name} Iterator.`
	        )
	      }

	      // 6. Let index be objects index.
	      // 7. Let kind be objects kind.
	      // 8. Let values be objects target's value pairs to iterate over.
	      const { index, kind, target } = object;
	      const values = target();

	      // 9. Let len be the length of values.
	      const len = values.length;

	      // 10. If index is greater than or equal to len, then return
	      //     CreateIterResultObject(undefined, true).
	      if (index >= len) {
	        return { value: undefined, done: true }
	      }

	      // 11. Let pair be the entry in values at index index.
	      const pair = values[index];

	      // 12. Set objects index to index + 1.
	      object.index = index + 1;

	      // 13. Return the iterator result for pair and kind.
	      return iteratorResult(pair, kind)
	    },
	    // The class string of an iterator prototype object for a given interface is the
	    // result of concatenating the identifier of the interface and the string " Iterator".
	    [Symbol.toStringTag]: `${name} Iterator`
	  };

	  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
	  Object.setPrototypeOf(i, esIteratorPrototype);
	  // esIteratorPrototype needs to be the prototype of i
	  // which is the prototype of an empty object. Yes, it's confusing.
	  return Object.setPrototypeOf({}, i)
	}

	// https://webidl.spec.whatwg.org/#iterator-result
	function iteratorResult (pair, kind) {
	  let result;

	  // 1. Let result be a value determined by the value of kind:
	  switch (kind) {
	    case 'key': {
	      // 1. Let idlKey be pairs key.
	      // 2. Let key be the result of converting idlKey to an
	      //    ECMAScript value.
	      // 3. result is key.
	      result = pair[0];
	      break
	    }
	    case 'value': {
	      // 1. Let idlValue be pairs value.
	      // 2. Let value be the result of converting idlValue to
	      //    an ECMAScript value.
	      // 3. result is value.
	      result = pair[1];
	      break
	    }
	    case 'key+value': {
	      // 1. Let idlKey be pairs key.
	      // 2. Let idlValue be pairs value.
	      // 3. Let key be the result of converting idlKey to an
	      //    ECMAScript value.
	      // 4. Let value be the result of converting idlValue to
	      //    an ECMAScript value.
	      // 5. Let array be ! ArrayCreate(2).
	      // 6. Call ! CreateDataProperty(array, "0", key).
	      // 7. Call ! CreateDataProperty(array, "1", value).
	      // 8. result is array.
	      result = pair;
	      break
	    }
	  }

	  // 2. Return CreateIterResultObject(result, false).
	  return { value: result, done: false }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#body-fully-read
	 */
	async function fullyReadBody (body, processBody, processBodyError) {
	  // 1. If taskDestination is null, then set taskDestination to
	  //    the result of starting a new parallel queue.

	  // 2. Let successSteps given a byte sequence bytes be to queue a
	  //    fetch task to run processBody given bytes, with taskDestination.
	  const successSteps = processBody;

	  // 3. Let errorSteps be to queue a fetch task to run processBodyError,
	  //    with taskDestination.
	  const errorSteps = processBodyError;

	  // 4. Let reader be the result of getting a reader for bodys stream.
	  //    If that threw an exception, then run errorSteps with that
	  //    exception and return.
	  let reader;

	  try {
	    reader = body.stream.getReader();
	  } catch (e) {
	    errorSteps(e);
	    return
	  }

	  // 5. Read all bytes from reader, given successSteps and errorSteps.
	  try {
	    const result = await readAllBytes(reader);
	    successSteps(result);
	  } catch (e) {
	    errorSteps(e);
	  }
	}

	/** @type {ReadableStream} */
	let ReadableStream = globalThis.ReadableStream;

	function isReadableStreamLike (stream) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  return stream instanceof ReadableStream || (
	    stream[Symbol.toStringTag] === 'ReadableStream' &&
	    typeof stream.tee === 'function'
	  )
	}

	const MAXIMUM_ARGUMENT_LENGTH = 65535;

	/**
	 * @see https://infra.spec.whatwg.org/#isomorphic-decode
	 * @param {number[]|Uint8Array} input
	 */
	function isomorphicDecode (input) {
	  // 1. To isomorphic decode a byte sequence input, return a string whose code point
	  //    length is equal to inputs length and whose code points have the same values
	  //    as the values of inputs bytes, in the same order.

	  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
	    return String.fromCharCode(...input)
	  }

	  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')
	}

	/**
	 * @param {ReadableStreamController<Uint8Array>} controller
	 */
	function readableStreamClose (controller) {
	  try {
	    controller.close();
	  } catch (err) {
	    // TODO: add comment explaining why this error occurs.
	    if (!err.message.includes('Controller is already closed')) {
	      throw err
	    }
	  }
	}

	/**
	 * @see https://infra.spec.whatwg.org/#isomorphic-encode
	 * @param {string} input
	 */
	function isomorphicEncode (input) {
	  // 1. Assert: input contains no code points greater than U+00FF.
	  for (let i = 0; i < input.length; i++) {
	    assert(input.charCodeAt(i) <= 0xFF);
	  }

	  // 2. Return a byte sequence whose length is equal to inputs code
	  //    point length and whose bytes have the same values as the
	  //    values of inputs code points, in the same order
	  return input
	}

	/**
	 * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	 * @see https://streams.spec.whatwg.org/#read-loop
	 * @param {ReadableStreamDefaultReader} reader
	 */
	async function readAllBytes (reader) {
	  const bytes = [];
	  let byteLength = 0;

	  while (true) {
	    const { done, value: chunk } = await reader.read();

	    if (done) {
	      // 1. Call successSteps with bytes.
	      return Buffer.concat(bytes, byteLength)
	    }

	    // 1. If chunk is not a Uint8Array object, call failureSteps
	    //    with a TypeError and abort these steps.
	    if (!isUint8Array(chunk)) {
	      throw new TypeError('Received non-Uint8Array chunk')
	    }

	    // 2. Append the bytes represented by chunk to bytes.
	    bytes.push(chunk);
	    byteLength += chunk.length;

	    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.
	  }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#is-local
	 * @param {URL} url
	 */
	function urlIsLocal (url) {
	  assert('protocol' in url); // ensure it's a url object

	  const protocol = url.protocol;

	  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'
	}

	/**
	 * @param {string|URL} url
	 */
	function urlHasHttpsScheme (url) {
	  if (typeof url === 'string') {
	    return url.startsWith('https:')
	  }

	  return url.protocol === 'https:'
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-scheme
	 * @param {URL} url
	 */
	function urlIsHttpHttpsScheme (url) {
	  assert('protocol' in url); // ensure it's a url object

	  const protocol = url.protocol;

	  return protocol === 'http:' || protocol === 'https:'
	}

	/**
	 * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	 */
	const hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));

	util$5 = {
	  isAborted,
	  isCancelled,
	  createDeferredPromise,
	  ReadableStreamFrom,
	  toUSVString,
	  tryUpgradeRequestToAPotentiallyTrustworthyURL,
	  coarsenedSharedCurrentTime,
	  determineRequestsReferrer,
	  makePolicyContainer,
	  clonePolicyContainer,
	  appendFetchMetadata,
	  appendRequestOriginHeader,
	  TAOCheck,
	  corsCheck,
	  crossOriginResourcePolicyCheck,
	  createOpaqueTimingInfo,
	  setRequestReferrerPolicyOnRedirect,
	  isValidHTTPToken,
	  requestBadPort,
	  requestCurrentURL,
	  responseURL,
	  responseLocationURL,
	  isBlobLike,
	  isURLPotentiallyTrustworthy,
	  isValidReasonPhrase,
	  sameOrigin,
	  normalizeMethod,
	  serializeJavascriptValueToJSONString,
	  makeIterator,
	  isValidHeaderName,
	  isValidHeaderValue,
	  hasOwn,
	  isErrorLike,
	  fullyReadBody,
	  bytesMatch,
	  isReadableStreamLike,
	  readableStreamClose,
	  isomorphicEncode,
	  isomorphicDecode,
	  urlIsLocal,
	  urlHasHttpsScheme,
	  urlIsHttpHttpsScheme,
	  readAllBytes,
	  normalizeMethodRecord,
	  parseMetadata
	};
	return util$5;
}

var symbols$3;
var hasRequiredSymbols$3;

function requireSymbols$3 () {
	if (hasRequiredSymbols$3) return symbols$3;
	hasRequiredSymbols$3 = 1;

	symbols$3 = {
	  kUrl: Symbol('url'),
	  kHeaders: Symbol('headers'),
	  kSignal: Symbol('signal'),
	  kState: Symbol('state'),
	  kGuard: Symbol('guard'),
	  kRealm: Symbol('realm')
	};
	return symbols$3;
}

var webidl_1;
var hasRequiredWebidl;

function requireWebidl () {
	if (hasRequiredWebidl) return webidl_1;
	hasRequiredWebidl = 1;

	const { types } = require$$0$1;
	const { hasOwn, toUSVString } = requireUtil$5();

	/** @type {import('../../types/webidl').Webidl} */
	const webidl = {};
	webidl.converters = {};
	webidl.util = {};
	webidl.errors = {};

	webidl.errors.exception = function (message) {
	  return new TypeError(`${message.header}: ${message.message}`)
	};

	webidl.errors.conversionFailed = function (context) {
	  const plural = context.types.length === 1 ? '' : ' one of';
	  const message =
	    `${context.argument} could not be converted to` +
	    `${plural}: ${context.types.join(', ')}.`;

	  return webidl.errors.exception({
	    header: context.prefix,
	    message
	  })
	};

	webidl.errors.invalidArgument = function (context) {
	  return webidl.errors.exception({
	    header: context.prefix,
	    message: `"${context.value}" is an invalid ${context.type}.`
	  })
	};

	// https://webidl.spec.whatwg.org/#implements
	webidl.brandCheck = function (V, I, opts = undefined) {
	  if (opts?.strict !== false && !(V instanceof I)) {
	    throw new TypeError('Illegal invocation')
	  } else {
	    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]
	  }
	};

	webidl.argumentLengthCheck = function ({ length }, min, ctx) {
	  if (length < min) {
	    throw webidl.errors.exception({
	      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +
	               `but${length ? ' only' : ''} ${length} found.`,
	      ...ctx
	    })
	  }
	};

	webidl.illegalConstructor = function () {
	  throw webidl.errors.exception({
	    header: 'TypeError',
	    message: 'Illegal constructor'
	  })
	};

	// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
	webidl.util.Type = function (V) {
	  switch (typeof V) {
	    case 'undefined': return 'Undefined'
	    case 'boolean': return 'Boolean'
	    case 'string': return 'String'
	    case 'symbol': return 'Symbol'
	    case 'number': return 'Number'
	    case 'bigint': return 'BigInt'
	    case 'function':
	    case 'object': {
	      if (V === null) {
	        return 'Null'
	      }

	      return 'Object'
	    }
	  }
	};

	// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
	webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
	  let upperBound;
	  let lowerBound;

	  // 1. If bitLength is 64, then:
	  if (bitLength === 64) {
	    // 1. Let upperBound be 2^53  1.
	    upperBound = Math.pow(2, 53) - 1;

	    // 2. If signedness is "unsigned", then let lowerBound be 0.
	    if (signedness === 'unsigned') {
	      lowerBound = 0;
	    } else {
	      // 3. Otherwise let lowerBound be 2^53 + 1.
	      lowerBound = Math.pow(-2, 53) + 1;
	    }
	  } else if (signedness === 'unsigned') {
	    // 2. Otherwise, if signedness is "unsigned", then:

	    // 1. Let lowerBound be 0.
	    lowerBound = 0;

	    // 2. Let upperBound be 2^bitLength  1.
	    upperBound = Math.pow(2, bitLength) - 1;
	  } else {
	    // 3. Otherwise:

	    // 1. Let lowerBound be -2^bitLength  1.
	    lowerBound = Math.pow(-2, bitLength) - 1;

	    // 2. Let upperBound be 2^bitLength  1  1.
	    upperBound = Math.pow(2, bitLength - 1) - 1;
	  }

	  // 4. Let x be ? ToNumber(V).
	  let x = Number(V);

	  // 5. If x is 0, then set x to +0.
	  if (x === 0) {
	    x = 0;
	  }

	  // 6. If the conversion is to an IDL type associated
	  //    with the [EnforceRange] extended attribute, then:
	  if (opts.enforceRange === true) {
	    // 1. If x is NaN, +, or , then throw a TypeError.
	    if (
	      Number.isNaN(x) ||
	      x === Number.POSITIVE_INFINITY ||
	      x === Number.NEGATIVE_INFINITY
	    ) {
	      throw webidl.errors.exception({
	        header: 'Integer conversion',
	        message: `Could not convert ${V} to an integer.`
	      })
	    }

	    // 2. Set x to IntegerPart(x).
	    x = webidl.util.IntegerPart(x);

	    // 3. If x < lowerBound or x > upperBound, then
	    //    throw a TypeError.
	    if (x < lowerBound || x > upperBound) {
	      throw webidl.errors.exception({
	        header: 'Integer conversion',
	        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
	      })
	    }

	    // 4. Return x.
	    return x
	  }

	  // 7. If x is not NaN and the conversion is to an IDL
	  //    type associated with the [Clamp] extended
	  //    attribute, then:
	  if (!Number.isNaN(x) && opts.clamp === true) {
	    // 1. Set x to min(max(x, lowerBound), upperBound).
	    x = Math.min(Math.max(x, lowerBound), upperBound);

	    // 2. Round x to the nearest integer, choosing the
	    //    even integer if it lies halfway between two,
	    //    and choosing +0 rather than 0.
	    if (Math.floor(x) % 2 === 0) {
	      x = Math.floor(x);
	    } else {
	      x = Math.ceil(x);
	    }

	    // 3. Return x.
	    return x
	  }

	  // 8. If x is NaN, +0, +, or , then return +0.
	  if (
	    Number.isNaN(x) ||
	    (x === 0 && Object.is(0, x)) ||
	    x === Number.POSITIVE_INFINITY ||
	    x === Number.NEGATIVE_INFINITY
	  ) {
	    return 0
	  }

	  // 9. Set x to IntegerPart(x).
	  x = webidl.util.IntegerPart(x);

	  // 10. Set x to x modulo 2^bitLength.
	  x = x % Math.pow(2, bitLength);

	  // 11. If signedness is "signed" and x  2^bitLength  1,
	  //    then return x  2^bitLength.
	  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
	    return x - Math.pow(2, bitLength)
	  }

	  // 12. Otherwise, return x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
	webidl.util.IntegerPart = function (n) {
	  // 1. Let r be floor(abs(n)).
	  const r = Math.floor(Math.abs(n));

	  // 2. If n < 0, then return -1  r.
	  if (n < 0) {
	    return -1 * r
	  }

	  // 3. Otherwise, return r.
	  return r
	};

	// https://webidl.spec.whatwg.org/#es-sequence
	webidl.sequenceConverter = function (converter) {
	  return (V) => {
	    // 1. If Type(V) is not Object, throw a TypeError.
	    if (webidl.util.Type(V) !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Sequence',
	        message: `Value of type ${webidl.util.Type(V)} is not an Object.`
	      })
	    }

	    // 2. Let method be ? GetMethod(V, @@iterator).
	    /** @type {Generator} */
	    const method = V?.[Symbol.iterator]?.();
	    const seq = [];

	    // 3. If method is undefined, throw a TypeError.
	    if (
	      method === undefined ||
	      typeof method.next !== 'function'
	    ) {
	      throw webidl.errors.exception({
	        header: 'Sequence',
	        message: 'Object is not an iterator.'
	      })
	    }

	    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable
	    while (true) {
	      const { done, value } = method.next();

	      if (done) {
	        break
	      }

	      seq.push(converter(value));
	    }

	    return seq
	  }
	};

	// https://webidl.spec.whatwg.org/#es-to-record
	webidl.recordConverter = function (keyConverter, valueConverter) {
	  return (O) => {
	    // 1. If Type(O) is not Object, throw a TypeError.
	    if (webidl.util.Type(O) !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Record',
	        message: `Value of type ${webidl.util.Type(O)} is not an Object.`
	      })
	    }

	    // 2. Let result be a new empty instance of record<K, V>.
	    const result = {};

	    if (!types.isProxy(O)) {
	      // Object.keys only returns enumerable properties
	      const keys = Object.keys(O);

	      for (const key of keys) {
	        // 1. Let typedKey be key converted to an IDL value of type K.
	        const typedKey = keyConverter(key);

	        // 2. Let value be ? Get(O, key).
	        // 3. Let typedValue be value converted to an IDL value of type V.
	        const typedValue = valueConverter(O[key]);

	        // 4. Set result[typedKey] to typedValue.
	        result[typedKey] = typedValue;
	      }

	      // 5. Return result.
	      return result
	    }

	    // 3. Let keys be ? O.[[OwnPropertyKeys]]().
	    const keys = Reflect.ownKeys(O);

	    // 4. For each key of keys.
	    for (const key of keys) {
	      // 1. Let desc be ? O.[[GetOwnProperty]](key).
	      const desc = Reflect.getOwnPropertyDescriptor(O, key);

	      // 2. If desc is not undefined and desc.[[Enumerable]] is true:
	      if (desc?.enumerable) {
	        // 1. Let typedKey be key converted to an IDL value of type K.
	        const typedKey = keyConverter(key);

	        // 2. Let value be ? Get(O, key).
	        // 3. Let typedValue be value converted to an IDL value of type V.
	        const typedValue = valueConverter(O[key]);

	        // 4. Set result[typedKey] to typedValue.
	        result[typedKey] = typedValue;
	      }
	    }

	    // 5. Return result.
	    return result
	  }
	};

	webidl.interfaceConverter = function (i) {
	  return (V, opts = {}) => {
	    if (opts.strict !== false && !(V instanceof i)) {
	      throw webidl.errors.exception({
	        header: i.name,
	        message: `Expected ${V} to be an instance of ${i.name}.`
	      })
	    }

	    return V
	  }
	};

	webidl.dictionaryConverter = function (converters) {
	  return (dictionary) => {
	    const type = webidl.util.Type(dictionary);
	    const dict = {};

	    if (type === 'Null' || type === 'Undefined') {
	      return dict
	    } else if (type !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Dictionary',
	        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
	      })
	    }

	    for (const options of converters) {
	      const { key, defaultValue, required, converter } = options;

	      if (required === true) {
	        if (!hasOwn(dictionary, key)) {
	          throw webidl.errors.exception({
	            header: 'Dictionary',
	            message: `Missing required key "${key}".`
	          })
	        }
	      }

	      let value = dictionary[key];
	      const hasDefault = hasOwn(options, 'defaultValue');

	      // Only use defaultValue if value is undefined and
	      // a defaultValue options was provided.
	      if (hasDefault && value !== null) {
	        value = value ?? defaultValue;
	      }

	      // A key can be optional and have no default value.
	      // When this happens, do not perform a conversion,
	      // and do not assign the key a value.
	      if (required || hasDefault || value !== undefined) {
	        value = converter(value);

	        if (
	          options.allowedValues &&
	          !options.allowedValues.includes(value)
	        ) {
	          throw webidl.errors.exception({
	            header: 'Dictionary',
	            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
	          })
	        }

	        dict[key] = value;
	      }
	    }

	    return dict
	  }
	};

	webidl.nullableConverter = function (converter) {
	  return (V) => {
	    if (V === null) {
	      return V
	    }

	    return converter(V)
	  }
	};

	// https://webidl.spec.whatwg.org/#es-DOMString
	webidl.converters.DOMString = function (V, opts = {}) {
	  // 1. If V is null and the conversion is to an IDL type
	  //    associated with the [LegacyNullToEmptyString]
	  //    extended attribute, then return the DOMString value
	  //    that represents the empty string.
	  if (V === null && opts.legacyNullToEmptyString) {
	    return ''
	  }

	  // 2. Let x be ? ToString(V).
	  if (typeof V === 'symbol') {
	    throw new TypeError('Could not convert argument of type symbol to string.')
	  }

	  // 3. Return the IDL DOMString value that represents the
	  //    same sequence of code units as the one the
	  //    ECMAScript String value x represents.
	  return String(V)
	};

	// https://webidl.spec.whatwg.org/#es-ByteString
	webidl.converters.ByteString = function (V) {
	  // 1. Let x be ? ToString(V).
	  // Note: DOMString converter perform ? ToString(V)
	  const x = webidl.converters.DOMString(V);

	  // 2. If the value of any element of x is greater than
	  //    255, then throw a TypeError.
	  for (let index = 0; index < x.length; index++) {
	    if (x.charCodeAt(index) > 255) {
	      throw new TypeError(
	        'Cannot convert argument to a ByteString because the character at ' +
	        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
	      )
	    }
	  }

	  // 3. Return an IDL ByteString value whose length is the
	  //    length of x, and where the value of each element is
	  //    the value of the corresponding element of x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-USVString
	webidl.converters.USVString = toUSVString;

	// https://webidl.spec.whatwg.org/#es-boolean
	webidl.converters.boolean = function (V) {
	  // 1. Let x be the result of computing ToBoolean(V).
	  const x = Boolean(V);

	  // 2. Return the IDL boolean value that is the one that represents
	  //    the same truth value as the ECMAScript Boolean value x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-any
	webidl.converters.any = function (V) {
	  return V
	};

	// https://webidl.spec.whatwg.org/#es-long-long
	webidl.converters['long long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 64, "signed").
	  const x = webidl.util.ConvertToInt(V, 64, 'signed');

	  // 2. Return the IDL long long value that represents
	  //    the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-long-long
	webidl.converters['unsigned long long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 64, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 64, 'unsigned');

	  // 2. Return the IDL unsigned long long value that
	  //    represents the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-long
	webidl.converters['unsigned long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 32, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 32, 'unsigned');

	  // 2. Return the IDL unsigned long value that
	  //    represents the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-short
	webidl.converters['unsigned short'] = function (V, opts) {
	  // 1. Let x be ? ConvertToInt(V, 16, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts);

	  // 2. Return the IDL unsigned short value that represents
	  //    the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#idl-ArrayBuffer
	webidl.converters.ArrayBuffer = function (V, opts = {}) {
	  // 1. If Type(V) is not Object, or V does not have an
	  //    [[ArrayBufferData]] internal slot, then throw a
	  //    TypeError.
	  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
	  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
	  if (
	    webidl.util.Type(V) !== 'Object' ||
	    !types.isAnyArrayBuffer(V)
	  ) {
	    throw webidl.errors.conversionFailed({
	      prefix: `${V}`,
	      argument: `${V}`,
	      types: ['ArrayBuffer']
	    })
	  }

	  // 2. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V) is true, then throw a
	  //    TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V) is true, then throw a
	  //    TypeError.
	  // Note: resizable ArrayBuffers are currently a proposal.

	  // 4. Return the IDL ArrayBuffer value that is a
	  //    reference to the same object as V.
	  return V
	};

	webidl.converters.TypedArray = function (V, T, opts = {}) {
	  // 1. Let T be the IDL type V is being converted to.

	  // 2. If Type(V) is not Object, or V does not have a
	  //    [[TypedArrayName]] internal slot with a value
	  //    equal to Ts name, then throw a TypeError.
	  if (
	    webidl.util.Type(V) !== 'Object' ||
	    !types.isTypedArray(V) ||
	    V.constructor.name !== T.name
	  ) {
	    throw webidl.errors.conversionFailed({
	      prefix: `${T.name}`,
	      argument: `${V}`,
	      types: [T.name]
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 4. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  // Note: resizable array buffers are currently a proposal

	  // 5. Return the IDL value of type T that is a reference
	  //    to the same object as V.
	  return V
	};

	webidl.converters.DataView = function (V, opts = {}) {
	  // 1. If Type(V) is not Object, or V does not have a
	  //    [[DataView]] internal slot, then throw a TypeError.
	  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
	    throw webidl.errors.exception({
	      header: 'DataView',
	      message: 'Object is not a DataView.'
	    })
	  }

	  // 2. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
	  //    then throw a TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  // Note: resizable ArrayBuffers are currently a proposal

	  // 4. Return the IDL DataView value that is a reference
	  //    to the same object as V.
	  return V
	};

	// https://webidl.spec.whatwg.org/#BufferSource
	webidl.converters.BufferSource = function (V, opts = {}) {
	  if (types.isAnyArrayBuffer(V)) {
	    return webidl.converters.ArrayBuffer(V, opts)
	  }

	  if (types.isTypedArray(V)) {
	    return webidl.converters.TypedArray(V, V.constructor)
	  }

	  if (types.isDataView(V)) {
	    return webidl.converters.DataView(V, opts)
	  }

	  throw new TypeError(`Could not convert ${V} to a BufferSource.`)
	};

	webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(
	  webidl.converters.ByteString
	);

	webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(
	  webidl.converters['sequence<ByteString>']
	);

	webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(
	  webidl.converters.ByteString,
	  webidl.converters.ByteString
	);

	webidl_1 = {
	  webidl
	};
	return webidl_1;
}

var dataURL;
var hasRequiredDataURL;

function requireDataURL () {
	if (hasRequiredDataURL) return dataURL;
	hasRequiredDataURL = 1;
	const assert = require$$0$2;
	const { atob } = require$$7;
	const { isomorphicDecode } = requireUtil$5();

	const encoder = new TextEncoder();

	/**
	 * @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	 */
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/; // eslint-disable-line
	/**
	 * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	 */
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/; // eslint-disable-line

	// https://fetch.spec.whatwg.org/#data-url-processor
	/** @param {URL} dataURL */
	function dataURLProcessor (dataURL) {
	  // 1. Assert: dataURLs scheme is "data".
	  assert(dataURL.protocol === 'data:');

	  // 2. Let input be the result of running the URL
	  // serializer on dataURL with exclude fragment
	  // set to true.
	  let input = URLSerializer(dataURL, true);

	  // 3. Remove the leading "data:" string from input.
	  input = input.slice(5);

	  // 4. Let position point at the start of input.
	  const position = { position: 0 };

	  // 5. Let mimeType be the result of collecting a
	  // sequence of code points that are not equal
	  // to U+002C (,), given position.
	  let mimeType = collectASequenceOfCodePointsFast(
	    ',',
	    input,
	    position
	  );

	  // 6. Strip leading and trailing ASCII whitespace
	  // from mimeType.
	  // Undici implementation note: we need to store the
	  // length because if the mimetype has spaces removed,
	  // the wrong amount will be sliced from the input in
	  // step #9
	  const mimeTypeLength = mimeType.length;
	  mimeType = removeASCIIWhitespace(mimeType, true, true);

	  // 7. If position is past the end of input, then
	  // return failure
	  if (position.position >= input.length) {
	    return 'failure'
	  }

	  // 8. Advance position by 1.
	  position.position++;

	  // 9. Let encodedBody be the remainder of input.
	  const encodedBody = input.slice(mimeTypeLength + 1);

	  // 10. Let body be the percent-decoding of encodedBody.
	  let body = stringPercentDecode(encodedBody);

	  // 11. If mimeType ends with U+003B (;), followed by
	  // zero or more U+0020 SPACE, followed by an ASCII
	  // case-insensitive match for "base64", then:
	  if (/;(\u0020){0,}base64$/i.test(mimeType)) {
	    // 1. Let stringBody be the isomorphic decode of body.
	    const stringBody = isomorphicDecode(body);

	    // 2. Set body to the forgiving-base64 decode of
	    // stringBody.
	    body = forgivingBase64(stringBody);

	    // 3. If body is failure, then return failure.
	    if (body === 'failure') {
	      return 'failure'
	    }

	    // 4. Remove the last 6 code points from mimeType.
	    mimeType = mimeType.slice(0, -6);

	    // 5. Remove trailing U+0020 SPACE code points from mimeType,
	    // if any.
	    mimeType = mimeType.replace(/(\u0020)+$/, '');

	    // 6. Remove the last U+003B (;) code point from mimeType.
	    mimeType = mimeType.slice(0, -1);
	  }

	  // 12. If mimeType starts with U+003B (;), then prepend
	  // "text/plain" to mimeType.
	  if (mimeType.startsWith(';')) {
	    mimeType = 'text/plain' + mimeType;
	  }

	  // 13. Let mimeTypeRecord be the result of parsing
	  // mimeType.
	  let mimeTypeRecord = parseMIMEType(mimeType);

	  // 14. If mimeTypeRecord is failure, then set
	  // mimeTypeRecord to text/plain;charset=US-ASCII.
	  if (mimeTypeRecord === 'failure') {
	    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
	  }

	  // 15. Return a new data: URL struct whose MIME
	  // type is mimeTypeRecord and body is body.
	  // https://fetch.spec.whatwg.org/#data-url-struct
	  return { mimeType: mimeTypeRecord, body }
	}

	// https://url.spec.whatwg.org/#concept-url-serializer
	/**
	 * @param {URL} url
	 * @param {boolean} excludeFragment
	 */
	function URLSerializer (url, excludeFragment = false) {
	  if (!excludeFragment) {
	    return url.href
	  }

	  const href = url.href;
	  const hashLength = url.hash.length;

	  return hashLength === 0 ? href : href.substring(0, href.length - hashLength)
	}

	// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
	/**
	 * @param {(char: string) => boolean} condition
	 * @param {string} input
	 * @param {{ position: number }} position
	 */
	function collectASequenceOfCodePoints (condition, input, position) {
	  // 1. Let result be the empty string.
	  let result = '';

	  // 2. While position doesnt point past the end of input and the
	  // code point at position within input meets the condition condition:
	  while (position.position < input.length && condition(input[position.position])) {
	    // 1. Append that code point to the end of result.
	    result += input[position.position];

	    // 2. Advance position by 1.
	    position.position++;
	  }

	  // 3. Return result.
	  return result
	}

	/**
	 * A faster collectASequenceOfCodePoints that only works when comparing a single character.
	 * @param {string} char
	 * @param {string} input
	 * @param {{ position: number }} position
	 */
	function collectASequenceOfCodePointsFast (char, input, position) {
	  const idx = input.indexOf(char, position.position);
	  const start = position.position;

	  if (idx === -1) {
	    position.position = input.length;
	    return input.slice(start)
	  }

	  position.position = idx;
	  return input.slice(start, position.position)
	}

	// https://url.spec.whatwg.org/#string-percent-decode
	/** @param {string} input */
	function stringPercentDecode (input) {
	  // 1. Let bytes be the UTF-8 encoding of input.
	  const bytes = encoder.encode(input);

	  // 2. Return the percent-decoding of bytes.
	  return percentDecode(bytes)
	}

	// https://url.spec.whatwg.org/#percent-decode
	/** @param {Uint8Array} input */
	function percentDecode (input) {
	  // 1. Let output be an empty byte sequence.
	  /** @type {number[]} */
	  const output = [];

	  // 2. For each byte byte in input:
	  for (let i = 0; i < input.length; i++) {
	    const byte = input[i];

	    // 1. If byte is not 0x25 (%), then append byte to output.
	    if (byte !== 0x25) {
	      output.push(byte);

	    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes
	    // after byte in input are not in the ranges
	    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
	    // and 0x61 (a) to 0x66 (f), all inclusive, append byte
	    // to output.
	    } else if (
	      byte === 0x25 &&
	      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))
	    ) {
	      output.push(0x25);

	    // 3. Otherwise:
	    } else {
	      // 1. Let bytePoint be the two bytes after byte in input,
	      // decoded, and then interpreted as hexadecimal number.
	      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
	      const bytePoint = Number.parseInt(nextTwoBytes, 16);

	      // 2. Append a byte whose value is bytePoint to output.
	      output.push(bytePoint);

	      // 3. Skip the next two bytes in input.
	      i += 2;
	    }
	  }

	  // 3. Return output.
	  return Uint8Array.from(output)
	}

	// https://mimesniff.spec.whatwg.org/#parse-a-mime-type
	/** @param {string} input */
	function parseMIMEType (input) {
	  // 1. Remove any leading and trailing HTTP whitespace
	  // from input.
	  input = removeHTTPWhitespace(input, true, true);

	  // 2. Let position be a position variable for input,
	  // initially pointing at the start of input.
	  const position = { position: 0 };

	  // 3. Let type be the result of collecting a sequence
	  // of code points that are not U+002F (/) from
	  // input, given position.
	  const type = collectASequenceOfCodePointsFast(
	    '/',
	    input,
	    position
	  );

	  // 4. If type is the empty string or does not solely
	  // contain HTTP token code points, then return failure.
	  // https://mimesniff.spec.whatwg.org/#http-token-code-point
	  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
	    return 'failure'
	  }

	  // 5. If position is past the end of input, then return
	  // failure
	  if (position.position > input.length) {
	    return 'failure'
	  }

	  // 6. Advance position by 1. (This skips past U+002F (/).)
	  position.position++;

	  // 7. Let subtype be the result of collecting a sequence of
	  // code points that are not U+003B (;) from input, given
	  // position.
	  let subtype = collectASequenceOfCodePointsFast(
	    ';',
	    input,
	    position
	  );

	  // 8. Remove any trailing HTTP whitespace from subtype.
	  subtype = removeHTTPWhitespace(subtype, false, true);

	  // 9. If subtype is the empty string or does not solely
	  // contain HTTP token code points, then return failure.
	  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
	    return 'failure'
	  }

	  const typeLowercase = type.toLowerCase();
	  const subtypeLowercase = subtype.toLowerCase();

	  // 10. Let mimeType be a new MIME type record whose type
	  // is type, in ASCII lowercase, and subtype is subtype,
	  // in ASCII lowercase.
	  // https://mimesniff.spec.whatwg.org/#mime-type
	  const mimeType = {
	    type: typeLowercase,
	    subtype: subtypeLowercase,
	    /** @type {Map<string, string>} */
	    parameters: new Map(),
	    // https://mimesniff.spec.whatwg.org/#mime-type-essence
	    essence: `${typeLowercase}/${subtypeLowercase}`
	  };

	  // 11. While position is not past the end of input:
	  while (position.position < input.length) {
	    // 1. Advance position by 1. (This skips past U+003B (;).)
	    position.position++;

	    // 2. Collect a sequence of code points that are HTTP
	    // whitespace from input given position.
	    collectASequenceOfCodePoints(
	      // https://fetch.spec.whatwg.org/#http-whitespace
	      char => HTTP_WHITESPACE_REGEX.test(char),
	      input,
	      position
	    );

	    // 3. Let parameterName be the result of collecting a
	    // sequence of code points that are not U+003B (;)
	    // or U+003D (=) from input, given position.
	    let parameterName = collectASequenceOfCodePoints(
	      (char) => char !== ';' && char !== '=',
	      input,
	      position
	    );

	    // 4. Set parameterName to parameterName, in ASCII
	    // lowercase.
	    parameterName = parameterName.toLowerCase();

	    // 5. If position is not past the end of input, then:
	    if (position.position < input.length) {
	      // 1. If the code point at position within input is
	      // U+003B (;), then continue.
	      if (input[position.position] === ';') {
	        continue
	      }

	      // 2. Advance position by 1. (This skips past U+003D (=).)
	      position.position++;
	    }

	    // 6. If position is past the end of input, then break.
	    if (position.position > input.length) {
	      break
	    }

	    // 7. Let parameterValue be null.
	    let parameterValue = null;

	    // 8. If the code point at position within input is
	    // U+0022 ("), then:
	    if (input[position.position] === '"') {
	      // 1. Set parameterValue to the result of collecting
	      // an HTTP quoted string from input, given position
	      // and the extract-value flag.
	      parameterValue = collectAnHTTPQuotedString(input, position, true);

	      // 2. Collect a sequence of code points that are not
	      // U+003B (;) from input, given position.
	      collectASequenceOfCodePointsFast(
	        ';',
	        input,
	        position
	      );

	    // 9. Otherwise:
	    } else {
	      // 1. Set parameterValue to the result of collecting
	      // a sequence of code points that are not U+003B (;)
	      // from input, given position.
	      parameterValue = collectASequenceOfCodePointsFast(
	        ';',
	        input,
	        position
	      );

	      // 2. Remove any trailing HTTP whitespace from parameterValue.
	      parameterValue = removeHTTPWhitespace(parameterValue, false, true);

	      // 3. If parameterValue is the empty string, then continue.
	      if (parameterValue.length === 0) {
	        continue
	      }
	    }

	    // 10. If all of the following are true
	    // - parameterName is not the empty string
	    // - parameterName solely contains HTTP token code points
	    // - parameterValue solely contains HTTP quoted-string token code points
	    // - mimeTypes parameters[parameterName] does not exist
	    // then set mimeTypes parameters[parameterName] to parameterValue.
	    if (
	      parameterName.length !== 0 &&
	      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
	      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
	      !mimeType.parameters.has(parameterName)
	    ) {
	      mimeType.parameters.set(parameterName, parameterValue);
	    }
	  }

	  // 12. Return mimeType.
	  return mimeType
	}

	// https://infra.spec.whatwg.org/#forgiving-base64-decode
	/** @param {string} data */
	function forgivingBase64 (data) {
	  // 1. Remove all ASCII whitespace from data.
	  data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '');  // eslint-disable-line

	  // 2. If datas code point length divides by 4 leaving
	  // no remainder, then:
	  if (data.length % 4 === 0) {
	    // 1. If data ends with one or two U+003D (=) code points,
	    // then remove them from data.
	    data = data.replace(/=?=$/, '');
	  }

	  // 3. If datas code point length divides by 4 leaving
	  // a remainder of 1, then return failure.
	  if (data.length % 4 === 1) {
	    return 'failure'
	  }

	  // 4. If data contains a code point that is not one of
	  //  U+002B (+)
	  //  U+002F (/)
	  //  ASCII alphanumeric
	  // then return failure.
	  if (/[^+/0-9A-Za-z]/.test(data)) {
	    return 'failure'
	  }

	  const binary = atob(data);
	  const bytes = new Uint8Array(binary.length);

	  for (let byte = 0; byte < binary.length; byte++) {
	    bytes[byte] = binary.charCodeAt(byte);
	  }

	  return bytes
	}

	// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
	// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
	/**
	 * @param {string} input
	 * @param {{ position: number }} position
	 * @param {boolean?} extractValue
	 */
	function collectAnHTTPQuotedString (input, position, extractValue) {
	  // 1. Let positionStart be position.
	  const positionStart = position.position;

	  // 2. Let value be the empty string.
	  let value = '';

	  // 3. Assert: the code point at position within input
	  // is U+0022 (").
	  assert(input[position.position] === '"');

	  // 4. Advance position by 1.
	  position.position++;

	  // 5. While true:
	  while (true) {
	    // 1. Append the result of collecting a sequence of code points
	    // that are not U+0022 (") or U+005C (\) from input, given
	    // position, to value.
	    value += collectASequenceOfCodePoints(
	      (char) => char !== '"' && char !== '\\',
	      input,
	      position
	    );

	    // 2. If position is past the end of input, then break.
	    if (position.position >= input.length) {
	      break
	    }

	    // 3. Let quoteOrBackslash be the code point at position within
	    // input.
	    const quoteOrBackslash = input[position.position];

	    // 4. Advance position by 1.
	    position.position++;

	    // 5. If quoteOrBackslash is U+005C (\), then:
	    if (quoteOrBackslash === '\\') {
	      // 1. If position is past the end of input, then append
	      // U+005C (\) to value and break.
	      if (position.position >= input.length) {
	        value += '\\';
	        break
	      }

	      // 2. Append the code point at position within input to value.
	      value += input[position.position];

	      // 3. Advance position by 1.
	      position.position++;

	    // 6. Otherwise:
	    } else {
	      // 1. Assert: quoteOrBackslash is U+0022 (").
	      assert(quoteOrBackslash === '"');

	      // 2. Break.
	      break
	    }
	  }

	  // 6. If the extract-value flag is set, then return value.
	  if (extractValue) {
	    return value
	  }

	  // 7. Return the code points from positionStart to position,
	  // inclusive, within input.
	  return input.slice(positionStart, position.position)
	}

	/**
	 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	 */
	function serializeAMimeType (mimeType) {
	  assert(mimeType !== 'failure');
	  const { parameters, essence } = mimeType;

	  // 1. Let serialization be the concatenation of mimeTypes
	  //    type, U+002F (/), and mimeTypes subtype.
	  let serialization = essence;

	  // 2. For each name  value of mimeTypes parameters:
	  for (let [name, value] of parameters.entries()) {
	    // 1. Append U+003B (;) to serialization.
	    serialization += ';';

	    // 2. Append name to serialization.
	    serialization += name;

	    // 3. Append U+003D (=) to serialization.
	    serialization += '=';

	    // 4. If value does not solely contain HTTP token code
	    //    points or value is the empty string, then:
	    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
	      // 1. Precede each occurence of U+0022 (") or
	      //    U+005C (\) in value with U+005C (\).
	      value = value.replace(/(\\|")/g, '\\$1');

	      // 2. Prepend U+0022 (") to value.
	      value = '"' + value;

	      // 3. Append U+0022 (") to value.
	      value += '"';
	    }

	    // 5. Append value to serialization.
	    serialization += value;
	  }

	  // 3. Return serialization.
	  return serialization
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-whitespace
	 * @param {string} char
	 */
	function isHTTPWhiteSpace (char) {
	  return char === '\r' || char === '\n' || char === '\t' || char === ' '
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-whitespace
	 * @param {string} str
	 */
	function removeHTTPWhitespace (str, leading = true, trailing = true) {
	  let lead = 0;
	  let trail = str.length - 1;

	  if (leading) {
	    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
	  }

	  if (trailing) {
	    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
	  }

	  return str.slice(lead, trail + 1)
	}

	/**
	 * @see https://infra.spec.whatwg.org/#ascii-whitespace
	 * @param {string} char
	 */
	function isASCIIWhitespace (char) {
	  return char === '\r' || char === '\n' || char === '\t' || char === '\f' || char === ' '
	}

	/**
	 * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	 */
	function removeASCIIWhitespace (str, leading = true, trailing = true) {
	  let lead = 0;
	  let trail = str.length - 1;

	  if (leading) {
	    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
	  }

	  if (trailing) {
	    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
	  }

	  return str.slice(lead, trail + 1)
	}

	dataURL = {
	  dataURLProcessor,
	  URLSerializer,
	  collectASequenceOfCodePoints,
	  collectASequenceOfCodePointsFast,
	  stringPercentDecode,
	  parseMIMEType,
	  collectAnHTTPQuotedString,
	  serializeAMimeType
	};
	return dataURL;
}

var file;
var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;

	const { Blob, File: NativeFile } = require$$7;
	const { types } = require$$0$1;
	const { kState } = requireSymbols$3();
	const { isBlobLike } = requireUtil$5();
	const { webidl } = requireWebidl();
	const { parseMIMEType, serializeAMimeType } = requireDataURL();
	const { kEnumerableProperty } = requireUtil$6();
	const encoder = new TextEncoder();

	class File extends Blob {
	  constructor (fileBits, fileName, options = {}) {
	    // The File constructor is invoked with two or three parameters, depending
	    // on whether the optional dictionary parameter is used. When the File()
	    // constructor is invoked, user agents must run the following steps:
	    webidl.argumentLengthCheck(arguments, 2, { header: 'File constructor' });

	    fileBits = webidl.converters['sequence<BlobPart>'](fileBits);
	    fileName = webidl.converters.USVString(fileName);
	    options = webidl.converters.FilePropertyBag(options);

	    // 1. Let bytes be the result of processing blob parts given fileBits and
	    // options.
	    // Note: Blob handles this for us

	    // 2. Let n be the fileName argument to the constructor.
	    const n = fileName;

	    // 3. Process FilePropertyBag dictionary argument by running the following
	    // substeps:

	    //    1. If the type member is provided and is not the empty string, let t
	    //    be set to the type dictionary member. If t contains any characters
	    //    outside the range U+0020 to U+007E, then set t to the empty string
	    //    and return from these substeps.
	    //    2. Convert every character in t to ASCII lowercase.
	    let t = options.type;
	    let d;

	    // eslint-disable-next-line no-labels
	    substep: {
	      if (t) {
	        t = parseMIMEType(t);

	        if (t === 'failure') {
	          t = '';
	          // eslint-disable-next-line no-labels
	          break substep
	        }

	        t = serializeAMimeType(t).toLowerCase();
	      }

	      //    3. If the lastModified member is provided, let d be set to the
	      //    lastModified dictionary member. If it is not provided, set d to the
	      //    current date and time represented as the number of milliseconds since
	      //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
	      d = options.lastModified;
	    }

	    // 4. Return a new File object F such that:
	    // F refers to the bytes byte sequence.
	    // F.size is set to the number of total bytes in bytes.
	    // F.name is set to n.
	    // F.type is set to t.
	    // F.lastModified is set to d.

	    super(processBlobParts(fileBits, options), { type: t });
	    this[kState] = {
	      name: n,
	      lastModified: d,
	      type: t
	    };
	  }

	  get name () {
	    webidl.brandCheck(this, File);

	    return this[kState].name
	  }

	  get lastModified () {
	    webidl.brandCheck(this, File);

	    return this[kState].lastModified
	  }

	  get type () {
	    webidl.brandCheck(this, File);

	    return this[kState].type
	  }
	}

	class FileLike {
	  constructor (blobLike, fileName, options = {}) {
	    // TODO: argument idl type check

	    // The File constructor is invoked with two or three parameters, depending
	    // on whether the optional dictionary parameter is used. When the File()
	    // constructor is invoked, user agents must run the following steps:

	    // 1. Let bytes be the result of processing blob parts given fileBits and
	    // options.

	    // 2. Let n be the fileName argument to the constructor.
	    const n = fileName;

	    // 3. Process FilePropertyBag dictionary argument by running the following
	    // substeps:

	    //    1. If the type member is provided and is not the empty string, let t
	    //    be set to the type dictionary member. If t contains any characters
	    //    outside the range U+0020 to U+007E, then set t to the empty string
	    //    and return from these substeps.
	    //    TODO
	    const t = options.type;

	    //    2. Convert every character in t to ASCII lowercase.
	    //    TODO

	    //    3. If the lastModified member is provided, let d be set to the
	    //    lastModified dictionary member. If it is not provided, set d to the
	    //    current date and time represented as the number of milliseconds since
	    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
	    const d = options.lastModified ?? Date.now();

	    // 4. Return a new File object F such that:
	    // F refers to the bytes byte sequence.
	    // F.size is set to the number of total bytes in bytes.
	    // F.name is set to n.
	    // F.type is set to t.
	    // F.lastModified is set to d.

	    this[kState] = {
	      blobLike,
	      name: n,
	      type: t,
	      lastModified: d
	    };
	  }

	  stream (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.stream(...args)
	  }

	  arrayBuffer (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.arrayBuffer(...args)
	  }

	  slice (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.slice(...args)
	  }

	  text (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.text(...args)
	  }

	  get size () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.size
	  }

	  get type () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.type
	  }

	  get name () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].name
	  }

	  get lastModified () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].lastModified
	  }

	  get [Symbol.toStringTag] () {
	    return 'File'
	  }
	}

	Object.defineProperties(File.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'File',
	    configurable: true
	  },
	  name: kEnumerableProperty,
	  lastModified: kEnumerableProperty
	});

	webidl.converters.Blob = webidl.interfaceConverter(Blob);

	webidl.converters.BlobPart = function (V, opts) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (isBlobLike(V)) {
	      return webidl.converters.Blob(V, { strict: false })
	    }

	    if (
	      ArrayBuffer.isView(V) ||
	      types.isAnyArrayBuffer(V)
	    ) {
	      return webidl.converters.BufferSource(V, opts)
	    }
	  }

	  return webidl.converters.USVString(V, opts)
	};

	webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(
	  webidl.converters.BlobPart
	);

	// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
	webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
	  {
	    key: 'lastModified',
	    converter: webidl.converters['long long'],
	    get defaultValue () {
	      return Date.now()
	    }
	  },
	  {
	    key: 'type',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'endings',
	    converter: (value) => {
	      value = webidl.converters.DOMString(value);
	      value = value.toLowerCase();

	      if (value !== 'native') {
	        value = 'transparent';
	      }

	      return value
	    },
	    defaultValue: 'transparent'
	  }
	]);

	/**
	 * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	 * @param {(NodeJS.TypedArray|Blob|string)[]} parts
	 * @param {{ type: string, endings: string }} options
	 */
	function processBlobParts (parts, options) {
	  // 1. Let bytes be an empty sequence of bytes.
	  /** @type {NodeJS.TypedArray[]} */
	  const bytes = [];

	  // 2. For each element in parts:
	  for (const element of parts) {
	    // 1. If element is a USVString, run the following substeps:
	    if (typeof element === 'string') {
	      // 1. Let s be element.
	      let s = element;

	      // 2. If the endings member of options is "native", set s
	      //    to the result of converting line endings to native
	      //    of element.
	      if (options.endings === 'native') {
	        s = convertLineEndingsNative(s);
	      }

	      // 3. Append the result of UTF-8 encoding s to bytes.
	      bytes.push(encoder.encode(s));
	    } else if (
	      types.isAnyArrayBuffer(element) ||
	      types.isTypedArray(element)
	    ) {
	      // 2. If element is a BufferSource, get a copy of the
	      //    bytes held by the buffer source, and append those
	      //    bytes to bytes.
	      if (!element.buffer) { // ArrayBuffer
	        bytes.push(new Uint8Array(element));
	      } else {
	        bytes.push(
	          new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
	        );
	      }
	    } else if (isBlobLike(element)) {
	      // 3. If element is a Blob, append the bytes it represents
	      //    to bytes.
	      bytes.push(element);
	    }
	  }

	  // 3. Return bytes.
	  return bytes
	}

	/**
	 * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	 * @param {string} s
	 */
	function convertLineEndingsNative (s) {
	  // 1. Let native line ending be be the code point U+000A LF.
	  let nativeLineEnding = '\n';

	  // 2. If the underlying platforms conventions are to
	  //    represent newlines as a carriage return and line feed
	  //    sequence, set native line ending to the code point
	  //    U+000D CR followed by the code point U+000A LF.
	  if (process.platform === 'win32') {
	    nativeLineEnding = '\r\n';
	  }

	  return s.replace(/\r?\n/g, nativeLineEnding)
	}

	// If this function is moved to ./util.js, some tools (such as
	// rollup) will warn about circular dependencies. See:
	// https://github.com/nodejs/undici/issues/1629
	function isFileLike (object) {
	  return (
	    (NativeFile && object instanceof NativeFile) ||
	    object instanceof File || (
	      object &&
	      (typeof object.stream === 'function' ||
	      typeof object.arrayBuffer === 'function') &&
	      object[Symbol.toStringTag] === 'File'
	    )
	  )
	}

	file = { File, FileLike, isFileLike };
	return file;
}

var formdata;
var hasRequiredFormdata;

function requireFormdata () {
	if (hasRequiredFormdata) return formdata;
	hasRequiredFormdata = 1;

	const { isBlobLike, toUSVString, makeIterator } = requireUtil$5();
	const { kState } = requireSymbols$3();
	const { File: UndiciFile, FileLike, isFileLike } = requireFile();
	const { webidl } = requireWebidl();
	const { Blob, File: NativeFile } = require$$7;

	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;

	// https://xhr.spec.whatwg.org/#formdata
	class FormData {
	  constructor (form) {
	    if (form !== undefined) {
	      throw webidl.errors.conversionFailed({
	        prefix: 'FormData constructor',
	        argument: 'Argument 1',
	        types: ['undefined']
	      })
	    }

	    this[kState] = [];
	  }

	  append (name, value, filename = undefined) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' });

	    if (arguments.length === 3 && !isBlobLike(value)) {
	      throw new TypeError(
	        "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
	      )
	    }

	    // 1. Let value be value if given; otherwise blobValue.

	    name = webidl.converters.USVString(name);
	    value = isBlobLike(value)
	      ? webidl.converters.Blob(value, { strict: false })
	      : webidl.converters.USVString(value);
	    filename = arguments.length === 3
	      ? webidl.converters.USVString(filename)
	      : undefined;

	    // 2. Let entry be the result of creating an entry with
	    // name, value, and filename if given.
	    const entry = makeEntry(name, value, filename);

	    // 3. Append entry to thiss entry list.
	    this[kState].push(entry);
	  }

	  delete (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' });

	    name = webidl.converters.USVString(name);

	    // The delete(name) method steps are to remove all entries whose name
	    // is name from thiss entry list.
	    this[kState] = this[kState].filter(entry => entry.name !== name);
	  }

	  get (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' });

	    name = webidl.converters.USVString(name);

	    // 1. If there is no entry whose name is name in thiss entry list,
	    // then return null.
	    const idx = this[kState].findIndex((entry) => entry.name === name);
	    if (idx === -1) {
	      return null
	    }

	    // 2. Return the value of the first entry whose name is name from
	    // thiss entry list.
	    return this[kState][idx].value
	  }

	  getAll (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' });

	    name = webidl.converters.USVString(name);

	    // 1. If there is no entry whose name is name in thiss entry list,
	    // then return the empty list.
	    // 2. Return the values of all entries whose name is name, in order,
	    // from thiss entry list.
	    return this[kState]
	      .filter((entry) => entry.name === name)
	      .map((entry) => entry.value)
	  }

	  has (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' });

	    name = webidl.converters.USVString(name);

	    // The has(name) method steps are to return true if there is an entry
	    // whose name is name in thiss entry list; otherwise false.
	    return this[kState].findIndex((entry) => entry.name === name) !== -1
	  }

	  set (name, value, filename = undefined) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' });

	    if (arguments.length === 3 && !isBlobLike(value)) {
	      throw new TypeError(
	        "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
	      )
	    }

	    // The set(name, value) and set(name, blobValue, filename) method steps
	    // are:

	    // 1. Let value be value if given; otherwise blobValue.

	    name = webidl.converters.USVString(name);
	    value = isBlobLike(value)
	      ? webidl.converters.Blob(value, { strict: false })
	      : webidl.converters.USVString(value);
	    filename = arguments.length === 3
	      ? toUSVString(filename)
	      : undefined;

	    // 2. Let entry be the result of creating an entry with name, value, and
	    // filename if given.
	    const entry = makeEntry(name, value, filename);

	    // 3. If there are entries in thiss entry list whose name is name, then
	    // replace the first such entry with entry and remove the others.
	    const idx = this[kState].findIndex((entry) => entry.name === name);
	    if (idx !== -1) {
	      this[kState] = [
	        ...this[kState].slice(0, idx),
	        entry,
	        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)
	      ];
	    } else {
	      // 4. Otherwise, append entry to thiss entry list.
	      this[kState].push(entry);
	    }
	  }

	  entries () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'key+value'
	    )
	  }

	  keys () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'key'
	    )
	  }

	  values () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'value'
	    )
	  }

	  /**
	   * @param {(value: string, key: string, self: FormData) => void} callbackFn
	   * @param {unknown} thisArg
	   */
	  forEach (callbackFn, thisArg = globalThis) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.forEach' });

	    if (typeof callbackFn !== 'function') {
	      throw new TypeError(
	        "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
	      )
	    }

	    for (const [key, value] of this) {
	      callbackFn.apply(thisArg, [value, key, this]);
	    }
	  }
	}

	FormData.prototype[Symbol.iterator] = FormData.prototype.entries;

	Object.defineProperties(FormData.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'FormData',
	    configurable: true
	  }
	});

	/**
	 * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	 * @param {string} name
	 * @param {string|Blob} value
	 * @param {?string} filename
	 * @returns
	 */
	function makeEntry (name, value, filename) {
	  // 1. Set name to the result of converting name into a scalar value string.
	  // "To convert a string into a scalar value string, replace any surrogates
	  //  with U+FFFD."
	  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end
	  name = Buffer.from(name).toString('utf8');

	  // 2. If value is a string, then set value to the result of converting
	  //    value into a scalar value string.
	  if (typeof value === 'string') {
	    value = Buffer.from(value).toString('utf8');
	  } else {
	    // 3. Otherwise:

	    // 1. If value is not a File object, then set value to a new File object,
	    //    representing the same bytes, whose name attribute value is "blob"
	    if (!isFileLike(value)) {
	      value = value instanceof Blob
	        ? new File([value], 'blob', { type: value.type })
	        : new FileLike(value, 'blob', { type: value.type });
	    }

	    // 2. If filename is given, then set value to a new File object,
	    //    representing the same bytes, whose name attribute is filename.
	    if (filename !== undefined) {
	      /** @type {FilePropertyBag} */
	      const options = {
	        type: value.type,
	        lastModified: value.lastModified
	      };

	      value = (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile
	        ? new File([value], filename, options)
	        : new FileLike(value, filename, options);
	    }
	  }

	  // 4. Return an entry whose name is name and whose value is value.
	  return { name, value }
	}

	formdata = { FormData };
	return formdata;
}

var body;
var hasRequiredBody;

function requireBody () {
	if (hasRequiredBody) return body;
	hasRequiredBody = 1;

	const Busboy = requireMain();
	const util = requireUtil$6();
	const {
	  ReadableStreamFrom,
	  isBlobLike,
	  isReadableStreamLike,
	  readableStreamClose,
	  createDeferredPromise,
	  fullyReadBody
	} = requireUtil$5();
	const { FormData } = requireFormdata();
	const { kState } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { DOMException, structuredClone } = requireConstants$3();
	const { Blob, File: NativeFile } = require$$7;
	const { kBodyUsed } = requireSymbols$4();
	const assert = require$$0$2;
	const { isErrored } = requireUtil$6();
	const { isUint8Array, isArrayBuffer } = require$$5;
	const { File: UndiciFile } = requireFile();
	const { parseMIMEType, serializeAMimeType } = requireDataURL();

	let random;
	try {
	  const crypto = require('node:crypto');
	  random = (max) => crypto.randomInt(0, max);
	} catch {
	  random = (max) => Math.floor(Math.random(max));
	}

	let ReadableStream = globalThis.ReadableStream;

	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;
	const textEncoder = new TextEncoder();
	const textDecoder = new TextDecoder();

	// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
	function extractBody (object, keepalive = false) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  // 1. Let stream be null.
	  let stream = null;

	  // 2. If object is a ReadableStream object, then set stream to object.
	  if (object instanceof ReadableStream) {
	    stream = object;
	  } else if (isBlobLike(object)) {
	    // 3. Otherwise, if object is a Blob object, set stream to the
	    //    result of running objects get stream.
	    stream = object.stream();
	  } else {
	    // 4. Otherwise, set stream to a new ReadableStream object, and set
	    //    up stream.
	    stream = new ReadableStream({
	      async pull (controller) {
	        controller.enqueue(
	          typeof source === 'string' ? textEncoder.encode(source) : source
	        );
	        queueMicrotask(() => readableStreamClose(controller));
	      },
	      start () {},
	      type: undefined
	    });
	  }

	  // 5. Assert: stream is a ReadableStream object.
	  assert(isReadableStreamLike(stream));

	  // 6. Let action be null.
	  let action = null;

	  // 7. Let source be null.
	  let source = null;

	  // 8. Let length be null.
	  let length = null;

	  // 9. Let type be null.
	  let type = null;

	  // 10. Switch on object:
	  if (typeof object === 'string') {
	    // Set source to the UTF-8 encoding of object.
	    // Note: setting source to a Uint8Array here breaks some mocking assumptions.
	    source = object;

	    // Set type to `text/plain;charset=UTF-8`.
	    type = 'text/plain;charset=UTF-8';
	  } else if (object instanceof URLSearchParams) {
	    // URLSearchParams

	    // spec says to run application/x-www-form-urlencoded on body.list
	    // this is implemented in Node.js as apart of an URLSearchParams instance toString method
	    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
	    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

	    // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.
	    source = object.toString();

	    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
	    type = 'application/x-www-form-urlencoded;charset=UTF-8';
	  } else if (isArrayBuffer(object)) {
	    // BufferSource/ArrayBuffer

	    // Set source to a copy of the bytes held by object.
	    source = new Uint8Array(object.slice());
	  } else if (ArrayBuffer.isView(object)) {
	    // BufferSource/ArrayBufferView

	    // Set source to a copy of the bytes held by object.
	    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
	  } else if (util.isFormDataLike(object)) {
	    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`;
	    const prefix = `--${boundary}\r\nContent-Disposition: form-data`;

	    /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
	    const escape = (str) =>
	      str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
	    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');

	    // Set action to this step: run the multipart/form-data
	    // encoding algorithm, with objects entry list and UTF-8.
	    // - This ensures that the body is immutable and can't be changed afterwords
	    // - That the content-length is calculated in advance.
	    // - And that all parts are pre-encoded and ready to be sent.

	    const blobParts = [];
	    const rn = new Uint8Array([13, 10]); // '\r\n'
	    length = 0;
	    let hasUnknownSizeValue = false;

	    for (const [name, value] of object) {
	      if (typeof value === 'string') {
	        const chunk = textEncoder.encode(prefix +
	          `; name="${escape(normalizeLinefeeds(name))}"` +
	          `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
	        blobParts.push(chunk);
	        length += chunk.byteLength;
	      } else {
	        const chunk = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
	          (value.name ? `; filename="${escape(value.name)}"` : '') + '\r\n' +
	          `Content-Type: ${
	            value.type || 'application/octet-stream'
	          }\r\n\r\n`);
	        blobParts.push(chunk, value, rn);
	        if (typeof value.size === 'number') {
	          length += chunk.byteLength + value.size + rn.byteLength;
	        } else {
	          hasUnknownSizeValue = true;
	        }
	      }
	    }

	    const chunk = textEncoder.encode(`--${boundary}--`);
	    blobParts.push(chunk);
	    length += chunk.byteLength;
	    if (hasUnknownSizeValue) {
	      length = null;
	    }

	    // Set source to object.
	    source = object;

	    action = async function * () {
	      for (const part of blobParts) {
	        if (part.stream) {
	          yield * part.stream();
	        } else {
	          yield part;
	        }
	      }
	    };

	    // Set type to `multipart/form-data; boundary=`,
	    // followed by the multipart/form-data boundary string generated
	    // by the multipart/form-data encoding algorithm.
	    type = 'multipart/form-data; boundary=' + boundary;
	  } else if (isBlobLike(object)) {
	    // Blob

	    // Set source to object.
	    source = object;

	    // Set length to objects size.
	    length = object.size;

	    // If objects type attribute is not the empty byte sequence, set
	    // type to its value.
	    if (object.type) {
	      type = object.type;
	    }
	  } else if (typeof object[Symbol.asyncIterator] === 'function') {
	    // If keepalive is true, then throw a TypeError.
	    if (keepalive) {
	      throw new TypeError('keepalive')
	    }

	    // If object is disturbed or locked, then throw a TypeError.
	    if (util.isDisturbed(object) || object.locked) {
	      throw new TypeError(
	        'Response body object should not be disturbed or locked'
	      )
	    }

	    stream =
	      object instanceof ReadableStream ? object : ReadableStreamFrom(object);
	  }

	  // 11. If source is a byte sequence, then set action to a
	  // step that returns source and length to sources length.
	  if (typeof source === 'string' || util.isBuffer(source)) {
	    length = Buffer.byteLength(source);
	  }

	  // 12. If action is non-null, then run these steps in in parallel:
	  if (action != null) {
	    // Run action.
	    let iterator;
	    stream = new ReadableStream({
	      async start () {
	        iterator = action(object)[Symbol.asyncIterator]();
	      },
	      async pull (controller) {
	        const { value, done } = await iterator.next();
	        if (done) {
	          // When running action is done, close stream.
	          queueMicrotask(() => {
	            controller.close();
	          });
	        } else {
	          // Whenever one or more bytes are available and stream is not errored,
	          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available
	          // bytes into stream.
	          if (!isErrored(stream)) {
	            controller.enqueue(new Uint8Array(value));
	          }
	        }
	        return controller.desiredSize > 0
	      },
	      async cancel (reason) {
	        await iterator.return();
	      },
	      type: undefined
	    });
	  }

	  // 13. Let body be a body whose stream is stream, source is source,
	  // and length is length.
	  const body = { stream, source, length };

	  // 14. Return (body, type).
	  return [body, type]
	}

	// https://fetch.spec.whatwg.org/#bodyinit-safely-extract
	function safelyExtractBody (object, keepalive = false) {
	  if (!ReadableStream) {
	    // istanbul ignore next
	    ReadableStream = require$$14.ReadableStream;
	  }

	  // To safely extract a body and a `Content-Type` value from
	  // a byte sequence or BodyInit object object, run these steps:

	  // 1. If object is a ReadableStream object, then:
	  if (object instanceof ReadableStream) {
	    // Assert: object is neither disturbed nor locked.
	    // istanbul ignore next
	    assert(!util.isDisturbed(object), 'The body has already been consumed.');
	    // istanbul ignore next
	    assert(!object.locked, 'The stream is locked.');
	  }

	  // 2. Return the results of extracting object.
	  return extractBody(object, keepalive)
	}

	function cloneBody (body) {
	  // To clone a body body, run these steps:

	  // https://fetch.spec.whatwg.org/#concept-body-clone

	  // 1. Let  out1, out2  be the result of teeing bodys stream.
	  const [out1, out2] = body.stream.tee();
	  const out2Clone = structuredClone(out2, { transfer: [out2] });
	  // This, for whatever reasons, unrefs out2Clone which allows
	  // the process to exit by itself.
	  const [, finalClone] = out2Clone.tee();

	  // 2. Set bodys stream to out1.
	  body.stream = out1;

	  // 3. Return a body whose stream is out2 and other members are copied from body.
	  return {
	    stream: finalClone,
	    length: body.length,
	    source: body.source
	  }
	}

	async function * consumeBody (body) {
	  if (body) {
	    if (isUint8Array(body)) {
	      yield body;
	    } else {
	      const stream = body.stream;

	      if (util.isDisturbed(stream)) {
	        throw new TypeError('The body has already been consumed.')
	      }

	      if (stream.locked) {
	        throw new TypeError('The stream is locked.')
	      }

	      // Compat.
	      stream[kBodyUsed] = true;

	      yield * stream;
	    }
	  }
	}

	function throwIfAborted (state) {
	  if (state.aborted) {
	    throw new DOMException('The operation was aborted.', 'AbortError')
	  }
	}

	function bodyMixinMethods (instance) {
	  const methods = {
	    blob () {
	      // The blob() method steps are to return the result of
	      // running consume body with this and the following step
	      // given a byte sequence bytes: return a Blob whose
	      // contents are bytes and whose type attribute is thiss
	      // MIME type.
	      return specConsumeBody(this, (bytes) => {
	        let mimeType = bodyMimeType(this);

	        if (mimeType === 'failure') {
	          mimeType = '';
	        } else if (mimeType) {
	          mimeType = serializeAMimeType(mimeType);
	        }

	        // Return a Blob whose contents are bytes and type attribute
	        // is mimeType.
	        return new Blob([bytes], { type: mimeType })
	      }, instance)
	    },

	    arrayBuffer () {
	      // The arrayBuffer() method steps are to return the result
	      // of running consume body with this and the following step
	      // given a byte sequence bytes: return a new ArrayBuffer
	      // whose contents are bytes.
	      return specConsumeBody(this, (bytes) => {
	        return new Uint8Array(bytes).buffer
	      }, instance)
	    },

	    text () {
	      // The text() method steps are to return the result of running
	      // consume body with this and UTF-8 decode.
	      return specConsumeBody(this, utf8DecodeBytes, instance)
	    },

	    json () {
	      // The json() method steps are to return the result of running
	      // consume body with this and parse JSON from bytes.
	      return specConsumeBody(this, parseJSONFromBytes, instance)
	    },

	    async formData () {
	      webidl.brandCheck(this, instance);

	      throwIfAborted(this[kState]);

	      const contentType = this.headers.get('Content-Type');

	      // If mimeTypes essence is "multipart/form-data", then:
	      if (/multipart\/form-data/.test(contentType)) {
	        const headers = {};
	        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;

	        const responseFormData = new FormData();

	        let busboy;

	        try {
	          busboy = new Busboy({
	            headers,
	            preservePath: true
	          });
	        } catch (err) {
	          throw new DOMException(`${err}`, 'AbortError')
	        }

	        busboy.on('field', (name, value) => {
	          responseFormData.append(name, value);
	        });
	        busboy.on('file', (name, value, filename, encoding, mimeType) => {
	          const chunks = [];

	          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {
	            let base64chunk = '';

	            value.on('data', (chunk) => {
	              base64chunk += chunk.toString().replace(/[\r\n]/gm, '');

	              const end = base64chunk.length - base64chunk.length % 4;
	              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));

	              base64chunk = base64chunk.slice(end);
	            });
	            value.on('end', () => {
	              chunks.push(Buffer.from(base64chunk, 'base64'));
	              responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
	            });
	          } else {
	            value.on('data', (chunk) => {
	              chunks.push(chunk);
	            });
	            value.on('end', () => {
	              responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
	            });
	          }
	        });

	        const busboyResolve = new Promise((resolve, reject) => {
	          busboy.on('finish', resolve);
	          busboy.on('error', (err) => reject(new TypeError(err)));
	        });

	        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
	        busboy.end();
	        await busboyResolve;

	        return responseFormData
	      } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
	        // Otherwise, if mimeTypes essence is "application/x-www-form-urlencoded", then:

	        // 1. Let entries be the result of parsing bytes.
	        let entries;
	        try {
	          let text = '';
	          // application/x-www-form-urlencoded parser will keep the BOM.
	          // https://url.spec.whatwg.org/#concept-urlencoded-parser
	          // Note that streaming decoder is stateful and cannot be reused
	          const streamingDecoder = new TextDecoder('utf-8', { ignoreBOM: true });

	          for await (const chunk of consumeBody(this[kState].body)) {
	            if (!isUint8Array(chunk)) {
	              throw new TypeError('Expected Uint8Array chunk')
	            }
	            text += streamingDecoder.decode(chunk, { stream: true });
	          }
	          text += streamingDecoder.decode();
	          entries = new URLSearchParams(text);
	        } catch (err) {
	          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
	          // 2. If entries is failure, then throw a TypeError.
	          throw Object.assign(new TypeError(), { cause: err })
	        }

	        // 3. Return a new FormData object whose entries are entries.
	        const formData = new FormData();
	        for (const [name, value] of entries) {
	          formData.append(name, value);
	        }
	        return formData
	      } else {
	        // Wait a tick before checking if the request has been aborted.
	        // Otherwise, a TypeError can be thrown when an AbortError should.
	        await Promise.resolve();

	        throwIfAborted(this[kState]);

	        // Otherwise, throw a TypeError.
	        throw webidl.errors.exception({
	          header: `${instance.name}.formData`,
	          message: 'Could not parse content as FormData.'
	        })
	      }
	    }
	  };

	  return methods
	}

	function mixinBody (prototype) {
	  Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	 * @param {Response|Request} object
	 * @param {(value: unknown) => unknown} convertBytesToJSValue
	 * @param {Response|Request} instance
	 */
	async function specConsumeBody (object, convertBytesToJSValue, instance) {
	  webidl.brandCheck(object, instance);

	  throwIfAborted(object[kState]);

	  // 1. If object is unusable, then return a promise rejected
	  //    with a TypeError.
	  if (bodyUnusable(object[kState].body)) {
	    throw new TypeError('Body is unusable')
	  }

	  // 2. Let promise be a new promise.
	  const promise = createDeferredPromise();

	  // 3. Let errorSteps given error be to reject promise with error.
	  const errorSteps = (error) => promise.reject(error);

	  // 4. Let successSteps given a byte sequence data be to resolve
	  //    promise with the result of running convertBytesToJSValue
	  //    with data. If that threw an exception, then run errorSteps
	  //    with that exception.
	  const successSteps = (data) => {
	    try {
	      promise.resolve(convertBytesToJSValue(data));
	    } catch (e) {
	      errorSteps(e);
	    }
	  };

	  // 5. If objects body is null, then run successSteps with an
	  //    empty byte sequence.
	  if (object[kState].body == null) {
	    successSteps(new Uint8Array());
	    return promise.promise
	  }

	  // 6. Otherwise, fully read objects body given successSteps,
	  //    errorSteps, and objects relevant global object.
	  await fullyReadBody(object[kState].body, successSteps, errorSteps);

	  // 7. Return promise.
	  return promise.promise
	}

	// https://fetch.spec.whatwg.org/#body-unusable
	function bodyUnusable (body) {
	  // An object including the Body interface mixin is
	  // said to be unusable if its body is non-null and
	  // its bodys stream is disturbed or locked.
	  return body != null && (body.stream.locked || util.isDisturbed(body.stream))
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#utf-8-decode
	 * @param {Buffer} buffer
	 */
	function utf8DecodeBytes (buffer) {
	  if (buffer.length === 0) {
	    return ''
	  }

	  // 1. Let buffer be the result of peeking three bytes from
	  //    ioQueue, converted to a byte sequence.

	  // 2. If buffer is 0xEF 0xBB 0xBF, then read three
	  //    bytes from ioQueue. (Do nothing with those bytes.)
	  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
	    buffer = buffer.subarray(3);
	  }

	  // 3. Process a queue with an instance of UTF-8s
	  //    decoder, ioQueue, output, and "replacement".
	  const output = textDecoder.decode(buffer);

	  // 4. Return output.
	  return output
	}

	/**
	 * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	 * @param {Uint8Array} bytes
	 */
	function parseJSONFromBytes (bytes) {
	  return JSON.parse(utf8DecodeBytes(bytes))
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	 * @param {import('./response').Response|import('./request').Request} object
	 */
	function bodyMimeType (object) {
	  const { headersList } = object[kState];
	  const contentType = headersList.get('content-type');

	  if (contentType === null) {
	    return 'failure'
	  }

	  return parseMIMEType(contentType)
	}

	body = {
	  extractBody,
	  safelyExtractBody,
	  cloneBody,
	  mixinBody
	};
	return body;
}

var request$2;
var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request$2;
	hasRequiredRequest$1 = 1;

	const {
	  InvalidArgumentError,
	  NotSupportedError
	} = requireErrors();
	const assert = require$$0$2;
	const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = requireSymbols$4();
	const util = requireUtil$6();

	// tokenRegExp and headerCharRegex have been lifted from
	// https://github.com/nodejs/node/blob/main/lib/_http_common.js

	/**
	 * Verifies that the given val is a valid HTTP token
	 * per the rules defined in RFC 7230
	 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
	 */
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;

	/**
	 * Matches if val contains an invalid field-vchar
	 *  field-value    = *( field-content / obs-fold )
	 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 *  field-vchar    = VCHAR / obs-text
	 */
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

	// Verifies that a given path is valid does not contain control chars \x00 to \x20
	const invalidPathRegex = /[^\u0021-\u00ff]/;

	const kHandler = Symbol('handler');

	const channels = {};

	let extractBody;

	try {
	  const diagnosticsChannel = require('diagnostics_channel');
	  channels.create = diagnosticsChannel.channel('undici:request:create');
	  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent');
	  channels.headers = diagnosticsChannel.channel('undici:request:headers');
	  channels.trailers = diagnosticsChannel.channel('undici:request:trailers');
	  channels.error = diagnosticsChannel.channel('undici:request:error');
	} catch {
	  channels.create = { hasSubscribers: false };
	  channels.bodySent = { hasSubscribers: false };
	  channels.headers = { hasSubscribers: false };
	  channels.trailers = { hasSubscribers: false };
	  channels.error = { hasSubscribers: false };
	}

	class Request {
	  constructor (origin, {
	    path,
	    method,
	    body,
	    headers,
	    query,
	    idempotent,
	    blocking,
	    upgrade,
	    headersTimeout,
	    bodyTimeout,
	    reset,
	    throwOnError,
	    expectContinue
	  }, handler) {
	    if (typeof path !== 'string') {
	      throw new InvalidArgumentError('path must be a string')
	    } else if (
	      path[0] !== '/' &&
	      !(path.startsWith('http://') || path.startsWith('https://')) &&
	      method !== 'CONNECT'
	    ) {
	      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')
	    } else if (invalidPathRegex.exec(path) !== null) {
	      throw new InvalidArgumentError('invalid request path')
	    }

	    if (typeof method !== 'string') {
	      throw new InvalidArgumentError('method must be a string')
	    } else if (tokenRegExp.exec(method) === null) {
	      throw new InvalidArgumentError('invalid request method')
	    }

	    if (upgrade && typeof upgrade !== 'string') {
	      throw new InvalidArgumentError('upgrade must be a string')
	    }

	    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
	      throw new InvalidArgumentError('invalid headersTimeout')
	    }

	    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
	      throw new InvalidArgumentError('invalid bodyTimeout')
	    }

	    if (reset != null && typeof reset !== 'boolean') {
	      throw new InvalidArgumentError('invalid reset')
	    }

	    if (expectContinue != null && typeof expectContinue !== 'boolean') {
	      throw new InvalidArgumentError('invalid expectContinue')
	    }

	    this.headersTimeout = headersTimeout;

	    this.bodyTimeout = bodyTimeout;

	    this.throwOnError = throwOnError === true;

	    this.method = method;

	    this.abort = null;

	    if (body == null) {
	      this.body = null;
	    } else if (util.isStream(body)) {
	      this.body = body;

	      const rState = this.body._readableState;
	      if (!rState || !rState.autoDestroy) {
	        this.endHandler = function autoDestroy () {
	          util.destroy(this);
	        };
	        this.body.on('end', this.endHandler);
	      }

	      this.errorHandler = err => {
	        if (this.abort) {
	          this.abort(err);
	        } else {
	          this.error = err;
	        }
	      };
	      this.body.on('error', this.errorHandler);
	    } else if (util.isBuffer(body)) {
	      this.body = body.byteLength ? body : null;
	    } else if (ArrayBuffer.isView(body)) {
	      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
	    } else if (body instanceof ArrayBuffer) {
	      this.body = body.byteLength ? Buffer.from(body) : null;
	    } else if (typeof body === 'string') {
	      this.body = body.length ? Buffer.from(body) : null;
	    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
	      this.body = body;
	    } else {
	      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')
	    }

	    this.completed = false;

	    this.aborted = false;

	    this.upgrade = upgrade || null;

	    this.path = query ? util.buildURL(path, query) : path;

	    this.origin = origin;

	    this.idempotent = idempotent == null
	      ? method === 'HEAD' || method === 'GET'
	      : idempotent;

	    this.blocking = blocking == null ? false : blocking;

	    this.reset = reset == null ? null : reset;

	    this.host = null;

	    this.contentLength = null;

	    this.contentType = null;

	    this.headers = '';

	    // Only for H2
	    this.expectContinue = expectContinue != null ? expectContinue : false;

	    if (Array.isArray(headers)) {
	      if (headers.length % 2 !== 0) {
	        throw new InvalidArgumentError('headers array must be even')
	      }
	      for (let i = 0; i < headers.length; i += 2) {
	        processHeader(this, headers[i], headers[i + 1]);
	      }
	    } else if (headers && typeof headers === 'object') {
	      const keys = Object.keys(headers);
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        processHeader(this, key, headers[key]);
	      }
	    } else if (headers != null) {
	      throw new InvalidArgumentError('headers must be an object or an array')
	    }

	    if (util.isFormDataLike(this.body)) {
	      if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {
	        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.')
	      }

	      if (!extractBody) {
	        extractBody = requireBody().extractBody;
	      }

	      const [bodyStream, contentType] = extractBody(body);
	      if (this.contentType == null) {
	        this.contentType = contentType;
	        this.headers += `content-type: ${contentType}\r\n`;
	      }
	      this.body = bodyStream.stream;
	      this.contentLength = bodyStream.length;
	    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
	      this.contentType = body.type;
	      this.headers += `content-type: ${body.type}\r\n`;
	    }

	    util.validateHandler(handler, method, upgrade);

	    this.servername = util.getServerName(this.host);

	    this[kHandler] = handler;

	    if (channels.create.hasSubscribers) {
	      channels.create.publish({ request: this });
	    }
	  }

	  onBodySent (chunk) {
	    if (this[kHandler].onBodySent) {
	      try {
	        return this[kHandler].onBodySent(chunk)
	      } catch (err) {
	        this.abort(err);
	      }
	    }
	  }

	  onRequestSent () {
	    if (channels.bodySent.hasSubscribers) {
	      channels.bodySent.publish({ request: this });
	    }

	    if (this[kHandler].onRequestSent) {
	      try {
	        return this[kHandler].onRequestSent()
	      } catch (err) {
	        this.abort(err);
	      }
	    }
	  }

	  onConnect (abort) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    if (this.error) {
	      abort(this.error);
	    } else {
	      this.abort = abort;
	      return this[kHandler].onConnect(abort)
	    }
	  }

	  onHeaders (statusCode, headers, resume, statusText) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    if (channels.headers.hasSubscribers) {
	      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
	    }

	    try {
	      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)
	    } catch (err) {
	      this.abort(err);
	    }
	  }

	  onData (chunk) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    try {
	      return this[kHandler].onData(chunk)
	    } catch (err) {
	      this.abort(err);
	      return false
	    }
	  }

	  onUpgrade (statusCode, headers, socket) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    return this[kHandler].onUpgrade(statusCode, headers, socket)
	  }

	  onComplete (trailers) {
	    this.onFinally();

	    assert(!this.aborted);

	    this.completed = true;
	    if (channels.trailers.hasSubscribers) {
	      channels.trailers.publish({ request: this, trailers });
	    }

	    try {
	      return this[kHandler].onComplete(trailers)
	    } catch (err) {
	      // TODO (fix): This might be a bad idea?
	      this.onError(err);
	    }
	  }

	  onError (error) {
	    this.onFinally();

	    if (channels.error.hasSubscribers) {
	      channels.error.publish({ request: this, error });
	    }

	    if (this.aborted) {
	      return
	    }
	    this.aborted = true;

	    return this[kHandler].onError(error)
	  }

	  onFinally () {
	    if (this.errorHandler) {
	      this.body.off('error', this.errorHandler);
	      this.errorHandler = null;
	    }

	    if (this.endHandler) {
	      this.body.off('end', this.endHandler);
	      this.endHandler = null;
	    }
	  }

	  // TODO: adjust to support H2
	  addHeader (key, value) {
	    processHeader(this, key, value);
	    return this
	  }

	  static [kHTTP1BuildRequest] (origin, opts, handler) {
	    // TODO: Migrate header parsing here, to make Requests
	    // HTTP agnostic
	    return new Request(origin, opts, handler)
	  }

	  static [kHTTP2BuildRequest] (origin, opts, handler) {
	    const headers = opts.headers;
	    opts = { ...opts, headers: null };

	    const request = new Request(origin, opts, handler);

	    request.headers = {};

	    if (Array.isArray(headers)) {
	      if (headers.length % 2 !== 0) {
	        throw new InvalidArgumentError('headers array must be even')
	      }
	      for (let i = 0; i < headers.length; i += 2) {
	        processHeader(request, headers[i], headers[i + 1], true);
	      }
	    } else if (headers && typeof headers === 'object') {
	      const keys = Object.keys(headers);
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        processHeader(request, key, headers[key], true);
	      }
	    } else if (headers != null) {
	      throw new InvalidArgumentError('headers must be an object or an array')
	    }

	    return request
	  }

	  static [kHTTP2CopyHeaders] (raw) {
	    const rawHeaders = raw.split('\r\n');
	    const headers = {};

	    for (const header of rawHeaders) {
	      const [key, value] = header.split(': ');

	      if (value == null || value.length === 0) continue

	      if (headers[key]) headers[key] += `,${value}`;
	      else headers[key] = value;
	    }

	    return headers
	  }
	}

	function processHeaderValue (key, val, skipAppend) {
	  if (val && typeof val === 'object') {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  }

	  val = val != null ? `${val}` : '';

	  if (headerCharRegex.exec(val) !== null) {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  }

	  return skipAppend ? val : `${key}: ${val}\r\n`
	}

	function processHeader (request, key, val, skipAppend = false) {
	  if (val && (typeof val === 'object' && !Array.isArray(val))) {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  } else if (val === undefined) {
	    return
	  }

	  if (
	    request.host === null &&
	    key.length === 4 &&
	    key.toLowerCase() === 'host'
	  ) {
	    if (headerCharRegex.exec(val) !== null) {
	      throw new InvalidArgumentError(`invalid ${key} header`)
	    }
	    // Consumed by Client
	    request.host = val;
	  } else if (
	    request.contentLength === null &&
	    key.length === 14 &&
	    key.toLowerCase() === 'content-length'
	  ) {
	    request.contentLength = parseInt(val, 10);
	    if (!Number.isFinite(request.contentLength)) {
	      throw new InvalidArgumentError('invalid content-length header')
	    }
	  } else if (
	    request.contentType === null &&
	    key.length === 12 &&
	    key.toLowerCase() === 'content-type'
	  ) {
	    request.contentType = val;
	    if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
	    else request.headers += processHeaderValue(key, val);
	  } else if (
	    key.length === 17 &&
	    key.toLowerCase() === 'transfer-encoding'
	  ) {
	    throw new InvalidArgumentError('invalid transfer-encoding header')
	  } else if (
	    key.length === 10 &&
	    key.toLowerCase() === 'connection'
	  ) {
	    const value = typeof val === 'string' ? val.toLowerCase() : null;
	    if (value !== 'close' && value !== 'keep-alive') {
	      throw new InvalidArgumentError('invalid connection header')
	    } else if (value === 'close') {
	      request.reset = true;
	    }
	  } else if (
	    key.length === 10 &&
	    key.toLowerCase() === 'keep-alive'
	  ) {
	    throw new InvalidArgumentError('invalid keep-alive header')
	  } else if (
	    key.length === 7 &&
	    key.toLowerCase() === 'upgrade'
	  ) {
	    throw new InvalidArgumentError('invalid upgrade header')
	  } else if (
	    key.length === 6 &&
	    key.toLowerCase() === 'expect'
	  ) {
	    throw new NotSupportedError('expect header not supported')
	  } else if (tokenRegExp.exec(key) === null) {
	    throw new InvalidArgumentError('invalid header key')
	  } else {
	    if (Array.isArray(val)) {
	      for (let i = 0; i < val.length; i++) {
	        if (skipAppend) {
	          if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
	          else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
	        } else {
	          request.headers += processHeaderValue(key, val[i]);
	        }
	      }
	    } else {
	      if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
	      else request.headers += processHeaderValue(key, val);
	    }
	  }
	}

	request$2 = Request;
	return request$2;
}

var dispatcher;
var hasRequiredDispatcher;

function requireDispatcher () {
	if (hasRequiredDispatcher) return dispatcher;
	hasRequiredDispatcher = 1;

	const EventEmitter = require$$4$1;

	class Dispatcher extends EventEmitter {
	  dispatch () {
	    throw new Error('not implemented')
	  }

	  close () {
	    throw new Error('not implemented')
	  }

	  destroy () {
	    throw new Error('not implemented')
	  }
	}

	dispatcher = Dispatcher;
	return dispatcher;
}

var dispatcherBase;
var hasRequiredDispatcherBase;

function requireDispatcherBase () {
	if (hasRequiredDispatcherBase) return dispatcherBase;
	hasRequiredDispatcherBase = 1;

	const Dispatcher = requireDispatcher();
	const {
	  ClientDestroyedError,
	  ClientClosedError,
	  InvalidArgumentError
	} = requireErrors();
	const { kDestroy, kClose, kDispatch, kInterceptors } = requireSymbols$4();

	const kDestroyed = Symbol('destroyed');
	const kClosed = Symbol('closed');
	const kOnDestroyed = Symbol('onDestroyed');
	const kOnClosed = Symbol('onClosed');
	const kInterceptedDispatch = Symbol('Intercepted Dispatch');

	class DispatcherBase extends Dispatcher {
	  constructor () {
	    super();

	    this[kDestroyed] = false;
	    this[kOnDestroyed] = null;
	    this[kClosed] = false;
	    this[kOnClosed] = [];
	  }

	  get destroyed () {
	    return this[kDestroyed]
	  }

	  get closed () {
	    return this[kClosed]
	  }

	  get interceptors () {
	    return this[kInterceptors]
	  }

	  set interceptors (newInterceptors) {
	    if (newInterceptors) {
	      for (let i = newInterceptors.length - 1; i >= 0; i--) {
	        const interceptor = this[kInterceptors][i];
	        if (typeof interceptor !== 'function') {
	          throw new InvalidArgumentError('interceptor must be an function')
	        }
	      }
	    }

	    this[kInterceptors] = newInterceptors;
	  }

	  close (callback) {
	    if (callback === undefined) {
	      return new Promise((resolve, reject) => {
	        this.close((err, data) => {
	          return err ? reject(err) : resolve(data)
	        });
	      })
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    if (this[kDestroyed]) {
	      queueMicrotask(() => callback(new ClientDestroyedError(), null));
	      return
	    }

	    if (this[kClosed]) {
	      if (this[kOnClosed]) {
	        this[kOnClosed].push(callback);
	      } else {
	        queueMicrotask(() => callback(null, null));
	      }
	      return
	    }

	    this[kClosed] = true;
	    this[kOnClosed].push(callback);

	    const onClosed = () => {
	      const callbacks = this[kOnClosed];
	      this[kOnClosed] = null;
	      for (let i = 0; i < callbacks.length; i++) {
	        callbacks[i](null, null);
	      }
	    };

	    // Should not error.
	    this[kClose]()
	      .then(() => this.destroy())
	      .then(() => {
	        queueMicrotask(onClosed);
	      });
	  }

	  destroy (err, callback) {
	    if (typeof err === 'function') {
	      callback = err;
	      err = null;
	    }

	    if (callback === undefined) {
	      return new Promise((resolve, reject) => {
	        this.destroy(err, (err, data) => {
	          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)
	        });
	      })
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    if (this[kDestroyed]) {
	      if (this[kOnDestroyed]) {
	        this[kOnDestroyed].push(callback);
	      } else {
	        queueMicrotask(() => callback(null, null));
	      }
	      return
	    }

	    if (!err) {
	      err = new ClientDestroyedError();
	    }

	    this[kDestroyed] = true;
	    this[kOnDestroyed] = this[kOnDestroyed] || [];
	    this[kOnDestroyed].push(callback);

	    const onDestroyed = () => {
	      const callbacks = this[kOnDestroyed];
	      this[kOnDestroyed] = null;
	      for (let i = 0; i < callbacks.length; i++) {
	        callbacks[i](null, null);
	      }
	    };

	    // Should not error.
	    this[kDestroy](err).then(() => {
	      queueMicrotask(onDestroyed);
	    });
	  }

	  [kInterceptedDispatch] (opts, handler) {
	    if (!this[kInterceptors] || this[kInterceptors].length === 0) {
	      this[kInterceptedDispatch] = this[kDispatch];
	      return this[kDispatch](opts, handler)
	    }

	    let dispatch = this[kDispatch].bind(this);
	    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
	      dispatch = this[kInterceptors][i](dispatch);
	    }
	    this[kInterceptedDispatch] = dispatch;
	    return dispatch(opts, handler)
	  }

	  dispatch (opts, handler) {
	    if (!handler || typeof handler !== 'object') {
	      throw new InvalidArgumentError('handler must be an object')
	    }

	    try {
	      if (!opts || typeof opts !== 'object') {
	        throw new InvalidArgumentError('opts must be an object.')
	      }

	      if (this[kDestroyed] || this[kOnDestroyed]) {
	        throw new ClientDestroyedError()
	      }

	      if (this[kClosed]) {
	        throw new ClientClosedError()
	      }

	      return this[kInterceptedDispatch](opts, handler)
	    } catch (err) {
	      if (typeof handler.onError !== 'function') {
	        throw new InvalidArgumentError('invalid onError method')
	      }

	      handler.onError(err);

	      return false
	    }
	  }
	}

	dispatcherBase = DispatcherBase;
	return dispatcherBase;
}

var connect;
var hasRequiredConnect;

function requireConnect () {
	if (hasRequiredConnect) return connect;
	hasRequiredConnect = 1;

	const net = require$$0$5;
	const assert = require$$0$2;
	const util = requireUtil$6();
	const { InvalidArgumentError, ConnectTimeoutError } = requireErrors();

	let tls; // include tls conditionally since it is not always available

	// TODO: session re-use does not wait for the first
	// connection to resolve the session and might therefore
	// resolve the same servername multiple times even when
	// re-use is enabled.

	let SessionCache;
	// FIXME: remove workaround when the Node bug is fixed
	// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
	if (commonjsGlobal.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
	  SessionCache = class WeakSessionCache {
	    constructor (maxCachedSessions) {
	      this._maxCachedSessions = maxCachedSessions;
	      this._sessionCache = new Map();
	      this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
	        if (this._sessionCache.size < this._maxCachedSessions) {
	          return
	        }

	        const ref = this._sessionCache.get(key);
	        if (ref !== undefined && ref.deref() === undefined) {
	          this._sessionCache.delete(key);
	        }
	      });
	    }

	    get (sessionKey) {
	      const ref = this._sessionCache.get(sessionKey);
	      return ref ? ref.deref() : null
	    }

	    set (sessionKey, session) {
	      if (this._maxCachedSessions === 0) {
	        return
	      }

	      this._sessionCache.set(sessionKey, new WeakRef(session));
	      this._sessionRegistry.register(session, sessionKey);
	    }
	  };
	} else {
	  SessionCache = class SimpleSessionCache {
	    constructor (maxCachedSessions) {
	      this._maxCachedSessions = maxCachedSessions;
	      this._sessionCache = new Map();
	    }

	    get (sessionKey) {
	      return this._sessionCache.get(sessionKey)
	    }

	    set (sessionKey, session) {
	      if (this._maxCachedSessions === 0) {
	        return
	      }

	      if (this._sessionCache.size >= this._maxCachedSessions) {
	        // remove the oldest session
	        const { value: oldestKey } = this._sessionCache.keys().next();
	        this._sessionCache.delete(oldestKey);
	      }

	      this._sessionCache.set(sessionKey, session);
	    }
	  };
	}

	function buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
	  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
	    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')
	  }

	  const options = { path: socketPath, ...opts };
	  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
	  timeout = timeout == null ? 10e3 : timeout;
	  allowH2 = allowH2 != null ? allowH2 : false;
	  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
	    let socket;
	    if (protocol === 'https:') {
	      if (!tls) {
	        tls = require$$1$3;
	      }
	      servername = servername || options.servername || util.getServerName(host) || null;

	      const sessionKey = servername || hostname;
	      const session = sessionCache.get(sessionKey) || null;

	      assert(sessionKey);

	      socket = tls.connect({
	        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
	        ...options,
	        servername,
	        session,
	        localAddress,
	        // TODO(HTTP/2): Add support for h2c
	        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],
	        socket: httpSocket, // upgrade socket connection
	        port: port || 443,
	        host: hostname
	      });

	      socket
	        .on('session', function (session) {
	          // TODO (fix): Can a session become invalid once established? Don't think so?
	          sessionCache.set(sessionKey, session);
	        });
	    } else {
	      assert(!httpSocket, 'httpSocket can only be sent on TLS update');
	      socket = net.connect({
	        highWaterMark: 64 * 1024, // Same as nodejs fs streams.
	        ...options,
	        localAddress,
	        port: port || 80,
	        host: hostname
	      });
	    }

	    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket
	    if (options.keepAlive == null || options.keepAlive) {
	      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;
	      socket.setKeepAlive(true, keepAliveInitialDelay);
	    }

	    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);

	    socket
	      .setNoDelay(true)
	      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
	        cancelTimeout();

	        if (callback) {
	          const cb = callback;
	          callback = null;
	          cb(null, this);
	        }
	      })
	      .on('error', function (err) {
	        cancelTimeout();

	        if (callback) {
	          const cb = callback;
	          callback = null;
	          cb(err);
	        }
	      });

	    return socket
	  }
	}

	function setupTimeout (onConnectTimeout, timeout) {
	  if (!timeout) {
	    return () => {}
	  }

	  let s1 = null;
	  let s2 = null;
	  const timeoutId = setTimeout(() => {
	    // setImmediate is added to make sure that we priotorise socket error events over timeouts
	    s1 = setImmediate(() => {
	      if (process.platform === 'win32') {
	        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic
	        s2 = setImmediate(() => onConnectTimeout());
	      } else {
	        onConnectTimeout();
	      }
	    });
	  }, timeout);
	  return () => {
	    clearTimeout(timeoutId);
	    clearImmediate(s1);
	    clearImmediate(s2);
	  }
	}

	function onConnectTimeout (socket) {
	  util.destroy(socket, new ConnectTimeoutError());
	}

	connect = buildConnector;
	return connect;
}

var constants$2 = {};

var utils$2 = {};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	Object.defineProperty(utils$2, "__esModule", { value: true });
	utils$2.enumToMap = void 0;
	function enumToMap(obj) {
	    const res = {};
	    Object.keys(obj).forEach((key) => {
	        const value = obj[key];
	        if (typeof value === 'number') {
	            res[key] = value;
	        }
	    });
	    return res;
	}
	utils$2.enumToMap = enumToMap;
	
	return utils$2;
}

var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
		const utils_1 = requireUtils$2();
		(function (ERROR) {
		    ERROR[ERROR["OK"] = 0] = "OK";
		    ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		    ERROR[ERROR["STRICT"] = 2] = "STRICT";
		    ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		    ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		    ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		    ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		    ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		    ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		    ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		    ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		    ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		    ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		    ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		    ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		    ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		    ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		    ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		    ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		    ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		    ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		    ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		    ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		    ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		    ERROR[ERROR["USER"] = 24] = "USER";
		})(exports.ERROR || (exports.ERROR = {}));
		(function (TYPE) {
		    TYPE[TYPE["BOTH"] = 0] = "BOTH";
		    TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		    TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
		})(exports.TYPE || (exports.TYPE = {}));
		(function (FLAGS) {
		    FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		    FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		    FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		    FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		    FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		    FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		    FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		    FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		    // 1 << 8 is unused
		    FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
		})(exports.FLAGS || (exports.FLAGS = {}));
		(function (LENIENT_FLAGS) {
		    LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		    LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		    LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
		})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
		var METHODS;
		(function (METHODS) {
		    METHODS[METHODS["DELETE"] = 0] = "DELETE";
		    METHODS[METHODS["GET"] = 1] = "GET";
		    METHODS[METHODS["HEAD"] = 2] = "HEAD";
		    METHODS[METHODS["POST"] = 3] = "POST";
		    METHODS[METHODS["PUT"] = 4] = "PUT";
		    /* pathological */
		    METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
		    METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
		    METHODS[METHODS["TRACE"] = 7] = "TRACE";
		    /* WebDAV */
		    METHODS[METHODS["COPY"] = 8] = "COPY";
		    METHODS[METHODS["LOCK"] = 9] = "LOCK";
		    METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
		    METHODS[METHODS["MOVE"] = 11] = "MOVE";
		    METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
		    METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
		    METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
		    METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
		    METHODS[METHODS["BIND"] = 16] = "BIND";
		    METHODS[METHODS["REBIND"] = 17] = "REBIND";
		    METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
		    METHODS[METHODS["ACL"] = 19] = "ACL";
		    /* subversion */
		    METHODS[METHODS["REPORT"] = 20] = "REPORT";
		    METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
		    METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
		    METHODS[METHODS["MERGE"] = 23] = "MERGE";
		    /* upnp */
		    METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
		    METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
		    METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		    METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		    /* RFC-5789 */
		    METHODS[METHODS["PATCH"] = 28] = "PATCH";
		    METHODS[METHODS["PURGE"] = 29] = "PURGE";
		    /* CalDAV */
		    METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
		    /* RFC-2068, section 19.6.1.2 */
		    METHODS[METHODS["LINK"] = 31] = "LINK";
		    METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
		    /* icecast */
		    METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
		    /* RFC-7540, section 11.6 */
		    METHODS[METHODS["PRI"] = 34] = "PRI";
		    /* RFC-2326 RTSP */
		    METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
		    METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
		    METHODS[METHODS["SETUP"] = 37] = "SETUP";
		    METHODS[METHODS["PLAY"] = 38] = "PLAY";
		    METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
		    METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
		    METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		    METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		    METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
		    METHODS[METHODS["RECORD"] = 44] = "RECORD";
		    /* RAOP */
		    METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
		})(METHODS = exports.METHODS || (exports.METHODS = {}));
		exports.METHODS_HTTP = [
		    METHODS.DELETE,
		    METHODS.GET,
		    METHODS.HEAD,
		    METHODS.POST,
		    METHODS.PUT,
		    METHODS.CONNECT,
		    METHODS.OPTIONS,
		    METHODS.TRACE,
		    METHODS.COPY,
		    METHODS.LOCK,
		    METHODS.MKCOL,
		    METHODS.MOVE,
		    METHODS.PROPFIND,
		    METHODS.PROPPATCH,
		    METHODS.SEARCH,
		    METHODS.UNLOCK,
		    METHODS.BIND,
		    METHODS.REBIND,
		    METHODS.UNBIND,
		    METHODS.ACL,
		    METHODS.REPORT,
		    METHODS.MKACTIVITY,
		    METHODS.CHECKOUT,
		    METHODS.MERGE,
		    METHODS['M-SEARCH'],
		    METHODS.NOTIFY,
		    METHODS.SUBSCRIBE,
		    METHODS.UNSUBSCRIBE,
		    METHODS.PATCH,
		    METHODS.PURGE,
		    METHODS.MKCALENDAR,
		    METHODS.LINK,
		    METHODS.UNLINK,
		    METHODS.PRI,
		    // TODO(indutny): should we allow it with HTTP?
		    METHODS.SOURCE,
		];
		exports.METHODS_ICE = [
		    METHODS.SOURCE,
		];
		exports.METHODS_RTSP = [
		    METHODS.OPTIONS,
		    METHODS.DESCRIBE,
		    METHODS.ANNOUNCE,
		    METHODS.SETUP,
		    METHODS.PLAY,
		    METHODS.PAUSE,
		    METHODS.TEARDOWN,
		    METHODS.GET_PARAMETER,
		    METHODS.SET_PARAMETER,
		    METHODS.REDIRECT,
		    METHODS.RECORD,
		    METHODS.FLUSH,
		    // For AirPlay
		    METHODS.GET,
		    METHODS.POST,
		];
		exports.METHOD_MAP = utils_1.enumToMap(METHODS);
		exports.H_METHOD_MAP = {};
		Object.keys(exports.METHOD_MAP).forEach((key) => {
		    if (/^H/.test(key)) {
		        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
		    }
		});
		(function (FINISH) {
		    FINISH[FINISH["SAFE"] = 0] = "SAFE";
		    FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		    FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
		})(exports.FINISH || (exports.FINISH = {}));
		exports.ALPHA = [];
		for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
		    // Upper case
		    exports.ALPHA.push(String.fromCharCode(i));
		    // Lower case
		    exports.ALPHA.push(String.fromCharCode(i + 0x20));
		}
		exports.NUM_MAP = {
		    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
		    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
		};
		exports.HEX_MAP = {
		    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
		    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
		    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,
		    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,
		};
		exports.NUM = [
		    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		];
		exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
		exports.MARK = ['-', '_', '.', '!', '~', '*', '\'', '(', ')'];
		exports.USERINFO_CHARS = exports.ALPHANUM
		    .concat(exports.MARK)
		    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);
		// TODO(indutny): use RFC
		exports.STRICT_URL_CHAR = [
		    '!', '"', '$', '%', '&', '\'',
		    '(', ')', '*', '+', ',', '-', '.', '/',
		    ':', ';', '<', '=', '>',
		    '@', '[', '\\', ']', '^', '_',
		    '`',
		    '{', '|', '}', '~',
		].concat(exports.ALPHANUM);
		exports.URL_CHAR = exports.STRICT_URL_CHAR
		    .concat(['\t', '\f']);
		// All characters with 0x80 bit set to 1
		for (let i = 0x80; i <= 0xff; i++) {
		    exports.URL_CHAR.push(i);
		}
		exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
		/* Tokens as defined by rfc 2616. Also lowercases them.
		 *        token       = 1*<any CHAR except CTLs or separators>
		 *     separators     = "(" | ")" | "<" | ">" | "@"
		 *                    | "," | ";" | ":" | "\" | <">
		 *                    | "/" | "[" | "]" | "?" | "="
		 *                    | "{" | "}" | SP | HT
		 */
		exports.STRICT_TOKEN = [
		    '!', '#', '$', '%', '&', '\'',
		    '*', '+', '-', '.',
		    '^', '_', '`',
		    '|', '~',
		].concat(exports.ALPHANUM);
		exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
		/*
		 * Verify that a char is a valid visible (printable) US-ASCII
		 * character or %x80-FF
		 */
		exports.HEADER_CHARS = ['\t'];
		for (let i = 32; i <= 255; i++) {
		    if (i !== 127) {
		        exports.HEADER_CHARS.push(i);
		    }
		}
		// ',' = \x44
		exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
		exports.MAJOR = exports.NUM_MAP;
		exports.MINOR = exports.MAJOR;
		var HEADER_STATE;
		(function (HEADER_STATE) {
		    HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
		    HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
		    HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		    HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
		})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
		exports.SPECIAL_HEADERS = {
		    'connection': HEADER_STATE.CONNECTION,
		    'content-length': HEADER_STATE.CONTENT_LENGTH,
		    'proxy-connection': HEADER_STATE.CONNECTION,
		    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
		    'upgrade': HEADER_STATE.UPGRADE,
		};
		
	} (constants$2));
	return constants$2;
}

var RedirectHandler_1;
var hasRequiredRedirectHandler;

function requireRedirectHandler () {
	if (hasRequiredRedirectHandler) return RedirectHandler_1;
	hasRequiredRedirectHandler = 1;

	const util = requireUtil$6();
	const { kBodyUsed } = requireSymbols$4();
	const assert = require$$0$2;
	const { InvalidArgumentError } = requireErrors();
	const EE = require$$4$1;

	const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];

	const kBody = Symbol('body');

	class BodyAsyncIterable {
	  constructor (body) {
	    this[kBody] = body;
	    this[kBodyUsed] = false;
	  }

	  async * [Symbol.asyncIterator] () {
	    assert(!this[kBodyUsed], 'disturbed');
	    this[kBodyUsed] = true;
	    yield * this[kBody];
	  }
	}

	class RedirectHandler {
	  constructor (dispatch, maxRedirections, opts, handler) {
	    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    util.validateHandler(handler, opts.method, opts.upgrade);

	    this.dispatch = dispatch;
	    this.location = null;
	    this.abort = null;
	    this.opts = { ...opts, maxRedirections: 0 }; // opts must be a copy
	    this.maxRedirections = maxRedirections;
	    this.handler = handler;
	    this.history = [];

	    if (util.isStream(this.opts.body)) {
	      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
	      // so that it can be dispatched again?
	      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?
	      if (util.bodyLength(this.opts.body) === 0) {
	        this.opts.body
	          .on('data', function () {
	            assert(false);
	          });
	      }

	      if (typeof this.opts.body.readableDidRead !== 'boolean') {
	        this.opts.body[kBodyUsed] = false;
	        EE.prototype.on.call(this.opts.body, 'data', function () {
	          this[kBodyUsed] = true;
	        });
	      }
	    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
	      // TODO (fix): We can't access ReadableStream internal state
	      // to determine whether or not it has been disturbed. This is just
	      // a workaround.
	      this.opts.body = new BodyAsyncIterable(this.opts.body);
	    } else if (
	      this.opts.body &&
	      typeof this.opts.body !== 'string' &&
	      !ArrayBuffer.isView(this.opts.body) &&
	      util.isIterable(this.opts.body)
	    ) {
	      // TODO: Should we allow re-using iterable if !this.opts.idempotent
	      // or through some other flag?
	      this.opts.body = new BodyAsyncIterable(this.opts.body);
	    }
	  }

	  onConnect (abort) {
	    this.abort = abort;
	    this.handler.onConnect(abort, { history: this.history });
	  }

	  onUpgrade (statusCode, headers, socket) {
	    this.handler.onUpgrade(statusCode, headers, socket);
	  }

	  onError (error) {
	    this.handler.onError(error);
	  }

	  onHeaders (statusCode, headers, resume, statusText) {
	    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
	      ? null
	      : parseLocation(statusCode, headers);

	    if (this.opts.origin) {
	      this.history.push(new URL(this.opts.path, this.opts.origin));
	    }

	    if (!this.location) {
	      return this.handler.onHeaders(statusCode, headers, resume, statusText)
	    }

	    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
	    const path = search ? `${pathname}${search}` : pathname;

	    // Remove headers referring to the original URL.
	    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
	    // https://tools.ietf.org/html/rfc7231#section-6.4
	    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
	    this.opts.path = path;
	    this.opts.origin = origin;
	    this.opts.maxRedirections = 0;
	    this.opts.query = null;

	    // https://tools.ietf.org/html/rfc7231#section-6.4.4
	    // In case of HTTP 303, always replace method to be either HEAD or GET
	    if (statusCode === 303 && this.opts.method !== 'HEAD') {
	      this.opts.method = 'GET';
	      this.opts.body = null;
	    }
	  }

	  onData (chunk) {
	    if (this.location) ; else {
	      return this.handler.onData(chunk)
	    }
	  }

	  onComplete (trailers) {
	    if (this.location) {
	      /*
	        https://tools.ietf.org/html/rfc7231#section-6.4

	        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
	        and neither are useful if present.

	        See comment on onData method above for more detailed informations.
	      */

	      this.location = null;
	      this.abort = null;

	      this.dispatch(this.opts, this);
	    } else {
	      this.handler.onComplete(trailers);
	    }
	  }

	  onBodySent (chunk) {
	    if (this.handler.onBodySent) {
	      this.handler.onBodySent(chunk);
	    }
	  }
	}

	function parseLocation (statusCode, headers) {
	  if (redirectableStatusCodes.indexOf(statusCode) === -1) {
	    return null
	  }

	  for (let i = 0; i < headers.length; i += 2) {
	    if (headers[i].toString().toLowerCase() === 'location') {
	      return headers[i + 1]
	    }
	  }
	}

	// https://tools.ietf.org/html/rfc7231#section-6.4.4
	function shouldRemoveHeader (header, removeContent, unknownOrigin) {
	  if (header.length === 4) {
	    return util.headerNameToString(header) === 'host'
	  }
	  if (removeContent && util.headerNameToString(header).startsWith('content-')) {
	    return true
	  }
	  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
	    const name = util.headerNameToString(header);
	    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'
	  }
	  return false
	}

	// https://tools.ietf.org/html/rfc7231#section-6.4
	function cleanRequestHeaders (headers, removeContent, unknownOrigin) {
	  const ret = [];
	  if (Array.isArray(headers)) {
	    for (let i = 0; i < headers.length; i += 2) {
	      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
	        ret.push(headers[i], headers[i + 1]);
	      }
	    }
	  } else if (headers && typeof headers === 'object') {
	    for (const key of Object.keys(headers)) {
	      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
	        ret.push(key, headers[key]);
	      }
	    }
	  } else {
	    assert(headers == null, 'headers must be an object or an array');
	  }
	  return ret
	}

	RedirectHandler_1 = RedirectHandler;
	return RedirectHandler_1;
}

var redirectInterceptor;
var hasRequiredRedirectInterceptor;

function requireRedirectInterceptor () {
	if (hasRequiredRedirectInterceptor) return redirectInterceptor;
	hasRequiredRedirectInterceptor = 1;

	const RedirectHandler = requireRedirectHandler();

	function createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {
	  return (dispatch) => {
	    return function Intercept (opts, handler) {
	      const { maxRedirections = defaultMaxRedirections } = opts;

	      if (!maxRedirections) {
	        return dispatch(opts, handler)
	      }

	      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
	      opts = { ...opts, maxRedirections: 0 }; // Stop sub dispatcher from also redirecting.
	      return dispatch(opts, redirectHandler)
	    }
	  }
	}

	redirectInterceptor = createRedirectInterceptor;
	return redirectInterceptor;
}

var llhttpWasm;
var hasRequiredLlhttpWasm;

function requireLlhttpWasm () {
	if (hasRequiredLlhttpWasm) return llhttpWasm;
	hasRequiredLlhttpWasm = 1;
	llhttpWasm = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=';
	return llhttpWasm;
}

var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;

function requireLlhttp_simdWasm () {
	if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
	hasRequiredLlhttp_simdWasm = 1;
	llhttp_simdWasm = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==';
	return llhttp_simdWasm;
}

var client;
var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client;
	hasRequiredClient = 1;

	/* global WebAssembly */

	const assert = require$$0$2;
	const net = require$$0$5;
	const http = require$$2$1;
	const { pipeline } = require$$1;
	const util = requireUtil$6();
	const timers = requireTimers();
	const Request = requireRequest$1();
	const DispatcherBase = requireDispatcherBase();
	const {
	  RequestContentLengthMismatchError,
	  ResponseContentLengthMismatchError,
	  InvalidArgumentError,
	  RequestAbortedError,
	  HeadersTimeoutError,
	  HeadersOverflowError,
	  SocketError,
	  InformationalError,
	  BodyTimeoutError,
	  HTTPParserError,
	  ResponseExceededMaxSizeError,
	  ClientDestroyedError
	} = requireErrors();
	const buildConnector = requireConnect();
	const {
	  kUrl,
	  kReset,
	  kServerName,
	  kClient,
	  kBusy,
	  kParser,
	  kConnect,
	  kBlocking,
	  kResuming,
	  kRunning,
	  kPending,
	  kSize,
	  kWriting,
	  kQueue,
	  kConnected,
	  kConnecting,
	  kNeedDrain,
	  kNoRef,
	  kKeepAliveDefaultTimeout,
	  kHostHeader,
	  kPendingIdx,
	  kRunningIdx,
	  kError,
	  kPipelining,
	  kSocket,
	  kKeepAliveTimeoutValue,
	  kMaxHeadersSize,
	  kKeepAliveMaxTimeout,
	  kKeepAliveTimeoutThreshold,
	  kHeadersTimeout,
	  kBodyTimeout,
	  kStrictContentLength,
	  kConnector,
	  kMaxRedirections,
	  kMaxRequests,
	  kCounter,
	  kClose,
	  kDestroy,
	  kDispatch,
	  kInterceptors,
	  kLocalAddress,
	  kMaxResponseSize,
	  kHTTPConnVersion,
	  // HTTP2
	  kHost,
	  kHTTP2Session,
	  kHTTP2SessionState,
	  kHTTP2BuildRequest,
	  kHTTP2CopyHeaders,
	  kHTTP1BuildRequest
	} = requireSymbols$4();

	/** @type {import('http2')} */
	let http2;
	try {
	  http2 = require('http2');
	} catch {
	  // @ts-ignore
	  http2 = { constants: {} };
	}

	const {
	  constants: {
	    HTTP2_HEADER_AUTHORITY,
	    HTTP2_HEADER_METHOD,
	    HTTP2_HEADER_PATH,
	    HTTP2_HEADER_SCHEME,
	    HTTP2_HEADER_CONTENT_LENGTH,
	    HTTP2_HEADER_EXPECT,
	    HTTP2_HEADER_STATUS
	  }
	} = http2;

	// Experimental
	let h2ExperimentalWarned = false;

	const FastBuffer = Buffer[Symbol.species];

	const kClosedResolve = Symbol('kClosedResolve');

	const channels = {};

	try {
	  const diagnosticsChannel = require('diagnostics_channel');
	  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');
	  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');
	  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');
	  channels.connected = diagnosticsChannel.channel('undici:client:connected');
	} catch {
	  channels.sendHeaders = { hasSubscribers: false };
	  channels.beforeConnect = { hasSubscribers: false };
	  channels.connectError = { hasSubscribers: false };
	  channels.connected = { hasSubscribers: false };
	}

	/**
	 * @type {import('../types/client').default}
	 */
	class Client extends DispatcherBase {
	  /**
	   *
	   * @param {string|URL} url
	   * @param {import('../types/client').Client.Options} options
	   */
	  constructor (url, {
	    interceptors,
	    maxHeaderSize,
	    headersTimeout,
	    socketTimeout,
	    requestTimeout,
	    connectTimeout,
	    bodyTimeout,
	    idleTimeout,
	    keepAlive,
	    keepAliveTimeout,
	    maxKeepAliveTimeout,
	    keepAliveMaxTimeout,
	    keepAliveTimeoutThreshold,
	    socketPath,
	    pipelining,
	    tls,
	    strictContentLength,
	    maxCachedSessions,
	    maxRedirections,
	    connect,
	    maxRequestsPerClient,
	    localAddress,
	    maxResponseSize,
	    autoSelectFamily,
	    autoSelectFamilyAttemptTimeout,
	    // h2
	    allowH2,
	    maxConcurrentStreams
	  } = {}) {
	    super();

	    if (keepAlive !== undefined) {
	      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')
	    }

	    if (socketTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')
	    }

	    if (requestTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')
	    }

	    if (idleTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')
	    }

	    if (maxKeepAliveTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')
	    }

	    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
	      throw new InvalidArgumentError('invalid maxHeaderSize')
	    }

	    if (socketPath != null && typeof socketPath !== 'string') {
	      throw new InvalidArgumentError('invalid socketPath')
	    }

	    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
	      throw new InvalidArgumentError('invalid connectTimeout')
	    }

	    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
	      throw new InvalidArgumentError('invalid keepAliveTimeout')
	    }

	    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
	      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')
	    }

	    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
	      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')
	    }

	    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
	      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')
	    }

	    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
	      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
	      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')
	    }

	    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {
	      throw new InvalidArgumentError('localAddress must be valid string IP address')
	    }

	    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
	      throw new InvalidArgumentError('maxResponseSize must be a positive number')
	    }

	    if (
	      autoSelectFamilyAttemptTimeout != null &&
	      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)
	    ) {
	      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')
	    }

	    // h2
	    if (allowH2 != null && typeof allowH2 !== 'boolean') {
	      throw new InvalidArgumentError('allowH2 must be a valid boolean value')
	    }

	    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {
	      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0')
	    }

	    if (typeof connect !== 'function') {
	      connect = buildConnector({
	        ...tls,
	        maxCachedSessions,
	        allowH2,
	        socketPath,
	        timeout: connectTimeout,
	        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
	        ...connect
	      });
	    }

	    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)
	      ? interceptors.Client
	      : [createRedirectInterceptor({ maxRedirections })];
	    this[kUrl] = util.parseOrigin(url);
	    this[kConnector] = connect;
	    this[kSocket] = null;
	    this[kPipelining] = pipelining != null ? pipelining : 1;
	    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
	    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
	    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;
	    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
	    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
	    this[kServerName] = null;
	    this[kLocalAddress] = localAddress != null ? localAddress : null;
	    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming
	    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming
	    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`;
	    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;
	    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;
	    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
	    this[kMaxRedirections] = maxRedirections;
	    this[kMaxRequests] = maxRequestsPerClient;
	    this[kClosedResolve] = null;
	    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
	    this[kHTTPConnVersion] = 'h1';

	    // HTTP/2
	    this[kHTTP2Session] = null;
	    this[kHTTP2SessionState] = !allowH2
	      ? null
	      : {
	        // streams: null, // Fixed queue of streams - For future support of `push`
	          openStreams: 0, // Keep track of them to decide wether or not unref the session
	          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server
	        };
	    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`;

	    // kQueue is built up of 3 sections separated by
	    // the kRunningIdx and kPendingIdx indices.
	    // |   complete   |   running   |   pending   |
	    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
	    // kRunningIdx points to the first running element.
	    // kPendingIdx points to the first pending element.
	    // This implements a fast queue with an amortized
	    // time of O(1).

	    this[kQueue] = [];
	    this[kRunningIdx] = 0;
	    this[kPendingIdx] = 0;
	  }

	  get pipelining () {
	    return this[kPipelining]
	  }

	  set pipelining (value) {
	    this[kPipelining] = value;
	    resume(this, true);
	  }

	  get [kPending] () {
	    return this[kQueue].length - this[kPendingIdx]
	  }

	  get [kRunning] () {
	    return this[kPendingIdx] - this[kRunningIdx]
	  }

	  get [kSize] () {
	    return this[kQueue].length - this[kRunningIdx]
	  }

	  get [kConnected] () {
	    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed
	  }

	  get [kBusy] () {
	    const socket = this[kSocket];
	    return (
	      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
	      (this[kSize] >= (this[kPipelining] || 1)) ||
	      this[kPending] > 0
	    )
	  }

	  /* istanbul ignore: only used for test */
	  [kConnect] (cb) {
	    connect(this);
	    this.once('connect', cb);
	  }

	  [kDispatch] (opts, handler) {
	    const origin = opts.origin || this[kUrl].origin;

	    const request = this[kHTTPConnVersion] === 'h2'
	      ? Request[kHTTP2BuildRequest](origin, opts, handler)
	      : Request[kHTTP1BuildRequest](origin, opts, handler);

	    this[kQueue].push(request);
	    if (this[kResuming]) ; else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
	      // Wait a tick in case stream/iterator is ended in the same tick.
	      this[kResuming] = 1;
	      process.nextTick(resume, this);
	    } else {
	      resume(this, true);
	    }

	    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
	      this[kNeedDrain] = 2;
	    }

	    return this[kNeedDrain] < 2
	  }

	  async [kClose] () {
	    // TODO: for H2 we need to gracefully flush the remaining enqueued
	    // request and close each stream.
	    return new Promise((resolve) => {
	      if (!this[kSize]) {
	        resolve(null);
	      } else {
	        this[kClosedResolve] = resolve;
	      }
	    })
	  }

	  async [kDestroy] (err) {
	    return new Promise((resolve) => {
	      const requests = this[kQueue].splice(this[kPendingIdx]);
	      for (let i = 0; i < requests.length; i++) {
	        const request = requests[i];
	        errorRequest(this, request, err);
	      }

	      const callback = () => {
	        if (this[kClosedResolve]) {
	          // TODO (fix): Should we error here with ClientDestroyedError?
	          this[kClosedResolve]();
	          this[kClosedResolve] = null;
	        }
	        resolve();
	      };

	      if (this[kHTTP2Session] != null) {
	        util.destroy(this[kHTTP2Session], err);
	        this[kHTTP2Session] = null;
	        this[kHTTP2SessionState] = null;
	      }

	      if (!this[kSocket]) {
	        queueMicrotask(callback);
	      } else {
	        util.destroy(this[kSocket].on('close', callback), err);
	      }

	      resume(this);
	    })
	  }
	}

	function onHttp2SessionError (err) {
	  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');

	  this[kSocket][kError] = err;

	  onError(this[kClient], err);
	}

	function onHttp2FrameError (type, code, id) {
	  const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);

	  if (id === 0) {
	    this[kSocket][kError] = err;
	    onError(this[kClient], err);
	  }
	}

	function onHttp2SessionEnd () {
	  util.destroy(this, new SocketError('other side closed'));
	  util.destroy(this[kSocket], new SocketError('other side closed'));
	}

	function onHTTP2GoAway (code) {
	  const client = this[kClient];
	  const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
	  client[kSocket] = null;
	  client[kHTTP2Session] = null;

	  if (client.destroyed) {
	    assert(this[kPending] === 0);

	    // Fail entire queue.
	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(this, request, err);
	    }
	  } else if (client[kRunning] > 0) {
	    // Fail head of pipeline.
	    const request = client[kQueue][client[kRunningIdx]];
	    client[kQueue][client[kRunningIdx]++] = null;

	    errorRequest(client, request, err);
	  }

	  client[kPendingIdx] = client[kRunningIdx];

	  assert(client[kRunning] === 0);

	  client.emit('disconnect',
	    client[kUrl],
	    [client],
	    err
	  );

	  resume(client);
	}

	const constants = requireConstants$2();
	const createRedirectInterceptor = requireRedirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);

	async function lazyllhttp () {
	  const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : undefined;

	  let mod;
	  try {
	    mod = await WebAssembly.compile(Buffer.from(requireLlhttp_simdWasm(), 'base64'));
	  } catch (e) {
	    /* istanbul ignore next */

	    // We could check if the error was caused by the simd option not
	    // being enabled, but the occurring of this other error
	    // * https://github.com/emscripten-core/emscripten/issues/11495
	    // got me to remove that check to avoid breaking Node 12.
	    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || requireLlhttpWasm(), 'base64'));
	  }

	  return await WebAssembly.instantiate(mod, {
	    env: {
	      /* eslint-disable camelcase */

	      wasm_on_url: (p, at, len) => {
	        /* istanbul ignore next */
	        return 0
	      },
	      wasm_on_status: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_message_begin: (p) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onMessageBegin() || 0
	      },
	      wasm_on_header_field: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_header_value: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0
	      },
	      wasm_on_body: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_message_complete: (p) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onMessageComplete() || 0
	      }

	      /* eslint-enable camelcase */
	    }
	  })
	}

	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();

	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;

	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;

	class Parser {
	  constructor (client, socket, { exports }) {
	    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);

	    this.llhttp = exports;
	    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
	    this.client = client;
	    this.socket = socket;
	    this.timeout = null;
	    this.timeoutValue = null;
	    this.timeoutType = null;
	    this.statusCode = null;
	    this.statusText = '';
	    this.upgrade = false;
	    this.headers = [];
	    this.headersSize = 0;
	    this.headersMaxSize = client[kMaxHeadersSize];
	    this.shouldKeepAlive = false;
	    this.paused = false;
	    this.resume = this.resume.bind(this);

	    this.bytesRead = 0;

	    this.keepAlive = '';
	    this.contentLength = '';
	    this.connection = '';
	    this.maxResponseSize = client[kMaxResponseSize];
	  }

	  setTimeout (value, type) {
	    this.timeoutType = type;
	    if (value !== this.timeoutValue) {
	      timers.clearTimeout(this.timeout);
	      if (value) {
	        this.timeout = timers.setTimeout(onParserTimeout, value, this);
	        // istanbul ignore else: only for jest
	        if (this.timeout.unref) {
	          this.timeout.unref();
	        }
	      } else {
	        this.timeout = null;
	      }
	      this.timeoutValue = value;
	    } else if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }
	  }

	  resume () {
	    if (this.socket.destroyed || !this.paused) {
	      return
	    }

	    assert(this.ptr != null);
	    assert(currentParser == null);

	    this.llhttp.llhttp_resume(this.ptr);

	    assert(this.timeoutType === TIMEOUT_BODY);
	    if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    this.paused = false;
	    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.
	    this.readMore();
	  }

	  readMore () {
	    while (!this.paused && this.ptr) {
	      const chunk = this.socket.read();
	      if (chunk === null) {
	        break
	      }
	      this.execute(chunk);
	    }
	  }

	  execute (data) {
	    assert(this.ptr != null);
	    assert(currentParser == null);
	    assert(!this.paused);

	    const { socket, llhttp } = this;

	    if (data.length > currentBufferSize) {
	      if (currentBufferPtr) {
	        llhttp.free(currentBufferPtr);
	      }
	      currentBufferSize = Math.ceil(data.length / 4096) * 4096;
	      currentBufferPtr = llhttp.malloc(currentBufferSize);
	    }

	    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);

	    // Call `execute` on the wasm parser.
	    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
	    // and finally the length of bytes to parse.
	    // The return value is an error code or `constants.ERROR.OK`.
	    try {
	      let ret;

	      try {
	        currentBufferRef = data;
	        currentParser = this;
	        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
	        /* eslint-disable-next-line no-useless-catch */
	      } catch (err) {
	        /* istanbul ignore next: difficult to make a test case for */
	        throw err
	      } finally {
	        currentParser = null;
	        currentBufferRef = null;
	      }

	      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;

	      if (ret === constants.ERROR.PAUSED_UPGRADE) {
	        this.onUpgrade(data.slice(offset));
	      } else if (ret === constants.ERROR.PAUSED) {
	        this.paused = true;
	        socket.unshift(data.slice(offset));
	      } else if (ret !== constants.ERROR.OK) {
	        const ptr = llhttp.llhttp_get_error_reason(this.ptr);
	        let message = '';
	        /* istanbul ignore else: difficult to make a test case for */
	        if (ptr) {
	          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
	          message =
	            'Response does not match the HTTP/1.1 protocol (' +
	            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
	            ')';
	        }
	        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))
	      }
	    } catch (err) {
	      util.destroy(socket, err);
	    }
	  }

	  destroy () {
	    assert(this.ptr != null);
	    assert(currentParser == null);

	    this.llhttp.llhttp_free(this.ptr);
	    this.ptr = null;

	    timers.clearTimeout(this.timeout);
	    this.timeout = null;
	    this.timeoutValue = null;
	    this.timeoutType = null;

	    this.paused = false;
	  }

	  onStatus (buf) {
	    this.statusText = buf.toString();
	  }

	  onMessageBegin () {
	    const { socket, client } = this;

	    /* istanbul ignore next: difficult to make a test case for */
	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    if (!request) {
	      return -1
	    }
	  }

	  onHeaderField (buf) {
	    const len = this.headers.length;

	    if ((len & 1) === 0) {
	      this.headers.push(buf);
	    } else {
	      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
	    }

	    this.trackHeader(buf.length);
	  }

	  onHeaderValue (buf) {
	    let len = this.headers.length;

	    if ((len & 1) === 1) {
	      this.headers.push(buf);
	      len += 1;
	    } else {
	      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
	    }

	    const key = this.headers[len - 2];
	    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {
	      this.keepAlive += buf.toString();
	    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {
	      this.connection += buf.toString();
	    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {
	      this.contentLength += buf.toString();
	    }

	    this.trackHeader(buf.length);
	  }

	  trackHeader (len) {
	    this.headersSize += len;
	    if (this.headersSize >= this.headersMaxSize) {
	      util.destroy(this.socket, new HeadersOverflowError());
	    }
	  }

	  onUpgrade (head) {
	    const { upgrade, client, socket, headers, statusCode } = this;

	    assert(upgrade);

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert(!socket.destroyed);
	    assert(socket === client[kSocket]);
	    assert(!this.paused);
	    assert(request.upgrade || request.method === 'CONNECT');

	    this.statusCode = null;
	    this.statusText = '';
	    this.shouldKeepAlive = null;

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    socket.unshift(head);

	    socket[kParser].destroy();
	    socket[kParser] = null;

	    socket[kClient] = null;
	    socket[kError] = null;
	    socket
	      .removeListener('error', onSocketError)
	      .removeListener('readable', onSocketReadable)
	      .removeListener('end', onSocketEnd)
	      .removeListener('close', onSocketClose);

	    client[kSocket] = null;
	    client[kQueue][client[kRunningIdx]++] = null;
	    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));

	    try {
	      request.onUpgrade(statusCode, headers, socket);
	    } catch (err) {
	      util.destroy(socket, err);
	    }

	    resume(client);
	  }

	  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {
	    const { client, socket, headers, statusText } = this;

	    /* istanbul ignore next: difficult to make a test case for */
	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];

	    /* istanbul ignore next: difficult to make a test case for */
	    if (!request) {
	      return -1
	    }

	    assert(!this.upgrade);
	    assert(this.statusCode < 200);

	    if (statusCode === 100) {
	      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));
	      return -1
	    }

	    /* this can only happen if server is misbehaving */
	    if (upgrade && !request.upgrade) {
	      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));
	      return -1
	    }

	    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);

	    this.statusCode = statusCode;
	    this.shouldKeepAlive = (
	      shouldKeepAlive ||
	      // Override llhttp value which does not allow keepAlive for HEAD.
	      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')
	    );

	    if (this.statusCode >= 200) {
	      const bodyTimeout = request.bodyTimeout != null
	        ? request.bodyTimeout
	        : client[kBodyTimeout];
	      this.setTimeout(bodyTimeout, TIMEOUT_BODY);
	    } else if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    if (request.method === 'CONNECT') {
	      assert(client[kRunning] === 1);
	      this.upgrade = true;
	      return 2
	    }

	    if (upgrade) {
	      assert(client[kRunning] === 1);
	      this.upgrade = true;
	      return 2
	    }

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    if (this.shouldKeepAlive && client[kPipelining]) {
	      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;

	      if (keepAliveTimeout != null) {
	        const timeout = Math.min(
	          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
	          client[kKeepAliveMaxTimeout]
	        );
	        if (timeout <= 0) {
	          socket[kReset] = true;
	        } else {
	          client[kKeepAliveTimeoutValue] = timeout;
	        }
	      } else {
	        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
	      }
	    } else {
	      // Stop more requests from being dispatched.
	      socket[kReset] = true;
	    }

	    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;

	    if (request.aborted) {
	      return -1
	    }

	    if (request.method === 'HEAD') {
	      return 1
	    }

	    if (statusCode < 200) {
	      return 1
	    }

	    if (socket[kBlocking]) {
	      socket[kBlocking] = false;
	      resume(client);
	    }

	    return pause ? constants.ERROR.PAUSED : 0
	  }

	  onBody (buf) {
	    const { client, socket, statusCode, maxResponseSize } = this;

	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
	    if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    assert(statusCode >= 200);

	    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
	      util.destroy(socket, new ResponseExceededMaxSizeError());
	      return -1
	    }

	    this.bytesRead += buf.length;

	    if (request.onData(buf) === false) {
	      return constants.ERROR.PAUSED
	    }
	  }

	  onMessageComplete () {
	    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;

	    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
	      return -1
	    }

	    if (upgrade) {
	      return
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert(statusCode >= 100);

	    this.statusCode = null;
	    this.statusText = '';
	    this.bytesRead = 0;
	    this.contentLength = '';
	    this.keepAlive = '';
	    this.connection = '';

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    if (statusCode < 200) {
	      return
	    }

	    /* istanbul ignore next: should be handled by llhttp? */
	    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
	      util.destroy(socket, new ResponseContentLengthMismatchError());
	      return -1
	    }

	    request.onComplete(headers);

	    client[kQueue][client[kRunningIdx]++] = null;

	    if (socket[kWriting]) {
	      assert.strictEqual(client[kRunning], 0);
	      // Response completed before request.
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (!shouldKeepAlive) {
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (socket[kReset] && client[kRunning] === 0) {
	      // Destroy socket once all requests have completed.
	      // The request at the tail of the pipeline is the one
	      // that requested reset and no further requests should
	      // have been queued since then.
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (client[kPipelining] === 1) {
	      // We must wait a full event loop cycle to reuse this socket to make sure
	      // that non-spec compliant servers are not closing the connection even if they
	      // said they won't.
	      setImmediate(resume, client);
	    } else {
	      resume(client);
	    }
	  }
	}

	function onParserTimeout (parser) {
	  const { socket, timeoutType, client } = parser;

	  /* istanbul ignore else */
	  if (timeoutType === TIMEOUT_HEADERS) {
	    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
	      assert(!parser.paused, 'cannot be paused while waiting for headers');
	      util.destroy(socket, new HeadersTimeoutError());
	    }
	  } else if (timeoutType === TIMEOUT_BODY) {
	    if (!parser.paused) {
	      util.destroy(socket, new BodyTimeoutError());
	    }
	  } else if (timeoutType === TIMEOUT_IDLE) {
	    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
	    util.destroy(socket, new InformationalError('socket idle timeout'));
	  }
	}

	function onSocketReadable () {
	  const { [kParser]: parser } = this;
	  if (parser) {
	    parser.readMore();
	  }
	}

	function onSocketError (err) {
	  const { [kClient]: client, [kParser]: parser } = this;

	  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');

	  if (client[kHTTPConnVersion] !== 'h2') {
	    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
	    // to the user.
	    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so for as a valid response.
	      parser.onMessageComplete();
	      return
	    }
	  }

	  this[kError] = err;

	  onError(this[kClient], err);
	}

	function onError (client, err) {
	  if (
	    client[kRunning] === 0 &&
	    err.code !== 'UND_ERR_INFO' &&
	    err.code !== 'UND_ERR_SOCKET'
	  ) {
	    // Error is not caused by running request and not a recoverable
	    // socket error.

	    assert(client[kPendingIdx] === client[kRunningIdx]);

	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(client, request, err);
	    }
	    assert(client[kSize] === 0);
	  }
	}

	function onSocketEnd () {
	  const { [kParser]: parser, [kClient]: client } = this;

	  if (client[kHTTPConnVersion] !== 'h2') {
	    if (parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so far as a valid response.
	      parser.onMessageComplete();
	      return
	    }
	  }

	  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
	}

	function onSocketClose () {
	  const { [kClient]: client, [kParser]: parser } = this;

	  if (client[kHTTPConnVersion] === 'h1' && parser) {
	    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so far as a valid response.
	      parser.onMessageComplete();
	    }

	    this[kParser].destroy();
	    this[kParser] = null;
	  }

	  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));

	  client[kSocket] = null;

	  if (client.destroyed) {
	    assert(client[kPending] === 0);

	    // Fail entire queue.
	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(client, request, err);
	    }
	  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
	    // Fail head of pipeline.
	    const request = client[kQueue][client[kRunningIdx]];
	    client[kQueue][client[kRunningIdx]++] = null;

	    errorRequest(client, request, err);
	  }

	  client[kPendingIdx] = client[kRunningIdx];

	  assert(client[kRunning] === 0);

	  client.emit('disconnect', client[kUrl], [client], err);

	  resume(client);
	}

	async function connect (client) {
	  assert(!client[kConnecting]);
	  assert(!client[kSocket]);

	  let { host, hostname, protocol, port } = client[kUrl];

	  // Resolve ipv6
	  if (hostname[0] === '[') {
	    const idx = hostname.indexOf(']');

	    assert(idx !== -1);
	    const ip = hostname.substring(1, idx);

	    assert(net.isIP(ip));
	    hostname = ip;
	  }

	  client[kConnecting] = true;

	  if (channels.beforeConnect.hasSubscribers) {
	    channels.beforeConnect.publish({
	      connectParams: {
	        host,
	        hostname,
	        protocol,
	        port,
	        servername: client[kServerName],
	        localAddress: client[kLocalAddress]
	      },
	      connector: client[kConnector]
	    });
	  }

	  try {
	    const socket = await new Promise((resolve, reject) => {
	      client[kConnector]({
	        host,
	        hostname,
	        protocol,
	        port,
	        servername: client[kServerName],
	        localAddress: client[kLocalAddress]
	      }, (err, socket) => {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(socket);
	        }
	      });
	    });

	    if (client.destroyed) {
	      util.destroy(socket.on('error', () => {}), new ClientDestroyedError());
	      return
	    }

	    client[kConnecting] = false;

	    assert(socket);

	    const isH2 = socket.alpnProtocol === 'h2';
	    if (isH2) {
	      if (!h2ExperimentalWarned) {
	        h2ExperimentalWarned = true;
	        process.emitWarning('H2 support is experimental, expect them to change at any time.', {
	          code: 'UNDICI-H2'
	        });
	      }

	      const session = http2.connect(client[kUrl], {
	        createConnection: () => socket,
	        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
	      });

	      client[kHTTPConnVersion] = 'h2';
	      session[kClient] = client;
	      session[kSocket] = socket;
	      session.on('error', onHttp2SessionError);
	      session.on('frameError', onHttp2FrameError);
	      session.on('end', onHttp2SessionEnd);
	      session.on('goaway', onHTTP2GoAway);
	      session.on('close', onSocketClose);
	      session.unref();

	      client[kHTTP2Session] = session;
	      socket[kHTTP2Session] = session;
	    } else {
	      if (!llhttpInstance) {
	        llhttpInstance = await llhttpPromise;
	        llhttpPromise = null;
	      }

	      socket[kNoRef] = false;
	      socket[kWriting] = false;
	      socket[kReset] = false;
	      socket[kBlocking] = false;
	      socket[kParser] = new Parser(client, socket, llhttpInstance);
	    }

	    socket[kCounter] = 0;
	    socket[kMaxRequests] = client[kMaxRequests];
	    socket[kClient] = client;
	    socket[kError] = null;

	    socket
	      .on('error', onSocketError)
	      .on('readable', onSocketReadable)
	      .on('end', onSocketEnd)
	      .on('close', onSocketClose);

	    client[kSocket] = socket;

	    if (channels.connected.hasSubscribers) {
	      channels.connected.publish({
	        connectParams: {
	          host,
	          hostname,
	          protocol,
	          port,
	          servername: client[kServerName],
	          localAddress: client[kLocalAddress]
	        },
	        connector: client[kConnector],
	        socket
	      });
	    }
	    client.emit('connect', client[kUrl], [client]);
	  } catch (err) {
	    if (client.destroyed) {
	      return
	    }

	    client[kConnecting] = false;

	    if (channels.connectError.hasSubscribers) {
	      channels.connectError.publish({
	        connectParams: {
	          host,
	          hostname,
	          protocol,
	          port,
	          servername: client[kServerName],
	          localAddress: client[kLocalAddress]
	        },
	        connector: client[kConnector],
	        error: err
	      });
	    }

	    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
	      assert(client[kRunning] === 0);
	      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
	        const request = client[kQueue][client[kPendingIdx]++];
	        errorRequest(client, request, err);
	      }
	    } else {
	      onError(client, err);
	    }

	    client.emit('connectionError', client[kUrl], [client], err);
	  }

	  resume(client);
	}

	function emitDrain (client) {
	  client[kNeedDrain] = 0;
	  client.emit('drain', client[kUrl], [client]);
	}

	function resume (client, sync) {
	  if (client[kResuming] === 2) {
	    return
	  }

	  client[kResuming] = 2;

	  _resume(client, sync);
	  client[kResuming] = 0;

	  if (client[kRunningIdx] > 256) {
	    client[kQueue].splice(0, client[kRunningIdx]);
	    client[kPendingIdx] -= client[kRunningIdx];
	    client[kRunningIdx] = 0;
	  }
	}

	function _resume (client, sync) {
	  while (true) {
	    if (client.destroyed) {
	      assert(client[kPending] === 0);
	      return
	    }

	    if (client[kClosedResolve] && !client[kSize]) {
	      client[kClosedResolve]();
	      client[kClosedResolve] = null;
	      return
	    }

	    const socket = client[kSocket];

	    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {
	      if (client[kSize] === 0) {
	        if (!socket[kNoRef] && socket.unref) {
	          socket.unref();
	          socket[kNoRef] = true;
	        }
	      } else if (socket[kNoRef] && socket.ref) {
	        socket.ref();
	        socket[kNoRef] = false;
	      }

	      if (client[kSize] === 0) {
	        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
	          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
	        }
	      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
	        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
	          const request = client[kQueue][client[kRunningIdx]];
	          const headersTimeout = request.headersTimeout != null
	            ? request.headersTimeout
	            : client[kHeadersTimeout];
	          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
	        }
	      }
	    }

	    if (client[kBusy]) {
	      client[kNeedDrain] = 2;
	    } else if (client[kNeedDrain] === 2) {
	      if (sync) {
	        client[kNeedDrain] = 1;
	        process.nextTick(emitDrain, client);
	      } else {
	        emitDrain(client);
	      }
	      continue
	    }

	    if (client[kPending] === 0) {
	      return
	    }

	    if (client[kRunning] >= (client[kPipelining] || 1)) {
	      return
	    }

	    const request = client[kQueue][client[kPendingIdx]];

	    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {
	      if (client[kRunning] > 0) {
	        return
	      }

	      client[kServerName] = request.servername;

	      if (socket && socket.servername !== request.servername) {
	        util.destroy(socket, new InformationalError('servername changed'));
	        return
	      }
	    }

	    if (client[kConnecting]) {
	      return
	    }

	    if (!socket && !client[kHTTP2Session]) {
	      connect(client);
	      return
	    }

	    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
	      return
	    }

	    if (client[kRunning] > 0 && !request.idempotent) {
	      // Non-idempotent request cannot be retried.
	      // Ensure that no other requests are inflight and
	      // could cause failure.
	      return
	    }

	    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {
	      // Don't dispatch an upgrade until all preceding requests have completed.
	      // A misbehaving server might upgrade the connection before all pipelined
	      // request has completed.
	      return
	    }

	    if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&
	      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
	      // Request with stream or iterator body can error while other requests
	      // are inflight and indirectly error those as well.
	      // Ensure this doesn't happen by waiting for inflight
	      // to complete before dispatching.

	      // Request with stream or iterator body cannot be retried.
	      // Ensure that no other requests are inflight and
	      // could cause failure.
	      return
	    }

	    if (!request.aborted && write(client, request)) {
	      client[kPendingIdx]++;
	    } else {
	      client[kQueue].splice(client[kPendingIdx], 1);
	    }
	  }
	}

	// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
	function shouldSendContentLength (method) {
	  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'
	}

	function write (client, request) {
	  if (client[kHTTPConnVersion] === 'h2') {
	    writeH2(client, client[kHTTP2Session], request);
	    return
	  }

	  const { body, method, path, host, upgrade, headers, blocking, reset } = request;

	  // https://tools.ietf.org/html/rfc7231#section-4.3.1
	  // https://tools.ietf.org/html/rfc7231#section-4.3.2
	  // https://tools.ietf.org/html/rfc7231#section-4.3.5

	  // Sending a payload body on a request that does not
	  // expect it can cause undefined behavior on some
	  // servers and corrupt connection state. Do not
	  // re-use the connection for further requests.

	  const expectsPayload = (
	    method === 'PUT' ||
	    method === 'POST' ||
	    method === 'PATCH'
	  );

	  if (body && typeof body.read === 'function') {
	    // Try to read EOF in order to get length.
	    body.read(0);
	  }

	  const bodyLength = util.bodyLength(body);

	  let contentLength = bodyLength;

	  if (contentLength === null) {
	    contentLength = request.contentLength;
	  }

	  if (contentLength === 0 && !expectsPayload) {
	    // https://tools.ietf.org/html/rfc7230#section-3.3.2
	    // A user agent SHOULD NOT send a Content-Length header field when
	    // the request message does not contain a payload body and the method
	    // semantics do not anticipate such a body.

	    contentLength = null;
	  }

	  // https://github.com/nodejs/undici/issues/2046
	  // A user agent may send a Content-Length header with 0 value, this should be allowed.
	  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
	    if (client[kStrictContentLength]) {
	      errorRequest(client, request, new RequestContentLengthMismatchError());
	      return false
	    }

	    process.emitWarning(new RequestContentLengthMismatchError());
	  }

	  const socket = client[kSocket];

	  try {
	    request.onConnect((err) => {
	      if (request.aborted || request.completed) {
	        return
	      }

	      errorRequest(client, request, err || new RequestAbortedError());

	      util.destroy(socket, new InformationalError('aborted'));
	    });
	  } catch (err) {
	    errorRequest(client, request, err);
	  }

	  if (request.aborted) {
	    return false
	  }

	  if (method === 'HEAD') {
	    // https://github.com/mcollina/undici/issues/258
	    // Close after a HEAD request to interop with misbehaving servers
	    // that may send a body in the response.

	    socket[kReset] = true;
	  }

	  if (upgrade || method === 'CONNECT') {
	    // On CONNECT or upgrade, block pipeline from dispatching further
	    // requests on this connection.

	    socket[kReset] = true;
	  }

	  if (reset != null) {
	    socket[kReset] = reset;
	  }

	  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
	    socket[kReset] = true;
	  }

	  if (blocking) {
	    socket[kBlocking] = true;
	  }

	  let header = `${method} ${path} HTTP/1.1\r\n`;

	  if (typeof host === 'string') {
	    header += `host: ${host}\r\n`;
	  } else {
	    header += client[kHostHeader];
	  }

	  if (upgrade) {
	    header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
	  } else if (client[kPipelining] && !socket[kReset]) {
	    header += 'connection: keep-alive\r\n';
	  } else {
	    header += 'connection: close\r\n';
	  }

	  if (headers) {
	    header += headers;
	  }

	  if (channels.sendHeaders.hasSubscribers) {
	    channels.sendHeaders.publish({ request, headers: header, socket });
	  }

	  /* istanbul ignore else: assertion */
	  if (!body || bodyLength === 0) {
	    if (contentLength === 0) {
	      socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
	    } else {
	      assert(contentLength === null, 'no body must not have content length');
	      socket.write(`${header}\r\n`, 'latin1');
	    }
	    request.onRequestSent();
	  } else if (util.isBuffer(body)) {
	    assert(contentLength === body.byteLength, 'buffer body must have content length');

	    socket.cork();
	    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	    socket.write(body);
	    socket.uncork();
	    request.onBodySent(body);
	    request.onRequestSent();
	    if (!expectsPayload) {
	      socket[kReset] = true;
	    }
	  } else if (util.isBlobLike(body)) {
	    if (typeof body.stream === 'function') {
	      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
	    } else {
	      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
	    }
	  } else if (util.isStream(body)) {
	    writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
	  } else if (util.isIterable(body)) {
	    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
	  } else {
	    assert(false);
	  }

	  return true
	}

	function writeH2 (client, session, request) {
	  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;

	  let headers;
	  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
	  else headers = reqHeaders;

	  if (upgrade) {
	    errorRequest(client, request, new Error('Upgrade not supported for H2'));
	    return false
	  }

	  try {
	    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?
	    request.onConnect((err) => {
	      if (request.aborted || request.completed) {
	        return
	      }

	      errorRequest(client, request, err || new RequestAbortedError());
	    });
	  } catch (err) {
	    errorRequest(client, request, err);
	  }

	  if (request.aborted) {
	    return false
	  }

	  /** @type {import('node:http2').ClientHttp2Stream} */
	  let stream;
	  const h2State = client[kHTTP2SessionState];

	  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
	  headers[HTTP2_HEADER_METHOD] = method;

	  if (method === 'CONNECT') {
	    session.ref();
	    // we are already connected, streams are pending, first request
	    // will create a new stream. We trigger a request to create the stream and wait until
	    // `ready` event is triggered
	    // We disabled endStream to allow the user to write to the stream
	    stream = session.request(headers, { endStream: false, signal });

	    if (stream.id && !stream.pending) {
	      request.onUpgrade(null, null, stream);
	      ++h2State.openStreams;
	    } else {
	      stream.once('ready', () => {
	        request.onUpgrade(null, null, stream);
	        ++h2State.openStreams;
	      });
	    }

	    stream.once('close', () => {
	      h2State.openStreams -= 1;
	      // TODO(HTTP/2): unref only if current streams count is 0
	      if (h2State.openStreams === 0) session.unref();
	    });

	    return true
	  }

	  // https://tools.ietf.org/html/rfc7540#section-8.3
	  // :path and :scheme headers must be omited when sending CONNECT

	  headers[HTTP2_HEADER_PATH] = path;
	  headers[HTTP2_HEADER_SCHEME] = 'https';

	  // https://tools.ietf.org/html/rfc7231#section-4.3.1
	  // https://tools.ietf.org/html/rfc7231#section-4.3.2
	  // https://tools.ietf.org/html/rfc7231#section-4.3.5

	  // Sending a payload body on a request that does not
	  // expect it can cause undefined behavior on some
	  // servers and corrupt connection state. Do not
	  // re-use the connection for further requests.

	  const expectsPayload = (
	    method === 'PUT' ||
	    method === 'POST' ||
	    method === 'PATCH'
	  );

	  if (body && typeof body.read === 'function') {
	    // Try to read EOF in order to get length.
	    body.read(0);
	  }

	  let contentLength = util.bodyLength(body);

	  if (contentLength == null) {
	    contentLength = request.contentLength;
	  }

	  if (contentLength === 0 || !expectsPayload) {
	    // https://tools.ietf.org/html/rfc7230#section-3.3.2
	    // A user agent SHOULD NOT send a Content-Length header field when
	    // the request message does not contain a payload body and the method
	    // semantics do not anticipate such a body.

	    contentLength = null;
	  }

	  // https://github.com/nodejs/undici/issues/2046
	  // A user agent may send a Content-Length header with 0 value, this should be allowed.
	  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
	    if (client[kStrictContentLength]) {
	      errorRequest(client, request, new RequestContentLengthMismatchError());
	      return false
	    }

	    process.emitWarning(new RequestContentLengthMismatchError());
	  }

	  if (contentLength != null) {
	    assert(body, 'no body must not have content length');
	    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
	  }

	  session.ref();

	  const shouldEndStream = method === 'GET' || method === 'HEAD';
	  if (expectContinue) {
	    headers[HTTP2_HEADER_EXPECT] = '100-continue';
	    stream = session.request(headers, { endStream: shouldEndStream, signal });

	    stream.once('continue', writeBodyH2);
	  } else {
	    stream = session.request(headers, {
	      endStream: shouldEndStream,
	      signal
	    });
	    writeBodyH2();
	  }

	  // Increment counter as we have new several streams open
	  ++h2State.openStreams;

	  stream.once('response', headers => {
	    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;

	    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {
	      stream.pause();
	    }
	  });

	  stream.once('end', () => {
	    request.onComplete([]);
	  });

	  stream.on('data', (chunk) => {
	    if (request.onData(chunk) === false) {
	      stream.pause();
	    }
	  });

	  stream.once('close', () => {
	    h2State.openStreams -= 1;
	    // TODO(HTTP/2): unref only if current streams count is 0
	    if (h2State.openStreams === 0) {
	      session.unref();
	    }
	  });

	  stream.once('error', function (err) {
	    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
	      h2State.streams -= 1;
	      util.destroy(stream, err);
	    }
	  });

	  stream.once('frameError', (type, code) => {
	    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
	    errorRequest(client, request, err);

	    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
	      h2State.streams -= 1;
	      util.destroy(stream, err);
	    }
	  });

	  // stream.on('aborted', () => {
	  //   // TODO(HTTP/2): Support aborted
	  // })

	  // stream.on('timeout', () => {
	  //   // TODO(HTTP/2): Support timeout
	  // })

	  // stream.on('push', headers => {
	  //   // TODO(HTTP/2): Suppor push
	  // })

	  // stream.on('trailers', headers => {
	  //   // TODO(HTTP/2): Support trailers
	  // })

	  return true

	  function writeBodyH2 () {
	    /* istanbul ignore else: assertion */
	    if (!body) {
	      request.onRequestSent();
	    } else if (util.isBuffer(body)) {
	      assert(contentLength === body.byteLength, 'buffer body must have content length');
	      stream.cork();
	      stream.write(body);
	      stream.uncork();
	      stream.end();
	      request.onBodySent(body);
	      request.onRequestSent();
	    } else if (util.isBlobLike(body)) {
	      if (typeof body.stream === 'function') {
	        writeIterable({
	          client,
	          request,
	          contentLength,
	          h2stream: stream,
	          expectsPayload,
	          body: body.stream(),
	          socket: client[kSocket],
	          header: ''
	        });
	      } else {
	        writeBlob({
	          body,
	          client,
	          request,
	          contentLength,
	          expectsPayload,
	          h2stream: stream,
	          header: '',
	          socket: client[kSocket]
	        });
	      }
	    } else if (util.isStream(body)) {
	      writeStream({
	        body,
	        client,
	        request,
	        contentLength,
	        expectsPayload,
	        socket: client[kSocket],
	        h2stream: stream,
	        header: ''
	      });
	    } else if (util.isIterable(body)) {
	      writeIterable({
	        body,
	        client,
	        request,
	        contentLength,
	        expectsPayload,
	        header: '',
	        h2stream: stream,
	        socket: client[kSocket]
	      });
	    } else {
	      assert(false);
	    }
	  }
	}

	function writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');

	  if (client[kHTTPConnVersion] === 'h2') {
	    // For HTTP/2, is enough to pipe the stream
	    const pipe = pipeline(
	      body,
	      h2stream,
	      (err) => {
	        if (err) {
	          util.destroy(body, err);
	          util.destroy(h2stream, err);
	        } else {
	          request.onRequestSent();
	        }
	      }
	    );

	    pipe.on('data', onPipeData);
	    pipe.once('end', () => {
	      pipe.removeListener('data', onPipeData);
	      util.destroy(pipe);
	    });

	    function onPipeData (chunk) {
	      request.onBodySent(chunk);
	    }

	    return
	  }

	  let finished = false;

	  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });

	  const onData = function (chunk) {
	    if (finished) {
	      return
	    }

	    try {
	      if (!writer.write(chunk) && this.pause) {
	        this.pause();
	      }
	    } catch (err) {
	      util.destroy(this, err);
	    }
	  };
	  const onDrain = function () {
	    if (finished) {
	      return
	    }

	    if (body.resume) {
	      body.resume();
	    }
	  };
	  const onAbort = function () {
	    if (finished) {
	      return
	    }
	    const err = new RequestAbortedError();
	    queueMicrotask(() => onFinished(err));
	  };
	  const onFinished = function (err) {
	    if (finished) {
	      return
	    }

	    finished = true;

	    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1));

	    socket
	      .off('drain', onDrain)
	      .off('error', onFinished);

	    body
	      .removeListener('data', onData)
	      .removeListener('end', onFinished)
	      .removeListener('error', onFinished)
	      .removeListener('close', onAbort);

	    if (!err) {
	      try {
	        writer.end();
	      } catch (er) {
	        err = er;
	      }
	    }

	    writer.destroy(err);

	    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
	      util.destroy(body, err);
	    } else {
	      util.destroy(body);
	    }
	  };

	  body
	    .on('data', onData)
	    .on('end', onFinished)
	    .on('error', onFinished)
	    .on('close', onAbort);

	  if (body.resume) {
	    body.resume();
	  }

	  socket
	    .on('drain', onDrain)
	    .on('error', onFinished);
	}

	async function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength === body.size, 'blob body must have content length');

	  const isH2 = client[kHTTPConnVersion] === 'h2';
	  try {
	    if (contentLength != null && contentLength !== body.size) {
	      throw new RequestContentLengthMismatchError()
	    }

	    const buffer = Buffer.from(await body.arrayBuffer());

	    if (isH2) {
	      h2stream.cork();
	      h2stream.write(buffer);
	      h2stream.uncork();
	    } else {
	      socket.cork();
	      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	      socket.write(buffer);
	      socket.uncork();
	    }

	    request.onBodySent(buffer);
	    request.onRequestSent();

	    if (!expectsPayload) {
	      socket[kReset] = true;
	    }

	    resume(client);
	  } catch (err) {
	    util.destroy(isH2 ? h2stream : socket, err);
	  }
	}

	async function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');

	  let callback = null;
	  function onDrain () {
	    if (callback) {
	      const cb = callback;
	      callback = null;
	      cb();
	    }
	  }

	  const waitForDrain = () => new Promise((resolve, reject) => {
	    assert(callback === null);

	    if (socket[kError]) {
	      reject(socket[kError]);
	    } else {
	      callback = resolve;
	    }
	  });

	  if (client[kHTTPConnVersion] === 'h2') {
	    h2stream
	      .on('close', onDrain)
	      .on('drain', onDrain);

	    try {
	      // It's up to the user to somehow abort the async iterable.
	      for await (const chunk of body) {
	        if (socket[kError]) {
	          throw socket[kError]
	        }

	        const res = h2stream.write(chunk);
	        request.onBodySent(chunk);
	        if (!res) {
	          await waitForDrain();
	        }
	      }
	    } catch (err) {
	      h2stream.destroy(err);
	    } finally {
	      request.onRequestSent();
	      h2stream.end();
	      h2stream
	        .off('close', onDrain)
	        .off('drain', onDrain);
	    }

	    return
	  }

	  socket
	    .on('close', onDrain)
	    .on('drain', onDrain);

	  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
	  try {
	    // It's up to the user to somehow abort the async iterable.
	    for await (const chunk of body) {
	      if (socket[kError]) {
	        throw socket[kError]
	      }

	      if (!writer.write(chunk)) {
	        await waitForDrain();
	      }
	    }

	    writer.end();
	  } catch (err) {
	    writer.destroy(err);
	  } finally {
	    socket
	      .off('close', onDrain)
	      .off('drain', onDrain);
	  }
	}

	class AsyncWriter {
	  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {
	    this.socket = socket;
	    this.request = request;
	    this.contentLength = contentLength;
	    this.client = client;
	    this.bytesWritten = 0;
	    this.expectsPayload = expectsPayload;
	    this.header = header;

	    socket[kWriting] = true;
	  }

	  write (chunk) {
	    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;

	    if (socket[kError]) {
	      throw socket[kError]
	    }

	    if (socket.destroyed) {
	      return false
	    }

	    const len = Buffer.byteLength(chunk);
	    if (!len) {
	      return true
	    }

	    // We should defer writing chunks.
	    if (contentLength !== null && bytesWritten + len > contentLength) {
	      if (client[kStrictContentLength]) {
	        throw new RequestContentLengthMismatchError()
	      }

	      process.emitWarning(new RequestContentLengthMismatchError());
	    }

	    socket.cork();

	    if (bytesWritten === 0) {
	      if (!expectsPayload) {
	        socket[kReset] = true;
	      }

	      if (contentLength === null) {
	        socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1');
	      } else {
	        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	      }
	    }

	    if (contentLength === null) {
	      socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1');
	    }

	    this.bytesWritten += len;

	    const ret = socket.write(chunk);

	    socket.uncork();

	    request.onBodySent(chunk);

	    if (!ret) {
	      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
	        // istanbul ignore else: only for jest
	        if (socket[kParser].timeout.refresh) {
	          socket[kParser].timeout.refresh();
	        }
	      }
	    }

	    return ret
	  }

	  end () {
	    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
	    request.onRequestSent();

	    socket[kWriting] = false;

	    if (socket[kError]) {
	      throw socket[kError]
	    }

	    if (socket.destroyed) {
	      return
	    }

	    if (bytesWritten === 0) {
	      if (expectsPayload) {
	        // https://tools.ietf.org/html/rfc7230#section-3.3.2
	        // A user agent SHOULD send a Content-Length in a request message when
	        // no Transfer-Encoding is sent and the request method defines a meaning
	        // for an enclosed payload body.

	        socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
	      } else {
	        socket.write(`${header}\r\n`, 'latin1');
	      }
	    } else if (contentLength === null) {
	      socket.write('\r\n0\r\n\r\n', 'latin1');
	    }

	    if (contentLength !== null && bytesWritten !== contentLength) {
	      if (client[kStrictContentLength]) {
	        throw new RequestContentLengthMismatchError()
	      } else {
	        process.emitWarning(new RequestContentLengthMismatchError());
	      }
	    }

	    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
	      // istanbul ignore else: only for jest
	      if (socket[kParser].timeout.refresh) {
	        socket[kParser].timeout.refresh();
	      }
	    }

	    resume(client);
	  }

	  destroy (err) {
	    const { socket, client } = this;

	    socket[kWriting] = false;

	    if (err) {
	      assert(client[kRunning] <= 1, 'pipeline should only contain this request');
	      util.destroy(socket, err);
	    }
	  }
	}

	function errorRequest (client, request, err) {
	  try {
	    request.onError(err);
	    assert(request.aborted);
	  } catch (err) {
	    client.emit('error', err);
	  }
	}

	client = Client;
	return client;
}

/* eslint-disable */

var fixedQueue;
var hasRequiredFixedQueue;

function requireFixedQueue () {
	if (hasRequiredFixedQueue) return fixedQueue;
	hasRequiredFixedQueue = 1;

	// Extracted from node/lib/internal/fixed_queue.js

	// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
	const kSize = 2048;
	const kMask = kSize - 1;

	// The FixedQueue is implemented as a singly-linked list of fixed-size
	// circular buffers. It looks something like this:
	//
	//  head                                                       tail
	//    |                                                          |
	//    v                                                          v
	// +-----------+ <-----\       +-----------+ <------\         +-----------+
	// |  [null]   |        \----- |   next    |         \------- |   next    |
	// +-----------+               +-----------+                  +-----------+
	// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |       bottom --> |   item    |
	// |   item    |               |   item    |                  |   item    |
	// |    ...    |               |    ...    |                  |    ...    |
	// |   item    |               |   item    |                  |   item    |
	// |   item    |               |   item    |                  |   item    |
	// |  [empty]  | <-- top       |   item    |                  |   item    |
	// |  [empty]  |               |   item    |                  |   item    |
	// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
	// +-----------+               +-----------+                  +-----------+
	//
	// Or, if there is only one circular buffer, it looks something
	// like either of these:
	//
	//  head   tail                                 head   tail
	//    |     |                                     |     |
	//    v     v                                     v     v
	// +-----------+                               +-----------+
	// |  [null]   |                               |  [null]   |
	// +-----------+                               +-----------+
	// |  [empty]  |                               |   item    |
	// |  [empty]  |                               |   item    |
	// |   item    | <-- bottom            top --> |  [empty]  |
	// |   item    |                               |  [empty]  |
	// |  [empty]  | <-- top            bottom --> |   item    |
	// |  [empty]  |                               |   item    |
	// +-----------+                               +-----------+
	//
	// Adding a value means moving `top` forward by one, removing means
	// moving `bottom` forward by one. After reaching the end, the queue
	// wraps around.
	//
	// When `top === bottom` the current queue is empty and when
	// `top + 1 === bottom` it's full. This wastes a single space of storage
	// but allows much quicker checks.

	class FixedCircularBuffer {
	  constructor() {
	    this.bottom = 0;
	    this.top = 0;
	    this.list = new Array(kSize);
	    this.next = null;
	  }

	  isEmpty() {
	    return this.top === this.bottom;
	  }

	  isFull() {
	    return ((this.top + 1) & kMask) === this.bottom;
	  }

	  push(data) {
	    this.list[this.top] = data;
	    this.top = (this.top + 1) & kMask;
	  }

	  shift() {
	    const nextItem = this.list[this.bottom];
	    if (nextItem === undefined)
	      return null;
	    this.list[this.bottom] = undefined;
	    this.bottom = (this.bottom + 1) & kMask;
	    return nextItem;
	  }
	}

	fixedQueue = class FixedQueue {
	  constructor() {
	    this.head = this.tail = new FixedCircularBuffer();
	  }

	  isEmpty() {
	    return this.head.isEmpty();
	  }

	  push(data) {
	    if (this.head.isFull()) {
	      // Head is full: Creates a new queue, sets the old queue's `.next` to it,
	      // and sets it as the new main queue.
	      this.head = this.head.next = new FixedCircularBuffer();
	    }
	    this.head.push(data);
	  }

	  shift() {
	    const tail = this.tail;
	    const next = tail.shift();
	    if (tail.isEmpty() && tail.next !== null) {
	      // If there is another queue, it forms the new tail.
	      this.tail = tail.next;
	    }
	    return next;
	  }
	};
	return fixedQueue;
}

var poolStats;
var hasRequiredPoolStats;

function requirePoolStats () {
	if (hasRequiredPoolStats) return poolStats;
	hasRequiredPoolStats = 1;
	const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = requireSymbols$4();
	const kPool = Symbol('pool');

	class PoolStats {
	  constructor (pool) {
	    this[kPool] = pool;
	  }

	  get connected () {
	    return this[kPool][kConnected]
	  }

	  get free () {
	    return this[kPool][kFree]
	  }

	  get pending () {
	    return this[kPool][kPending]
	  }

	  get queued () {
	    return this[kPool][kQueued]
	  }

	  get running () {
	    return this[kPool][kRunning]
	  }

	  get size () {
	    return this[kPool][kSize]
	  }
	}

	poolStats = PoolStats;
	return poolStats;
}

var poolBase;
var hasRequiredPoolBase;

function requirePoolBase () {
	if (hasRequiredPoolBase) return poolBase;
	hasRequiredPoolBase = 1;

	const DispatcherBase = requireDispatcherBase();
	const FixedQueue = requireFixedQueue();
	const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = requireSymbols$4();
	const PoolStats = requirePoolStats();

	const kClients = Symbol('clients');
	const kNeedDrain = Symbol('needDrain');
	const kQueue = Symbol('queue');
	const kClosedResolve = Symbol('closed resolve');
	const kOnDrain = Symbol('onDrain');
	const kOnConnect = Symbol('onConnect');
	const kOnDisconnect = Symbol('onDisconnect');
	const kOnConnectionError = Symbol('onConnectionError');
	const kGetDispatcher = Symbol('get dispatcher');
	const kAddClient = Symbol('add client');
	const kRemoveClient = Symbol('remove client');
	const kStats = Symbol('stats');

	class PoolBase extends DispatcherBase {
	  constructor () {
	    super();

	    this[kQueue] = new FixedQueue();
	    this[kClients] = [];
	    this[kQueued] = 0;

	    const pool = this;

	    this[kOnDrain] = function onDrain (origin, targets) {
	      const queue = pool[kQueue];

	      let needDrain = false;

	      while (!needDrain) {
	        const item = queue.shift();
	        if (!item) {
	          break
	        }
	        pool[kQueued]--;
	        needDrain = !this.dispatch(item.opts, item.handler);
	      }

	      this[kNeedDrain] = needDrain;

	      if (!this[kNeedDrain] && pool[kNeedDrain]) {
	        pool[kNeedDrain] = false;
	        pool.emit('drain', origin, [pool, ...targets]);
	      }

	      if (pool[kClosedResolve] && queue.isEmpty()) {
	        Promise
	          .all(pool[kClients].map(c => c.close()))
	          .then(pool[kClosedResolve]);
	      }
	    };

	    this[kOnConnect] = (origin, targets) => {
	      pool.emit('connect', origin, [pool, ...targets]);
	    };

	    this[kOnDisconnect] = (origin, targets, err) => {
	      pool.emit('disconnect', origin, [pool, ...targets], err);
	    };

	    this[kOnConnectionError] = (origin, targets, err) => {
	      pool.emit('connectionError', origin, [pool, ...targets], err);
	    };

	    this[kStats] = new PoolStats(this);
	  }

	  get [kBusy] () {
	    return this[kNeedDrain]
	  }

	  get [kConnected] () {
	    return this[kClients].filter(client => client[kConnected]).length
	  }

	  get [kFree] () {
	    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length
	  }

	  get [kPending] () {
	    let ret = this[kQueued];
	    for (const { [kPending]: pending } of this[kClients]) {
	      ret += pending;
	    }
	    return ret
	  }

	  get [kRunning] () {
	    let ret = 0;
	    for (const { [kRunning]: running } of this[kClients]) {
	      ret += running;
	    }
	    return ret
	  }

	  get [kSize] () {
	    let ret = this[kQueued];
	    for (const { [kSize]: size } of this[kClients]) {
	      ret += size;
	    }
	    return ret
	  }

	  get stats () {
	    return this[kStats]
	  }

	  async [kClose] () {
	    if (this[kQueue].isEmpty()) {
	      return Promise.all(this[kClients].map(c => c.close()))
	    } else {
	      return new Promise((resolve) => {
	        this[kClosedResolve] = resolve;
	      })
	    }
	  }

	  async [kDestroy] (err) {
	    while (true) {
	      const item = this[kQueue].shift();
	      if (!item) {
	        break
	      }
	      item.handler.onError(err);
	    }

	    return Promise.all(this[kClients].map(c => c.destroy(err)))
	  }

	  [kDispatch] (opts, handler) {
	    const dispatcher = this[kGetDispatcher]();

	    if (!dispatcher) {
	      this[kNeedDrain] = true;
	      this[kQueue].push({ opts, handler });
	      this[kQueued]++;
	    } else if (!dispatcher.dispatch(opts, handler)) {
	      dispatcher[kNeedDrain] = true;
	      this[kNeedDrain] = !this[kGetDispatcher]();
	    }

	    return !this[kNeedDrain]
	  }

	  [kAddClient] (client) {
	    client
	      .on('drain', this[kOnDrain])
	      .on('connect', this[kOnConnect])
	      .on('disconnect', this[kOnDisconnect])
	      .on('connectionError', this[kOnConnectionError]);

	    this[kClients].push(client);

	    if (this[kNeedDrain]) {
	      process.nextTick(() => {
	        if (this[kNeedDrain]) {
	          this[kOnDrain](client[kUrl], [this, client]);
	        }
	      });
	    }

	    return this
	  }

	  [kRemoveClient] (client) {
	    client.close(() => {
	      const idx = this[kClients].indexOf(client);
	      if (idx !== -1) {
	        this[kClients].splice(idx, 1);
	      }
	    });

	    this[kNeedDrain] = this[kClients].some(dispatcher => (
	      !dispatcher[kNeedDrain] &&
	      dispatcher.closed !== true &&
	      dispatcher.destroyed !== true
	    ));
	  }
	}

	poolBase = {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kRemoveClient,
	  kGetDispatcher
	};
	return poolBase;
}

var pool;
var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return pool;
	hasRequiredPool = 1;

	const {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kGetDispatcher
	} = requirePoolBase();
	const Client = requireClient();
	const {
	  InvalidArgumentError
	} = requireErrors();
	const util = requireUtil$6();
	const { kUrl, kInterceptors } = requireSymbols$4();
	const buildConnector = requireConnect();

	const kOptions = Symbol('options');
	const kConnections = Symbol('connections');
	const kFactory = Symbol('factory');

	function defaultFactory (origin, opts) {
	  return new Client(origin, opts)
	}

	class Pool extends PoolBase {
	  constructor (origin, {
	    connections,
	    factory = defaultFactory,
	    connect,
	    connectTimeout,
	    tls,
	    maxCachedSessions,
	    socketPath,
	    autoSelectFamily,
	    autoSelectFamilyAttemptTimeout,
	    allowH2,
	    ...options
	  } = {}) {
	    super();

	    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
	      throw new InvalidArgumentError('invalid connections')
	    }

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (typeof connect !== 'function') {
	      connect = buildConnector({
	        ...tls,
	        maxCachedSessions,
	        allowH2,
	        socketPath,
	        timeout: connectTimeout,
	        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
	        ...connect
	      });
	    }

	    this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool)
	      ? options.interceptors.Pool
	      : [];
	    this[kConnections] = connections || null;
	    this[kUrl] = util.parseOrigin(origin);
	    this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
	    this[kOptions].interceptors = options.interceptors
	      ? { ...options.interceptors }
	      : undefined;
	    this[kFactory] = factory;

	    this.on('connectionError', (origin, targets, error) => {
	      // If a connection error occurs, we remove the client from the pool,
	      // and emit a connectionError event. They will not be re-used.
	      // Fixes https://github.com/nodejs/undici/issues/3895
	      for (const target of targets) {
	        // Do not use kRemoveClient here, as it will close the client,
	        // but the client cannot be closed in this state.
	        const idx = this[kClients].indexOf(target);
	        if (idx !== -1) {
	          this[kClients].splice(idx, 1);
	        }
	      }
	    });
	  }

	  [kGetDispatcher] () {
	    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain]);

	    if (dispatcher) {
	      return dispatcher
	    }

	    if (!this[kConnections] || this[kClients].length < this[kConnections]) {
	      dispatcher = this[kFactory](this[kUrl], this[kOptions]);
	      this[kAddClient](dispatcher);
	    }

	    return dispatcher
	  }
	}

	pool = Pool;
	return pool;
}

var balancedPool;
var hasRequiredBalancedPool;

function requireBalancedPool () {
	if (hasRequiredBalancedPool) return balancedPool;
	hasRequiredBalancedPool = 1;

	const {
	  BalancedPoolMissingUpstreamError,
	  InvalidArgumentError
	} = requireErrors();
	const {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kRemoveClient,
	  kGetDispatcher
	} = requirePoolBase();
	const Pool = requirePool();
	const { kUrl, kInterceptors } = requireSymbols$4();
	const { parseOrigin } = requireUtil$6();
	const kFactory = Symbol('factory');

	const kOptions = Symbol('options');
	const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');
	const kCurrentWeight = Symbol('kCurrentWeight');
	const kIndex = Symbol('kIndex');
	const kWeight = Symbol('kWeight');
	const kMaxWeightPerServer = Symbol('kMaxWeightPerServer');
	const kErrorPenalty = Symbol('kErrorPenalty');

	function getGreatestCommonDivisor (a, b) {
	  if (b === 0) return a
	  return getGreatestCommonDivisor(b, a % b)
	}

	function defaultFactory (origin, opts) {
	  return new Pool(origin, opts)
	}

	class BalancedPool extends PoolBase {
	  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {
	    super();

	    this[kOptions] = opts;
	    this[kIndex] = -1;
	    this[kCurrentWeight] = 0;

	    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
	    this[kErrorPenalty] = this[kOptions].errorPenalty || 15;

	    if (!Array.isArray(upstreams)) {
	      upstreams = [upstreams];
	    }

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)
	      ? opts.interceptors.BalancedPool
	      : [];
	    this[kFactory] = factory;

	    for (const upstream of upstreams) {
	      this.addUpstream(upstream);
	    }
	    this._updateBalancedPoolStats();
	  }

	  addUpstream (upstream) {
	    const upstreamOrigin = parseOrigin(upstream).origin;

	    if (this[kClients].find((pool) => (
	      pool[kUrl].origin === upstreamOrigin &&
	      pool.closed !== true &&
	      pool.destroyed !== true
	    ))) {
	      return this
	    }
	    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));

	    this[kAddClient](pool);
	    pool.on('connect', () => {
	      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
	    });

	    pool.on('connectionError', () => {
	      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
	      this._updateBalancedPoolStats();
	    });

	    pool.on('disconnect', (...args) => {
	      const err = args[2];
	      if (err && err.code === 'UND_ERR_SOCKET') {
	        // decrease the weight of the pool.
	        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
	        this._updateBalancedPoolStats();
	      }
	    });

	    for (const client of this[kClients]) {
	      client[kWeight] = this[kMaxWeightPerServer];
	    }

	    this._updateBalancedPoolStats();

	    return this
	  }

	  _updateBalancedPoolStats () {
	    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
	  }

	  removeUpstream (upstream) {
	    const upstreamOrigin = parseOrigin(upstream).origin;

	    const pool = this[kClients].find((pool) => (
	      pool[kUrl].origin === upstreamOrigin &&
	      pool.closed !== true &&
	      pool.destroyed !== true
	    ));

	    if (pool) {
	      this[kRemoveClient](pool);
	    }

	    return this
	  }

	  get upstreams () {
	    return this[kClients]
	      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)
	      .map((p) => p[kUrl].origin)
	  }

	  [kGetDispatcher] () {
	    // We validate that pools is greater than 0,
	    // otherwise we would have to wait until an upstream
	    // is added, which might never happen.
	    if (this[kClients].length === 0) {
	      throw new BalancedPoolMissingUpstreamError()
	    }

	    const dispatcher = this[kClients].find(dispatcher => (
	      !dispatcher[kNeedDrain] &&
	      dispatcher.closed !== true &&
	      dispatcher.destroyed !== true
	    ));

	    if (!dispatcher) {
	      return
	    }

	    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true);

	    if (allClientsBusy) {
	      return
	    }

	    let counter = 0;

	    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);

	    while (counter++ < this[kClients].length) {
	      this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
	      const pool = this[kClients][this[kIndex]];

	      // find pool index with the largest weight
	      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
	        maxWeightIndex = this[kIndex];
	      }

	      // decrease the current weight every `this[kClients].length`.
	      if (this[kIndex] === 0) {
	        // Set the current weight to the next lower weight.
	        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];

	        if (this[kCurrentWeight] <= 0) {
	          this[kCurrentWeight] = this[kMaxWeightPerServer];
	        }
	      }
	      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {
	        return pool
	      }
	    }

	    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
	    this[kIndex] = maxWeightIndex;
	    return this[kClients][maxWeightIndex]
	  }
	}

	balancedPool = BalancedPool;
	return balancedPool;
}

var dispatcherWeakref;
var hasRequiredDispatcherWeakref;

function requireDispatcherWeakref () {
	if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
	hasRequiredDispatcherWeakref = 1;

	/* istanbul ignore file: only for Node 12 */

	const { kConnected, kSize } = requireSymbols$4();

	class CompatWeakRef {
	  constructor (value) {
	    this.value = value;
	  }

	  deref () {
	    return this.value[kConnected] === 0 && this.value[kSize] === 0
	      ? undefined
	      : this.value
	  }
	}

	class CompatFinalizer {
	  constructor (finalizer) {
	    this.finalizer = finalizer;
	  }

	  register (dispatcher, key) {
	    if (dispatcher.on) {
	      dispatcher.on('disconnect', () => {
	        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
	          this.finalizer(key);
	        }
	      });
	    }
	  }
	}

	dispatcherWeakref = function () {
	  // FIXME: remove workaround when the Node bug is fixed
	  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
	  if (process.env.NODE_V8_COVERAGE) {
	    return {
	      WeakRef: CompatWeakRef,
	      FinalizationRegistry: CompatFinalizer
	    }
	  }
	  return {
	    WeakRef: commonjsGlobal.WeakRef || CompatWeakRef,
	    FinalizationRegistry: commonjsGlobal.FinalizationRegistry || CompatFinalizer
	  }
	};
	return dispatcherWeakref;
}

var agent;
var hasRequiredAgent;

function requireAgent () {
	if (hasRequiredAgent) return agent;
	hasRequiredAgent = 1;

	const { InvalidArgumentError } = requireErrors();
	const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = requireSymbols$4();
	const DispatcherBase = requireDispatcherBase();
	const Pool = requirePool();
	const Client = requireClient();
	const util = requireUtil$6();
	const createRedirectInterceptor = requireRedirectInterceptor();
	const { WeakRef, FinalizationRegistry } = requireDispatcherWeakref()();

	const kOnConnect = Symbol('onConnect');
	const kOnDisconnect = Symbol('onDisconnect');
	const kOnConnectionError = Symbol('onConnectionError');
	const kMaxRedirections = Symbol('maxRedirections');
	const kOnDrain = Symbol('onDrain');
	const kFactory = Symbol('factory');
	const kFinalizer = Symbol('finalizer');
	const kOptions = Symbol('options');

	function defaultFactory (origin, opts) {
	  return opts && opts.connections === 1
	    ? new Client(origin, opts)
	    : new Pool(origin, opts)
	}

	class Agent extends DispatcherBase {
	  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
	    super();

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    if (connect && typeof connect !== 'function') {
	      connect = { ...connect };
	    }

	    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)
	      ? options.interceptors.Agent
	      : [createRedirectInterceptor({ maxRedirections })];

	    this[kOptions] = { ...util.deepClone(options), connect };
	    this[kOptions].interceptors = options.interceptors
	      ? { ...options.interceptors }
	      : undefined;
	    this[kMaxRedirections] = maxRedirections;
	    this[kFactory] = factory;
	    this[kClients] = new Map();
	    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {
	      const ref = this[kClients].get(key);
	      if (ref !== undefined && ref.deref() === undefined) {
	        this[kClients].delete(key);
	      }
	    });

	    const agent = this;

	    this[kOnDrain] = (origin, targets) => {
	      agent.emit('drain', origin, [agent, ...targets]);
	    };

	    this[kOnConnect] = (origin, targets) => {
	      agent.emit('connect', origin, [agent, ...targets]);
	    };

	    this[kOnDisconnect] = (origin, targets, err) => {
	      agent.emit('disconnect', origin, [agent, ...targets], err);
	    };

	    this[kOnConnectionError] = (origin, targets, err) => {
	      agent.emit('connectionError', origin, [agent, ...targets], err);
	    };
	  }

	  get [kRunning] () {
	    let ret = 0;
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore next: gc is undeterministic */
	      if (client) {
	        ret += client[kRunning];
	      }
	    }
	    return ret
	  }

	  [kDispatch] (opts, handler) {
	    let key;
	    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
	      key = String(opts.origin);
	    } else {
	      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')
	    }

	    const ref = this[kClients].get(key);

	    let dispatcher = ref ? ref.deref() : null;
	    if (!dispatcher) {
	      dispatcher = this[kFactory](opts.origin, this[kOptions])
	        .on('drain', this[kOnDrain])
	        .on('connect', this[kOnConnect])
	        .on('disconnect', this[kOnDisconnect])
	        .on('connectionError', this[kOnConnectionError]);

	      this[kClients].set(key, new WeakRef(dispatcher));
	      this[kFinalizer].register(dispatcher, key);
	    }

	    return dispatcher.dispatch(opts, handler)
	  }

	  async [kClose] () {
	    const closePromises = [];
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore else: gc is undeterministic */
	      if (client) {
	        closePromises.push(client.close());
	      }
	    }

	    await Promise.all(closePromises);
	  }

	  async [kDestroy] (err) {
	    const destroyPromises = [];
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore else: gc is undeterministic */
	      if (client) {
	        destroyPromises.push(client.destroy(err));
	      }
	    }

	    await Promise.all(destroyPromises);
	  }
	}

	agent = Agent;
	return agent;
}

var api = {};

var apiRequest = {exports: {}};

var readable;
var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable;
	hasRequiredReadable = 1;

	const assert = require$$0$2;
	const { Readable } = require$$1;
	const { RequestAbortedError, NotSupportedError, InvalidArgumentError } = requireErrors();
	const util = requireUtil$6();
	const { ReadableStreamFrom, toUSVString } = requireUtil$6();

	let Blob;

	const kConsume = Symbol('kConsume');
	const kReading = Symbol('kReading');
	const kBody = Symbol('kBody');
	const kAbort = Symbol('abort');
	const kContentType = Symbol('kContentType');

	const noop = () => {};

	readable = class BodyReadable extends Readable {
	  constructor ({
	    resume,
	    abort,
	    contentType = '',
	    highWaterMark = 64 * 1024 // Same as nodejs fs streams.
	  }) {
	    super({
	      autoDestroy: true,
	      read: resume,
	      highWaterMark
	    });

	    this._readableState.dataEmitted = false;

	    this[kAbort] = abort;
	    this[kConsume] = null;
	    this[kBody] = null;
	    this[kContentType] = contentType;

	    // Is stream being consumed through Readable API?
	    // This is an optimization so that we avoid checking
	    // for 'data' and 'readable' listeners in the hot path
	    // inside push().
	    this[kReading] = false;
	  }

	  destroy (err) {
	    if (this.destroyed) {
	      // Node < 16
	      return this
	    }

	    if (!err && !this._readableState.endEmitted) {
	      err = new RequestAbortedError();
	    }

	    if (err) {
	      this[kAbort]();
	    }

	    return super.destroy(err)
	  }

	  emit (ev, ...args) {
	    if (ev === 'data') {
	      // Node < 16.7
	      this._readableState.dataEmitted = true;
	    } else if (ev === 'error') {
	      // Node < 16
	      this._readableState.errorEmitted = true;
	    }
	    return super.emit(ev, ...args)
	  }

	  on (ev, ...args) {
	    if (ev === 'data' || ev === 'readable') {
	      this[kReading] = true;
	    }
	    return super.on(ev, ...args)
	  }

	  addListener (ev, ...args) {
	    return this.on(ev, ...args)
	  }

	  off (ev, ...args) {
	    const ret = super.off(ev, ...args);
	    if (ev === 'data' || ev === 'readable') {
	      this[kReading] = (
	        this.listenerCount('data') > 0 ||
	        this.listenerCount('readable') > 0
	      );
	    }
	    return ret
	  }

	  removeListener (ev, ...args) {
	    return this.off(ev, ...args)
	  }

	  push (chunk) {
	    if (this[kConsume] && chunk !== null && this.readableLength === 0) {
	      consumePush(this[kConsume], chunk);
	      return this[kReading] ? super.push(chunk) : true
	    }
	    return super.push(chunk)
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-text
	  async text () {
	    return consume(this, 'text')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-json
	  async json () {
	    return consume(this, 'json')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-blob
	  async blob () {
	    return consume(this, 'blob')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
	  async arrayBuffer () {
	    return consume(this, 'arrayBuffer')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-formdata
	  async formData () {
	    // TODO: Implement.
	    throw new NotSupportedError()
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-bodyused
	  get bodyUsed () {
	    return util.isDisturbed(this)
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-body
	  get body () {
	    if (!this[kBody]) {
	      this[kBody] = ReadableStreamFrom(this);
	      if (this[kConsume]) {
	        // TODO: Is this the best way to force a lock?
	        this[kBody].getReader(); // Ensure stream is locked.
	        assert(this[kBody].locked);
	      }
	    }
	    return this[kBody]
	  }

	  dump (opts) {
	    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
	    const signal = opts && opts.signal;

	    if (signal) {
	      try {
	        if (typeof signal !== 'object' || !('aborted' in signal)) {
	          throw new InvalidArgumentError('signal must be an AbortSignal')
	        }
	        util.throwIfAborted(signal);
	      } catch (err) {
	        return Promise.reject(err)
	      }
	    }

	    if (this.closed) {
	      return Promise.resolve(null)
	    }

	    return new Promise((resolve, reject) => {
	      const signalListenerCleanup = signal
	        ? util.addAbortListener(signal, () => {
	          this.destroy();
	        })
	        : noop;

	      this
	        .on('close', function () {
	          signalListenerCleanup();
	          if (signal && signal.aborted) {
	            reject(signal.reason || Object.assign(new Error('The operation was aborted'), { name: 'AbortError' }));
	          } else {
	            resolve(null);
	          }
	        })
	        .on('error', noop)
	        .on('data', function (chunk) {
	          limit -= chunk.length;
	          if (limit <= 0) {
	            this.destroy();
	          }
	        })
	        .resume();
	    })
	  }
	};

	// https://streams.spec.whatwg.org/#readablestream-locked
	function isLocked (self) {
	  // Consume is an implicit lock.
	  return (self[kBody] && self[kBody].locked === true) || self[kConsume]
	}

	// https://fetch.spec.whatwg.org/#body-unusable
	function isUnusable (self) {
	  return util.isDisturbed(self) || isLocked(self)
	}

	async function consume (stream, type) {
	  if (isUnusable(stream)) {
	    throw new TypeError('unusable')
	  }

	  assert(!stream[kConsume]);

	  return new Promise((resolve, reject) => {
	    stream[kConsume] = {
	      type,
	      stream,
	      resolve,
	      reject,
	      length: 0,
	      body: []
	    };

	    stream
	      .on('error', function (err) {
	        consumeFinish(this[kConsume], err);
	      })
	      .on('close', function () {
	        if (this[kConsume].body !== null) {
	          consumeFinish(this[kConsume], new RequestAbortedError());
	        }
	      });

	    process.nextTick(consumeStart, stream[kConsume]);
	  })
	}

	function consumeStart (consume) {
	  if (consume.body === null) {
	    return
	  }

	  const { _readableState: state } = consume.stream;

	  for (const chunk of state.buffer) {
	    consumePush(consume, chunk);
	  }

	  if (state.endEmitted) {
	    consumeEnd(this[kConsume]);
	  } else {
	    consume.stream.on('end', function () {
	      consumeEnd(this[kConsume]);
	    });
	  }

	  consume.stream.resume();

	  while (consume.stream.read() != null) {
	    // Loop
	  }
	}

	function consumeEnd (consume) {
	  const { type, body, resolve, stream, length } = consume;

	  try {
	    if (type === 'text') {
	      resolve(toUSVString(Buffer.concat(body)));
	    } else if (type === 'json') {
	      resolve(JSON.parse(Buffer.concat(body)));
	    } else if (type === 'arrayBuffer') {
	      const dst = new Uint8Array(length);

	      let pos = 0;
	      for (const buf of body) {
	        dst.set(buf, pos);
	        pos += buf.byteLength;
	      }

	      resolve(dst.buffer);
	    } else if (type === 'blob') {
	      if (!Blob) {
	        Blob = require('buffer').Blob;
	      }
	      resolve(new Blob(body, { type: stream[kContentType] }));
	    }

	    consumeFinish(consume);
	  } catch (err) {
	    stream.destroy(err);
	  }
	}

	function consumePush (consume, chunk) {
	  consume.length += chunk.length;
	  consume.body.push(chunk);
	}

	function consumeFinish (consume, err) {
	  if (consume.body === null) {
	    return
	  }

	  if (err) {
	    consume.reject(err);
	  } else {
	    consume.resolve();
	  }

	  consume.type = null;
	  consume.stream = null;
	  consume.resolve = null;
	  consume.reject = null;
	  consume.length = 0;
	  consume.body = null;
	}
	return readable;
}

var util$4;
var hasRequiredUtil$4;

function requireUtil$4 () {
	if (hasRequiredUtil$4) return util$4;
	hasRequiredUtil$4 = 1;
	const assert = require$$0$2;
	const {
	  ResponseStatusCodeError
	} = requireErrors();
	const { toUSVString } = requireUtil$6();

	async function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {
	  assert(body);

	  let chunks = [];
	  let limit = 0;

	  for await (const chunk of body) {
	    chunks.push(chunk);
	    limit += chunk.length;
	    if (limit > 128 * 1024) {
	      chunks = null;
	      break
	    }
	  }

	  if (statusCode === 204 || !contentType || !chunks) {
	    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
	    return
	  }

	  try {
	    if (contentType.startsWith('application/json')) {
	      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
	      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
	      return
	    }

	    if (contentType.startsWith('text/')) {
	      const payload = toUSVString(Buffer.concat(chunks));
	      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
	      return
	    }
	  } catch (err) {
	    // Process in a fallback if error
	  }

	  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
	}

	util$4 = { getResolveErrorBodyCallback };
	return util$4;
}

var abortSignal;
var hasRequiredAbortSignal;

function requireAbortSignal () {
	if (hasRequiredAbortSignal) return abortSignal;
	hasRequiredAbortSignal = 1;
	const { addAbortListener } = requireUtil$6();
	const { RequestAbortedError } = requireErrors();

	const kListener = Symbol('kListener');
	const kSignal = Symbol('kSignal');

	function abort (self) {
	  if (self.abort) {
	    self.abort();
	  } else {
	    self.onError(new RequestAbortedError());
	  }
	}

	function addSignal (self, signal) {
	  self[kSignal] = null;
	  self[kListener] = null;

	  if (!signal) {
	    return
	  }

	  if (signal.aborted) {
	    abort(self);
	    return
	  }

	  self[kSignal] = signal;
	  self[kListener] = () => {
	    abort(self);
	  };

	  addAbortListener(self[kSignal], self[kListener]);
	}

	function removeSignal (self) {
	  if (!self[kSignal]) {
	    return
	  }

	  if ('removeEventListener' in self[kSignal]) {
	    self[kSignal].removeEventListener('abort', self[kListener]);
	  } else {
	    self[kSignal].removeListener('abort', self[kListener]);
	  }

	  self[kSignal] = null;
	  self[kListener] = null;
	}

	abortSignal = {
	  addSignal,
	  removeSignal
	};
	return abortSignal;
}

var hasRequiredApiRequest;

function requireApiRequest () {
	if (hasRequiredApiRequest) return apiRequest.exports;
	hasRequiredApiRequest = 1;

	const Readable = requireReadable();
	const {
	  InvalidArgumentError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$6();
	const { getResolveErrorBodyCallback } = requireUtil$4();
	const { AsyncResource } = require$$4$2;
	const { addSignal, removeSignal } = requireAbortSignal();

	class RequestHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;

	    try {
	      if (typeof callback !== 'function') {
	        throw new InvalidArgumentError('invalid callback')
	      }

	      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {
	        throw new InvalidArgumentError('invalid highWaterMark')
	      }

	      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	      }

	      if (method === 'CONNECT') {
	        throw new InvalidArgumentError('invalid method')
	      }

	      if (onInfo && typeof onInfo !== 'function') {
	        throw new InvalidArgumentError('invalid onInfo callback')
	      }

	      super('UNDICI_REQUEST');
	    } catch (err) {
	      if (util.isStream(body)) {
	        util.destroy(body.on('error', util.nop), err);
	      }
	      throw err
	    }

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.callback = callback;
	    this.res = null;
	    this.abort = null;
	    this.body = body;
	    this.trailers = {};
	    this.context = null;
	    this.onInfo = onInfo || null;
	    this.throwOnError = throwOnError;
	    this.highWaterMark = highWaterMark;

	    if (util.isStream(body)) {
	      body.on('error', (err) => {
	        this.onError(err);
	      });
	    }

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;

	    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
	    const contentType = parsedHeaders['content-type'];
	    const body = new Readable({ resume, abort, contentType, highWaterMark });

	    this.callback = null;
	    this.res = body;
	    if (callback !== null) {
	      if (this.throwOnError && statusCode >= 400) {
	        this.runInAsyncScope(getResolveErrorBodyCallback, null,
	          { callback, body, contentType, statusCode, statusMessage, headers }
	        );
	      } else {
	        this.runInAsyncScope(callback, null, null, {
	          statusCode,
	          headers,
	          trailers: this.trailers,
	          opaque,
	          body,
	          context
	        });
	      }
	    }
	  }

	  onData (chunk) {
	    const { res } = this;
	    return res.push(chunk)
	  }

	  onComplete (trailers) {
	    const { res } = this;

	    removeSignal(this);

	    util.parseHeaders(trailers, this.trailers);

	    res.push(null);
	  }

	  onError (err) {
	    const { res, callback, body, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      // TODO: Does this need queueMicrotask?
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }

	    if (res) {
	      this.res = null;
	      // Ensure all queued handlers are invoked before destroying res.
	      queueMicrotask(() => {
	        util.destroy(res, err);
	      });
	    }

	    if (body) {
	      this.body = null;
	      util.destroy(body, err);
	    }
	  }
	}

	function request (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      request.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    this.dispatch(opts, new RequestHandler(opts, callback));
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiRequest.exports = request;
	apiRequest.exports.RequestHandler = RequestHandler;
	return apiRequest.exports;
}

var apiStream;
var hasRequiredApiStream;

function requireApiStream () {
	if (hasRequiredApiStream) return apiStream;
	hasRequiredApiStream = 1;

	const { finished, PassThrough } = require$$1;
	const {
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$6();
	const { getResolveErrorBodyCallback } = requireUtil$4();
	const { AsyncResource } = require$$4$2;
	const { addSignal, removeSignal } = requireAbortSignal();

	class StreamHandler extends AsyncResource {
	  constructor (opts, factory, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;

	    try {
	      if (typeof callback !== 'function') {
	        throw new InvalidArgumentError('invalid callback')
	      }

	      if (typeof factory !== 'function') {
	        throw new InvalidArgumentError('invalid factory')
	      }

	      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	      }

	      if (method === 'CONNECT') {
	        throw new InvalidArgumentError('invalid method')
	      }

	      if (onInfo && typeof onInfo !== 'function') {
	        throw new InvalidArgumentError('invalid onInfo callback')
	      }

	      super('UNDICI_STREAM');
	    } catch (err) {
	      if (util.isStream(body)) {
	        util.destroy(body.on('error', util.nop), err);
	      }
	      throw err
	    }

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.factory = factory;
	    this.callback = callback;
	    this.res = null;
	    this.abort = null;
	    this.context = null;
	    this.trailers = null;
	    this.body = body;
	    this.onInfo = onInfo || null;
	    this.throwOnError = throwOnError || false;

	    if (util.isStream(body)) {
	      body.on('error', (err) => {
	        this.onError(err);
	      });
	    }

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const { factory, opaque, context, callback, responseHeaders } = this;

	    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    this.factory = null;

	    let res;

	    if (this.throwOnError && statusCode >= 400) {
	      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
	      const contentType = parsedHeaders['content-type'];
	      res = new PassThrough();

	      this.callback = null;
	      this.runInAsyncScope(getResolveErrorBodyCallback, null,
	        { callback, body: res, contentType, statusCode, statusMessage, headers }
	      );
	    } else {
	      if (factory === null) {
	        return
	      }

	      res = this.runInAsyncScope(factory, null, {
	        statusCode,
	        headers,
	        opaque,
	        context
	      });

	      if (
	        !res ||
	        typeof res.write !== 'function' ||
	        typeof res.end !== 'function' ||
	        typeof res.on !== 'function'
	      ) {
	        throw new InvalidReturnValueError('expected Writable')
	      }

	      // TODO: Avoid finished. It registers an unnecessary amount of listeners.
	      finished(res, { readable: false }, (err) => {
	        const { callback, res, opaque, trailers, abort } = this;

	        this.res = null;
	        if (err || !res.readable) {
	          util.destroy(res, err);
	        }

	        this.callback = null;
	        this.runInAsyncScope(callback, null, err || null, { opaque, trailers });

	        if (err) {
	          abort();
	        }
	      });
	    }

	    res.on('drain', resume);

	    this.res = res;

	    const needDrain = res.writableNeedDrain !== undefined
	      ? res.writableNeedDrain
	      : res._writableState && res._writableState.needDrain;

	    return needDrain !== true
	  }

	  onData (chunk) {
	    const { res } = this;

	    return res ? res.write(chunk) : true
	  }

	  onComplete (trailers) {
	    const { res } = this;

	    removeSignal(this);

	    if (!res) {
	      return
	    }

	    this.trailers = util.parseHeaders(trailers);

	    res.end();
	  }

	  onError (err) {
	    const { res, callback, opaque, body } = this;

	    removeSignal(this);

	    this.factory = null;

	    if (res) {
	      this.res = null;
	      util.destroy(res, err);
	    } else if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }

	    if (body) {
	      this.body = null;
	      util.destroy(body, err);
	    }
	  }
	}

	function stream (opts, factory, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      stream.call(this, opts, factory, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    this.dispatch(opts, new StreamHandler(opts, factory, callback));
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiStream = stream;
	return apiStream;
}

var apiPipeline;
var hasRequiredApiPipeline;

function requireApiPipeline () {
	if (hasRequiredApiPipeline) return apiPipeline;
	hasRequiredApiPipeline = 1;

	const {
	  Readable,
	  Duplex,
	  PassThrough
	} = require$$1;
	const {
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$6();
	const { AsyncResource } = require$$4$2;
	const { addSignal, removeSignal } = requireAbortSignal();
	const assert = require$$0$2;

	const kResume = Symbol('resume');

	class PipelineRequest extends Readable {
	  constructor () {
	    super({ autoDestroy: true });

	    this[kResume] = null;
	  }

	  _read () {
	    const { [kResume]: resume } = this;

	    if (resume) {
	      this[kResume] = null;
	      resume();
	    }
	  }

	  _destroy (err, callback) {
	    this._read();

	    callback(err);
	  }
	}

	class PipelineResponse extends Readable {
	  constructor (resume) {
	    super({ autoDestroy: true });
	    this[kResume] = resume;
	  }

	  _read () {
	    this[kResume]();
	  }

	  _destroy (err, callback) {
	    if (!err && !this._readableState.endEmitted) {
	      err = new RequestAbortedError();
	    }

	    callback(err);
	  }
	}

	class PipelineHandler extends AsyncResource {
	  constructor (opts, handler) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof handler !== 'function') {
	      throw new InvalidArgumentError('invalid handler')
	    }

	    const { signal, method, opaque, onInfo, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    if (method === 'CONNECT') {
	      throw new InvalidArgumentError('invalid method')
	    }

	    if (onInfo && typeof onInfo !== 'function') {
	      throw new InvalidArgumentError('invalid onInfo callback')
	    }

	    super('UNDICI_PIPELINE');

	    this.opaque = opaque || null;
	    this.responseHeaders = responseHeaders || null;
	    this.handler = handler;
	    this.abort = null;
	    this.context = null;
	    this.onInfo = onInfo || null;

	    this.req = new PipelineRequest().on('error', util.nop);

	    this.ret = new Duplex({
	      readableObjectMode: opts.objectMode,
	      autoDestroy: true,
	      read: () => {
	        const { body } = this;

	        if (body && body.resume) {
	          body.resume();
	        }
	      },
	      write: (chunk, encoding, callback) => {
	        const { req } = this;

	        if (req.push(chunk, encoding) || req._readableState.destroyed) {
	          callback();
	        } else {
	          req[kResume] = callback;
	        }
	      },
	      destroy: (err, callback) => {
	        const { body, req, res, ret, abort } = this;

	        if (!err && !ret._readableState.endEmitted) {
	          err = new RequestAbortedError();
	        }

	        if (abort && err) {
	          abort();
	        }

	        util.destroy(body, err);
	        util.destroy(req, err);
	        util.destroy(res, err);

	        removeSignal(this);

	        callback(err);
	      }
	    }).on('prefinish', () => {
	      const { req } = this;

	      // Node < 15 does not call _final in same tick.
	      req.push(null);
	    });

	    this.res = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    const { ret, res } = this;

	    assert(!res, 'pipeline cannot be retried');

	    if (ret.destroyed) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume) {
	    const { opaque, handler, context } = this;

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    this.res = new PipelineResponse(resume);

	    let body;
	    try {
	      this.handler = null;
	      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	      body = this.runInAsyncScope(handler, null, {
	        statusCode,
	        headers,
	        opaque,
	        body: this.res,
	        context
	      });
	    } catch (err) {
	      this.res.on('error', util.nop);
	      throw err
	    }

	    if (!body || typeof body.on !== 'function') {
	      throw new InvalidReturnValueError('expected Readable')
	    }

	    body
	      .on('data', (chunk) => {
	        const { ret, body } = this;

	        if (!ret.push(chunk) && body.pause) {
	          body.pause();
	        }
	      })
	      .on('error', (err) => {
	        const { ret } = this;

	        util.destroy(ret, err);
	      })
	      .on('end', () => {
	        const { ret } = this;

	        ret.push(null);
	      })
	      .on('close', () => {
	        const { ret } = this;

	        if (!ret._readableState.ended) {
	          util.destroy(ret, new RequestAbortedError());
	        }
	      });

	    this.body = body;
	  }

	  onData (chunk) {
	    const { res } = this;
	    return res.push(chunk)
	  }

	  onComplete (trailers) {
	    const { res } = this;
	    res.push(null);
	  }

	  onError (err) {
	    const { ret } = this;
	    this.handler = null;
	    util.destroy(ret, err);
	  }
	}

	function pipeline (opts, handler) {
	  try {
	    const pipelineHandler = new PipelineHandler(opts, handler);
	    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
	    return pipelineHandler.ret
	  } catch (err) {
	    return new PassThrough().destroy(err)
	  }
	}

	apiPipeline = pipeline;
	return apiPipeline;
}

var apiUpgrade;
var hasRequiredApiUpgrade;

function requireApiUpgrade () {
	if (hasRequiredApiUpgrade) return apiUpgrade;
	hasRequiredApiUpgrade = 1;

	const { InvalidArgumentError, RequestAbortedError, SocketError } = requireErrors();
	const { AsyncResource } = require$$4$2;
	const util = requireUtil$6();
	const { addSignal, removeSignal } = requireAbortSignal();
	const assert = require$$0$2;

	class UpgradeHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    const { signal, opaque, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    super('UNDICI_UPGRADE');

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.callback = callback;
	    this.abort = null;
	    this.context = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = null;
	  }

	  onHeaders () {
	    throw new SocketError('bad upgrade', null)
	  }

	  onUpgrade (statusCode, rawHeaders, socket) {
	    const { callback, opaque, context } = this;

	    assert.strictEqual(statusCode, 101);

	    removeSignal(this);

	    this.callback = null;
	    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	    this.runInAsyncScope(callback, null, null, {
	      headers,
	      socket,
	      opaque,
	      context
	    });
	  }

	  onError (err) {
	    const { callback, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }
	  }
	}

	function upgrade (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      upgrade.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    const upgradeHandler = new UpgradeHandler(opts, callback);
	    this.dispatch({
	      ...opts,
	      method: opts.method || 'GET',
	      upgrade: opts.protocol || 'Websocket'
	    }, upgradeHandler);
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiUpgrade = upgrade;
	return apiUpgrade;
}

var apiConnect;
var hasRequiredApiConnect;

function requireApiConnect () {
	if (hasRequiredApiConnect) return apiConnect;
	hasRequiredApiConnect = 1;

	const { AsyncResource } = require$$4$2;
	const { InvalidArgumentError, RequestAbortedError, SocketError } = requireErrors();
	const util = requireUtil$6();
	const { addSignal, removeSignal } = requireAbortSignal();

	class ConnectHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    const { signal, opaque, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    super('UNDICI_CONNECT');

	    this.opaque = opaque || null;
	    this.responseHeaders = responseHeaders || null;
	    this.callback = callback;
	    this.abort = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders () {
	    throw new SocketError('bad connect', null)
	  }

	  onUpgrade (statusCode, rawHeaders, socket) {
	    const { callback, opaque, context } = this;

	    removeSignal(this);

	    this.callback = null;

	    let headers = rawHeaders;
	    // Indicates is an HTTP2Session
	    if (headers != null) {
	      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	    }

	    this.runInAsyncScope(callback, null, null, {
	      statusCode,
	      headers,
	      socket,
	      opaque,
	      context
	    });
	  }

	  onError (err) {
	    const { callback, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }
	  }
	}

	function connect (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      connect.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    const connectHandler = new ConnectHandler(opts, callback);
	    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler);
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiConnect = connect;
	return apiConnect;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;

	api.request = requireApiRequest();
	api.stream = requireApiStream();
	api.pipeline = requireApiPipeline();
	api.upgrade = requireApiUpgrade();
	api.connect = requireApiConnect();
	return api;
}

var mockErrors;
var hasRequiredMockErrors;

function requireMockErrors () {
	if (hasRequiredMockErrors) return mockErrors;
	hasRequiredMockErrors = 1;

	const { UndiciError } = requireErrors();

	class MockNotMatchedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, MockNotMatchedError);
	    this.name = 'MockNotMatchedError';
	    this.message = message || 'The request does not match any registered mock dispatches';
	    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
	  }
	}

	mockErrors = {
	  MockNotMatchedError
	};
	return mockErrors;
}

var mockSymbols;
var hasRequiredMockSymbols;

function requireMockSymbols () {
	if (hasRequiredMockSymbols) return mockSymbols;
	hasRequiredMockSymbols = 1;

	mockSymbols = {
	  kAgent: Symbol('agent'),
	  kOptions: Symbol('options'),
	  kFactory: Symbol('factory'),
	  kDispatches: Symbol('dispatches'),
	  kDispatchKey: Symbol('dispatch key'),
	  kDefaultHeaders: Symbol('default headers'),
	  kDefaultTrailers: Symbol('default trailers'),
	  kContentLength: Symbol('content length'),
	  kMockAgent: Symbol('mock agent'),
	  kMockAgentSet: Symbol('mock agent set'),
	  kMockAgentGet: Symbol('mock agent get'),
	  kMockDispatch: Symbol('mock dispatch'),
	  kClose: Symbol('close'),
	  kOriginalClose: Symbol('original agent close'),
	  kOrigin: Symbol('origin'),
	  kIsMockActive: Symbol('is mock active'),
	  kNetConnect: Symbol('net connect'),
	  kGetNetConnect: Symbol('get net connect'),
	  kConnected: Symbol('connected')
	};
	return mockSymbols;
}

var mockUtils;
var hasRequiredMockUtils;

function requireMockUtils () {
	if (hasRequiredMockUtils) return mockUtils;
	hasRequiredMockUtils = 1;

	const { MockNotMatchedError } = requireMockErrors();
	const {
	  kDispatches,
	  kMockAgent,
	  kOriginalDispatch,
	  kOrigin,
	  kGetNetConnect
	} = requireMockSymbols();
	const { buildURL, nop } = requireUtil$6();
	const { STATUS_CODES } = require$$2$1;
	const {
	  types: {
	    isPromise
	  }
	} = require$$0$1;

	function matchValue (match, value) {
	  if (typeof match === 'string') {
	    return match === value
	  }
	  if (match instanceof RegExp) {
	    return match.test(value)
	  }
	  if (typeof match === 'function') {
	    return match(value) === true
	  }
	  return false
	}

	function lowerCaseEntries (headers) {
	  return Object.fromEntries(
	    Object.entries(headers).map(([headerName, headerValue]) => {
	      return [headerName.toLocaleLowerCase(), headerValue]
	    })
	  )
	}

	/**
	 * @param {import('../../index').Headers|string[]|Record<string, string>} headers
	 * @param {string} key
	 */
	function getHeaderByName (headers, key) {
	  if (Array.isArray(headers)) {
	    for (let i = 0; i < headers.length; i += 2) {
	      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
	        return headers[i + 1]
	      }
	    }

	    return undefined
	  } else if (typeof headers.get === 'function') {
	    return headers.get(key)
	  } else {
	    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]
	  }
	}

	/** @param {string[]} headers */
	function buildHeadersFromArray (headers) { // fetch HeadersList
	  const clone = headers.slice();
	  const entries = [];
	  for (let index = 0; index < clone.length; index += 2) {
	    entries.push([clone[index], clone[index + 1]]);
	  }
	  return Object.fromEntries(entries)
	}

	function matchHeaders (mockDispatch, headers) {
	  if (typeof mockDispatch.headers === 'function') {
	    if (Array.isArray(headers)) { // fetch HeadersList
	      headers = buildHeadersFromArray(headers);
	    }
	    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})
	  }
	  if (typeof mockDispatch.headers === 'undefined') {
	    return true
	  }
	  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {
	    return false
	  }

	  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {
	    const headerValue = getHeaderByName(headers, matchHeaderName);

	    if (!matchValue(matchHeaderValue, headerValue)) {
	      return false
	    }
	  }
	  return true
	}

	function safeUrl (path) {
	  if (typeof path !== 'string') {
	    return path
	  }

	  const pathSegments = path.split('?');

	  if (pathSegments.length !== 2) {
	    return path
	  }

	  const qp = new URLSearchParams(pathSegments.pop());
	  qp.sort();
	  return [...pathSegments, qp.toString()].join('?')
	}

	function matchKey (mockDispatch, { path, method, body, headers }) {
	  const pathMatch = matchValue(mockDispatch.path, path);
	  const methodMatch = matchValue(mockDispatch.method, method);
	  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;
	  const headersMatch = matchHeaders(mockDispatch, headers);
	  return pathMatch && methodMatch && bodyMatch && headersMatch
	}

	function getResponseData (data) {
	  if (Buffer.isBuffer(data)) {
	    return data
	  } else if (typeof data === 'object') {
	    return JSON.stringify(data)
	  } else {
	    return data.toString()
	  }
	}

	function getMockDispatch (mockDispatches, key) {
	  const basePath = key.query ? buildURL(key.path, key.query) : key.path;
	  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath;

	  // Match path
	  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)
	  }

	  // Match method
	  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)
	  }

	  // Match body
	  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true);
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)
	  }

	  // Match headers
	  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)
	  }

	  return matchedMockDispatches[0]
	}

	function addMockDispatch (mockDispatches, key, data) {
	  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
	  const replyData = typeof data === 'function' ? { callback: data } : { ...data };
	  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
	  mockDispatches.push(newMockDispatch);
	  return newMockDispatch
	}

	function deleteMockDispatch (mockDispatches, key) {
	  const index = mockDispatches.findIndex(dispatch => {
	    if (!dispatch.consumed) {
	      return false
	    }
	    return matchKey(dispatch, key)
	  });
	  if (index !== -1) {
	    mockDispatches.splice(index, 1);
	  }
	}

	function buildKey (opts) {
	  const { path, method, body, headers, query } = opts;
	  return {
	    path,
	    method,
	    body,
	    headers,
	    query
	  }
	}

	function generateKeyValues (data) {
	  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
	    ...keyValuePairs,
	    Buffer.from(`${key}`),
	    Array.isArray(value) ? value.map(x => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
	  ], [])
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	 * @param {number} statusCode
	 */
	function getStatusText (statusCode) {
	  return STATUS_CODES[statusCode] || 'unknown'
	}

	async function getResponse (body) {
	  const buffers = [];
	  for await (const data of body) {
	    buffers.push(data);
	  }
	  return Buffer.concat(buffers).toString('utf8')
	}

	/**
	 * Mock dispatch function used to simulate undici dispatches
	 */
	function mockDispatch (opts, handler) {
	  // Get mock dispatch from built key
	  const key = buildKey(opts);
	  const mockDispatch = getMockDispatch(this[kDispatches], key);

	  mockDispatch.timesInvoked++;

	  // Here's where we resolve a callback if a callback is present for the dispatch data.
	  if (mockDispatch.data.callback) {
	    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) };
	  }

	  // Parse mockDispatch data
	  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;
	  const { timesInvoked, times } = mockDispatch;

	  // If it's used up and not persistent, mark as consumed
	  mockDispatch.consumed = !persist && timesInvoked >= times;
	  mockDispatch.pending = timesInvoked < times;

	  // If specified, trigger dispatch error
	  if (error !== null) {
	    deleteMockDispatch(this[kDispatches], key);
	    handler.onError(error);
	    return true
	  }

	  // Handle the request with a delay if necessary
	  if (typeof delay === 'number' && delay > 0) {
	    setTimeout(() => {
	      handleReply(this[kDispatches]);
	    }, delay);
	  } else {
	    handleReply(this[kDispatches]);
	  }

	  function handleReply (mockDispatches, _data = data) {
	    // fetch's HeadersList is a 1D string array
	    const optsHeaders = Array.isArray(opts.headers)
	      ? buildHeadersFromArray(opts.headers)
	      : opts.headers;
	    const body = typeof _data === 'function'
	      ? _data({ ...opts, headers: optsHeaders })
	      : _data;

	    // util.types.isPromise is likely needed for jest.
	    if (isPromise(body)) {
	      // If handleReply is asynchronous, throwing an error
	      // in the callback will reject the promise, rather than
	      // synchronously throw the error, which breaks some tests.
	      // Rather, we wait for the callback to resolve if it is a
	      // promise, and then re-run handleReply with the new body.
	      body.then((newData) => handleReply(mockDispatches, newData));
	      return
	    }

	    const responseData = getResponseData(body);
	    const responseHeaders = generateKeyValues(headers);
	    const responseTrailers = generateKeyValues(trailers);

	    handler.abort = nop;
	    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
	    handler.onData(Buffer.from(responseData));
	    handler.onComplete(responseTrailers);
	    deleteMockDispatch(mockDispatches, key);
	  }

	  function resume () {}

	  return true
	}

	function buildMockDispatch () {
	  const agent = this[kMockAgent];
	  const origin = this[kOrigin];
	  const originalDispatch = this[kOriginalDispatch];

	  return function dispatch (opts, handler) {
	    if (agent.isMockActive) {
	      try {
	        mockDispatch.call(this, opts, handler);
	      } catch (error) {
	        if (error instanceof MockNotMatchedError) {
	          const netConnect = agent[kGetNetConnect]();
	          if (netConnect === false) {
	            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)
	          }
	          if (checkNetConnect(netConnect, origin)) {
	            originalDispatch.call(this, opts, handler);
	          } else {
	            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)
	          }
	        } else {
	          throw error
	        }
	      }
	    } else {
	      originalDispatch.call(this, opts, handler);
	    }
	  }
	}

	function checkNetConnect (netConnect, origin) {
	  const url = new URL(origin);
	  if (netConnect === true) {
	    return true
	  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
	    return true
	  }
	  return false
	}

	function buildMockOptions (opts) {
	  if (opts) {
	    const { agent, ...mockOptions } = opts;
	    return mockOptions
	  }
	}

	mockUtils = {
	  getResponseData,
	  getMockDispatch,
	  addMockDispatch,
	  deleteMockDispatch,
	  buildKey,
	  generateKeyValues,
	  matchValue,
	  getResponse,
	  getStatusText,
	  mockDispatch,
	  buildMockDispatch,
	  checkNetConnect,
	  buildMockOptions,
	  getHeaderByName
	};
	return mockUtils;
}

var mockInterceptor = {};

var hasRequiredMockInterceptor;

function requireMockInterceptor () {
	if (hasRequiredMockInterceptor) return mockInterceptor;
	hasRequiredMockInterceptor = 1;

	const { getResponseData, buildKey, addMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kDispatchKey,
	  kDefaultHeaders,
	  kDefaultTrailers,
	  kContentLength,
	  kMockDispatch
	} = requireMockSymbols();
	const { InvalidArgumentError } = requireErrors();
	const { buildURL } = requireUtil$6();

	/**
	 * Defines the scope API for an interceptor reply
	 */
	class MockScope {
	  constructor (mockDispatch) {
	    this[kMockDispatch] = mockDispatch;
	  }

	  /**
	   * Delay a reply by a set amount in ms.
	   */
	  delay (waitInMs) {
	    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {
	      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')
	    }

	    this[kMockDispatch].delay = waitInMs;
	    return this
	  }

	  /**
	   * For a defined reply, never mark as consumed.
	   */
	  persist () {
	    this[kMockDispatch].persist = true;
	    return this
	  }

	  /**
	   * Allow one to define a reply for a set amount of matching requests.
	   */
	  times (repeatTimes) {
	    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
	      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')
	    }

	    this[kMockDispatch].times = repeatTimes;
	    return this
	  }
	}

	/**
	 * Defines an interceptor for a Mock
	 */
	class MockInterceptor {
	  constructor (opts, mockDispatches) {
	    if (typeof opts !== 'object') {
	      throw new InvalidArgumentError('opts must be an object')
	    }
	    if (typeof opts.path === 'undefined') {
	      throw new InvalidArgumentError('opts.path must be defined')
	    }
	    if (typeof opts.method === 'undefined') {
	      opts.method = 'GET';
	    }
	    // See https://github.com/nodejs/undici/issues/1245
	    // As per RFC 3986, clients are not supposed to send URI
	    // fragments to servers when they retrieve a document,
	    if (typeof opts.path === 'string') {
	      if (opts.query) {
	        opts.path = buildURL(opts.path, opts.query);
	      } else {
	        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811
	        const parsedURL = new URL(opts.path, 'data://');
	        opts.path = parsedURL.pathname + parsedURL.search;
	      }
	    }
	    if (typeof opts.method === 'string') {
	      opts.method = opts.method.toUpperCase();
	    }

	    this[kDispatchKey] = buildKey(opts);
	    this[kDispatches] = mockDispatches;
	    this[kDefaultHeaders] = {};
	    this[kDefaultTrailers] = {};
	    this[kContentLength] = false;
	  }

	  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {
	    const responseData = getResponseData(data);
	    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {};
	    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
	    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };

	    return { statusCode, data, headers, trailers }
	  }

	  validateReplyParameters (statusCode, data, responseOptions) {
	    if (typeof statusCode === 'undefined') {
	      throw new InvalidArgumentError('statusCode must be defined')
	    }
	    if (typeof data === 'undefined') {
	      throw new InvalidArgumentError('data must be defined')
	    }
	    if (typeof responseOptions !== 'object') {
	      throw new InvalidArgumentError('responseOptions must be an object')
	    }
	  }

	  /**
	   * Mock an undici request with a defined reply.
	   */
	  reply (replyData) {
	    // Values of reply aren't available right now as they
	    // can only be available when the reply callback is invoked.
	    if (typeof replyData === 'function') {
	      // We'll first wrap the provided callback in another function,
	      // this function will properly resolve the data from the callback
	      // when invoked.
	      const wrappedDefaultsCallback = (opts) => {
	        // Our reply options callback contains the parameter for statusCode, data and options.
	        const resolvedData = replyData(opts);

	        // Check if it is in the right format
	        if (typeof resolvedData !== 'object') {
	          throw new InvalidArgumentError('reply options callback must return an object')
	        }

	        const { statusCode, data = '', responseOptions = {} } = resolvedData;
	        this.validateReplyParameters(statusCode, data, responseOptions);
	        // Since the values can be obtained immediately we return them
	        // from this higher order function that will be resolved later.
	        return {
	          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)
	        }
	      };

	      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
	      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
	      return new MockScope(newMockDispatch)
	    }

	    // We can have either one or three parameters, if we get here,
	    // we should have 1-3 parameters. So we spread the arguments of
	    // this function to obtain the parameters, since replyData will always
	    // just be the statusCode.
	    const [statusCode, data = '', responseOptions = {}] = [...arguments];
	    this.validateReplyParameters(statusCode, data, responseOptions);

	    // Send in-already provided data like usual
	    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
	    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
	    return new MockScope(newMockDispatch)
	  }

	  /**
	   * Mock an undici request with a defined error.
	   */
	  replyWithError (error) {
	    if (typeof error === 'undefined') {
	      throw new InvalidArgumentError('error must be defined')
	    }

	    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
	    return new MockScope(newMockDispatch)
	  }

	  /**
	   * Set default reply headers on the interceptor for subsequent replies
	   */
	  defaultReplyHeaders (headers) {
	    if (typeof headers === 'undefined') {
	      throw new InvalidArgumentError('headers must be defined')
	    }

	    this[kDefaultHeaders] = headers;
	    return this
	  }

	  /**
	   * Set default reply trailers on the interceptor for subsequent replies
	   */
	  defaultReplyTrailers (trailers) {
	    if (typeof trailers === 'undefined') {
	      throw new InvalidArgumentError('trailers must be defined')
	    }

	    this[kDefaultTrailers] = trailers;
	    return this
	  }

	  /**
	   * Set reply content length header for replies on the interceptor
	   */
	  replyContentLength () {
	    this[kContentLength] = true;
	    return this
	  }
	}

	mockInterceptor.MockInterceptor = MockInterceptor;
	mockInterceptor.MockScope = MockScope;
	return mockInterceptor;
}

var mockClient;
var hasRequiredMockClient;

function requireMockClient () {
	if (hasRequiredMockClient) return mockClient;
	hasRequiredMockClient = 1;

	const { promisify } = require$$0$1;
	const Client = requireClient();
	const { buildMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kMockAgent,
	  kClose,
	  kOriginalClose,
	  kOrigin,
	  kOriginalDispatch,
	  kConnected
	} = requireMockSymbols();
	const { MockInterceptor } = requireMockInterceptor();
	const Symbols = requireSymbols$4();
	const { InvalidArgumentError } = requireErrors();

	/**
	 * MockClient provides an API that extends the Client to influence the mockDispatches.
	 */
	class MockClient extends Client {
	  constructor (origin, opts) {
	    super(origin, opts);

	    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }

	    this[kMockAgent] = opts.agent;
	    this[kOrigin] = origin;
	    this[kDispatches] = [];
	    this[kConnected] = 1;
	    this[kOriginalDispatch] = this.dispatch;
	    this[kOriginalClose] = this.close.bind(this);

	    this.dispatch = buildMockDispatch.call(this);
	    this.close = this[kClose];
	  }

	  get [Symbols.kConnected] () {
	    return this[kConnected]
	  }

	  /**
	   * Sets up the base interceptor for mocking replies from undici.
	   */
	  intercept (opts) {
	    return new MockInterceptor(opts, this[kDispatches])
	  }

	  async [kClose] () {
	    await promisify(this[kOriginalClose])();
	    this[kConnected] = 0;
	    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	  }
	}

	mockClient = MockClient;
	return mockClient;
}

var mockPool;
var hasRequiredMockPool;

function requireMockPool () {
	if (hasRequiredMockPool) return mockPool;
	hasRequiredMockPool = 1;

	const { promisify } = require$$0$1;
	const Pool = requirePool();
	const { buildMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kMockAgent,
	  kClose,
	  kOriginalClose,
	  kOrigin,
	  kOriginalDispatch,
	  kConnected
	} = requireMockSymbols();
	const { MockInterceptor } = requireMockInterceptor();
	const Symbols = requireSymbols$4();
	const { InvalidArgumentError } = requireErrors();

	/**
	 * MockPool provides an API that extends the Pool to influence the mockDispatches.
	 */
	class MockPool extends Pool {
	  constructor (origin, opts) {
	    super(origin, opts);

	    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }

	    this[kMockAgent] = opts.agent;
	    this[kOrigin] = origin;
	    this[kDispatches] = [];
	    this[kConnected] = 1;
	    this[kOriginalDispatch] = this.dispatch;
	    this[kOriginalClose] = this.close.bind(this);

	    this.dispatch = buildMockDispatch.call(this);
	    this.close = this[kClose];
	  }

	  get [Symbols.kConnected] () {
	    return this[kConnected]
	  }

	  /**
	   * Sets up the base interceptor for mocking replies from undici.
	   */
	  intercept (opts) {
	    return new MockInterceptor(opts, this[kDispatches])
	  }

	  async [kClose] () {
	    await promisify(this[kOriginalClose])();
	    this[kConnected] = 0;
	    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	  }
	}

	mockPool = MockPool;
	return mockPool;
}

var pluralizer;
var hasRequiredPluralizer;

function requirePluralizer () {
	if (hasRequiredPluralizer) return pluralizer;
	hasRequiredPluralizer = 1;

	const singulars = {
	  pronoun: 'it',
	  is: 'is',
	  was: 'was',
	  this: 'this'
	};

	const plurals = {
	  pronoun: 'they',
	  is: 'are',
	  was: 'were',
	  this: 'these'
	};

	pluralizer = class Pluralizer {
	  constructor (singular, plural) {
	    this.singular = singular;
	    this.plural = plural;
	  }

	  pluralize (count) {
	    const one = count === 1;
	    const keys = one ? singulars : plurals;
	    const noun = one ? this.singular : this.plural;
	    return { ...keys, count, noun }
	  }
	};
	return pluralizer;
}

var pendingInterceptorsFormatter;
var hasRequiredPendingInterceptorsFormatter;

function requirePendingInterceptorsFormatter () {
	if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
	hasRequiredPendingInterceptorsFormatter = 1;

	const { Transform } = require$$1;
	const { Console } = require$$1$5;

	/**
	 * Gets the output of `console.table()` as a string.
	 */
	pendingInterceptorsFormatter = class PendingInterceptorsFormatter {
	  constructor ({ disableColors } = {}) {
	    this.transform = new Transform({
	      transform (chunk, _enc, cb) {
	        cb(null, chunk);
	      }
	    });

	    this.logger = new Console({
	      stdout: this.transform,
	      inspectOptions: {
	        colors: !disableColors && !process.env.CI
	      }
	    });
	  }

	  format (pendingInterceptors) {
	    const withPrettyHeaders = pendingInterceptors.map(
	      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
	        Method: method,
	        Origin: origin,
	        Path: path,
	        'Status code': statusCode,
	        Persistent: persist ? '' : '',
	        Invocations: timesInvoked,
	        Remaining: persist ? Infinity : times - timesInvoked
	      }));

	    this.logger.table(withPrettyHeaders);
	    return this.transform.read().toString()
	  }
	};
	return pendingInterceptorsFormatter;
}

var mockAgent;
var hasRequiredMockAgent;

function requireMockAgent () {
	if (hasRequiredMockAgent) return mockAgent;
	hasRequiredMockAgent = 1;

	const { kClients } = requireSymbols$4();
	const Agent = requireAgent();
	const {
	  kAgent,
	  kMockAgentSet,
	  kMockAgentGet,
	  kDispatches,
	  kIsMockActive,
	  kNetConnect,
	  kGetNetConnect,
	  kOptions,
	  kFactory
	} = requireMockSymbols();
	const MockClient = requireMockClient();
	const MockPool = requireMockPool();
	const { matchValue, buildMockOptions } = requireMockUtils();
	const { InvalidArgumentError, UndiciError } = requireErrors();
	const Dispatcher = requireDispatcher();
	const Pluralizer = requirePluralizer();
	const PendingInterceptorsFormatter = requirePendingInterceptorsFormatter();

	class FakeWeakRef {
	  constructor (value) {
	    this.value = value;
	  }

	  deref () {
	    return this.value
	  }
	}

	class MockAgent extends Dispatcher {
	  constructor (opts) {
	    super(opts);

	    this[kNetConnect] = true;
	    this[kIsMockActive] = true;

	    // Instantiate Agent and encapsulate
	    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }
	    const agent = opts && opts.agent ? opts.agent : new Agent(opts);
	    this[kAgent] = agent;

	    this[kClients] = agent[kClients];
	    this[kOptions] = buildMockOptions(opts);
	  }

	  get (origin) {
	    let dispatcher = this[kMockAgentGet](origin);

	    if (!dispatcher) {
	      dispatcher = this[kFactory](origin);
	      this[kMockAgentSet](origin, dispatcher);
	    }
	    return dispatcher
	  }

	  dispatch (opts, handler) {
	    // Call MockAgent.get to perform additional setup before dispatching as normal
	    this.get(opts.origin);
	    return this[kAgent].dispatch(opts, handler)
	  }

	  async close () {
	    await this[kAgent].close();
	    this[kClients].clear();
	  }

	  deactivate () {
	    this[kIsMockActive] = false;
	  }

	  activate () {
	    this[kIsMockActive] = true;
	  }

	  enableNetConnect (matcher) {
	    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {
	      if (Array.isArray(this[kNetConnect])) {
	        this[kNetConnect].push(matcher);
	      } else {
	        this[kNetConnect] = [matcher];
	      }
	    } else if (typeof matcher === 'undefined') {
	      this[kNetConnect] = true;
	    } else {
	      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')
	    }
	  }

	  disableNetConnect () {
	    this[kNetConnect] = false;
	  }

	  // This is required to bypass issues caused by using global symbols - see:
	  // https://github.com/nodejs/undici/issues/1447
	  get isMockActive () {
	    return this[kIsMockActive]
	  }

	  [kMockAgentSet] (origin, dispatcher) {
	    this[kClients].set(origin, new FakeWeakRef(dispatcher));
	  }

	  [kFactory] (origin) {
	    const mockOptions = Object.assign({ agent: this }, this[kOptions]);
	    return this[kOptions] && this[kOptions].connections === 1
	      ? new MockClient(origin, mockOptions)
	      : new MockPool(origin, mockOptions)
	  }

	  [kMockAgentGet] (origin) {
	    // First check if we can immediately find it
	    const ref = this[kClients].get(origin);
	    if (ref) {
	      return ref.deref()
	    }

	    // If the origin is not a string create a dummy parent pool and return to user
	    if (typeof origin !== 'string') {
	      const dispatcher = this[kFactory]('http://localhost:9999');
	      this[kMockAgentSet](origin, dispatcher);
	      return dispatcher
	    }

	    // If we match, create a pool and assign the same dispatches
	    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
	      const nonExplicitDispatcher = nonExplicitRef.deref();
	      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {
	        const dispatcher = this[kFactory](origin);
	        this[kMockAgentSet](origin, dispatcher);
	        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
	        return dispatcher
	      }
	    }
	  }

	  [kGetNetConnect] () {
	    return this[kNetConnect]
	  }

	  pendingInterceptors () {
	    const mockAgentClients = this[kClients];

	    return Array.from(mockAgentClients.entries())
	      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))
	      .filter(({ pending }) => pending)
	  }

	  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
	    const pending = this.pendingInterceptors();

	    if (pending.length === 0) {
	      return
	    }

	    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);

	    throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim())
	  }
	}

	mockAgent = MockAgent;
	return mockAgent;
}

var proxyAgent;
var hasRequiredProxyAgent;

function requireProxyAgent () {
	if (hasRequiredProxyAgent) return proxyAgent;
	hasRequiredProxyAgent = 1;

	const { kProxy, kClose, kDestroy, kInterceptors } = requireSymbols$4();
	const { URL } = require$$1$6;
	const Agent = requireAgent();
	const Pool = requirePool();
	const DispatcherBase = requireDispatcherBase();
	const { InvalidArgumentError, RequestAbortedError } = requireErrors();
	const buildConnector = requireConnect();

	const kAgent = Symbol('proxy agent');
	const kClient = Symbol('proxy client');
	const kProxyHeaders = Symbol('proxy headers');
	const kRequestTls = Symbol('request tls settings');
	const kProxyTls = Symbol('proxy tls settings');
	const kConnectEndpoint = Symbol('connect endpoint function');

	function defaultProtocolPort (protocol) {
	  return protocol === 'https:' ? 443 : 80
	}

	function buildProxyOptions (opts) {
	  if (typeof opts === 'string') {
	    opts = { uri: opts };
	  }

	  if (!opts || !opts.uri) {
	    throw new InvalidArgumentError('Proxy opts.uri is mandatory')
	  }

	  return {
	    uri: opts.uri,
	    protocol: opts.protocol || 'https'
	  }
	}

	function defaultFactory (origin, opts) {
	  return new Pool(origin, opts)
	}

	class ProxyAgent extends DispatcherBase {
	  constructor (opts) {
	    super(opts);
	    this[kProxy] = buildProxyOptions(opts);
	    this[kAgent] = new Agent(opts);
	    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)
	      ? opts.interceptors.ProxyAgent
	      : [];

	    if (typeof opts === 'string') {
	      opts = { uri: opts };
	    }

	    if (!opts || !opts.uri) {
	      throw new InvalidArgumentError('Proxy opts.uri is mandatory')
	    }

	    const { clientFactory = defaultFactory } = opts;

	    if (typeof clientFactory !== 'function') {
	      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')
	    }

	    this[kRequestTls] = opts.requestTls;
	    this[kProxyTls] = opts.proxyTls;
	    this[kProxyHeaders] = opts.headers || {};

	    const resolvedUrl = new URL(opts.uri);
	    const { origin, port, host, username, password } = resolvedUrl;

	    if (opts.auth && opts.token) {
	      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')
	    } else if (opts.auth) {
	      /* @deprecated in favour of opts.token */
	      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;
	    } else if (opts.token) {
	      this[kProxyHeaders]['proxy-authorization'] = opts.token;
	    } else if (username && password) {
	      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;
	    }

	    const connect = buildConnector({ ...opts.proxyTls });
	    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
	    this[kClient] = clientFactory(resolvedUrl, { connect });
	    this[kAgent] = new Agent({
	      ...opts,
	      connect: async (opts, callback) => {
	        let requestedHost = opts.host;
	        if (!opts.port) {
	          requestedHost += `:${defaultProtocolPort(opts.protocol)}`;
	        }
	        try {
	          const { socket, statusCode } = await this[kClient].connect({
	            origin,
	            port,
	            path: requestedHost,
	            signal: opts.signal,
	            headers: {
	              ...this[kProxyHeaders],
	              host
	            }
	          });
	          if (statusCode !== 200) {
	            socket.on('error', () => {}).destroy();
	            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
	          }
	          if (opts.protocol !== 'https:') {
	            callback(null, socket);
	            return
	          }
	          let servername;
	          if (this[kRequestTls]) {
	            servername = this[kRequestTls].servername;
	          } else {
	            servername = opts.servername;
	          }
	          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback);
	        } catch (err) {
	          callback(err);
	        }
	      }
	    });
	  }

	  dispatch (opts, handler) {
	    const { host } = new URL(opts.origin);
	    const headers = buildHeaders(opts.headers);
	    throwIfProxyAuthIsSent(headers);
	    return this[kAgent].dispatch(
	      {
	        ...opts,
	        headers: {
	          ...headers,
	          host
	        }
	      },
	      handler
	    )
	  }

	  async [kClose] () {
	    await this[kAgent].close();
	    await this[kClient].close();
	  }

	  async [kDestroy] () {
	    await this[kAgent].destroy();
	    await this[kClient].destroy();
	  }
	}

	/**
	 * @param {string[] | Record<string, string>} headers
	 * @returns {Record<string, string>}
	 */
	function buildHeaders (headers) {
	  // When using undici.fetch, the headers list is stored
	  // as an array.
	  if (Array.isArray(headers)) {
	    /** @type {Record<string, string>} */
	    const headersPair = {};

	    for (let i = 0; i < headers.length; i += 2) {
	      headersPair[headers[i]] = headers[i + 1];
	    }

	    return headersPair
	  }

	  return headers
	}

	/**
	 * @param {Record<string, string>} headers
	 *
	 * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	 * Nevertheless, it was changed and to avoid a security vulnerability by end users
	 * this check was created.
	 * It should be removed in the next major version for performance reasons
	 */
	function throwIfProxyAuthIsSent (headers) {
	  const existProxyAuth = headers && Object.keys(headers)
	    .find((key) => key.toLowerCase() === 'proxy-authorization');
	  if (existProxyAuth) {
	    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')
	  }
	}

	proxyAgent = ProxyAgent;
	return proxyAgent;
}

var RetryHandler_1;
var hasRequiredRetryHandler;

function requireRetryHandler () {
	if (hasRequiredRetryHandler) return RetryHandler_1;
	hasRequiredRetryHandler = 1;
	const assert = require$$0$2;

	const { kRetryHandlerDefaultRetry } = requireSymbols$4();
	const { RequestRetryError } = requireErrors();
	const { isDisturbed, parseHeaders, parseRangeHeader } = requireUtil$6();

	function calculateRetryAfterHeader (retryAfter) {
	  const current = Date.now();
	  const diff = new Date(retryAfter).getTime() - current;

	  return diff
	}

	class RetryHandler {
	  constructor (opts, handlers) {
	    const { retryOptions, ...dispatchOpts } = opts;
	    const {
	      // Retry scoped
	      retry: retryFn,
	      maxRetries,
	      maxTimeout,
	      minTimeout,
	      timeoutFactor,
	      // Response scoped
	      methods,
	      errorCodes,
	      retryAfter,
	      statusCodes
	    } = retryOptions ?? {};

	    this.dispatch = handlers.dispatch;
	    this.handler = handlers.handler;
	    this.opts = dispatchOpts;
	    this.abort = null;
	    this.aborted = false;
	    this.retryOpts = {
	      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
	      retryAfter: retryAfter ?? true,
	      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,
	      timeout: minTimeout ?? 500, // .5s
	      timeoutFactor: timeoutFactor ?? 2,
	      maxRetries: maxRetries ?? 5,
	      // What errors we should retry
	      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],
	      // Indicates which errors to retry
	      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
	      // List of errors to retry
	      errorCodes: errorCodes ?? [
	        'ECONNRESET',
	        'ECONNREFUSED',
	        'ENOTFOUND',
	        'ENETDOWN',
	        'ENETUNREACH',
	        'EHOSTDOWN',
	        'EHOSTUNREACH',
	        'EPIPE'
	      ]
	    };

	    this.retryCount = 0;
	    this.start = 0;
	    this.end = null;
	    this.etag = null;
	    this.resume = null;

	    // Handle possible onConnect duplication
	    this.handler.onConnect(reason => {
	      this.aborted = true;
	      if (this.abort) {
	        this.abort(reason);
	      } else {
	        this.reason = reason;
	      }
	    });
	  }

	  onRequestSent () {
	    if (this.handler.onRequestSent) {
	      this.handler.onRequestSent();
	    }
	  }

	  onUpgrade (statusCode, headers, socket) {
	    if (this.handler.onUpgrade) {
	      this.handler.onUpgrade(statusCode, headers, socket);
	    }
	  }

	  onConnect (abort) {
	    if (this.aborted) {
	      abort(this.reason);
	    } else {
	      this.abort = abort;
	    }
	  }

	  onBodySent (chunk) {
	    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)
	  }

	  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {
	    const { statusCode, code, headers } = err;
	    const { method, retryOptions } = opts;
	    const {
	      maxRetries,
	      timeout,
	      maxTimeout,
	      timeoutFactor,
	      statusCodes,
	      errorCodes,
	      methods
	    } = retryOptions;
	    let { counter, currentTimeout } = state;

	    currentTimeout =
	      currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;

	    // Any code that is not a Undici's originated and allowed to retry
	    if (
	      code &&
	      code !== 'UND_ERR_REQ_RETRY' &&
	      code !== 'UND_ERR_SOCKET' &&
	      !errorCodes.includes(code)
	    ) {
	      cb(err);
	      return
	    }

	    // If a set of method are provided and the current method is not in the list
	    if (Array.isArray(methods) && !methods.includes(method)) {
	      cb(err);
	      return
	    }

	    // If a set of status code are provided and the current status code is not in the list
	    if (
	      statusCode != null &&
	      Array.isArray(statusCodes) &&
	      !statusCodes.includes(statusCode)
	    ) {
	      cb(err);
	      return
	    }

	    // If we reached the max number of retries
	    if (counter > maxRetries) {
	      cb(err);
	      return
	    }

	    let retryAfterHeader = headers != null && headers['retry-after'];
	    if (retryAfterHeader) {
	      retryAfterHeader = Number(retryAfterHeader);
	      retryAfterHeader = isNaN(retryAfterHeader)
	        ? calculateRetryAfterHeader(retryAfterHeader)
	        : retryAfterHeader * 1e3; // Retry-After is in seconds
	    }

	    const retryTimeout =
	      retryAfterHeader > 0
	        ? Math.min(retryAfterHeader, maxTimeout)
	        : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);

	    state.currentTimeout = retryTimeout;

	    setTimeout(() => cb(null), retryTimeout);
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const headers = parseHeaders(rawHeaders);

	    this.retryCount += 1;

	    if (statusCode >= 300) {
	      this.abort(
	        new RequestRetryError('Request failed', statusCode, {
	          headers,
	          count: this.retryCount
	        })
	      );
	      return false
	    }

	    // Checkpoint for resume from where we left it
	    if (this.resume != null) {
	      this.resume = null;

	      if (statusCode !== 206) {
	        return true
	      }

	      const contentRange = parseRangeHeader(headers['content-range']);
	      // If no content range
	      if (!contentRange) {
	        this.abort(
	          new RequestRetryError('Content-Range mismatch', statusCode, {
	            headers,
	            count: this.retryCount
	          })
	        );
	        return false
	      }

	      // Let's start with a weak etag check
	      if (this.etag != null && this.etag !== headers.etag) {
	        this.abort(
	          new RequestRetryError('ETag mismatch', statusCode, {
	            headers,
	            count: this.retryCount
	          })
	        );
	        return false
	      }

	      const { start, size, end = size } = contentRange;

	      assert(this.start === start, 'content-range mismatch');
	      assert(this.end == null || this.end === end, 'content-range mismatch');

	      this.resume = resume;
	      return true
	    }

	    if (this.end == null) {
	      if (statusCode === 206) {
	        // First time we receive 206
	        const range = parseRangeHeader(headers['content-range']);

	        if (range == null) {
	          return this.handler.onHeaders(
	            statusCode,
	            rawHeaders,
	            resume,
	            statusMessage
	          )
	        }

	        const { start, size, end = size } = range;

	        assert(
	          start != null && Number.isFinite(start) && this.start !== start,
	          'content-range mismatch'
	        );
	        assert(Number.isFinite(start));
	        assert(
	          end != null && Number.isFinite(end) && this.end !== end,
	          'invalid content-length'
	        );

	        this.start = start;
	        this.end = end;
	      }

	      // We make our best to checkpoint the body for further range headers
	      if (this.end == null) {
	        const contentLength = headers['content-length'];
	        this.end = contentLength != null ? Number(contentLength) : null;
	      }

	      assert(Number.isFinite(this.start));
	      assert(
	        this.end == null || Number.isFinite(this.end),
	        'invalid content-length'
	      );

	      this.resume = resume;
	      this.etag = headers.etag != null ? headers.etag : null;

	      return this.handler.onHeaders(
	        statusCode,
	        rawHeaders,
	        resume,
	        statusMessage
	      )
	    }

	    const err = new RequestRetryError('Request failed', statusCode, {
	      headers,
	      count: this.retryCount
	    });

	    this.abort(err);

	    return false
	  }

	  onData (chunk) {
	    this.start += chunk.length;

	    return this.handler.onData(chunk)
	  }

	  onComplete (rawTrailers) {
	    this.retryCount = 0;
	    return this.handler.onComplete(rawTrailers)
	  }

	  onError (err) {
	    if (this.aborted || isDisturbed(this.opts.body)) {
	      return this.handler.onError(err)
	    }

	    this.retryOpts.retry(
	      err,
	      {
	        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
	        opts: { retryOptions: this.retryOpts, ...this.opts }
	      },
	      onRetry.bind(this)
	    );

	    function onRetry (err) {
	      if (err != null || this.aborted || isDisturbed(this.opts.body)) {
	        return this.handler.onError(err)
	      }

	      if (this.start !== 0) {
	        this.opts = {
	          ...this.opts,
	          headers: {
	            ...this.opts.headers,
	            range: `bytes=${this.start}-${this.end ?? ''}`
	          }
	        };
	      }

	      try {
	        this.dispatch(this.opts, this);
	      } catch (err) {
	        this.handler.onError(err);
	      }
	    }
	  }
	}

	RetryHandler_1 = RetryHandler;
	return RetryHandler_1;
}

var global$1;
var hasRequiredGlobal;

function requireGlobal () {
	if (hasRequiredGlobal) return global$1;
	hasRequiredGlobal = 1;

	// We include a version number for the Dispatcher API. In case of breaking changes,
	// this version number must be increased to avoid conflicts.
	const globalDispatcher = Symbol.for('undici.globalDispatcher.1');
	const { InvalidArgumentError } = requireErrors();
	const Agent = requireAgent();

	if (getGlobalDispatcher() === undefined) {
	  setGlobalDispatcher(new Agent());
	}

	function setGlobalDispatcher (agent) {
	  if (!agent || typeof agent.dispatch !== 'function') {
	    throw new InvalidArgumentError('Argument agent must implement Agent')
	  }
	  Object.defineProperty(globalThis, globalDispatcher, {
	    value: agent,
	    writable: true,
	    enumerable: false,
	    configurable: false
	  });
	}

	function getGlobalDispatcher () {
	  return globalThis[globalDispatcher]
	}

	global$1 = {
	  setGlobalDispatcher,
	  getGlobalDispatcher
	};
	return global$1;
}

var DecoratorHandler_1;
var hasRequiredDecoratorHandler;

function requireDecoratorHandler () {
	if (hasRequiredDecoratorHandler) return DecoratorHandler_1;
	hasRequiredDecoratorHandler = 1;

	DecoratorHandler_1 = class DecoratorHandler {
	  constructor (handler) {
	    this.handler = handler;
	  }

	  onConnect (...args) {
	    return this.handler.onConnect(...args)
	  }

	  onError (...args) {
	    return this.handler.onError(...args)
	  }

	  onUpgrade (...args) {
	    return this.handler.onUpgrade(...args)
	  }

	  onHeaders (...args) {
	    return this.handler.onHeaders(...args)
	  }

	  onData (...args) {
	    return this.handler.onData(...args)
	  }

	  onComplete (...args) {
	    return this.handler.onComplete(...args)
	  }

	  onBodySent (...args) {
	    return this.handler.onBodySent(...args)
	  }
	};
	return DecoratorHandler_1;
}

var headers;
var hasRequiredHeaders;

function requireHeaders () {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;

	const { kHeadersList, kConstruct } = requireSymbols$4();
	const { kGuard } = requireSymbols$3();
	const { kEnumerableProperty } = requireUtil$6();
	const {
	  makeIterator,
	  isValidHeaderName,
	  isValidHeaderValue
	} = requireUtil$5();
	const util = require$$0$1;
	const { webidl } = requireWebidl();
	const assert = require$$0$2;

	const kHeadersMap = Symbol('headers map');
	const kHeadersSortedMap = Symbol('headers map sorted');

	/**
	 * @param {number} code
	 */
	function isHTTPWhiteSpaceCharCode (code) {
	  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	 * @param {string} potentialValue
	 */
	function headerValueNormalize (potentialValue) {
	  //  To normalize a byte sequence potentialValue, remove
	  //  any leading and trailing HTTP whitespace bytes from
	  //  potentialValue.
	  let i = 0; let j = potentialValue.length;

	  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
	  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;

	  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)
	}

	function fill (headers, object) {
	  // To fill a Headers object headers with a given object object, run these steps:

	  // 1. If object is a sequence, then for each header in object:
	  // Note: webidl conversion to array has already been done.
	  if (Array.isArray(object)) {
	    for (let i = 0; i < object.length; ++i) {
	      const header = object[i];
	      // 1. If header does not contain exactly two items, then throw a TypeError.
	      if (header.length !== 2) {
	        throw webidl.errors.exception({
	          header: 'Headers constructor',
	          message: `expected name/value pair to be length 2, found ${header.length}.`
	        })
	      }

	      // 2. Append (headers first item, headers second item) to headers.
	      appendHeader(headers, header[0], header[1]);
	    }
	  } else if (typeof object === 'object' && object !== null) {
	    // Note: null should throw

	    // 2. Otherwise, object is a record, then for each key  value in object,
	    //    append (key, value) to headers
	    const keys = Object.keys(object);
	    for (let i = 0; i < keys.length; ++i) {
	      appendHeader(headers, keys[i], object[keys[i]]);
	    }
	  } else {
	    throw webidl.errors.conversionFailed({
	      prefix: 'Headers constructor',
	      argument: 'Argument 1',
	      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
	    })
	  }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-headers-append
	 */
	function appendHeader (headers, name, value) {
	  // 1. Normalize value.
	  value = headerValueNormalize(value);

	  // 2. If name is not a header name or value is not a
	  //    header value, then throw a TypeError.
	  if (!isValidHeaderName(name)) {
	    throw webidl.errors.invalidArgument({
	      prefix: 'Headers.append',
	      value: name,
	      type: 'header name'
	    })
	  } else if (!isValidHeaderValue(value)) {
	    throw webidl.errors.invalidArgument({
	      prefix: 'Headers.append',
	      value,
	      type: 'header value'
	    })
	  }

	  // 3. If headerss guard is "immutable", then throw a TypeError.
	  // 4. Otherwise, if headerss guard is "request" and name is a
	  //    forbidden header name, return.
	  // Note: undici does not implement forbidden header names
	  if (headers[kGuard] === 'immutable') {
	    throw new TypeError('immutable')
	  } else if (headers[kGuard] === 'request-no-cors') ;

	  // 6. Otherwise, if headerss guard is "response" and name is a
	  //    forbidden response-header name, return.

	  // 7. Append (name, value) to headerss header list.
	  return headers[kHeadersList].append(name, value)

	  // 8. If headerss guard is "request-no-cors", then remove
	  //    privileged no-CORS request headers from headers
	}

	class HeadersList {
	  /** @type {[string, string][]|null} */
	  cookies = null

	  constructor (init) {
	    if (init instanceof HeadersList) {
	      this[kHeadersMap] = new Map(init[kHeadersMap]);
	      this[kHeadersSortedMap] = init[kHeadersSortedMap];
	      this.cookies = init.cookies === null ? null : [...init.cookies];
	    } else {
	      this[kHeadersMap] = new Map(init);
	      this[kHeadersSortedMap] = null;
	    }
	  }

	  // https://fetch.spec.whatwg.org/#header-list-contains
	  contains (name) {
	    // A header list list contains a header name name if list
	    // contains a header whose name is a byte-case-insensitive
	    // match for name.
	    name = name.toLowerCase();

	    return this[kHeadersMap].has(name)
	  }

	  clear () {
	    this[kHeadersMap].clear();
	    this[kHeadersSortedMap] = null;
	    this.cookies = null;
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-append
	  append (name, value) {
	    this[kHeadersSortedMap] = null;

	    // 1. If list contains name, then set name to the first such
	    //    headers name.
	    const lowercaseName = name.toLowerCase();
	    const exists = this[kHeadersMap].get(lowercaseName);

	    // 2. Append (name, value) to list.
	    if (exists) {
	      const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';
	      this[kHeadersMap].set(lowercaseName, {
	        name: exists.name,
	        value: `${exists.value}${delimiter}${value}`
	      });
	    } else {
	      this[kHeadersMap].set(lowercaseName, { name, value });
	    }

	    if (lowercaseName === 'set-cookie') {
	      this.cookies ??= [];
	      this.cookies.push(value);
	    }
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-set
	  set (name, value) {
	    this[kHeadersSortedMap] = null;
	    const lowercaseName = name.toLowerCase();

	    if (lowercaseName === 'set-cookie') {
	      this.cookies = [value];
	    }

	    // 1. If list contains name, then set the value of
	    //    the first such header to value and remove the
	    //    others.
	    // 2. Otherwise, append header (name, value) to list.
	    this[kHeadersMap].set(lowercaseName, { name, value });
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-delete
	  delete (name) {
	    this[kHeadersSortedMap] = null;

	    name = name.toLowerCase();

	    if (name === 'set-cookie') {
	      this.cookies = null;
	    }

	    this[kHeadersMap].delete(name);
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-get
	  get (name) {
	    const value = this[kHeadersMap].get(name.toLowerCase());

	    // 1. If list does not contain name, then return null.
	    // 2. Return the values of all headers in list whose name
	    //    is a byte-case-insensitive match for name,
	    //    separated from each other by 0x2C 0x20, in order.
	    return value === undefined ? null : value.value
	  }

	  * [Symbol.iterator] () {
	    // use the lowercased name
	    for (const [name, { value }] of this[kHeadersMap]) {
	      yield [name, value];
	    }
	  }

	  get entries () {
	    const headers = {};

	    if (this[kHeadersMap].size) {
	      for (const { name, value } of this[kHeadersMap].values()) {
	        headers[name] = value;
	      }
	    }

	    return headers
	  }
	}

	// https://fetch.spec.whatwg.org/#headers-class
	class Headers {
	  constructor (init = undefined) {
	    if (init === kConstruct) {
	      return
	    }
	    this[kHeadersList] = new HeadersList();

	    // The new Headers(init) constructor steps are:

	    // 1. Set thiss guard to "none".
	    this[kGuard] = 'none';

	    // 2. If init is given, then fill this with init.
	    if (init !== undefined) {
	      init = webidl.converters.HeadersInit(init);
	      fill(this, init);
	    }
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-append
	  append (name, value) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' });

	    name = webidl.converters.ByteString(name);
	    value = webidl.converters.ByteString(value);

	    return appendHeader(this, name, value)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-delete
	  delete (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.delete',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. If thiss guard is "immutable", then throw a TypeError.
	    // 3. Otherwise, if thiss guard is "request" and name is a
	    //    forbidden header name, return.
	    // 4. Otherwise, if thiss guard is "request-no-cors", name
	    //    is not a no-CORS-safelisted request-header name, and
	    //    name is not a privileged no-CORS request-header name,
	    //    return.
	    // 5. Otherwise, if thiss guard is "response" and name is
	    //    a forbidden response-header name, return.
	    // Note: undici does not implement forbidden header names
	    if (this[kGuard] === 'immutable') {
	      throw new TypeError('immutable')
	    } else if (this[kGuard] === 'request-no-cors') ;

	    // 6. If thiss header list does not contain name, then
	    //    return.
	    if (!this[kHeadersList].contains(name)) {
	      return
	    }

	    // 7. Delete name from thiss header list.
	    // 8. If thiss guard is "request-no-cors", then remove
	    //    privileged no-CORS request headers from this.
	    this[kHeadersList].delete(name);
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-get
	  get (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.get',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. Return the result of getting name from thiss header
	    //    list.
	    return this[kHeadersList].get(name)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-has
	  has (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.has',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. Return true if thiss header list contains name;
	    //    otherwise false.
	    return this[kHeadersList].contains(name)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-set
	  set (name, value) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' });

	    name = webidl.converters.ByteString(name);
	    value = webidl.converters.ByteString(value);

	    // 1. Normalize value.
	    value = headerValueNormalize(value);

	    // 2. If name is not a header name or value is not a
	    //    header value, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.set',
	        value: name,
	        type: 'header name'
	      })
	    } else if (!isValidHeaderValue(value)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.set',
	        value,
	        type: 'header value'
	      })
	    }

	    // 3. If thiss guard is "immutable", then throw a TypeError.
	    // 4. Otherwise, if thiss guard is "request" and name is a
	    //    forbidden header name, return.
	    // 5. Otherwise, if thiss guard is "request-no-cors" and
	    //    name/value is not a no-CORS-safelisted request-header,
	    //    return.
	    // 6. Otherwise, if thiss guard is "response" and name is a
	    //    forbidden response-header name, return.
	    // Note: undici does not implement forbidden header names
	    if (this[kGuard] === 'immutable') {
	      throw new TypeError('immutable')
	    } else if (this[kGuard] === 'request-no-cors') ;

	    // 7. Set (name, value) in thiss header list.
	    // 8. If thiss guard is "request-no-cors", then remove
	    //    privileged no-CORS request headers from this
	    this[kHeadersList].set(name, value);
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
	  getSetCookie () {
	    webidl.brandCheck(this, Headers);

	    // 1. If thiss header list does not contain `Set-Cookie`, then return  .
	    // 2. Return the values of all headers in thiss header list whose name is
	    //    a byte-case-insensitive match for `Set-Cookie`, in order.

	    const list = this[kHeadersList].cookies;

	    if (list) {
	      return [...list]
	    }

	    return []
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
	  get [kHeadersSortedMap] () {
	    if (this[kHeadersList][kHeadersSortedMap]) {
	      return this[kHeadersList][kHeadersSortedMap]
	    }

	    // 1. Let headers be an empty list of headers with the key being the name
	    //    and value the value.
	    const headers = [];

	    // 2. Let names be the result of convert header names to a sorted-lowercase
	    //    set with all the names of the headers in list.
	    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
	    const cookies = this[kHeadersList].cookies;

	    // 3. For each name of names:
	    for (let i = 0; i < names.length; ++i) {
	      const [name, value] = names[i];
	      // 1. If name is `set-cookie`, then:
	      if (name === 'set-cookie') {
	        // 1. Let values be a list of all values of headers in list whose name
	        //    is a byte-case-insensitive match for name, in order.

	        // 2. For each value of values:
	        // 1. Append (name, value) to headers.
	        for (let j = 0; j < cookies.length; ++j) {
	          headers.push([name, cookies[j]]);
	        }
	      } else {
	        // 2. Otherwise:

	        // 1. Let value be the result of getting name from list.

	        // 2. Assert: value is non-null.
	        assert(value !== null);

	        // 3. Append (name, value) to headers.
	        headers.push([name, value]);
	      }
	    }

	    this[kHeadersList][kHeadersSortedMap] = headers;

	    // 4. Return headers.
	    return headers
	  }

	  keys () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'key')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'key'
	    )
	  }

	  values () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'value')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'value'
	    )
	  }

	  entries () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'key+value')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'key+value'
	    )
	  }

	  /**
	   * @param {(value: string, key: string, self: Headers) => void} callbackFn
	   * @param {unknown} thisArg
	   */
	  forEach (callbackFn, thisArg = globalThis) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' });

	    if (typeof callbackFn !== 'function') {
	      throw new TypeError(
	        "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
	      )
	    }

	    for (const [key, value] of this) {
	      callbackFn.apply(thisArg, [value, key, this]);
	    }
	  }

	  [Symbol.for('nodejs.util.inspect.custom')] () {
	    webidl.brandCheck(this, Headers);

	    return this[kHeadersList]
	  }
	}

	Headers.prototype[Symbol.iterator] = Headers.prototype.entries;

	Object.defineProperties(Headers.prototype, {
	  append: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  get: kEnumerableProperty,
	  has: kEnumerableProperty,
	  set: kEnumerableProperty,
	  getSetCookie: kEnumerableProperty,
	  keys: kEnumerableProperty,
	  values: kEnumerableProperty,
	  entries: kEnumerableProperty,
	  forEach: kEnumerableProperty,
	  [Symbol.iterator]: { enumerable: false },
	  [Symbol.toStringTag]: {
	    value: 'Headers',
	    configurable: true
	  },
	  [util.inspect.custom]: {
	    enumerable: false
	  }
	});

	webidl.converters.HeadersInit = function (V) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (V[Symbol.iterator]) {
	      return webidl.converters['sequence<sequence<ByteString>>'](V)
	    }

	    return webidl.converters['record<ByteString, ByteString>'](V)
	  }

	  throw webidl.errors.conversionFailed({
	    prefix: 'Headers constructor',
	    argument: 'Argument 1',
	    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
	  })
	};

	headers = {
	  fill,
	  Headers,
	  HeadersList
	};
	return headers;
}

var response;
var hasRequiredResponse;

function requireResponse () {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;

	const { Headers, HeadersList, fill } = requireHeaders();
	const { extractBody, cloneBody, mixinBody } = requireBody();
	const util = requireUtil$6();
	const { kEnumerableProperty } = util;
	const {
	  isValidReasonPhrase,
	  isCancelled,
	  isAborted,
	  isBlobLike,
	  serializeJavascriptValueToJSONString,
	  isErrorLike,
	  isomorphicEncode
	} = requireUtil$5();
	const {
	  redirectStatusSet,
	  nullBodyStatus,
	  DOMException
	} = requireConstants$3();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { FormData } = requireFormdata();
	const { getGlobalOrigin } = requireGlobal$1();
	const { URLSerializer } = requireDataURL();
	const { kHeadersList, kConstruct } = requireSymbols$4();
	const assert = require$$0$2;
	const { types } = require$$0$1;

	const ReadableStream = globalThis.ReadableStream || require$$14.ReadableStream;
	const textEncoder = new TextEncoder('utf-8');

	// https://fetch.spec.whatwg.org/#response-class
	class Response {
	  // Creates network error Response.
	  static error () {
	    // TODO
	    const relevantRealm = { settingsObject: {} };

	    // The static error() method steps are to return the result of creating a
	    // Response object, given a new network error, "immutable", and thiss
	    // relevant Realm.
	    const responseObject = new Response();
	    responseObject[kState] = makeNetworkError();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;
	    return responseObject
	  }

	  // https://fetch.spec.whatwg.org/#dom-response-json
	  static json (data, init = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' });

	    if (init !== null) {
	      init = webidl.converters.ResponseInit(init);
	    }

	    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
	    const bytes = textEncoder.encode(
	      serializeJavascriptValueToJSONString(data)
	    );

	    // 2. Let body be the result of extracting bytes.
	    const body = extractBody(bytes);

	    // 3. Let responseObject be the result of creating a Response object, given a new response,
	    //    "response", and thiss relevant Realm.
	    const relevantRealm = { settingsObject: {} };
	    const responseObject = new Response();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kGuard] = 'response';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 4. Perform initialize a response given responseObject, init, and (body, "application/json").
	    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' });

	    // 5. Return responseObject.
	    return responseObject
	  }

	  // Creates a redirect Response that redirects to url with status status.
	  static redirect (url, status = 302) {
	    const relevantRealm = { settingsObject: {} };

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' });

	    url = webidl.converters.USVString(url);
	    status = webidl.converters['unsigned short'](status);

	    // 1. Let parsedURL be the result of parsing url with current settings
	    // objects API base URL.
	    // 2. If parsedURL is failure, then throw a TypeError.
	    // TODO: base-URL?
	    let parsedURL;
	    try {
	      parsedURL = new URL(url, getGlobalOrigin());
	    } catch (err) {
	      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
	        cause: err
	      })
	    }

	    // 3. If status is not a redirect status, then throw a RangeError.
	    if (!redirectStatusSet.has(status)) {
	      throw new RangeError('Invalid status code ' + status)
	    }

	    // 4. Let responseObject be the result of creating a Response object,
	    // given a new response, "immutable", and thiss relevant Realm.
	    const responseObject = new Response();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 5. Set responseObjects responses status to status.
	    responseObject[kState].status = status;

	    // 6. Let value be parsedURL, serialized and isomorphic encoded.
	    const value = isomorphicEncode(URLSerializer(parsedURL));

	    // 7. Append `Location`/value to responseObjects responses header list.
	    responseObject[kState].headersList.append('location', value);

	    // 8. Return responseObject.
	    return responseObject
	  }

	  // https://fetch.spec.whatwg.org/#dom-response
	  constructor (body = null, init = {}) {
	    if (body !== null) {
	      body = webidl.converters.BodyInit(body);
	    }

	    init = webidl.converters.ResponseInit(init);

	    // TODO
	    this[kRealm] = { settingsObject: {} };

	    // 1. Set thiss response to a new response.
	    this[kState] = makeResponse({});

	    // 2. Set thiss headers to a new Headers object with thiss relevant
	    // Realm, whose header list is thiss responses header list and guard
	    // is "response".
	    this[kHeaders] = new Headers(kConstruct);
	    this[kHeaders][kGuard] = 'response';
	    this[kHeaders][kHeadersList] = this[kState].headersList;
	    this[kHeaders][kRealm] = this[kRealm];

	    // 3. Let bodyWithType be null.
	    let bodyWithType = null;

	    // 4. If body is non-null, then set bodyWithType to the result of extracting body.
	    if (body != null) {
	      const [extractedBody, type] = extractBody(body);
	      bodyWithType = { body: extractedBody, type };
	    }

	    // 5. Perform initialize a response given this, init, and bodyWithType.
	    initializeResponse(this, init, bodyWithType);
	  }

	  // Returns responses type, e.g., "cors".
	  get type () {
	    webidl.brandCheck(this, Response);

	    // The type getter steps are to return thiss responses type.
	    return this[kState].type
	  }

	  // Returns responses URL, if it has one; otherwise the empty string.
	  get url () {
	    webidl.brandCheck(this, Response);

	    const urlList = this[kState].urlList;

	    // The url getter steps are to return the empty string if thiss
	    // responses URL is null; otherwise thiss responses URL,
	    // serialized with exclude fragment set to true.
	    const url = urlList[urlList.length - 1] ?? null;

	    if (url === null) {
	      return ''
	    }

	    return URLSerializer(url, true)
	  }

	  // Returns whether response was obtained through a redirect.
	  get redirected () {
	    webidl.brandCheck(this, Response);

	    // The redirected getter steps are to return true if thiss responses URL
	    // list has more than one item; otherwise false.
	    return this[kState].urlList.length > 1
	  }

	  // Returns responses status.
	  get status () {
	    webidl.brandCheck(this, Response);

	    // The status getter steps are to return thiss responses status.
	    return this[kState].status
	  }

	  // Returns whether responses status is an ok status.
	  get ok () {
	    webidl.brandCheck(this, Response);

	    // The ok getter steps are to return true if thiss responses status is an
	    // ok status; otherwise false.
	    return this[kState].status >= 200 && this[kState].status <= 299
	  }

	  // Returns responses status message.
	  get statusText () {
	    webidl.brandCheck(this, Response);

	    // The statusText getter steps are to return thiss responses status
	    // message.
	    return this[kState].statusText
	  }

	  // Returns responses headers as Headers.
	  get headers () {
	    webidl.brandCheck(this, Response);

	    // The headers getter steps are to return thiss headers.
	    return this[kHeaders]
	  }

	  get body () {
	    webidl.brandCheck(this, Response);

	    return this[kState].body ? this[kState].body.stream : null
	  }

	  get bodyUsed () {
	    webidl.brandCheck(this, Response);

	    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
	  }

	  // Returns a clone of response.
	  clone () {
	    webidl.brandCheck(this, Response);

	    // 1. If this is unusable, then throw a TypeError.
	    if (this.bodyUsed || (this.body && this.body.locked)) {
	      throw webidl.errors.exception({
	        header: 'Response.clone',
	        message: 'Body has already been consumed.'
	      })
	    }

	    // 2. Let clonedResponse be the result of cloning thiss response.
	    const clonedResponse = cloneResponse(this[kState]);

	    // 3. Return the result of creating a Response object, given
	    // clonedResponse, thiss headerss guard, and thiss relevant Realm.
	    const clonedResponseObject = new Response();
	    clonedResponseObject[kState] = clonedResponse;
	    clonedResponseObject[kRealm] = this[kRealm];
	    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
	    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
	    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];

	    return clonedResponseObject
	  }
	}

	mixinBody(Response);

	Object.defineProperties(Response.prototype, {
	  type: kEnumerableProperty,
	  url: kEnumerableProperty,
	  status: kEnumerableProperty,
	  ok: kEnumerableProperty,
	  redirected: kEnumerableProperty,
	  statusText: kEnumerableProperty,
	  headers: kEnumerableProperty,
	  clone: kEnumerableProperty,
	  body: kEnumerableProperty,
	  bodyUsed: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'Response',
	    configurable: true
	  }
	});

	Object.defineProperties(Response, {
	  json: kEnumerableProperty,
	  redirect: kEnumerableProperty,
	  error: kEnumerableProperty
	});

	// https://fetch.spec.whatwg.org/#concept-response-clone
	function cloneResponse (response) {
	  // To clone a response response, run these steps:

	  // 1. If response is a filtered response, then return a new identical
	  // filtered response whose internal response is a clone of responses
	  // internal response.
	  if (response.internalResponse) {
	    return filterResponse(
	      cloneResponse(response.internalResponse),
	      response.type
	    )
	  }

	  // 2. Let newResponse be a copy of response, except for its body.
	  const newResponse = makeResponse({ ...response, body: null });

	  // 3. If responses body is non-null, then set newResponses body to the
	  // result of cloning responses body.
	  if (response.body != null) {
	    newResponse.body = cloneBody(response.body);
	  }

	  // 4. Return newResponse.
	  return newResponse
	}

	function makeResponse (init) {
	  return {
	    aborted: false,
	    rangeRequested: false,
	    timingAllowPassed: false,
	    requestIncludesCredentials: false,
	    type: 'default',
	    status: 200,
	    timingInfo: null,
	    cacheState: '',
	    statusText: '',
	    ...init,
	    headersList: init.headersList
	      ? new HeadersList(init.headersList)
	      : new HeadersList(),
	    urlList: init.urlList ? [...init.urlList] : []
	  }
	}

	function makeNetworkError (reason) {
	  const isError = isErrorLike(reason);
	  return makeResponse({
	    type: 'error',
	    status: 0,
	    error: isError
	      ? reason
	      : new Error(reason ? String(reason) : reason),
	    aborted: reason && reason.name === 'AbortError'
	  })
	}

	function makeFilteredResponse (response, state) {
	  state = {
	    internalResponse: response,
	    ...state
	  };

	  return new Proxy(response, {
	    get (target, p) {
	      return p in state ? state[p] : target[p]
	    },
	    set (target, p, value) {
	      assert(!(p in state));
	      target[p] = value;
	      return true
	    }
	  })
	}

	// https://fetch.spec.whatwg.org/#concept-filtered-response
	function filterResponse (response, type) {
	  // Set response to the following filtered response with response as its
	  // internal response, depending on requests response tainting:
	  if (type === 'basic') {
	    // A basic filtered response is a filtered response whose type is "basic"
	    // and header list excludes any headers in internal responses header list
	    // whose name is a forbidden response-header name.

	    // Note: undici does not implement forbidden response-header names
	    return makeFilteredResponse(response, {
	      type: 'basic',
	      headersList: response.headersList
	    })
	  } else if (type === 'cors') {
	    // A CORS filtered response is a filtered response whose type is "cors"
	    // and header list excludes any headers in internal responses header
	    // list whose name is not a CORS-safelisted response-header name, given
	    // internal responses CORS-exposed header-name list.

	    // Note: undici does not implement CORS-safelisted response-header names
	    return makeFilteredResponse(response, {
	      type: 'cors',
	      headersList: response.headersList
	    })
	  } else if (type === 'opaque') {
	    // An opaque filtered response is a filtered response whose type is
	    // "opaque", URL list is the empty list, status is 0, status message
	    // is the empty byte sequence, header list is empty, and body is null.

	    return makeFilteredResponse(response, {
	      type: 'opaque',
	      urlList: Object.freeze([]),
	      status: 0,
	      statusText: '',
	      body: null
	    })
	  } else if (type === 'opaqueredirect') {
	    // An opaque-redirect filtered response is a filtered response whose type
	    // is "opaqueredirect", status is 0, status message is the empty byte
	    // sequence, header list is empty, and body is null.

	    return makeFilteredResponse(response, {
	      type: 'opaqueredirect',
	      status: 0,
	      statusText: '',
	      headersList: [],
	      body: null
	    })
	  } else {
	    assert(false);
	  }
	}

	// https://fetch.spec.whatwg.org/#appropriate-network-error
	function makeAppropriateNetworkError (fetchParams, err = null) {
	  // 1. Assert: fetchParams is canceled.
	  assert(isCancelled(fetchParams));

	  // 2. Return an aborted network error if fetchParams is aborted;
	  // otherwise return a network error.
	  return isAborted(fetchParams)
	    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))
	    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))
	}

	// https://whatpr.org/fetch/1392.html#initialize-a-response
	function initializeResponse (response, init, body) {
	  // 1. If init["status"] is not in the range 200 to 599, inclusive, then
	  //    throw a RangeError.
	  if (init.status !== null && (init.status < 200 || init.status > 599)) {
	    throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.')
	  }

	  // 2. If init["statusText"] does not match the reason-phrase token production,
	  //    then throw a TypeError.
	  if ('statusText' in init && init.statusText != null) {
	    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
	    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
	    if (!isValidReasonPhrase(String(init.statusText))) {
	      throw new TypeError('Invalid statusText')
	    }
	  }

	  // 3. Set responses responses status to init["status"].
	  if ('status' in init && init.status != null) {
	    response[kState].status = init.status;
	  }

	  // 4. Set responses responses status message to init["statusText"].
	  if ('statusText' in init && init.statusText != null) {
	    response[kState].statusText = init.statusText;
	  }

	  // 5. If init["headers"] exists, then fill responses headers with init["headers"].
	  if ('headers' in init && init.headers != null) {
	    fill(response[kHeaders], init.headers);
	  }

	  // 6. If body was given, then:
	  if (body) {
	    // 1. If response's status is a null body status, then throw a TypeError.
	    if (nullBodyStatus.includes(response.status)) {
	      throw webidl.errors.exception({
	        header: 'Response constructor',
	        message: 'Invalid response status code ' + response.status
	      })
	    }

	    // 2. Set response's body to body's body.
	    response[kState].body = body.body;

	    // 3. If body's type is non-null and response's header list does not contain
	    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
	    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {
	      response[kState].headersList.append('content-type', body.type);
	    }
	  }
	}

	webidl.converters.ReadableStream = webidl.interfaceConverter(
	  ReadableStream
	);

	webidl.converters.FormData = webidl.interfaceConverter(
	  FormData
	);

	webidl.converters.URLSearchParams = webidl.interfaceConverter(
	  URLSearchParams
	);

	// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
	webidl.converters.XMLHttpRequestBodyInit = function (V) {
	  if (typeof V === 'string') {
	    return webidl.converters.USVString(V)
	  }

	  if (isBlobLike(V)) {
	    return webidl.converters.Blob(V, { strict: false })
	  }

	  if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
	    return webidl.converters.BufferSource(V)
	  }

	  if (util.isFormDataLike(V)) {
	    return webidl.converters.FormData(V, { strict: false })
	  }

	  if (V instanceof URLSearchParams) {
	    return webidl.converters.URLSearchParams(V)
	  }

	  return webidl.converters.DOMString(V)
	};

	// https://fetch.spec.whatwg.org/#bodyinit
	webidl.converters.BodyInit = function (V) {
	  if (V instanceof ReadableStream) {
	    return webidl.converters.ReadableStream(V)
	  }

	  // Note: the spec doesn't include async iterables,
	  // this is an undici extension.
	  if (V?.[Symbol.asyncIterator]) {
	    return V
	  }

	  return webidl.converters.XMLHttpRequestBodyInit(V)
	};

	webidl.converters.ResponseInit = webidl.dictionaryConverter([
	  {
	    key: 'status',
	    converter: webidl.converters['unsigned short'],
	    defaultValue: 200
	  },
	  {
	    key: 'statusText',
	    converter: webidl.converters.ByteString,
	    defaultValue: ''
	  },
	  {
	    key: 'headers',
	    converter: webidl.converters.HeadersInit
	  }
	]);

	response = {
	  makeNetworkError,
	  makeResponse,
	  makeAppropriateNetworkError,
	  filterResponse,
	  Response,
	  cloneResponse
	};
	return response;
}

/* globals AbortController */

var request$1;
var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request$1;
	hasRequiredRequest = 1;

	const { extractBody, mixinBody, cloneBody } = requireBody();
	const { Headers, fill: fillHeaders, HeadersList } = requireHeaders();
	const { FinalizationRegistry } = requireDispatcherWeakref()();
	const util = requireUtil$6();
	const {
	  isValidHTTPToken,
	  sameOrigin,
	  normalizeMethod,
	  makePolicyContainer,
	  normalizeMethodRecord
	} = requireUtil$5();
	const {
	  forbiddenMethodsSet,
	  corsSafeListedMethodsSet,
	  referrerPolicy,
	  requestRedirect,
	  requestMode,
	  requestCredentials,
	  requestCache,
	  requestDuplex
	} = requireConstants$3();
	const { kEnumerableProperty } = util;
	const { kHeaders, kSignal, kState, kGuard, kRealm } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { getGlobalOrigin } = requireGlobal$1();
	const { URLSerializer } = requireDataURL();
	const { kHeadersList, kConstruct } = requireSymbols$4();
	const assert = require$$0$2;
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$4$1;

	let TransformStream = globalThis.TransformStream;

	const kAbortController = Symbol('abortController');

	const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
	  signal.removeEventListener('abort', abort);
	});

	// https://fetch.spec.whatwg.org/#request-class
	class Request {
	  // https://fetch.spec.whatwg.org/#dom-request
	  constructor (input, init = {}) {
	    if (input === kConstruct) {
	      return
	    }

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Request constructor' });

	    input = webidl.converters.RequestInfo(input);
	    init = webidl.converters.RequestInit(init);

	    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
	    this[kRealm] = {
	      settingsObject: {
	        baseUrl: getGlobalOrigin(),
	        get origin () {
	          return this.baseUrl?.origin
	        },
	        policyContainer: makePolicyContainer()
	      }
	    };

	    // 1. Let request be null.
	    let request = null;

	    // 2. Let fallbackMode be null.
	    let fallbackMode = null;

	    // 3. Let baseURL be thiss relevant settings objects API base URL.
	    const baseUrl = this[kRealm].settingsObject.baseUrl;

	    // 4. Let signal be null.
	    let signal = null;

	    // 5. If input is a string, then:
	    if (typeof input === 'string') {
	      // 1. Let parsedURL be the result of parsing input with baseURL.
	      // 2. If parsedURL is failure, then throw a TypeError.
	      let parsedURL;
	      try {
	        parsedURL = new URL(input, baseUrl);
	      } catch (err) {
	        throw new TypeError('Failed to parse URL from ' + input, { cause: err })
	      }

	      // 3. If parsedURL includes credentials, then throw a TypeError.
	      if (parsedURL.username || parsedURL.password) {
	        throw new TypeError(
	          'Request cannot be constructed from a URL that includes credentials: ' +
	            input
	        )
	      }

	      // 4. Set request to a new request whose URL is parsedURL.
	      request = makeRequest({ urlList: [parsedURL] });

	      // 5. Set fallbackMode to "cors".
	      fallbackMode = 'cors';
	    } else {
	      // 6. Otherwise:

	      // 7. Assert: input is a Request object.
	      assert(input instanceof Request);

	      // 8. Set request to inputs request.
	      request = input[kState];

	      // 9. Set signal to inputs signal.
	      signal = input[kSignal];
	    }

	    // 7. Let origin be thiss relevant settings objects origin.
	    const origin = this[kRealm].settingsObject.origin;

	    // 8. Let window be "client".
	    let window = 'client';

	    // 9. If requests window is an environment settings object and its origin
	    // is same origin with origin, then set window to requests window.
	    if (
	      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&
	      sameOrigin(request.window, origin)
	    ) {
	      window = request.window;
	    }

	    // 10. If init["window"] exists and is non-null, then throw a TypeError.
	    if (init.window != null) {
	      throw new TypeError(`'window' option '${window}' must be null`)
	    }

	    // 11. If init["window"] exists, then set window to "no-window".
	    if ('window' in init) {
	      window = 'no-window';
	    }

	    // 12. Set request to a new request with the following properties:
	    request = makeRequest({
	      // URL requests URL.
	      // undici implementation note: this is set as the first item in request's urlList in makeRequest
	      // method requests method.
	      method: request.method,
	      // header list A copy of requests header list.
	      // undici implementation note: headersList is cloned in makeRequest
	      headersList: request.headersList,
	      // unsafe-request flag Set.
	      unsafeRequest: request.unsafeRequest,
	      // client Thiss relevant settings object.
	      client: this[kRealm].settingsObject,
	      // window window.
	      window,
	      // priority requests priority.
	      priority: request.priority,
	      // origin requests origin. The propagation of the origin is only significant for navigation requests
	      // being handled by a service worker. In this scenario a request can have an origin that is different
	      // from the current client.
	      origin: request.origin,
	      // referrer requests referrer.
	      referrer: request.referrer,
	      // referrer policy requests referrer policy.
	      referrerPolicy: request.referrerPolicy,
	      // mode requests mode.
	      mode: request.mode,
	      // credentials mode requests credentials mode.
	      credentials: request.credentials,
	      // cache mode requests cache mode.
	      cache: request.cache,
	      // redirect mode requests redirect mode.
	      redirect: request.redirect,
	      // integrity metadata requests integrity metadata.
	      integrity: request.integrity,
	      // keepalive requests keepalive.
	      keepalive: request.keepalive,
	      // reload-navigation flag requests reload-navigation flag.
	      reloadNavigation: request.reloadNavigation,
	      // history-navigation flag requests history-navigation flag.
	      historyNavigation: request.historyNavigation,
	      // URL list A clone of requests URL list.
	      urlList: [...request.urlList]
	    });

	    const initHasKey = Object.keys(init).length !== 0;

	    // 13. If init is not empty, then:
	    if (initHasKey) {
	      // 1. If requests mode is "navigate", then set it to "same-origin".
	      if (request.mode === 'navigate') {
	        request.mode = 'same-origin';
	      }

	      // 2. Unset requests reload-navigation flag.
	      request.reloadNavigation = false;

	      // 3. Unset requests history-navigation flag.
	      request.historyNavigation = false;

	      // 4. Set requests origin to "client".
	      request.origin = 'client';

	      // 5. Set requests referrer to "client"
	      request.referrer = 'client';

	      // 6. Set requests referrer policy to the empty string.
	      request.referrerPolicy = '';

	      // 7. Set requests URL to requests current URL.
	      request.url = request.urlList[request.urlList.length - 1];

	      // 8. Set requests URL list to  requests URL .
	      request.urlList = [request.url];
	    }

	    // 14. If init["referrer"] exists, then:
	    if (init.referrer !== undefined) {
	      // 1. Let referrer be init["referrer"].
	      const referrer = init.referrer;

	      // 2. If referrer is the empty string, then set requests referrer to "no-referrer".
	      if (referrer === '') {
	        request.referrer = 'no-referrer';
	      } else {
	        // 1. Let parsedReferrer be the result of parsing referrer with
	        // baseURL.
	        // 2. If parsedReferrer is failure, then throw a TypeError.
	        let parsedReferrer;
	        try {
	          parsedReferrer = new URL(referrer, baseUrl);
	        } catch (err) {
	          throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err })
	        }

	        // 3. If one of the following is true
	        // - parsedReferrers scheme is "about" and path is the string "client"
	        // - parsedReferrers origin is not same origin with origin
	        // then set requests referrer to "client".
	        if (
	          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||
	          (origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
	        ) {
	          request.referrer = 'client';
	        } else {
	          // 4. Otherwise, set requests referrer to parsedReferrer.
	          request.referrer = parsedReferrer;
	        }
	      }
	    }

	    // 15. If init["referrerPolicy"] exists, then set requests referrer policy
	    // to it.
	    if (init.referrerPolicy !== undefined) {
	      request.referrerPolicy = init.referrerPolicy;
	    }

	    // 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
	    let mode;
	    if (init.mode !== undefined) {
	      mode = init.mode;
	    } else {
	      mode = fallbackMode;
	    }

	    // 17. If mode is "navigate", then throw a TypeError.
	    if (mode === 'navigate') {
	      throw webidl.errors.exception({
	        header: 'Request constructor',
	        message: 'invalid request mode navigate.'
	      })
	    }

	    // 18. If mode is non-null, set requests mode to mode.
	    if (mode != null) {
	      request.mode = mode;
	    }

	    // 19. If init["credentials"] exists, then set requests credentials mode
	    // to it.
	    if (init.credentials !== undefined) {
	      request.credentials = init.credentials;
	    }

	    // 18. If init["cache"] exists, then set requests cache mode to it.
	    if (init.cache !== undefined) {
	      request.cache = init.cache;
	    }

	    // 21. If requests cache mode is "only-if-cached" and requests mode is
	    // not "same-origin", then throw a TypeError.
	    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
	      throw new TypeError(
	        "'only-if-cached' can be set only with 'same-origin' mode"
	      )
	    }

	    // 22. If init["redirect"] exists, then set requests redirect mode to it.
	    if (init.redirect !== undefined) {
	      request.redirect = init.redirect;
	    }

	    // 23. If init["integrity"] exists, then set requests integrity metadata to it.
	    if (init.integrity != null) {
	      request.integrity = String(init.integrity);
	    }

	    // 24. If init["keepalive"] exists, then set requests keepalive to it.
	    if (init.keepalive !== undefined) {
	      request.keepalive = Boolean(init.keepalive);
	    }

	    // 25. If init["method"] exists, then:
	    if (init.method !== undefined) {
	      // 1. Let method be init["method"].
	      let method = init.method;

	      // 2. If method is not a method or method is a forbidden method, then
	      // throw a TypeError.
	      if (!isValidHTTPToken(method)) {
	        throw new TypeError(`'${method}' is not a valid HTTP method.`)
	      }

	      if (forbiddenMethodsSet.has(method.toUpperCase())) {
	        throw new TypeError(`'${method}' HTTP method is unsupported.`)
	      }

	      // 3. Normalize method.
	      method = normalizeMethodRecord[method] ?? normalizeMethod(method);

	      // 4. Set requests method to method.
	      request.method = method;
	    }

	    // 26. If init["signal"] exists, then set signal to it.
	    if (init.signal !== undefined) {
	      signal = init.signal;
	    }

	    // 27. Set thiss request to request.
	    this[kState] = request;

	    // 28. Set thiss signal to a new AbortSignal object with thiss relevant
	    // Realm.
	    // TODO: could this be simplified with AbortSignal.any
	    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)
	    const ac = new AbortController();
	    this[kSignal] = ac.signal;
	    this[kSignal][kRealm] = this[kRealm];

	    // 29. If signal is not null, then make thiss signal follow signal.
	    if (signal != null) {
	      if (
	        !signal ||
	        typeof signal.aborted !== 'boolean' ||
	        typeof signal.addEventListener !== 'function'
	      ) {
	        throw new TypeError(
	          "Failed to construct 'Request': member signal is not of type AbortSignal."
	        )
	      }

	      if (signal.aborted) {
	        ac.abort(signal.reason);
	      } else {
	        // Keep a strong ref to ac while request object
	        // is alive. This is needed to prevent AbortController
	        // from being prematurely garbage collected.
	        // See, https://github.com/nodejs/undici/issues/1926.
	        this[kAbortController] = ac;

	        const acRef = new WeakRef(ac);
	        const abort = function () {
	          const ac = acRef.deref();
	          if (ac !== undefined) {
	            ac.abort(this.reason);
	          }
	        };

	        // Third-party AbortControllers may not work with these.
	        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.
	        try {
	          // If the max amount of listeners is equal to the default, increase it
	          // This is only available in node >= v19.9.0
	          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {
	            setMaxListeners(100, signal);
	          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {
	            setMaxListeners(100, signal);
	          }
	        } catch {}

	        util.addAbortListener(signal, abort);
	        requestFinalizer.register(ac, { signal, abort });
	      }
	    }

	    // 30. Set thiss headers to a new Headers object with thiss relevant
	    // Realm, whose header list is requests header list and guard is
	    // "request".
	    this[kHeaders] = new Headers(kConstruct);
	    this[kHeaders][kHeadersList] = request.headersList;
	    this[kHeaders][kGuard] = 'request';
	    this[kHeaders][kRealm] = this[kRealm];

	    // 31. If thiss requests mode is "no-cors", then:
	    if (mode === 'no-cors') {
	      // 1. If thiss requests method is not a CORS-safelisted method,
	      // then throw a TypeError.
	      if (!corsSafeListedMethodsSet.has(request.method)) {
	        throw new TypeError(
	          `'${request.method} is unsupported in no-cors mode.`
	        )
	      }

	      // 2. Set thiss headerss guard to "request-no-cors".
	      this[kHeaders][kGuard] = 'request-no-cors';
	    }

	    // 32. If init is not empty, then:
	    if (initHasKey) {
	      /** @type {HeadersList} */
	      const headersList = this[kHeaders][kHeadersList];
	      // 1. Let headers be a copy of thiss headers and its associated header
	      // list.
	      // 2. If init["headers"] exists, then set headers to init["headers"].
	      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);

	      // 3. Empty thiss headerss header list.
	      headersList.clear();

	      // 4. If headers is a Headers object, then for each header in its header
	      // list, append headers name/headers value to thiss headers.
	      if (headers instanceof HeadersList) {
	        for (const [key, val] of headers) {
	          headersList.append(key, val);
	        }
	        // Note: Copy the `set-cookie` meta-data.
	        headersList.cookies = headers.cookies;
	      } else {
	        // 5. Otherwise, fill thiss headers with headers.
	        fillHeaders(this[kHeaders], headers);
	      }
	    }

	    // 33. Let inputBody be inputs requests body if input is a Request
	    // object; otherwise null.
	    const inputBody = input instanceof Request ? input[kState].body : null;

	    // 34. If either init["body"] exists and is non-null or inputBody is
	    // non-null, and requests method is `GET` or `HEAD`, then throw a
	    // TypeError.
	    if (
	      (init.body != null || inputBody != null) &&
	      (request.method === 'GET' || request.method === 'HEAD')
	    ) {
	      throw new TypeError('Request with GET/HEAD method cannot have body.')
	    }

	    // 35. Let initBody be null.
	    let initBody = null;

	    // 36. If init["body"] exists and is non-null, then:
	    if (init.body != null) {
	      // 1. Let Content-Type be null.
	      // 2. Set initBody and Content-Type to the result of extracting
	      // init["body"], with keepalive set to requests keepalive.
	      const [extractedBody, contentType] = extractBody(
	        init.body,
	        request.keepalive
	      );
	      initBody = extractedBody;

	      // 3, If Content-Type is non-null and thiss headerss header list does
	      // not contain `Content-Type`, then append `Content-Type`/Content-Type to
	      // thiss headers.
	      if (contentType && !this[kHeaders][kHeadersList].contains('content-type')) {
	        this[kHeaders].append('content-type', contentType);
	      }
	    }

	    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise
	    // inputBody.
	    const inputOrInitBody = initBody ?? inputBody;

	    // 38. If inputOrInitBody is non-null and inputOrInitBodys source is
	    // null, then:
	    if (inputOrInitBody != null && inputOrInitBody.source == null) {
	      // 1. If initBody is non-null and init["duplex"] does not exist,
	      //    then throw a TypeError.
	      if (initBody != null && init.duplex == null) {
	        throw new TypeError('RequestInit: duplex option is required when sending a body.')
	      }

	      // 2. If thiss requests mode is neither "same-origin" nor "cors",
	      // then throw a TypeError.
	      if (request.mode !== 'same-origin' && request.mode !== 'cors') {
	        throw new TypeError(
	          'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
	        )
	      }

	      // 3. Set thiss requests use-CORS-preflight flag.
	      request.useCORSPreflightFlag = true;
	    }

	    // 39. Let finalBody be inputOrInitBody.
	    let finalBody = inputOrInitBody;

	    // 40. If initBody is null and inputBody is non-null, then:
	    if (initBody == null && inputBody != null) {
	      // 1. If input is unusable, then throw a TypeError.
	      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
	        throw new TypeError(
	          'Cannot construct a Request with a Request object that has already been used.'
	        )
	      }

	      // 2. Set finalBody to the result of creating a proxy for inputBody.
	      if (!TransformStream) {
	        TransformStream = require$$14.TransformStream;
	      }

	      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy
	      const identityTransform = new TransformStream();
	      inputBody.stream.pipeThrough(identityTransform);
	      finalBody = {
	        source: inputBody.source,
	        length: inputBody.length,
	        stream: identityTransform.readable
	      };
	    }

	    // 41. Set thiss requests body to finalBody.
	    this[kState].body = finalBody;
	  }

	  // Returns requests HTTP method, which is "GET" by default.
	  get method () {
	    webidl.brandCheck(this, Request);

	    // The method getter steps are to return thiss requests method.
	    return this[kState].method
	  }

	  // Returns the URL of request as a string.
	  get url () {
	    webidl.brandCheck(this, Request);

	    // The url getter steps are to return thiss requests URL, serialized.
	    return URLSerializer(this[kState].url)
	  }

	  // Returns a Headers object consisting of the headers associated with request.
	  // Note that headers added in the network layer by the user agent will not
	  // be accounted for in this object, e.g., the "Host" header.
	  get headers () {
	    webidl.brandCheck(this, Request);

	    // The headers getter steps are to return thiss headers.
	    return this[kHeaders]
	  }

	  // Returns the kind of resource requested by request, e.g., "document"
	  // or "script".
	  get destination () {
	    webidl.brandCheck(this, Request);

	    // The destination getter are to return thiss requests destination.
	    return this[kState].destination
	  }

	  // Returns the referrer of request. Its value can be a same-origin URL if
	  // explicitly set in init, the empty string to indicate no referrer, and
	  // "about:client" when defaulting to the globals default. This is used
	  // during fetching to determine the value of the `Referer` header of the
	  // request being made.
	  get referrer () {
	    webidl.brandCheck(this, Request);

	    // 1. If thiss requests referrer is "no-referrer", then return the
	    // empty string.
	    if (this[kState].referrer === 'no-referrer') {
	      return ''
	    }

	    // 2. If thiss requests referrer is "client", then return
	    // "about:client".
	    if (this[kState].referrer === 'client') {
	      return 'about:client'
	    }

	    // Return thiss requests referrer, serialized.
	    return this[kState].referrer.toString()
	  }

	  // Returns the referrer policy associated with request.
	  // This is used during fetching to compute the value of the requests
	  // referrer.
	  get referrerPolicy () {
	    webidl.brandCheck(this, Request);

	    // The referrerPolicy getter steps are to return thiss requests referrer policy.
	    return this[kState].referrerPolicy
	  }

	  // Returns the mode associated with request, which is a string indicating
	  // whether the request will use CORS, or will be restricted to same-origin
	  // URLs.
	  get mode () {
	    webidl.brandCheck(this, Request);

	    // The mode getter steps are to return thiss requests mode.
	    return this[kState].mode
	  }

	  // Returns the credentials mode associated with request,
	  // which is a string indicating whether credentials will be sent with the
	  // request always, never, or only when sent to a same-origin URL.
	  get credentials () {
	    // The credentials getter steps are to return thiss requests credentials mode.
	    return this[kState].credentials
	  }

	  // Returns the cache mode associated with request,
	  // which is a string indicating how the request will
	  // interact with the browsers cache when fetching.
	  get cache () {
	    webidl.brandCheck(this, Request);

	    // The cache getter steps are to return thiss requests cache mode.
	    return this[kState].cache
	  }

	  // Returns the redirect mode associated with request,
	  // which is a string indicating how redirects for the
	  // request will be handled during fetching. A request
	  // will follow redirects by default.
	  get redirect () {
	    webidl.brandCheck(this, Request);

	    // The redirect getter steps are to return thiss requests redirect mode.
	    return this[kState].redirect
	  }

	  // Returns requests subresource integrity metadata, which is a
	  // cryptographic hash of the resource being fetched. Its value
	  // consists of multiple hashes separated by whitespace. [SRI]
	  get integrity () {
	    webidl.brandCheck(this, Request);

	    // The integrity getter steps are to return thiss requests integrity
	    // metadata.
	    return this[kState].integrity
	  }

	  // Returns a boolean indicating whether or not request can outlive the
	  // global in which it was created.
	  get keepalive () {
	    webidl.brandCheck(this, Request);

	    // The keepalive getter steps are to return thiss requests keepalive.
	    return this[kState].keepalive
	  }

	  // Returns a boolean indicating whether or not request is for a reload
	  // navigation.
	  get isReloadNavigation () {
	    webidl.brandCheck(this, Request);

	    // The isReloadNavigation getter steps are to return true if thiss
	    // requests reload-navigation flag is set; otherwise false.
	    return this[kState].reloadNavigation
	  }

	  // Returns a boolean indicating whether or not request is for a history
	  // navigation (a.k.a. back-foward navigation).
	  get isHistoryNavigation () {
	    webidl.brandCheck(this, Request);

	    // The isHistoryNavigation getter steps are to return true if thiss requests
	    // history-navigation flag is set; otherwise false.
	    return this[kState].historyNavigation
	  }

	  // Returns the signal associated with request, which is an AbortSignal
	  // object indicating whether or not request has been aborted, and its
	  // abort event handler.
	  get signal () {
	    webidl.brandCheck(this, Request);

	    // The signal getter steps are to return thiss signal.
	    return this[kSignal]
	  }

	  get body () {
	    webidl.brandCheck(this, Request);

	    return this[kState].body ? this[kState].body.stream : null
	  }

	  get bodyUsed () {
	    webidl.brandCheck(this, Request);

	    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
	  }

	  get duplex () {
	    webidl.brandCheck(this, Request);

	    return 'half'
	  }

	  // Returns a clone of request.
	  clone () {
	    webidl.brandCheck(this, Request);

	    // 1. If this is unusable, then throw a TypeError.
	    if (this.bodyUsed || this.body?.locked) {
	      throw new TypeError('unusable')
	    }

	    // 2. Let clonedRequest be the result of cloning thiss request.
	    const clonedRequest = cloneRequest(this[kState]);

	    // 3. Let clonedRequestObject be the result of creating a Request object,
	    // given clonedRequest, thiss headerss guard, and thiss relevant Realm.
	    const clonedRequestObject = new Request(kConstruct);
	    clonedRequestObject[kState] = clonedRequest;
	    clonedRequestObject[kRealm] = this[kRealm];
	    clonedRequestObject[kHeaders] = new Headers(kConstruct);
	    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
	    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
	    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];

	    // 4. Make clonedRequestObjects signal follow thiss signal.
	    const ac = new AbortController();
	    if (this.signal.aborted) {
	      ac.abort(this.signal.reason);
	    } else {
	      util.addAbortListener(
	        this.signal,
	        () => {
	          ac.abort(this.signal.reason);
	        }
	      );
	    }
	    clonedRequestObject[kSignal] = ac.signal;

	    // 4. Return clonedRequestObject.
	    return clonedRequestObject
	  }
	}

	mixinBody(Request);

	function makeRequest (init) {
	  // https://fetch.spec.whatwg.org/#requests
	  const request = {
	    method: 'GET',
	    localURLsOnly: false,
	    unsafeRequest: false,
	    body: null,
	    client: null,
	    reservedClient: null,
	    replacesClientId: '',
	    window: 'client',
	    keepalive: false,
	    serviceWorkers: 'all',
	    initiator: '',
	    destination: '',
	    priority: null,
	    origin: 'client',
	    policyContainer: 'client',
	    referrer: 'client',
	    referrerPolicy: '',
	    mode: 'no-cors',
	    useCORSPreflightFlag: false,
	    credentials: 'same-origin',
	    useCredentials: false,
	    cache: 'default',
	    redirect: 'follow',
	    integrity: '',
	    cryptoGraphicsNonceMetadata: '',
	    parserMetadata: '',
	    reloadNavigation: false,
	    historyNavigation: false,
	    userActivation: false,
	    taintedOrigin: false,
	    redirectCount: 0,
	    responseTainting: 'basic',
	    preventNoCacheCacheControlHeaderModification: false,
	    done: false,
	    timingAllowFailed: false,
	    ...init,
	    headersList: init.headersList
	      ? new HeadersList(init.headersList)
	      : new HeadersList()
	  };
	  request.url = request.urlList[0];
	  return request
	}

	// https://fetch.spec.whatwg.org/#concept-request-clone
	function cloneRequest (request) {
	  // To clone a request request, run these steps:

	  // 1. Let newRequest be a copy of request, except for its body.
	  const newRequest = makeRequest({ ...request, body: null });

	  // 2. If requests body is non-null, set newRequests body to the
	  // result of cloning requests body.
	  if (request.body != null) {
	    newRequest.body = cloneBody(request.body);
	  }

	  // 3. Return newRequest.
	  return newRequest
	}

	Object.defineProperties(Request.prototype, {
	  method: kEnumerableProperty,
	  url: kEnumerableProperty,
	  headers: kEnumerableProperty,
	  redirect: kEnumerableProperty,
	  clone: kEnumerableProperty,
	  signal: kEnumerableProperty,
	  duplex: kEnumerableProperty,
	  destination: kEnumerableProperty,
	  body: kEnumerableProperty,
	  bodyUsed: kEnumerableProperty,
	  isHistoryNavigation: kEnumerableProperty,
	  isReloadNavigation: kEnumerableProperty,
	  keepalive: kEnumerableProperty,
	  integrity: kEnumerableProperty,
	  cache: kEnumerableProperty,
	  credentials: kEnumerableProperty,
	  attribute: kEnumerableProperty,
	  referrerPolicy: kEnumerableProperty,
	  referrer: kEnumerableProperty,
	  mode: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'Request',
	    configurable: true
	  }
	});

	webidl.converters.Request = webidl.interfaceConverter(
	  Request
	);

	// https://fetch.spec.whatwg.org/#requestinfo
	webidl.converters.RequestInfo = function (V) {
	  if (typeof V === 'string') {
	    return webidl.converters.USVString(V)
	  }

	  if (V instanceof Request) {
	    return webidl.converters.Request(V)
	  }

	  return webidl.converters.USVString(V)
	};

	webidl.converters.AbortSignal = webidl.interfaceConverter(
	  AbortSignal
	);

	// https://fetch.spec.whatwg.org/#requestinit
	webidl.converters.RequestInit = webidl.dictionaryConverter([
	  {
	    key: 'method',
	    converter: webidl.converters.ByteString
	  },
	  {
	    key: 'headers',
	    converter: webidl.converters.HeadersInit
	  },
	  {
	    key: 'body',
	    converter: webidl.nullableConverter(
	      webidl.converters.BodyInit
	    )
	  },
	  {
	    key: 'referrer',
	    converter: webidl.converters.USVString
	  },
	  {
	    key: 'referrerPolicy',
	    converter: webidl.converters.DOMString,
	    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
	    allowedValues: referrerPolicy
	  },
	  {
	    key: 'mode',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#concept-request-mode
	    allowedValues: requestMode
	  },
	  {
	    key: 'credentials',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestcredentials
	    allowedValues: requestCredentials
	  },
	  {
	    key: 'cache',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestcache
	    allowedValues: requestCache
	  },
	  {
	    key: 'redirect',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestredirect
	    allowedValues: requestRedirect
	  },
	  {
	    key: 'integrity',
	    converter: webidl.converters.DOMString
	  },
	  {
	    key: 'keepalive',
	    converter: webidl.converters.boolean
	  },
	  {
	    key: 'signal',
	    converter: webidl.nullableConverter(
	      (signal) => webidl.converters.AbortSignal(
	        signal,
	        { strict: false }
	      )
	    )
	  },
	  {
	    key: 'window',
	    converter: webidl.converters.any
	  },
	  {
	    key: 'duplex',
	    converter: webidl.converters.DOMString,
	    allowedValues: requestDuplex
	  }
	]);

	request$1 = { Request, makeRequest };
	return request$1;
}

var fetch_1;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1;

	const {
	  Response,
	  makeNetworkError,
	  makeAppropriateNetworkError,
	  filterResponse,
	  makeResponse
	} = requireResponse();
	const { Headers } = requireHeaders();
	const { Request, makeRequest } = requireRequest();
	const zlib = require$$1$1;
	const {
	  bytesMatch,
	  makePolicyContainer,
	  clonePolicyContainer,
	  requestBadPort,
	  TAOCheck,
	  appendRequestOriginHeader,
	  responseLocationURL,
	  requestCurrentURL,
	  setRequestReferrerPolicyOnRedirect,
	  tryUpgradeRequestToAPotentiallyTrustworthyURL,
	  createOpaqueTimingInfo,
	  appendFetchMetadata,
	  corsCheck,
	  crossOriginResourcePolicyCheck,
	  determineRequestsReferrer,
	  coarsenedSharedCurrentTime,
	  createDeferredPromise,
	  isBlobLike,
	  sameOrigin,
	  isCancelled,
	  isAborted,
	  isErrorLike,
	  fullyReadBody,
	  readableStreamClose,
	  isomorphicEncode,
	  urlIsLocal,
	  urlIsHttpHttpsScheme,
	  urlHasHttpsScheme
	} = requireUtil$5();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const assert = require$$0$2;
	const { safelyExtractBody } = requireBody();
	const {
	  redirectStatusSet,
	  nullBodyStatus,
	  safeMethodsSet,
	  requestBodyHeader,
	  subresourceSet,
	  DOMException
	} = requireConstants$3();
	const { kHeadersList } = requireSymbols$4();
	const EE = require$$4$1;
	const { Readable, pipeline } = require$$1;
	const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = requireUtil$6();
	const { dataURLProcessor, serializeAMimeType } = requireDataURL();
	const { TransformStream } = require$$14;
	const { getGlobalDispatcher } = requireGlobal();
	const { webidl } = requireWebidl();
	const { STATUS_CODES } = require$$2$1;
	const GET_OR_HEAD = ['GET', 'HEAD'];

	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream = globalThis.ReadableStream;

	class Fetch extends EE {
	  constructor (dispatcher) {
	    super();

	    this.dispatcher = dispatcher;
	    this.connection = null;
	    this.dump = false;
	    this.state = 'ongoing';
	    // 2 terminated listeners get added per request,
	    // but only 1 gets removed. If there are 20 redirects,
	    // 21 listeners will be added.
	    // See https://github.com/nodejs/undici/issues/1711
	    // TODO (fix): Find and fix root cause for leaked listener.
	    this.setMaxListeners(21);
	  }

	  terminate (reason) {
	    if (this.state !== 'ongoing') {
	      return
	    }

	    this.state = 'terminated';
	    this.connection?.destroy(reason);
	    this.emit('terminated', reason);
	  }

	  // https://fetch.spec.whatwg.org/#fetch-controller-abort
	  abort (error) {
	    if (this.state !== 'ongoing') {
	      return
	    }

	    // 1. Set controllers state to "aborted".
	    this.state = 'aborted';

	    // 2. Let fallbackError be an "AbortError" DOMException.
	    // 3. Set error to fallbackError if it is not given.
	    if (!error) {
	      error = new DOMException('The operation was aborted.', 'AbortError');
	    }

	    // 4. Let serializedError be StructuredSerialize(error).
	    //    If that threw an exception, catch it, and let
	    //    serializedError be StructuredSerialize(fallbackError).

	    // 5. Set controllers serialized abort reason to serializedError.
	    this.serializedAbortReason = error;

	    this.connection?.destroy(error);
	    this.emit('terminated', error);
	  }
	}

	// https://fetch.spec.whatwg.org/#fetch-method
	function fetch (input, init = {}) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' });

	  // 1. Let p be a new promise.
	  const p = createDeferredPromise();

	  // 2. Let requestObject be the result of invoking the initial value of
	  // Request as constructor with input and init as arguments. If this throws
	  // an exception, reject p with it and return p.
	  let requestObject;

	  try {
	    requestObject = new Request(input, init);
	  } catch (e) {
	    p.reject(e);
	    return p.promise
	  }

	  // 3. Let request be requestObjects request.
	  const request = requestObject[kState];

	  // 4. If requestObjects signals aborted flag is set, then:
	  if (requestObject.signal.aborted) {
	    // 1. Abort the fetch() call with p, request, null, and
	    //    requestObjects signals abort reason.
	    abortFetch(p, request, null, requestObject.signal.reason);

	    // 2. Return p.
	    return p.promise
	  }

	  // 5. Let globalObject be requests clients global object.
	  const globalObject = request.client.globalObject;

	  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set
	  // requests service-workers mode to "none".
	  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
	    request.serviceWorkers = 'none';
	  }

	  // 7. Let responseObject be null.
	  let responseObject = null;

	  // 8. Let relevantRealm be thiss relevant Realm.
	  const relevantRealm = null;

	  // 9. Let locallyAborted be false.
	  let locallyAborted = false;

	  // 10. Let controller be null.
	  let controller = null;

	  // 11. Add the following abort steps to requestObjects signal:
	  addAbortListener(
	    requestObject.signal,
	    () => {
	      // 1. Set locallyAborted to true.
	      locallyAborted = true;

	      // 2. Assert: controller is non-null.
	      assert(controller != null);

	      // 3. Abort controller with requestObjects signals abort reason.
	      controller.abort(requestObject.signal.reason);

	      // 4. Abort the fetch() call with p, request, responseObject,
	      //    and requestObjects signals abort reason.
	      abortFetch(p, request, responseObject, requestObject.signal.reason);
	    }
	  );

	  // 12. Let handleFetchDone given response response be to finalize and
	  // report timing with response, globalObject, and "fetch".
	  const handleFetchDone = (response) =>
	    finalizeAndReportTiming(response, 'fetch');

	  // 13. Set controller to the result of calling fetch given request,
	  // with processResponseEndOfBody set to handleFetchDone, and processResponse
	  // given response being these substeps:

	  const processResponse = (response) => {
	    // 1. If locallyAborted is true, terminate these substeps.
	    if (locallyAborted) {
	      return Promise.resolve()
	    }

	    // 2. If responses aborted flag is set, then:
	    if (response.aborted) {
	      // 1. Let deserializedError be the result of deserialize a serialized
	      //    abort reason given controllers serialized abort reason and
	      //    relevantRealm.

	      // 2. Abort the fetch() call with p, request, responseObject, and
	      //    deserializedError.

	      abortFetch(p, request, responseObject, controller.serializedAbortReason);
	      return Promise.resolve()
	    }

	    // 3. If response is a network error, then reject p with a TypeError
	    // and terminate these substeps.
	    if (response.type === 'error') {
	      p.reject(
	        Object.assign(new TypeError('fetch failed'), { cause: response.error })
	      );
	      return Promise.resolve()
	    }

	    // 4. Set responseObject to the result of creating a Response object,
	    // given response, "immutable", and relevantRealm.
	    responseObject = new Response();
	    responseObject[kState] = response;
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kHeadersList] = response.headersList;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 5. Resolve p with responseObject.
	    p.resolve(responseObject);
	  };

	  controller = fetching({
	    request,
	    processResponseEndOfBody: handleFetchDone,
	    processResponse,
	    dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici
	  });

	  // 14. Return p.
	  return p.promise
	}

	// https://fetch.spec.whatwg.org/#finalize-and-report-timing
	function finalizeAndReportTiming (response, initiatorType = 'other') {
	  // 1. If response is an aborted network error, then return.
	  if (response.type === 'error' && response.aborted) {
	    return
	  }

	  // 2. If responses URL list is null or empty, then return.
	  if (!response.urlList?.length) {
	    return
	  }

	  // 3. Let originalURL be responses URL list[0].
	  const originalURL = response.urlList[0];

	  // 4. Let timingInfo be responses timing info.
	  let timingInfo = response.timingInfo;

	  // 5. Let cacheState be responses cache state.
	  let cacheState = response.cacheState;

	  // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.
	  if (!urlIsHttpHttpsScheme(originalURL)) {
	    return
	  }

	  // 7. If timingInfo is null, then return.
	  if (timingInfo === null) {
	    return
	  }

	  // 8. If responses timing allow passed flag is not set, then:
	  if (!response.timingAllowPassed) {
	    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
	    timingInfo = createOpaqueTimingInfo({
	      startTime: timingInfo.startTime
	    });

	    //  2. Set cacheState to the empty string.
	    cacheState = '';
	  }

	  // 9. Set timingInfos end time to the coarsened shared current time
	  // given globals relevant settings objects cross-origin isolated
	  // capability.
	  // TODO: given globals relevant settings objects cross-origin isolated
	  // capability?
	  timingInfo.endTime = coarsenedSharedCurrentTime();

	  // 10. Set responses timing info to timingInfo.
	  response.timingInfo = timingInfo;

	  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,
	  // global, and cacheState.
	  markResourceTiming(
	    timingInfo,
	    originalURL,
	    initiatorType,
	    globalThis,
	    cacheState
	  );
	}

	// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
	function markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {
	  if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
	    performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
	  }
	}

	// https://fetch.spec.whatwg.org/#abort-fetch
	function abortFetch (p, request, responseObject, error) {
	  // Note: AbortSignal.reason was added in node v17.2.0
	  // which would give us an undefined error to reject with.
	  // Remove this once node v16 is no longer supported.
	  if (!error) {
	    error = new DOMException('The operation was aborted.', 'AbortError');
	  }

	  // 1. Reject promise with error.
	  p.reject(error);

	  // 2. If requests body is not null and is readable, then cancel requests
	  // body with error.
	  if (request.body != null && isReadable(request.body?.stream)) {
	    request.body.stream.cancel(error).catch((err) => {
	      if (err.code === 'ERR_INVALID_STATE') {
	        // Node bug?
	        return
	      }
	      throw err
	    });
	  }

	  // 3. If responseObject is null, then return.
	  if (responseObject == null) {
	    return
	  }

	  // 4. Let response be responseObjects response.
	  const response = responseObject[kState];

	  // 5. If responses body is not null and is readable, then error responses
	  // body with error.
	  if (response.body != null && isReadable(response.body?.stream)) {
	    response.body.stream.cancel(error).catch((err) => {
	      if (err.code === 'ERR_INVALID_STATE') {
	        // Node bug?
	        return
	      }
	      throw err
	    });
	  }
	}

	// https://fetch.spec.whatwg.org/#fetching
	function fetching ({
	  request,
	  processRequestBodyChunkLength,
	  processRequestEndOfBody,
	  processResponse,
	  processResponseEndOfBody,
	  processResponseConsumeBody,
	  useParallelQueue = false,
	  dispatcher // undici
	}) {
	  // 1. Let taskDestination be null.
	  let taskDestination = null;

	  // 2. Let crossOriginIsolatedCapability be false.
	  let crossOriginIsolatedCapability = false;

	  // 3. If requests client is non-null, then:
	  if (request.client != null) {
	    // 1. Set taskDestination to requests clients global object.
	    taskDestination = request.client.globalObject;

	    // 2. Set crossOriginIsolatedCapability to requests clients cross-origin
	    // isolated capability.
	    crossOriginIsolatedCapability =
	      request.client.crossOriginIsolatedCapability;
	  }

	  // 4. If useParallelQueue is true, then set taskDestination to the result of
	  // starting a new parallel queue.
	  // TODO

	  // 5. Let timingInfo be a new fetch timing info whose start time and
	  // post-redirect start time are the coarsened shared current time given
	  // crossOriginIsolatedCapability.
	  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
	  const timingInfo = createOpaqueTimingInfo({
	    startTime: currenTime
	  });

	  // 6. Let fetchParams be a new fetch params whose
	  // request is request,
	  // timing info is timingInfo,
	  // process request body chunk length is processRequestBodyChunkLength,
	  // process request end-of-body is processRequestEndOfBody,
	  // process response is processResponse,
	  // process response consume body is processResponseConsumeBody,
	  // process response end-of-body is processResponseEndOfBody,
	  // task destination is taskDestination,
	  // and cross-origin isolated capability is crossOriginIsolatedCapability.
	  const fetchParams = {
	    controller: new Fetch(dispatcher),
	    request,
	    timingInfo,
	    processRequestBodyChunkLength,
	    processRequestEndOfBody,
	    processResponse,
	    processResponseConsumeBody,
	    processResponseEndOfBody,
	    taskDestination,
	    crossOriginIsolatedCapability
	  };

	  // 7. If requests body is a byte sequence, then set requests body to
	  //    requests body as a body.
	  // NOTE: Since fetching is only called from fetch, body should already be
	  // extracted.
	  assert(!request.body || request.body.stream);

	  // 8. If requests window is "client", then set requests window to requests
	  // client, if requests clients global object is a Window object; otherwise
	  // "no-window".
	  if (request.window === 'client') {
	    // TODO: What if request.client is null?
	    request.window =
	      request.client?.globalObject?.constructor?.name === 'Window'
	        ? request.client
	        : 'no-window';
	  }

	  // 9. If requests origin is "client", then set requests origin to requests
	  // clients origin.
	  if (request.origin === 'client') {
	    // TODO: What if request.client is null?
	    request.origin = request.client?.origin;
	  }

	  // 10. If all of the following conditions are true:
	  // TODO

	  // 11. If requests policy container is "client", then:
	  if (request.policyContainer === 'client') {
	    // 1. If requests client is non-null, then set requests policy
	    // container to a clone of requests clients policy container. [HTML]
	    if (request.client != null) {
	      request.policyContainer = clonePolicyContainer(
	        request.client.policyContainer
	      );
	    } else {
	      // 2. Otherwise, set requests policy container to a new policy
	      // container.
	      request.policyContainer = makePolicyContainer();
	    }
	  }

	  // 12. If requests header list does not contain `Accept`, then:
	  if (!request.headersList.contains('accept')) {
	    // 1. Let value be `*/*`.
	    const value = '*/*';

	    // 2. A user agent should set value to the first matching statement, if
	    // any, switching on requests destination:
	    // "document"
	    // "frame"
	    // "iframe"
	    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
	    // "image"
	    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
	    // "style"
	    // `text/css,*/*;q=0.1`
	    // TODO

	    // 3. Append `Accept`/value to requests header list.
	    request.headersList.append('accept', value);
	  }

	  // 13. If requests header list does not contain `Accept-Language`, then
	  // user agents should append `Accept-Language`/an appropriate value to
	  // requests header list.
	  if (!request.headersList.contains('accept-language')) {
	    request.headersList.append('accept-language', '*');
	  }

	  // 14. If requests priority is null, then use requests initiator and
	  // destination appropriately in setting requests priority to a
	  // user-agent-defined object.
	  if (request.priority === null) ;

	  // 15. If request is a subresource request, then:
	  if (subresourceSet.has(request.destination)) ;

	  // 16. Run main fetch given fetchParams.
	  mainFetch(fetchParams)
	    .catch(err => {
	      fetchParams.controller.terminate(err);
	    });

	  // 17. Return fetchParam's controller
	  return fetchParams.controller
	}

	// https://fetch.spec.whatwg.org/#concept-main-fetch
	async function mainFetch (fetchParams, recursive = false) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. If requests local-URLs-only flag is set and requests current URL is
	  // not local, then set response to a network error.
	  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
	    response = makeNetworkError('local URLs only');
	  }

	  // 4. Run report Content Security Policy violations for request.
	  // TODO

	  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.
	  tryUpgradeRequestToAPotentiallyTrustworthyURL(request);

	  // 6. If should request be blocked due to a bad port, should fetching request
	  // be blocked as mixed content, or should request be blocked by Content
	  // Security Policy returns blocked, then set response to a network error.
	  if (requestBadPort(request) === 'blocked') {
	    response = makeNetworkError('bad port');
	  }
	  // TODO: should fetching request be blocked as mixed content?
	  // TODO: should request be blocked by Content Security Policy?

	  // 7. If requests referrer policy is the empty string, then set requests
	  // referrer policy to requests policy containers referrer policy.
	  if (request.referrerPolicy === '') {
	    request.referrerPolicy = request.policyContainer.referrerPolicy;
	  }

	  // 8. If requests referrer is not "no-referrer", then set requests
	  // referrer to the result of invoking determine requests referrer.
	  if (request.referrer !== 'no-referrer') {
	    request.referrer = determineRequestsReferrer(request);
	  }

	  // 9. Set requests current URLs scheme to "https" if all of the following
	  // conditions are true:
	  // - requests current URLs scheme is "http"
	  // - requests current URLs host is a domain
	  // - Matching requests current URLs host per Known HSTS Host Domain Name
	  //   Matching results in either a superdomain match with an asserted
	  //   includeSubDomains directive or a congruent match (with or without an
	  //   asserted includeSubDomains directive). [HSTS]
	  // TODO

	  // 10. If recursive is false, then run the remaining steps in parallel.
	  // TODO

	  // 11. If response is null, then set response to the result of running
	  // the steps corresponding to the first matching statement:
	  if (response === null) {
	    response = await (async () => {
	      const currentURL = requestCurrentURL(request);

	      if (
	        // - requests current URLs origin is same origin with requests origin,
	        //   and requests response tainting is "basic"
	        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||
	        // requests current URLs scheme is "data"
	        (currentURL.protocol === 'data:') ||
	        // - requests mode is "navigate" or "websocket"
	        (request.mode === 'navigate' || request.mode === 'websocket')
	      ) {
	        // 1. Set requests response tainting to "basic".
	        request.responseTainting = 'basic';

	        // 2. Return the result of running scheme fetch given fetchParams.
	        return await schemeFetch(fetchParams)
	      }

	      // requests mode is "same-origin"
	      if (request.mode === 'same-origin') {
	        // 1. Return a network error.
	        return makeNetworkError('request mode cannot be "same-origin"')
	      }

	      // requests mode is "no-cors"
	      if (request.mode === 'no-cors') {
	        // 1. If requests redirect mode is not "follow", then return a network
	        // error.
	        if (request.redirect !== 'follow') {
	          return makeNetworkError(
	            'redirect mode cannot be "follow" for "no-cors" request'
	          )
	        }

	        // 2. Set requests response tainting to "opaque".
	        request.responseTainting = 'opaque';

	        // 3. Return the result of running scheme fetch given fetchParams.
	        return await schemeFetch(fetchParams)
	      }

	      // requests current URLs scheme is not an HTTP(S) scheme
	      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
	        // Return a network error.
	        return makeNetworkError('URL scheme must be a HTTP(S) scheme')
	      }

	      // - requests use-CORS-preflight flag is set
	      // - requests unsafe-request flag is set and either requests method is
	      //   not a CORS-safelisted method or CORS-unsafe request-header names with
	      //   requests header list is not empty
	      //    1. Set requests response tainting to "cors".
	      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch
	      //    given fetchParams and true.
	      //    3. If corsWithPreflightResponse is a network error, then clear cache
	      //    entries using request.
	      //    4. Return corsWithPreflightResponse.
	      // TODO

	      // Otherwise
	      //    1. Set requests response tainting to "cors".
	      request.responseTainting = 'cors';

	      //    2. Return the result of running HTTP fetch given fetchParams.
	      return await httpFetch(fetchParams)
	    })();
	  }

	  // 12. If recursive is true, then return response.
	  if (recursive) {
	    return response
	  }

	  // 13. If response is not a network error and response is not a filtered
	  // response, then:
	  if (response.status !== 0 && !response.internalResponse) {
	    // If requests response tainting is "cors", then:
	    if (request.responseTainting === 'cors') ;

	    // Set response to the following filtered response with response as its
	    // internal response, depending on requests response tainting:
	    if (request.responseTainting === 'basic') {
	      response = filterResponse(response, 'basic');
	    } else if (request.responseTainting === 'cors') {
	      response = filterResponse(response, 'cors');
	    } else if (request.responseTainting === 'opaque') {
	      response = filterResponse(response, 'opaque');
	    } else {
	      assert(false);
	    }
	  }

	  // 14. Let internalResponse be response, if response is a network error,
	  // and responses internal response otherwise.
	  let internalResponse =
	    response.status === 0 ? response : response.internalResponse;

	  // 15. If internalResponses URL list is empty, then set it to a clone of
	  // requests URL list.
	  if (internalResponse.urlList.length === 0) {
	    internalResponse.urlList.push(...request.urlList);
	  }

	  // 16. If requests timing allow failed flag is unset, then set
	  // internalResponses timing allow passed flag.
	  if (!request.timingAllowFailed) {
	    response.timingAllowPassed = true;
	  }

	  // 17. If response is not a network error and any of the following returns
	  // blocked
	  // - should internalResponse to request be blocked as mixed content
	  // - should internalResponse to request be blocked by Content Security Policy
	  // - should internalResponse to request be blocked due to its MIME type
	  // - should internalResponse to request be blocked due to nosniff
	  // TODO

	  // 18. If responses type is "opaque", internalResponses status is 206,
	  // internalResponses range-requested flag is set, and requests header
	  // list does not contain `Range`, then set response and internalResponse
	  // to a network error.
	  if (
	    response.type === 'opaque' &&
	    internalResponse.status === 206 &&
	    internalResponse.rangeRequested &&
	    !request.headers.contains('range')
	  ) {
	    response = internalResponse = makeNetworkError();
	  }

	  // 19. If response is not a network error and either requests method is
	  // `HEAD` or `CONNECT`, or internalResponses status is a null body status,
	  // set internalResponses body to null and disregard any enqueuing toward
	  // it (if any).
	  if (
	    response.status !== 0 &&
	    (request.method === 'HEAD' ||
	      request.method === 'CONNECT' ||
	      nullBodyStatus.includes(internalResponse.status))
	  ) {
	    internalResponse.body = null;
	    fetchParams.controller.dump = true;
	  }

	  // 20. If requests integrity metadata is not the empty string, then:
	  if (request.integrity) {
	    // 1. Let processBodyError be this step: run fetch finale given fetchParams
	    // and a network error.
	    const processBodyError = (reason) =>
	      fetchFinale(fetchParams, makeNetworkError(reason));

	    // 2. If requests response tainting is "opaque", or responses body is null,
	    // then run processBodyError and abort these steps.
	    if (request.responseTainting === 'opaque' || response.body == null) {
	      processBodyError(response.error);
	      return
	    }

	    // 3. Let processBody given bytes be these steps:
	    const processBody = (bytes) => {
	      // 1. If bytes do not match requests integrity metadata,
	      // then run processBodyError and abort these steps. [SRI]
	      if (!bytesMatch(bytes, request.integrity)) {
	        processBodyError('integrity mismatch');
	        return
	      }

	      // 2. Set responses body to bytes as a body.
	      response.body = safelyExtractBody(bytes)[0];

	      // 3. Run fetch finale given fetchParams and response.
	      fetchFinale(fetchParams, response);
	    };

	    // 4. Fully read responses body given processBody and processBodyError.
	    await fullyReadBody(response.body, processBody, processBodyError);
	  } else {
	    // 21. Otherwise, run fetch finale given fetchParams and response.
	    fetchFinale(fetchParams, response);
	  }
	}

	// https://fetch.spec.whatwg.org/#concept-scheme-fetch
	// given a fetch params fetchParams
	function schemeFetch (fetchParams) {
	  // Note: since the connection is destroyed on redirect, which sets fetchParams to a
	  // cancelled state, we do not want this condition to trigger *unless* there have been
	  // no redirects. See https://github.com/nodejs/undici/issues/1776
	  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
	    return Promise.resolve(makeAppropriateNetworkError(fetchParams))
	  }

	  // 2. Let request be fetchParamss request.
	  const { request } = fetchParams;

	  const { protocol: scheme } = requestCurrentURL(request);

	  // 3. Switch on requests current URLs scheme and run the associated steps:
	  switch (scheme) {
	    case 'about:': {
	      // If requests current URLs path is the string "blank", then return a new response
	      // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,
	      // and body is the empty byte sequence as a body.

	      // Otherwise, return a network error.
	      return Promise.resolve(makeNetworkError('about scheme is not supported'))
	    }
	    case 'blob:': {
	      if (!resolveObjectURL) {
	        resolveObjectURL = require$$7.resolveObjectURL;
	      }

	      // 1. Let blobURLEntry be requests current URLs blob URL entry.
	      const blobURLEntry = requestCurrentURL(request);

	      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
	      // Buffer.resolveObjectURL does not ignore URL queries.
	      if (blobURLEntry.search.length !== 0) {
	        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))
	      }

	      const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());

	      // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys
	      //    object is not a Blob object, then return a network error.
	      if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {
	        return Promise.resolve(makeNetworkError('invalid method'))
	      }

	      // 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.
	      const bodyWithType = safelyExtractBody(blobURLEntryObject);

	      // 4. Let body be bodyWithTypes body.
	      const body = bodyWithType[0];

	      // 5. Let length be bodys length, serialized and isomorphic encoded.
	      const length = isomorphicEncode(`${body.length}`);

	      // 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.
	      const type = bodyWithType[1] ?? '';

	      // 7. Return a new response whose status message is `OK`, header list is
	      //     (`Content-Length`, length), (`Content-Type`, type) , and body is body.
	      const response = makeResponse({
	        statusText: 'OK',
	        headersList: [
	          ['content-length', { name: 'Content-Length', value: length }],
	          ['content-type', { name: 'Content-Type', value: type }]
	        ]
	      });

	      response.body = body;

	      return Promise.resolve(response)
	    }
	    case 'data:': {
	      // 1. Let dataURLStruct be the result of running the
	      //    data: URL processor on requests current URL.
	      const currentURL = requestCurrentURL(request);
	      const dataURLStruct = dataURLProcessor(currentURL);

	      // 2. If dataURLStruct is failure, then return a
	      //    network error.
	      if (dataURLStruct === 'failure') {
	        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))
	      }

	      // 3. Let mimeType be dataURLStructs MIME type, serialized.
	      const mimeType = serializeAMimeType(dataURLStruct.mimeType);

	      // 4. Return a response whose status message is `OK`,
	      //    header list is  (`Content-Type`, mimeType) ,
	      //    and body is dataURLStructs body as a body.
	      return Promise.resolve(makeResponse({
	        statusText: 'OK',
	        headersList: [
	          ['content-type', { name: 'Content-Type', value: mimeType }]
	        ],
	        body: safelyExtractBody(dataURLStruct.body)[0]
	      }))
	    }
	    case 'file:': {
	      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.
	      // When in doubt, return a network error.
	      return Promise.resolve(makeNetworkError('not implemented... yet...'))
	    }
	    case 'http:':
	    case 'https:': {
	      // Return the result of running HTTP fetch given fetchParams.

	      return httpFetch(fetchParams)
	        .catch((err) => makeNetworkError(err))
	    }
	    default: {
	      return Promise.resolve(makeNetworkError('unknown scheme'))
	    }
	  }
	}

	// https://fetch.spec.whatwg.org/#finalize-response
	function finalizeResponse (fetchParams, response) {
	  // 1. Set fetchParamss requests done flag.
	  fetchParams.request.done = true;

	  // 2, If fetchParamss process response done is not null, then queue a fetch
	  // task to run fetchParamss process response done given response, with
	  // fetchParamss task destination.
	  if (fetchParams.processResponseDone != null) {
	    queueMicrotask(() => fetchParams.processResponseDone(response));
	  }
	}

	// https://fetch.spec.whatwg.org/#fetch-finale
	function fetchFinale (fetchParams, response) {
	  // 1. If response is a network error, then:
	  if (response.type === 'error') {
	    // 1. Set responses URL list to  fetchParamss requests URL list[0] .
	    response.urlList = [fetchParams.request.urlList[0]];

	    // 2. Set responses timing info to the result of creating an opaque timing
	    // info for fetchParamss timing info.
	    response.timingInfo = createOpaqueTimingInfo({
	      startTime: fetchParams.timingInfo.startTime
	    });
	  }

	  // 2. Let processResponseEndOfBody be the following steps:
	  const processResponseEndOfBody = () => {
	    // 1. Set fetchParamss requests done flag.
	    fetchParams.request.done = true;

	    // If fetchParamss process response end-of-body is not null,
	    // then queue a fetch task to run fetchParamss process response
	    // end-of-body given response with fetchParamss task destination.
	    if (fetchParams.processResponseEndOfBody != null) {
	      queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
	    }
	  };

	  // 3. If fetchParamss process response is non-null, then queue a fetch task
	  // to run fetchParamss process response given response, with fetchParamss
	  // task destination.
	  if (fetchParams.processResponse != null) {
	    queueMicrotask(() => fetchParams.processResponse(response));
	  }

	  // 4. If responses body is null, then run processResponseEndOfBody.
	  if (response.body == null) {
	    processResponseEndOfBody();
	  } else {
	  // 5. Otherwise:

	    // 1. Let transformStream be a new a TransformStream.

	    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,
	    // enqueues chunk in transformStream.
	    const identityTransformAlgorithm = (chunk, controller) => {
	      controller.enqueue(chunk);
	    };

	    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm
	    // and flushAlgorithm set to processResponseEndOfBody.
	    const transformStream = new TransformStream({
	      start () {},
	      transform: identityTransformAlgorithm,
	      flush: processResponseEndOfBody
	    }, {
	      size () {
	        return 1
	      }
	    }, {
	      size () {
	        return 1
	      }
	    });

	    // 4. Set responses body to the result of piping responses body through transformStream.
	    response.body = { stream: response.body.stream.pipeThrough(transformStream) };
	  }

	  // 6. If fetchParamss process response consume body is non-null, then:
	  if (fetchParams.processResponseConsumeBody != null) {
	    // 1. Let processBody given nullOrBytes be this step: run fetchParamss
	    // process response consume body given response and nullOrBytes.
	    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);

	    // 2. Let processBodyError be this step: run fetchParamss process
	    // response consume body given response and failure.
	    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);

	    // 3. If responses body is null, then queue a fetch task to run processBody
	    // given null, with fetchParamss task destination.
	    if (response.body == null) {
	      queueMicrotask(() => processBody(null));
	    } else {
	      // 4. Otherwise, fully read responses body given processBody, processBodyError,
	      // and fetchParamss task destination.
	      return fullyReadBody(response.body, processBody, processBodyError)
	    }
	    return Promise.resolve()
	  }
	}

	// https://fetch.spec.whatwg.org/#http-fetch
	async function httpFetch (fetchParams) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. Let actualResponse be null.
	  let actualResponse = null;

	  // 4. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 5. If requests service-workers mode is "all", then:
	  if (request.serviceWorkers === 'all') ;

	  // 6. If response is null, then:
	  if (response === null) {
	    // 1. If makeCORSPreflight is true and one of these conditions is true:
	    // TODO

	    // 2. If requests redirect mode is "follow", then set requests
	    // service-workers mode to "none".
	    if (request.redirect === 'follow') {
	      request.serviceWorkers = 'none';
	    }

	    // 3. Set response and actualResponse to the result of running
	    // HTTP-network-or-cache fetch given fetchParams.
	    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);

	    // 4. If requests response tainting is "cors" and a CORS check
	    // for request and response returns failure, then return a network error.
	    if (
	      request.responseTainting === 'cors' &&
	      corsCheck(request, response) === 'failure'
	    ) {
	      return makeNetworkError('cors failure')
	    }

	    // 5. If the TAO check for request and response returns failure, then set
	    // requests timing allow failed flag.
	    if (TAOCheck(request, response) === 'failure') {
	      request.timingAllowFailed = true;
	    }
	  }

	  // 7. If either requests response tainting or responses type
	  // is "opaque", and the cross-origin resource policy check with
	  // requests origin, requests client, requests destination,
	  // and actualResponse returns blocked, then return a network error.
	  if (
	    (request.responseTainting === 'opaque' || response.type === 'opaque') &&
	    crossOriginResourcePolicyCheck(
	      request.origin,
	      request.client,
	      request.destination,
	      actualResponse
	    ) === 'blocked'
	  ) {
	    return makeNetworkError('blocked')
	  }

	  // 8. If actualResponses status is a redirect status, then:
	  if (redirectStatusSet.has(actualResponse.status)) {
	    // 1. If actualResponses status is not 303, requests body is not null,
	    // and the connection uses HTTP/2, then user agents may, and are even
	    // encouraged to, transmit an RST_STREAM frame.
	    // See, https://github.com/whatwg/fetch/issues/1288
	    if (request.redirect !== 'manual') {
	      fetchParams.controller.connection.destroy();
	    }

	    // 2. Switch on requests redirect mode:
	    if (request.redirect === 'error') {
	      // Set response to a network error.
	      response = makeNetworkError('unexpected redirect');
	    } else if (request.redirect === 'manual') {
	      // Set response to an opaque-redirect filtered response whose internal
	      // response is actualResponse.
	      // NOTE(spec): On the web this would return an `opaqueredirect` response,
	      // but that doesn't make sense server side.
	      // See https://github.com/nodejs/undici/issues/1193.
	      response = actualResponse;
	    } else if (request.redirect === 'follow') {
	      // Set response to the result of running HTTP-redirect fetch given
	      // fetchParams and response.
	      response = await httpRedirectFetch(fetchParams, response);
	    } else {
	      assert(false);
	    }
	  }

	  // 9. Set responses timing info to timingInfo.
	  response.timingInfo = timingInfo;

	  // 10. Return response.
	  return response
	}

	// https://fetch.spec.whatwg.org/#http-redirect-fetch
	function httpRedirectFetch (fetchParams, response) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let actualResponse be response, if response is not a filtered response,
	  // and responses internal response otherwise.
	  const actualResponse = response.internalResponse
	    ? response.internalResponse
	    : response;

	  // 3. Let locationURL be actualResponses location URL given requests current
	  // URLs fragment.
	  let locationURL;

	  try {
	    locationURL = responseLocationURL(
	      actualResponse,
	      requestCurrentURL(request).hash
	    );

	    // 4. If locationURL is null, then return response.
	    if (locationURL == null) {
	      return response
	    }
	  } catch (err) {
	    // 5. If locationURL is failure, then return a network error.
	    return Promise.resolve(makeNetworkError(err))
	  }

	  // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network
	  // error.
	  if (!urlIsHttpHttpsScheme(locationURL)) {
	    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))
	  }

	  // 7. If requests redirect count is 20, then return a network error.
	  if (request.redirectCount === 20) {
	    return Promise.resolve(makeNetworkError('redirect count exceeded'))
	  }

	  // 8. Increase requests redirect count by 1.
	  request.redirectCount += 1;

	  // 9. If requests mode is "cors", locationURL includes credentials, and
	  // requests origin is not same origin with locationURLs origin, then return
	  //  a network error.
	  if (
	    request.mode === 'cors' &&
	    (locationURL.username || locationURL.password) &&
	    !sameOrigin(request, locationURL)
	  ) {
	    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'))
	  }

	  // 10. If requests response tainting is "cors" and locationURL includes
	  // credentials, then return a network error.
	  if (
	    request.responseTainting === 'cors' &&
	    (locationURL.username || locationURL.password)
	  ) {
	    return Promise.resolve(makeNetworkError(
	      'URL cannot contain credentials for request mode "cors"'
	    ))
	  }

	  // 11. If actualResponses status is not 303, requests body is non-null,
	  // and requests bodys source is null, then return a network error.
	  if (
	    actualResponse.status !== 303 &&
	    request.body != null &&
	    request.body.source == null
	  ) {
	    return Promise.resolve(makeNetworkError())
	  }

	  // 12. If one of the following is true
	  // - actualResponses status is 301 or 302 and requests method is `POST`
	  // - actualResponses status is 303 and requests method is not `GET` or `HEAD`
	  if (
	    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||
	    (actualResponse.status === 303 &&
	      !GET_OR_HEAD.includes(request.method))
	  ) {
	    // then:
	    // 1. Set requests method to `GET` and requests body to null.
	    request.method = 'GET';
	    request.body = null;

	    // 2. For each headerName of request-body-header name, delete headerName from
	    // requests header list.
	    for (const headerName of requestBodyHeader) {
	      request.headersList.delete(headerName);
	    }
	  }

	  // 13. If requests current URLs origin is not same origin with locationURLs
	  //     origin, then for each headerName of CORS non-wildcard request-header name,
	  //     delete headerName from requests header list.
	  if (!sameOrigin(requestCurrentURL(request), locationURL)) {
	    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name
	    request.headersList.delete('authorization');

	    // https://fetch.spec.whatwg.org/#authentication-entries
	    request.headersList.delete('proxy-authorization', true);

	    // "Cookie" and "Host" are forbidden request-headers, which undici doesn't implement.
	    request.headersList.delete('cookie');
	    request.headersList.delete('host');
	  }

	  // 14. If requests body is non-null, then set requests body to the first return
	  // value of safely extracting requests bodys source.
	  if (request.body != null) {
	    assert(request.body.source != null);
	    request.body = safelyExtractBody(request.body.source)[0];
	  }

	  // 15. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 16. Set timingInfos redirect end time and post-redirect start time to the
	  // coarsened shared current time given fetchParamss cross-origin isolated
	  // capability.
	  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
	    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);

	  // 17. If timingInfos redirect start time is 0, then set timingInfos
	  //  redirect start time to timingInfos start time.
	  if (timingInfo.redirectStartTime === 0) {
	    timingInfo.redirectStartTime = timingInfo.startTime;
	  }

	  // 18. Append locationURL to requests URL list.
	  request.urlList.push(locationURL);

	  // 19. Invoke set requests referrer policy on redirect on request and
	  // actualResponse.
	  setRequestReferrerPolicyOnRedirect(request, actualResponse);

	  // 20. Return the result of running main fetch given fetchParams and true.
	  return mainFetch(fetchParams, true)
	}

	// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
	async function httpNetworkOrCacheFetch (
	  fetchParams,
	  isAuthenticationFetch = false,
	  isNewConnectionFetch = false
	) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let httpFetchParams be null.
	  let httpFetchParams = null;

	  // 3. Let httpRequest be null.
	  let httpRequest = null;

	  // 4. Let response be null.
	  let response = null;

	  // 8. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. If requests window is "no-window" and requests redirect mode is
	  //    "error", then set httpFetchParams to fetchParams and httpRequest to
	  //    request.
	  if (request.window === 'no-window' && request.redirect === 'error') {
	    httpFetchParams = fetchParams;
	    httpRequest = request;
	  } else {
	    // Otherwise:

	    // 1. Set httpRequest to a clone of request.
	    httpRequest = makeRequest(request);

	    // 2. Set httpFetchParams to a copy of fetchParams.
	    httpFetchParams = { ...fetchParams };

	    // 3. Set httpFetchParamss request to httpRequest.
	    httpFetchParams.request = httpRequest;
	  }

	  //    3. Let includeCredentials be true if one of
	  const includeCredentials =
	    request.credentials === 'include' ||
	    (request.credentials === 'same-origin' &&
	      request.responseTainting === 'basic');

	  //    4. Let contentLength be httpRequests bodys length, if httpRequests
	  //    body is non-null; otherwise null.
	  const contentLength = httpRequest.body ? httpRequest.body.length : null;

	  //    5. Let contentLengthHeaderValue be null.
	  let contentLengthHeaderValue = null;

	  //    6. If httpRequests body is null and httpRequests method is `POST` or
	  //    `PUT`, then set contentLengthHeaderValue to `0`.
	  if (
	    httpRequest.body == null &&
	    ['POST', 'PUT'].includes(httpRequest.method)
	  ) {
	    contentLengthHeaderValue = '0';
	  }

	  //    7. If contentLength is non-null, then set contentLengthHeaderValue to
	  //    contentLength, serialized and isomorphic encoded.
	  if (contentLength != null) {
	    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
	  }

	  //    8. If contentLengthHeaderValue is non-null, then append
	  //    `Content-Length`/contentLengthHeaderValue to httpRequests header
	  //    list.
	  if (contentLengthHeaderValue != null) {
	    httpRequest.headersList.append('content-length', contentLengthHeaderValue);
	  }

	  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
	  //    contentLengthHeaderValue) to httpRequests header list.

	  //    10. If contentLength is non-null and httpRequests keepalive is true,
	  //    then:
	  if (contentLength != null && httpRequest.keepalive) ;

	  //    11. If httpRequests referrer is a URL, then append
	  //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,
	  //     to httpRequests header list.
	  if (httpRequest.referrer instanceof URL) {
	    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href));
	  }

	  //    12. Append a request `Origin` header for httpRequest.
	  appendRequestOriginHeader(httpRequest);

	  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
	  appendFetchMetadata(httpRequest);

	  //    14. If httpRequests header list does not contain `User-Agent`, then
	  //    user agents should append `User-Agent`/default `User-Agent` value to
	  //    httpRequests header list.
	  if (!httpRequest.headersList.contains('user-agent')) {
	    httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node');
	  }

	  //    15. If httpRequests cache mode is "default" and httpRequests header
	  //    list contains `If-Modified-Since`, `If-None-Match`,
	  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
	  //    httpRequests cache mode to "no-store".
	  if (
	    httpRequest.cache === 'default' &&
	    (httpRequest.headersList.contains('if-modified-since') ||
	      httpRequest.headersList.contains('if-none-match') ||
	      httpRequest.headersList.contains('if-unmodified-since') ||
	      httpRequest.headersList.contains('if-match') ||
	      httpRequest.headersList.contains('if-range'))
	  ) {
	    httpRequest.cache = 'no-store';
	  }

	  //    16. If httpRequests cache mode is "no-cache", httpRequests prevent
	  //    no-cache cache-control header modification flag is unset, and
	  //    httpRequests header list does not contain `Cache-Control`, then append
	  //    `Cache-Control`/`max-age=0` to httpRequests header list.
	  if (
	    httpRequest.cache === 'no-cache' &&
	    !httpRequest.preventNoCacheCacheControlHeaderModification &&
	    !httpRequest.headersList.contains('cache-control')
	  ) {
	    httpRequest.headersList.append('cache-control', 'max-age=0');
	  }

	  //    17. If httpRequests cache mode is "no-store" or "reload", then:
	  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
	    // 1. If httpRequests header list does not contain `Pragma`, then append
	    // `Pragma`/`no-cache` to httpRequests header list.
	    if (!httpRequest.headersList.contains('pragma')) {
	      httpRequest.headersList.append('pragma', 'no-cache');
	    }

	    // 2. If httpRequests header list does not contain `Cache-Control`,
	    // then append `Cache-Control`/`no-cache` to httpRequests header list.
	    if (!httpRequest.headersList.contains('cache-control')) {
	      httpRequest.headersList.append('cache-control', 'no-cache');
	    }
	  }

	  //    18. If httpRequests header list contains `Range`, then append
	  //    `Accept-Encoding`/`identity` to httpRequests header list.
	  if (httpRequest.headersList.contains('range')) {
	    httpRequest.headersList.append('accept-encoding', 'identity');
	  }

	  //    19. Modify httpRequests header list per HTTP. Do not append a given
	  //    header if httpRequests header list contains that headers name.
	  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
	  if (!httpRequest.headersList.contains('accept-encoding')) {
	    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
	      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');
	    } else {
	      httpRequest.headersList.append('accept-encoding', 'gzip, deflate');
	    }
	  }

	  httpRequest.headersList.delete('host');

	  //    21. If theres a proxy-authentication entry, use it as appropriate.
	  //    TODO: proxy-authentication

	  //    22. Set httpCache to the result of determining the HTTP cache
	  //    partition, given httpRequest.
	  //    TODO: cache

	  //    23. If httpCache is null, then set httpRequests cache mode to
	  //    "no-store".
	  {
	    httpRequest.cache = 'no-store';
	  }

	  //    24. If httpRequests cache mode is neither "no-store" nor "reload",
	  //    then:
	  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') ;

	  // 9. If aborted, then return the appropriate network error for fetchParams.
	  // TODO

	  // 10. If response is null, then:
	  if (response == null) {
	    // 1. If httpRequests cache mode is "only-if-cached", then return a
	    // network error.
	    if (httpRequest.mode === 'only-if-cached') {
	      return makeNetworkError('only if cached')
	    }

	    // 2. Let forwardResponse be the result of running HTTP-network fetch
	    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.
	    const forwardResponse = await httpNetworkFetch(
	      httpFetchParams,
	      includeCredentials,
	      isNewConnectionFetch
	    );

	    // 3. If httpRequests method is unsafe and forwardResponses status is
	    // in the range 200 to 399, inclusive, invalidate appropriate stored
	    // responses in httpCache, as per the "Invalidation" chapter of HTTP
	    // Caching, and set storedResponse to null. [HTTP-CACHING]
	    if (
	      !safeMethodsSet.has(httpRequest.method) &&
	      forwardResponse.status >= 200 &&
	      forwardResponse.status <= 399
	    ) ;

	    // 5. If response is null, then:
	    if (response == null) {
	      // 1. Set response to forwardResponse.
	      response = forwardResponse;

	      // 2. Store httpRequest and forwardResponse in httpCache, as per the
	      // "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
	      // TODO: cache
	    }
	  }

	  // 11. Set responses URL list to a clone of httpRequests URL list.
	  response.urlList = [...httpRequest.urlList];

	  // 12. If httpRequests header list contains `Range`, then set responses
	  // range-requested flag.
	  if (httpRequest.headersList.contains('range')) {
	    response.rangeRequested = true;
	  }

	  // 13. Set responses request-includes-credentials to includeCredentials.
	  response.requestIncludesCredentials = includeCredentials;

	  // 14. If responses status is 401, httpRequests response tainting is not
	  // "cors", includeCredentials is true, and requests window is an environment
	  // settings object, then:
	  // TODO

	  // 15. If responses status is 407, then:
	  if (response.status === 407) {
	    // 1. If requests window is "no-window", then return a network error.
	    if (request.window === 'no-window') {
	      return makeNetworkError()
	    }

	    // 2. ???

	    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	    if (isCancelled(fetchParams)) {
	      return makeAppropriateNetworkError(fetchParams)
	    }

	    // 4. Prompt the end user as appropriate in requests window and store
	    // the result as a proxy-authentication entry. [HTTP-AUTH]
	    // TODO: Invoke some kind of callback?

	    // 5. Set response to the result of running HTTP-network-or-cache fetch given
	    // fetchParams.
	    // TODO
	    return makeNetworkError('proxy authentication required')
	  }

	  // 16. If all of the following are true
	  if (
	    // responses status is 421
	    response.status === 421 &&
	    // isNewConnectionFetch is false
	    !isNewConnectionFetch &&
	    // requests body is null, or requests body is non-null and requests bodys source is non-null
	    (request.body == null || request.body.source != null)
	  ) {
	    // then:

	    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	    if (isCancelled(fetchParams)) {
	      return makeAppropriateNetworkError(fetchParams)
	    }

	    // 2. Set response to the result of running HTTP-network-or-cache
	    // fetch given fetchParams, isAuthenticationFetch, and true.

	    // TODO (spec): The spec doesn't specify this but we need to cancel
	    // the active response before we can start a new one.
	    // https://github.com/whatwg/fetch/issues/1293
	    fetchParams.controller.connection.destroy();

	    response = await httpNetworkOrCacheFetch(
	      fetchParams,
	      isAuthenticationFetch,
	      true
	    );
	  }

	  // 18. Return response.
	  return response
	}

	// https://fetch.spec.whatwg.org/#http-network-fetch
	async function httpNetworkFetch (
	  fetchParams,
	  includeCredentials = false,
	  forceNewConnection = false
	) {
	  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);

	  fetchParams.controller.connection = {
	    abort: null,
	    destroyed: false,
	    destroy (err) {
	      if (!this.destroyed) {
	        this.destroyed = true;
	        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));
	      }
	    }
	  };

	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 5. If httpCache is null, then set requests cache mode to "no-store".
	  {
	    request.cache = 'no-store';
	  }

	  // 8. Switch on requests mode:
	  if (request.mode === 'websocket') ;

	  // 9. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. If connection is failure, then return a network error.

	  //    2. Set timingInfos final connection timing info to the result of
	  //    calling clamp and coarsen connection timing info with connections
	  //    timing info, timingInfos post-redirect start time, and fetchParamss
	  //    cross-origin isolated capability.

	  //    3. If connection is not an HTTP/2 connection, requests body is non-null,
	  //    and requests bodys source is null, then append (`Transfer-Encoding`,
	  //    `chunked`) to requests header list.

	  //    4. Set timingInfos final network-request start time to the coarsened
	  //    shared current time given fetchParamss cross-origin isolated
	  //    capability.

	  //    5. Set response to the result of making an HTTP request over connection
	  //    using request with the following caveats:

	  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
	  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

	  //        - If requests body is non-null, and requests bodys source is null,
	  //        then the user agent may have a buffer of up to 64 kibibytes and store
	  //        a part of requests body in that buffer. If the user agent reads from
	  //        requests body beyond that buffers size and the user agent needs to
	  //        resend request, then instead return a network error.

	  //        - Set timingInfos final network-response start time to the coarsened
	  //        shared current time given fetchParamss cross-origin isolated capability,
	  //        immediately after the user agents HTTP parser receives the first byte
	  //        of the response (e.g., frame header bytes for HTTP/2 or response status
	  //        line for HTTP/1.x).

	  //        - Wait until all the headers are transmitted.

	  //        - Any responses whose status is in the range 100 to 199, inclusive,
	  //        and is not 101, are to be ignored, except for the purposes of setting
	  //        timingInfos final network-response start time above.

	  //    - If requests header list contains `Transfer-Encoding`/`chunked` and
	  //    response is transferred via HTTP/1.0 or older, then return a network
	  //    error.

	  //    - If the HTTP request results in a TLS client certificate dialog, then:

	  //        1. If requests window is an environment settings object, make the
	  //        dialog available in requests window.

	  //        2. Otherwise, return a network error.

	  // To transmit requests body body, run these steps:
	  let requestBody = null;
	  // 1. If body is null and fetchParamss process request end-of-body is
	  // non-null, then queue a fetch task given fetchParamss process request
	  // end-of-body and fetchParamss task destination.
	  if (request.body == null && fetchParams.processRequestEndOfBody) {
	    queueMicrotask(() => fetchParams.processRequestEndOfBody());
	  } else if (request.body != null) {
	    // 2. Otherwise, if body is non-null:

	    //    1. Let processBodyChunk given bytes be these steps:
	    const processBodyChunk = async function * (bytes) {
	      // 1. If the ongoing fetch is terminated, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. Run this step in parallel: transmit bytes.
	      yield bytes;

	      // 3. If fetchParamss process request body is non-null, then run
	      // fetchParamss process request body given bytess length.
	      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
	    };

	    // 2. Let processEndOfBody be these steps:
	    const processEndOfBody = () => {
	      // 1. If fetchParams is canceled, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. If fetchParamss process request end-of-body is non-null,
	      // then run fetchParamss process request end-of-body.
	      if (fetchParams.processRequestEndOfBody) {
	        fetchParams.processRequestEndOfBody();
	      }
	    };

	    // 3. Let processBodyError given e be these steps:
	    const processBodyError = (e) => {
	      // 1. If fetchParams is canceled, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. If e is an "AbortError" DOMException, then abort fetchParamss controller.
	      if (e.name === 'AbortError') {
	        fetchParams.controller.abort();
	      } else {
	        fetchParams.controller.terminate(e);
	      }
	    };

	    // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,
	    // processBodyError, and fetchParamss task destination.
	    requestBody = (async function * () {
	      try {
	        for await (const bytes of request.body.stream) {
	          yield * processBodyChunk(bytes);
	        }
	        processEndOfBody();
	      } catch (err) {
	        processBodyError(err);
	      }
	    })();
	  }

	  try {
	    // socket is only provided for websockets
	    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });

	    if (socket) {
	      response = makeResponse({ status, statusText, headersList, socket });
	    } else {
	      const iterator = body[Symbol.asyncIterator]();
	      fetchParams.controller.next = () => iterator.next();

	      response = makeResponse({ status, statusText, headersList });
	    }
	  } catch (err) {
	    // 10. If aborted, then:
	    if (err.name === 'AbortError') {
	      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
	      fetchParams.controller.connection.destroy();

	      // 2. Return the appropriate network error for fetchParams.
	      return makeAppropriateNetworkError(fetchParams, err)
	    }

	    return makeNetworkError(err)
	  }

	  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch
	  // if it is suspended.
	  const pullAlgorithm = () => {
	    fetchParams.controller.resume();
	  };

	  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss
	  // controller with reason, given reason.
	  const cancelAlgorithm = (reason) => {
	    fetchParams.controller.abort(reason);
	  };

	  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
	  // the user agent.
	  // TODO

	  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
	  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
	  // TODO

	  // 15. Let stream be a new ReadableStream.
	  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,
	  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to
	  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  const stream = new ReadableStream(
	    {
	      async start (controller) {
	        fetchParams.controller.controller = controller;
	      },
	      async pull (controller) {
	        await pullAlgorithm();
	      },
	      async cancel (reason) {
	        await cancelAlgorithm(reason);
	      }
	    },
	    {
	      highWaterMark: 0,
	      size () {
	        return 1
	      }
	    }
	  );

	  // 17. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. Set responses body to a new body whose stream is stream.
	  response.body = { stream };

	  //    2. If response is not a network error and requests cache mode is
	  //    not "no-store", then update response in httpCache for request.
	  //    TODO

	  //    3. If includeCredentials is true and the user agent is not configured
	  //    to block cookies for request (see section 7 of [COOKIES]), then run the
	  //    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
	  //    the value of each header whose name is a byte-case-insensitive match for
	  //    `Set-Cookie` in responses header list, if any, and requests current URL.
	  //    TODO

	  // 18. If aborted, then:
	  // TODO

	  // 19. Run these steps in parallel:

	  //    1. Run these steps, but abort when fetchParams is canceled:
	  fetchParams.controller.on('terminated', onAborted);
	  fetchParams.controller.resume = async () => {
	    // 1. While true
	    while (true) {
	      // 1-3. See onData...

	      // 4. Set bytes to the result of handling content codings given
	      // codings and bytes.
	      let bytes;
	      let isFailure;
	      try {
	        const { done, value } = await fetchParams.controller.next();

	        if (isAborted(fetchParams)) {
	          break
	        }

	        bytes = done ? undefined : value;
	      } catch (err) {
	        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
	          // zlib doesn't like empty streams.
	          bytes = undefined;
	        } else {
	          bytes = err;

	          // err may be propagated from the result of calling readablestream.cancel,
	          // which might not be an error. https://github.com/nodejs/undici/issues/2009
	          isFailure = true;
	        }
	      }

	      if (bytes === undefined) {
	        // 2. Otherwise, if the bytes transmission for responses message
	        // body is done normally and stream is readable, then close
	        // stream, finalize response for fetchParams and response, and
	        // abort these in-parallel steps.
	        readableStreamClose(fetchParams.controller.controller);

	        finalizeResponse(fetchParams, response);

	        return
	      }

	      // 5. Increase timingInfos decoded body size by bytess length.
	      timingInfo.decodedBodySize += bytes?.byteLength ?? 0;

	      // 6. If bytes is failure, then terminate fetchParamss controller.
	      if (isFailure) {
	        fetchParams.controller.terminate(bytes);
	        return
	      }

	      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
	      // into stream.
	      fetchParams.controller.controller.enqueue(new Uint8Array(bytes));

	      // 8. If stream is errored, then terminate the ongoing fetch.
	      if (isErrored(stream)) {
	        fetchParams.controller.terminate();
	        return
	      }

	      // 9. If stream doesnt need more data ask the user agent to suspend
	      // the ongoing fetch.
	      if (!fetchParams.controller.controller.desiredSize) {
	        return
	      }
	    }
	  };

	  //    2. If aborted, then:
	  function onAborted (reason) {
	    // 2. If fetchParams is aborted, then:
	    if (isAborted(fetchParams)) {
	      // 1. Set responses aborted flag.
	      response.aborted = true;

	      // 2. If stream is readable, then error stream with the result of
	      //    deserialize a serialized abort reason given fetchParamss
	      //    controllers serialized abort reason and an
	      //    implementation-defined realm.
	      if (isReadable(stream)) {
	        fetchParams.controller.controller.error(
	          fetchParams.controller.serializedAbortReason
	        );
	      }
	    } else {
	      // 3. Otherwise, if stream is readable, error stream with a TypeError.
	      if (isReadable(stream)) {
	        fetchParams.controller.controller.error(new TypeError('terminated', {
	          cause: isErrorLike(reason) ? reason : undefined
	        }));
	      }
	    }

	    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
	    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
	    fetchParams.controller.connection.destroy();
	  }

	  // 20. Return response.
	  return response

	  async function dispatch ({ body }) {
	    const url = requestCurrentURL(request);
	    /** @type {import('../..').Agent} */
	    const agent = fetchParams.controller.dispatcher;

	    return new Promise((resolve, reject) => agent.dispatch(
	      {
	        path: url.pathname + url.search,
	        origin: url.origin,
	        method: request.method,
	        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
	        headers: request.headersList.entries,
	        maxRedirections: 0,
	        upgrade: request.mode === 'websocket' ? 'websocket' : undefined
	      },
	      {
	        body: null,
	        abort: null,

	        onConnect (abort) {
	          // TODO (fix): Do we need connection here?
	          const { connection } = fetchParams.controller;

	          if (connection.destroyed) {
	            abort(new DOMException('The operation was aborted.', 'AbortError'));
	          } else {
	            fetchParams.controller.on('terminated', abort);
	            this.abort = connection.abort = abort;
	          }
	        },

	        onHeaders (status, headersList, resume, statusText) {
	          if (status < 200) {
	            return
	          }

	          let codings = [];
	          let location = '';

	          const headers = new Headers();

	          // For H2, the headers are a plain JS object
	          // We distinguish between them and iterate accordingly
	          if (Array.isArray(headersList)) {
	            for (let n = 0; n < headersList.length; n += 2) {
	              const key = headersList[n + 0].toString('latin1');
	              const val = headersList[n + 1].toString('latin1');
	              if (key.toLowerCase() === 'content-encoding') {
	                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
	                // "All content-coding values are case-insensitive..."
	                codings = val.toLowerCase().split(',').map((x) => x.trim());
	              } else if (key.toLowerCase() === 'location') {
	                location = val;
	              }

	              headers[kHeadersList].append(key, val);
	            }
	          } else {
	            const keys = Object.keys(headersList);
	            for (const key of keys) {
	              const val = headersList[key];
	              if (key.toLowerCase() === 'content-encoding') {
	                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
	                // "All content-coding values are case-insensitive..."
	                codings = val.toLowerCase().split(',').map((x) => x.trim()).reverse();
	              } else if (key.toLowerCase() === 'location') {
	                location = val;
	              }

	              headers[kHeadersList].append(key, val);
	            }
	          }

	          this.body = new Readable({ read: resume });

	          const decoders = [];

	          const willFollow = request.redirect === 'follow' &&
	            location &&
	            redirectStatusSet.has(status);

	          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
	          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {
	            for (const coding of codings) {
	              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
	              if (coding === 'x-gzip' || coding === 'gzip') {
	                decoders.push(zlib.createGunzip({
	                  // Be less strict when decoding compressed responses, since sometimes
	                  // servers send slightly invalid responses that are still accepted
	                  // by common browsers.
	                  // Always using Z_SYNC_FLUSH is what cURL does.
	                  flush: zlib.constants.Z_SYNC_FLUSH,
	                  finishFlush: zlib.constants.Z_SYNC_FLUSH
	                }));
	              } else if (coding === 'deflate') {
	                decoders.push(zlib.createInflate());
	              } else if (coding === 'br') {
	                decoders.push(zlib.createBrotliDecompress());
	              } else {
	                decoders.length = 0;
	                break
	              }
	            }
	          }

	          resolve({
	            status,
	            statusText,
	            headersList: headers[kHeadersList],
	            body: decoders.length
	              ? pipeline(this.body, ...decoders, () => { })
	              : this.body.on('error', () => {})
	          });

	          return true
	        },

	        onData (chunk) {
	          if (fetchParams.controller.dump) {
	            return
	          }

	          // 1. If one or more bytes have been transmitted from responses
	          // message body, then:

	          //  1. Let bytes be the transmitted bytes.
	          const bytes = chunk;

	          //  2. Let codings be the result of extracting header list values
	          //  given `Content-Encoding` and responses header list.
	          //  See pullAlgorithm.

	          //  3. Increase timingInfos encoded body size by bytess length.
	          timingInfo.encodedBodySize += bytes.byteLength;

	          //  4. See pullAlgorithm...

	          return this.body.push(bytes)
	        },

	        onComplete () {
	          if (this.abort) {
	            fetchParams.controller.off('terminated', this.abort);
	          }

	          fetchParams.controller.ended = true;

	          this.body.push(null);
	        },

	        onError (error) {
	          if (this.abort) {
	            fetchParams.controller.off('terminated', this.abort);
	          }

	          this.body?.destroy(error);

	          fetchParams.controller.terminate(error);

	          reject(error);
	        },

	        onUpgrade (status, headersList, socket) {
	          if (status !== 101) {
	            return
	          }

	          const headers = new Headers();

	          for (let n = 0; n < headersList.length; n += 2) {
	            const key = headersList[n + 0].toString('latin1');
	            const val = headersList[n + 1].toString('latin1');

	            headers[kHeadersList].append(key, val);
	          }

	          resolve({
	            status,
	            statusText: STATUS_CODES[status],
	            headersList: headers[kHeadersList],
	            socket
	          });

	          return true
	        }
	      }
	    ))
	  }
	}

	fetch_1 = {
	  fetch,
	  Fetch,
	  fetching,
	  finalizeAndReportTiming
	};
	return fetch_1;
}

var symbols$2;
var hasRequiredSymbols$2;

function requireSymbols$2 () {
	if (hasRequiredSymbols$2) return symbols$2;
	hasRequiredSymbols$2 = 1;

	symbols$2 = {
	  kState: Symbol('FileReader state'),
	  kResult: Symbol('FileReader result'),
	  kError: Symbol('FileReader error'),
	  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
	  kEvents: Symbol('FileReader events'),
	  kAborted: Symbol('FileReader aborted')
	};
	return symbols$2;
}

var progressevent;
var hasRequiredProgressevent;

function requireProgressevent () {
	if (hasRequiredProgressevent) return progressevent;
	hasRequiredProgressevent = 1;

	const { webidl } = requireWebidl();

	const kState = Symbol('ProgressEvent state');

	/**
	 * @see https://xhr.spec.whatwg.org/#progressevent
	 */
	class ProgressEvent extends Event {
	  constructor (type, eventInitDict = {}) {
	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});

	    super(type, eventInitDict);

	    this[kState] = {
	      lengthComputable: eventInitDict.lengthComputable,
	      loaded: eventInitDict.loaded,
	      total: eventInitDict.total
	    };
	  }

	  get lengthComputable () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].lengthComputable
	  }

	  get loaded () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].loaded
	  }

	  get total () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].total
	  }
	}

	webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
	  {
	    key: 'lengthComputable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'loaded',
	    converter: webidl.converters['unsigned long long'],
	    defaultValue: 0
	  },
	  {
	    key: 'total',
	    converter: webidl.converters['unsigned long long'],
	    defaultValue: 0
	  },
	  {
	    key: 'bubbles',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'cancelable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'composed',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	]);

	progressevent = {
	  ProgressEvent
	};
	return progressevent;
}

var encoding;
var hasRequiredEncoding;

function requireEncoding () {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;

	/**
	 * @see https://encoding.spec.whatwg.org/#concept-encoding-get
	 * @param {string|undefined} label
	 */
	function getEncoding (label) {
	  if (!label) {
	    return 'failure'
	  }

	  // 1. Remove any leading and trailing ASCII whitespace from label.
	  // 2. If label is an ASCII case-insensitive match for any of the
	  //    labels listed in the table below, then return the
	  //    corresponding encoding; otherwise return failure.
	  switch (label.trim().toLowerCase()) {
	    case 'unicode-1-1-utf-8':
	    case 'unicode11utf8':
	    case 'unicode20utf8':
	    case 'utf-8':
	    case 'utf8':
	    case 'x-unicode20utf8':
	      return 'UTF-8'
	    case '866':
	    case 'cp866':
	    case 'csibm866':
	    case 'ibm866':
	      return 'IBM866'
	    case 'csisolatin2':
	    case 'iso-8859-2':
	    case 'iso-ir-101':
	    case 'iso8859-2':
	    case 'iso88592':
	    case 'iso_8859-2':
	    case 'iso_8859-2:1987':
	    case 'l2':
	    case 'latin2':
	      return 'ISO-8859-2'
	    case 'csisolatin3':
	    case 'iso-8859-3':
	    case 'iso-ir-109':
	    case 'iso8859-3':
	    case 'iso88593':
	    case 'iso_8859-3':
	    case 'iso_8859-3:1988':
	    case 'l3':
	    case 'latin3':
	      return 'ISO-8859-3'
	    case 'csisolatin4':
	    case 'iso-8859-4':
	    case 'iso-ir-110':
	    case 'iso8859-4':
	    case 'iso88594':
	    case 'iso_8859-4':
	    case 'iso_8859-4:1988':
	    case 'l4':
	    case 'latin4':
	      return 'ISO-8859-4'
	    case 'csisolatincyrillic':
	    case 'cyrillic':
	    case 'iso-8859-5':
	    case 'iso-ir-144':
	    case 'iso8859-5':
	    case 'iso88595':
	    case 'iso_8859-5':
	    case 'iso_8859-5:1988':
	      return 'ISO-8859-5'
	    case 'arabic':
	    case 'asmo-708':
	    case 'csiso88596e':
	    case 'csiso88596i':
	    case 'csisolatinarabic':
	    case 'ecma-114':
	    case 'iso-8859-6':
	    case 'iso-8859-6-e':
	    case 'iso-8859-6-i':
	    case 'iso-ir-127':
	    case 'iso8859-6':
	    case 'iso88596':
	    case 'iso_8859-6':
	    case 'iso_8859-6:1987':
	      return 'ISO-8859-6'
	    case 'csisolatingreek':
	    case 'ecma-118':
	    case 'elot_928':
	    case 'greek':
	    case 'greek8':
	    case 'iso-8859-7':
	    case 'iso-ir-126':
	    case 'iso8859-7':
	    case 'iso88597':
	    case 'iso_8859-7':
	    case 'iso_8859-7:1987':
	    case 'sun_eu_greek':
	      return 'ISO-8859-7'
	    case 'csiso88598e':
	    case 'csisolatinhebrew':
	    case 'hebrew':
	    case 'iso-8859-8':
	    case 'iso-8859-8-e':
	    case 'iso-ir-138':
	    case 'iso8859-8':
	    case 'iso88598':
	    case 'iso_8859-8':
	    case 'iso_8859-8:1988':
	    case 'visual':
	      return 'ISO-8859-8'
	    case 'csiso88598i':
	    case 'iso-8859-8-i':
	    case 'logical':
	      return 'ISO-8859-8-I'
	    case 'csisolatin6':
	    case 'iso-8859-10':
	    case 'iso-ir-157':
	    case 'iso8859-10':
	    case 'iso885910':
	    case 'l6':
	    case 'latin6':
	      return 'ISO-8859-10'
	    case 'iso-8859-13':
	    case 'iso8859-13':
	    case 'iso885913':
	      return 'ISO-8859-13'
	    case 'iso-8859-14':
	    case 'iso8859-14':
	    case 'iso885914':
	      return 'ISO-8859-14'
	    case 'csisolatin9':
	    case 'iso-8859-15':
	    case 'iso8859-15':
	    case 'iso885915':
	    case 'iso_8859-15':
	    case 'l9':
	      return 'ISO-8859-15'
	    case 'iso-8859-16':
	      return 'ISO-8859-16'
	    case 'cskoi8r':
	    case 'koi':
	    case 'koi8':
	    case 'koi8-r':
	    case 'koi8_r':
	      return 'KOI8-R'
	    case 'koi8-ru':
	    case 'koi8-u':
	      return 'KOI8-U'
	    case 'csmacintosh':
	    case 'mac':
	    case 'macintosh':
	    case 'x-mac-roman':
	      return 'macintosh'
	    case 'iso-8859-11':
	    case 'iso8859-11':
	    case 'iso885911':
	    case 'tis-620':
	    case 'windows-874':
	      return 'windows-874'
	    case 'cp1250':
	    case 'windows-1250':
	    case 'x-cp1250':
	      return 'windows-1250'
	    case 'cp1251':
	    case 'windows-1251':
	    case 'x-cp1251':
	      return 'windows-1251'
	    case 'ansi_x3.4-1968':
	    case 'ascii':
	    case 'cp1252':
	    case 'cp819':
	    case 'csisolatin1':
	    case 'ibm819':
	    case 'iso-8859-1':
	    case 'iso-ir-100':
	    case 'iso8859-1':
	    case 'iso88591':
	    case 'iso_8859-1':
	    case 'iso_8859-1:1987':
	    case 'l1':
	    case 'latin1':
	    case 'us-ascii':
	    case 'windows-1252':
	    case 'x-cp1252':
	      return 'windows-1252'
	    case 'cp1253':
	    case 'windows-1253':
	    case 'x-cp1253':
	      return 'windows-1253'
	    case 'cp1254':
	    case 'csisolatin5':
	    case 'iso-8859-9':
	    case 'iso-ir-148':
	    case 'iso8859-9':
	    case 'iso88599':
	    case 'iso_8859-9':
	    case 'iso_8859-9:1989':
	    case 'l5':
	    case 'latin5':
	    case 'windows-1254':
	    case 'x-cp1254':
	      return 'windows-1254'
	    case 'cp1255':
	    case 'windows-1255':
	    case 'x-cp1255':
	      return 'windows-1255'
	    case 'cp1256':
	    case 'windows-1256':
	    case 'x-cp1256':
	      return 'windows-1256'
	    case 'cp1257':
	    case 'windows-1257':
	    case 'x-cp1257':
	      return 'windows-1257'
	    case 'cp1258':
	    case 'windows-1258':
	    case 'x-cp1258':
	      return 'windows-1258'
	    case 'x-mac-cyrillic':
	    case 'x-mac-ukrainian':
	      return 'x-mac-cyrillic'
	    case 'chinese':
	    case 'csgb2312':
	    case 'csiso58gb231280':
	    case 'gb2312':
	    case 'gb_2312':
	    case 'gb_2312-80':
	    case 'gbk':
	    case 'iso-ir-58':
	    case 'x-gbk':
	      return 'GBK'
	    case 'gb18030':
	      return 'gb18030'
	    case 'big5':
	    case 'big5-hkscs':
	    case 'cn-big5':
	    case 'csbig5':
	    case 'x-x-big5':
	      return 'Big5'
	    case 'cseucpkdfmtjapanese':
	    case 'euc-jp':
	    case 'x-euc-jp':
	      return 'EUC-JP'
	    case 'csiso2022jp':
	    case 'iso-2022-jp':
	      return 'ISO-2022-JP'
	    case 'csshiftjis':
	    case 'ms932':
	    case 'ms_kanji':
	    case 'shift-jis':
	    case 'shift_jis':
	    case 'sjis':
	    case 'windows-31j':
	    case 'x-sjis':
	      return 'Shift_JIS'
	    case 'cseuckr':
	    case 'csksc56011987':
	    case 'euc-kr':
	    case 'iso-ir-149':
	    case 'korean':
	    case 'ks_c_5601-1987':
	    case 'ks_c_5601-1989':
	    case 'ksc5601':
	    case 'ksc_5601':
	    case 'windows-949':
	      return 'EUC-KR'
	    case 'csiso2022kr':
	    case 'hz-gb-2312':
	    case 'iso-2022-cn':
	    case 'iso-2022-cn-ext':
	    case 'iso-2022-kr':
	    case 'replacement':
	      return 'replacement'
	    case 'unicodefffe':
	    case 'utf-16be':
	      return 'UTF-16BE'
	    case 'csunicode':
	    case 'iso-10646-ucs-2':
	    case 'ucs-2':
	    case 'unicode':
	    case 'unicodefeff':
	    case 'utf-16':
	    case 'utf-16le':
	      return 'UTF-16LE'
	    case 'x-user-defined':
	      return 'x-user-defined'
	    default: return 'failure'
	  }
	}

	encoding = {
	  getEncoding
	};
	return encoding;
}

var util$3;
var hasRequiredUtil$3;

function requireUtil$3 () {
	if (hasRequiredUtil$3) return util$3;
	hasRequiredUtil$3 = 1;

	const {
	  kState,
	  kError,
	  kResult,
	  kAborted,
	  kLastProgressEventFired
	} = requireSymbols$2();
	const { ProgressEvent } = requireProgressevent();
	const { getEncoding } = requireEncoding();
	const { DOMException } = requireConstants$3();
	const { serializeAMimeType, parseMIMEType } = requireDataURL();
	const { types } = require$$0$1;
	const { StringDecoder } = require$$1$7;
	const { btoa } = require$$7;

	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
	  enumerable: true,
	  writable: false,
	  configurable: false
	};

	/**
	 * @see https://w3c.github.io/FileAPI/#readOperation
	 * @param {import('./filereader').FileReader} fr
	 * @param {import('buffer').Blob} blob
	 * @param {string} type
	 * @param {string?} encodingName
	 */
	function readOperation (fr, blob, type, encodingName) {
	  // 1. If frs state is "loading", throw an InvalidStateError
	  //    DOMException.
	  if (fr[kState] === 'loading') {
	    throw new DOMException('Invalid state', 'InvalidStateError')
	  }

	  // 2. Set frs state to "loading".
	  fr[kState] = 'loading';

	  // 3. Set frs result to null.
	  fr[kResult] = null;

	  // 4. Set frs error to null.
	  fr[kError] = null;

	  // 5. Let stream be the result of calling get stream on blob.
	  /** @type {import('stream/web').ReadableStream} */
	  const stream = blob.stream();

	  // 6. Let reader be the result of getting a reader from stream.
	  const reader = stream.getReader();

	  // 7. Let bytes be an empty byte sequence.
	  /** @type {Uint8Array[]} */
	  const bytes = [];

	  // 8. Let chunkPromise be the result of reading a chunk from
	  //    stream with reader.
	  let chunkPromise = reader.read();

	  // 9. Let isFirstChunk be true.
	  let isFirstChunk = true

	  // 10. In parallel, while true:
	  // Note: "In parallel" just means non-blocking
	  // Note 2: readOperation itself cannot be async as double
	  // reading the body would then reject the promise, instead
	  // of throwing an error.
	  ;(async () => {
	    while (!fr[kAborted]) {
	      // 1. Wait for chunkPromise to be fulfilled or rejected.
	      try {
	        const { done, value } = await chunkPromise;

	        // 2. If chunkPromise is fulfilled, and isFirstChunk is
	        //    true, queue a task to fire a progress event called
	        //    loadstart at fr.
	        if (isFirstChunk && !fr[kAborted]) {
	          queueMicrotask(() => {
	            fireAProgressEvent('loadstart', fr);
	          });
	        }

	        // 3. Set isFirstChunk to false.
	        isFirstChunk = false;

	        // 4. If chunkPromise is fulfilled with an object whose
	        //    done property is false and whose value property is
	        //    a Uint8Array object, run these steps:
	        if (!done && types.isUint8Array(value)) {
	          // 1. Let bs be the byte sequence represented by the
	          //    Uint8Array object.

	          // 2. Append bs to bytes.
	          bytes.push(value);

	          // 3. If roughly 50ms have passed since these steps
	          //    were last invoked, queue a task to fire a
	          //    progress event called progress at fr.
	          if (
	            (
	              fr[kLastProgressEventFired] === undefined ||
	              Date.now() - fr[kLastProgressEventFired] >= 50
	            ) &&
	            !fr[kAborted]
	          ) {
	            fr[kLastProgressEventFired] = Date.now();
	            queueMicrotask(() => {
	              fireAProgressEvent('progress', fr);
	            });
	          }

	          // 4. Set chunkPromise to the result of reading a
	          //    chunk from stream with reader.
	          chunkPromise = reader.read();
	        } else if (done) {
	          // 5. Otherwise, if chunkPromise is fulfilled with an
	          //    object whose done property is true, queue a task
	          //    to run the following steps and abort this algorithm:
	          queueMicrotask(() => {
	            // 1. Set frs state to "done".
	            fr[kState] = 'done';

	            // 2. Let result be the result of package data given
	            //    bytes, type, blobs type, and encodingName.
	            try {
	              const result = packageData(bytes, type, blob.type, encodingName);

	              // 4. Else:

	              if (fr[kAborted]) {
	                return
	              }

	              // 1. Set frs result to result.
	              fr[kResult] = result;

	              // 2. Fire a progress event called load at the fr.
	              fireAProgressEvent('load', fr);
	            } catch (error) {
	              // 3. If package data threw an exception error:

	              // 1. Set frs error to error.
	              fr[kError] = error;

	              // 2. Fire a progress event called error at fr.
	              fireAProgressEvent('error', fr);
	            }

	            // 5. If frs state is not "loading", fire a progress
	            //    event called loadend at the fr.
	            if (fr[kState] !== 'loading') {
	              fireAProgressEvent('loadend', fr);
	            }
	          });

	          break
	        }
	      } catch (error) {
	        if (fr[kAborted]) {
	          return
	        }

	        // 6. Otherwise, if chunkPromise is rejected with an
	        //    error error, queue a task to run the following
	        //    steps and abort this algorithm:
	        queueMicrotask(() => {
	          // 1. Set frs state to "done".
	          fr[kState] = 'done';

	          // 2. Set frs error to error.
	          fr[kError] = error;

	          // 3. Fire a progress event called error at fr.
	          fireAProgressEvent('error', fr);

	          // 4. If frs state is not "loading", fire a progress
	          //    event called loadend at fr.
	          if (fr[kState] !== 'loading') {
	            fireAProgressEvent('loadend', fr);
	          }
	        });

	        break
	      }
	    }
	  })();
	}

	/**
	 * @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	 * @see https://dom.spec.whatwg.org/#concept-event-fire
	 * @param {string} e The name of the event
	 * @param {import('./filereader').FileReader} reader
	 */
	function fireAProgressEvent (e, reader) {
	  // The progress event e does not bubble. e.bubbles must be false
	  // The progress event e is NOT cancelable. e.cancelable must be false
	  const event = new ProgressEvent(e, {
	    bubbles: false,
	    cancelable: false
	  });

	  reader.dispatchEvent(event);
	}

	/**
	 * @see https://w3c.github.io/FileAPI/#blob-package-data
	 * @param {Uint8Array[]} bytes
	 * @param {string} type
	 * @param {string?} mimeType
	 * @param {string?} encodingName
	 */
	function packageData (bytes, type, mimeType, encodingName) {
	  // 1. A Blob has an associated package data algorithm, given
	  //    bytes, a type, a optional mimeType, and a optional
	  //    encodingName, which switches on type and runs the
	  //    associated steps:

	  switch (type) {
	    case 'DataURL': {
	      // 1. Return bytes as a DataURL [RFC2397] subject to
	      //    the considerations below:
	      //  * Use mimeType as part of the Data URL if it is
	      //    available in keeping with the Data URL
	      //    specification [RFC2397].
	      //  * If mimeType is not available return a Data URL
	      //    without a media-type. [RFC2397].

	      // https://datatracker.ietf.org/doc/html/rfc2397#section-3
	      // dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
	      // mediatype  := [ type "/" subtype ] *( ";" parameter )
	      // data       := *urlchar
	      // parameter  := attribute "=" value
	      let dataURL = 'data:';

	      const parsed = parseMIMEType(mimeType || 'application/octet-stream');

	      if (parsed !== 'failure') {
	        dataURL += serializeAMimeType(parsed);
	      }

	      dataURL += ';base64,';

	      const decoder = new StringDecoder('latin1');

	      for (const chunk of bytes) {
	        dataURL += btoa(decoder.write(chunk));
	      }

	      dataURL += btoa(decoder.end());

	      return dataURL
	    }
	    case 'Text': {
	      // 1. Let encoding be failure
	      let encoding = 'failure';

	      // 2. If the encodingName is present, set encoding to the
	      //    result of getting an encoding from encodingName.
	      if (encodingName) {
	        encoding = getEncoding(encodingName);
	      }

	      // 3. If encoding is failure, and mimeType is present:
	      if (encoding === 'failure' && mimeType) {
	        // 1. Let type be the result of parse a MIME type
	        //    given mimeType.
	        const type = parseMIMEType(mimeType);

	        // 2. If type is not failure, set encoding to the result
	        //    of getting an encoding from types parameters["charset"].
	        if (type !== 'failure') {
	          encoding = getEncoding(type.parameters.get('charset'));
	        }
	      }

	      // 4. If encoding is failure, then set encoding to UTF-8.
	      if (encoding === 'failure') {
	        encoding = 'UTF-8';
	      }

	      // 5. Decode bytes using fallback encoding encoding, and
	      //    return the result.
	      return decode(bytes, encoding)
	    }
	    case 'ArrayBuffer': {
	      // Return a new ArrayBuffer whose contents are bytes.
	      const sequence = combineByteSequences(bytes);

	      return sequence.buffer
	    }
	    case 'BinaryString': {
	      // Return bytes as a binary string, in which every byte
	      //  is represented by a code unit of equal value [0..255].
	      let binaryString = '';

	      const decoder = new StringDecoder('latin1');

	      for (const chunk of bytes) {
	        binaryString += decoder.write(chunk);
	      }

	      binaryString += decoder.end();

	      return binaryString
	    }
	  }
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#decode
	 * @param {Uint8Array[]} ioQueue
	 * @param {string} encoding
	 */
	function decode (ioQueue, encoding) {
	  const bytes = combineByteSequences(ioQueue);

	  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.
	  const BOMEncoding = BOMSniffing(bytes);

	  let slice = 0;

	  // 2. If BOMEncoding is non-null:
	  if (BOMEncoding !== null) {
	    // 1. Set encoding to BOMEncoding.
	    encoding = BOMEncoding;

	    // 2. Read three bytes from ioQueue, if BOMEncoding is
	    //    UTF-8; otherwise read two bytes.
	    //    (Do nothing with those bytes.)
	    slice = BOMEncoding === 'UTF-8' ? 3 : 2;
	  }

	  // 3. Process a queue with an instance of encodings
	  //    decoder, ioQueue, output, and "replacement".

	  // 4. Return output.

	  const sliced = bytes.slice(slice);
	  return new TextDecoder(encoding).decode(sliced)
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#bom-sniff
	 * @param {Uint8Array} ioQueue
	 */
	function BOMSniffing (ioQueue) {
	  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,
	  //    converted to a byte sequence.
	  const [a, b, c] = ioQueue;

	  // 2. For each of the rows in the table below, starting with
	  //    the first one and going down, if BOM starts with the
	  //    bytes given in the first column, then return the
	  //    encoding given in the cell in the second column of that
	  //    row. Otherwise, return null.
	  if (a === 0xEF && b === 0xBB && c === 0xBF) {
	    return 'UTF-8'
	  } else if (a === 0xFE && b === 0xFF) {
	    return 'UTF-16BE'
	  } else if (a === 0xFF && b === 0xFE) {
	    return 'UTF-16LE'
	  }

	  return null
	}

	/**
	 * @param {Uint8Array[]} sequences
	 */
	function combineByteSequences (sequences) {
	  const size = sequences.reduce((a, b) => {
	    return a + b.byteLength
	  }, 0);

	  let offset = 0;

	  return sequences.reduce((a, b) => {
	    a.set(b, offset);
	    offset += b.byteLength;
	    return a
	  }, new Uint8Array(size))
	}

	util$3 = {
	  staticPropertyDescriptors,
	  readOperation,
	  fireAProgressEvent
	};
	return util$3;
}

var filereader;
var hasRequiredFilereader;

function requireFilereader () {
	if (hasRequiredFilereader) return filereader;
	hasRequiredFilereader = 1;

	const {
	  staticPropertyDescriptors,
	  readOperation,
	  fireAProgressEvent
	} = requireUtil$3();
	const {
	  kState,
	  kError,
	  kResult,
	  kEvents,
	  kAborted
	} = requireSymbols$2();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$6();

	class FileReader extends EventTarget {
	  constructor () {
	    super();

	    this[kState] = 'empty';
	    this[kResult] = null;
	    this[kError] = null;
	    this[kEvents] = {
	      loadend: null,
	      error: null,
	      abort: null,
	      load: null,
	      progress: null,
	      loadstart: null
	    };
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
	   * @param {import('buffer').Blob} blob
	   */
	  readAsArrayBuffer (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsArrayBuffer' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsArrayBuffer(blob) method, when invoked,
	    // must initiate a read operation for blob with ArrayBuffer.
	    readOperation(this, blob, 'ArrayBuffer');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#readAsBinaryString
	   * @param {import('buffer').Blob} blob
	   */
	  readAsBinaryString (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsBinaryString' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsBinaryString(blob) method, when invoked,
	    // must initiate a read operation for blob with BinaryString.
	    readOperation(this, blob, 'BinaryString');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#readAsDataText
	   * @param {import('buffer').Blob} blob
	   * @param {string?} encoding
	   */
	  readAsText (blob, encoding = undefined) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsText' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    if (encoding !== undefined) {
	      encoding = webidl.converters.DOMString(encoding);
	    }

	    // The readAsText(blob, encoding) method, when invoked,
	    // must initiate a read operation for blob with Text and encoding.
	    readOperation(this, blob, 'Text', encoding);
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
	   * @param {import('buffer').Blob} blob
	   */
	  readAsDataURL (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsDataURL' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsDataURL(blob) method, when invoked, must
	    // initiate a read operation for blob with DataURL.
	    readOperation(this, blob, 'DataURL');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-abort
	   */
	  abort () {
	    // 1. If this's state is "empty" or if this's state is
	    //    "done" set this's result to null and terminate
	    //    this algorithm.
	    if (this[kState] === 'empty' || this[kState] === 'done') {
	      this[kResult] = null;
	      return
	    }

	    // 2. If this's state is "loading" set this's state to
	    //    "done" and set this's result to null.
	    if (this[kState] === 'loading') {
	      this[kState] = 'done';
	      this[kResult] = null;
	    }

	    // 3. If there are any tasks from this on the file reading
	    //    task source in an affiliated task queue, then remove
	    //    those tasks from that task queue.
	    this[kAborted] = true;

	    // 4. Terminate the algorithm for the read method being processed.
	    // TODO

	    // 5. Fire a progress event called abort at this.
	    fireAProgressEvent('abort', this);

	    // 6. If this's state is not "loading", fire a progress
	    //    event called loadend at this.
	    if (this[kState] !== 'loading') {
	      fireAProgressEvent('loadend', this);
	    }
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
	   */
	  get readyState () {
	    webidl.brandCheck(this, FileReader);

	    switch (this[kState]) {
	      case 'empty': return this.EMPTY
	      case 'loading': return this.LOADING
	      case 'done': return this.DONE
	    }
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-result
	   */
	  get result () {
	    webidl.brandCheck(this, FileReader);

	    // The result attributes getter, when invoked, must return
	    // this's result.
	    return this[kResult]
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-error
	   */
	  get error () {
	    webidl.brandCheck(this, FileReader);

	    // The error attributes getter, when invoked, must return
	    // this's error.
	    return this[kError]
	  }

	  get onloadend () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].loadend
	  }

	  set onloadend (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].loadend) {
	      this.removeEventListener('loadend', this[kEvents].loadend);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].loadend = fn;
	      this.addEventListener('loadend', fn);
	    } else {
	      this[kEvents].loadend = null;
	    }
	  }

	  get onerror () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].error
	  }

	  set onerror (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].error) {
	      this.removeEventListener('error', this[kEvents].error);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].error = fn;
	      this.addEventListener('error', fn);
	    } else {
	      this[kEvents].error = null;
	    }
	  }

	  get onloadstart () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].loadstart
	  }

	  set onloadstart (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].loadstart) {
	      this.removeEventListener('loadstart', this[kEvents].loadstart);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].loadstart = fn;
	      this.addEventListener('loadstart', fn);
	    } else {
	      this[kEvents].loadstart = null;
	    }
	  }

	  get onprogress () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].progress
	  }

	  set onprogress (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].progress) {
	      this.removeEventListener('progress', this[kEvents].progress);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].progress = fn;
	      this.addEventListener('progress', fn);
	    } else {
	      this[kEvents].progress = null;
	    }
	  }

	  get onload () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].load
	  }

	  set onload (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].load) {
	      this.removeEventListener('load', this[kEvents].load);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].load = fn;
	      this.addEventListener('load', fn);
	    } else {
	      this[kEvents].load = null;
	    }
	  }

	  get onabort () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].abort
	  }

	  set onabort (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].abort) {
	      this.removeEventListener('abort', this[kEvents].abort);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].abort = fn;
	      this.addEventListener('abort', fn);
	    } else {
	      this[kEvents].abort = null;
	    }
	  }
	}

	// https://w3c.github.io/FileAPI/#dom-filereader-empty
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	// https://w3c.github.io/FileAPI/#dom-filereader-loading
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	// https://w3c.github.io/FileAPI/#dom-filereader-done
	FileReader.DONE = FileReader.prototype.DONE = 2;

	Object.defineProperties(FileReader.prototype, {
	  EMPTY: staticPropertyDescriptors,
	  LOADING: staticPropertyDescriptors,
	  DONE: staticPropertyDescriptors,
	  readAsArrayBuffer: kEnumerableProperty,
	  readAsBinaryString: kEnumerableProperty,
	  readAsText: kEnumerableProperty,
	  readAsDataURL: kEnumerableProperty,
	  abort: kEnumerableProperty,
	  readyState: kEnumerableProperty,
	  result: kEnumerableProperty,
	  error: kEnumerableProperty,
	  onloadstart: kEnumerableProperty,
	  onprogress: kEnumerableProperty,
	  onload: kEnumerableProperty,
	  onabort: kEnumerableProperty,
	  onerror: kEnumerableProperty,
	  onloadend: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'FileReader',
	    writable: false,
	    enumerable: false,
	    configurable: true
	  }
	});

	Object.defineProperties(FileReader, {
	  EMPTY: staticPropertyDescriptors,
	  LOADING: staticPropertyDescriptors,
	  DONE: staticPropertyDescriptors
	});

	filereader = {
	  FileReader
	};
	return filereader;
}

var symbols$1;
var hasRequiredSymbols$1;

function requireSymbols$1 () {
	if (hasRequiredSymbols$1) return symbols$1;
	hasRequiredSymbols$1 = 1;

	symbols$1 = {
	  kConstruct: requireSymbols$4().kConstruct
	};
	return symbols$1;
}

var util$2;
var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;

	const assert = require$$0$2;
	const { URLSerializer } = requireDataURL();
	const { isValidHeaderName } = requireUtil$5();

	/**
	 * @see https://url.spec.whatwg.org/#concept-url-equals
	 * @param {URL} A
	 * @param {URL} B
	 * @param {boolean | undefined} excludeFragment
	 * @returns {boolean}
	 */
	function urlEquals (A, B, excludeFragment = false) {
	  const serializedA = URLSerializer(A, excludeFragment);

	  const serializedB = URLSerializer(B, excludeFragment);

	  return serializedA === serializedB
	}

	/**
	 * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	 * @param {string} header
	 */
	function fieldValues (header) {
	  assert(header !== null);

	  const values = [];

	  for (let value of header.split(',')) {
	    value = value.trim();

	    if (!value.length) {
	      continue
	    } else if (!isValidHeaderName(value)) {
	      continue
	    }

	    values.push(value);
	  }

	  return values
	}

	util$2 = {
	  urlEquals,
	  fieldValues
	};
	return util$2;
}

var cache;
var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache;
	hasRequiredCache = 1;

	const { kConstruct } = requireSymbols$1();
	const { urlEquals, fieldValues: getFieldValues } = requireUtil$2();
	const { kEnumerableProperty, isDisturbed } = requireUtil$6();
	const { kHeadersList } = requireSymbols$4();
	const { webidl } = requireWebidl();
	const { Response, cloneResponse } = requireResponse();
	const { Request } = requireRequest();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const { fetching } = requireFetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$5();
	const assert = require$$0$2;
	const { getGlobalDispatcher } = requireGlobal();

	/**
	 * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	 * @typedef {Object} CacheBatchOperation
	 * @property {'delete' | 'put'} type
	 * @property {any} request
	 * @property {any} response
	 * @property {import('../../types/cache').CacheQueryOptions} options
	 */

	/**
	 * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	 * @typedef {[any, any][]} requestResponseList
	 */

	class Cache {
	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
	   * @type {requestResponseList}
	   */
	  #relevantRequestResponseList

	  constructor () {
	    if (arguments[0] !== kConstruct) {
	      webidl.illegalConstructor();
	    }

	    this.#relevantRequestResponseList = arguments[1];
	  }

	  async match (request, options = {}) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    const p = await this.matchAll(request, options);

	    if (p.length === 0) {
	      return
	    }

	    return p[0]
	  }

	  async matchAll (request = undefined, options = {}) {
	    webidl.brandCheck(this, Cache);

	    if (request !== undefined) request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    // 1.
	    let r = null;

	    // 2.
	    if (request !== undefined) {
	      if (request instanceof Request) {
	        // 2.1.1
	        r = request[kState];

	        // 2.1.2
	        if (r.method !== 'GET' && !options.ignoreMethod) {
	          return []
	        }
	      } else if (typeof request === 'string') {
	        // 2.2.1
	        r = new Request(request)[kState];
	      }
	    }

	    // 5.
	    // 5.1
	    const responses = [];

	    // 5.2
	    if (request === undefined) {
	      // 5.2.1
	      for (const requestResponse of this.#relevantRequestResponseList) {
	        responses.push(requestResponse[1]);
	      }
	    } else { // 5.3
	      // 5.3.1
	      const requestResponses = this.#queryCache(r, options);

	      // 5.3.2
	      for (const requestResponse of requestResponses) {
	        responses.push(requestResponse[1]);
	      }
	    }

	    // 5.4
	    // We don't implement CORs so we don't need to loop over the responses, yay!

	    // 5.5.1
	    const responseList = [];

	    // 5.5.2
	    for (const response of responses) {
	      // 5.5.2.1
	      const responseObject = new Response(response.body?.source ?? null);
	      const body = responseObject[kState].body;
	      responseObject[kState] = response;
	      responseObject[kState].body = body;
	      responseObject[kHeaders][kHeadersList] = response.headersList;
	      responseObject[kHeaders][kGuard] = 'immutable';

	      responseList.push(responseObject);
	    }

	    // 6.
	    return Object.freeze(responseList)
	  }

	  async add (request) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' });

	    request = webidl.converters.RequestInfo(request);

	    // 1.
	    const requests = [request];

	    // 2.
	    const responseArrayPromise = this.addAll(requests);

	    // 3.
	    return await responseArrayPromise
	  }

	  async addAll (requests) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' });

	    requests = webidl.converters['sequence<RequestInfo>'](requests);

	    // 1.
	    const responsePromises = [];

	    // 2.
	    const requestList = [];

	    // 3.
	    for (const request of requests) {
	      if (typeof request === 'string') {
	        continue
	      }

	      // 3.1
	      const r = request[kState];

	      // 3.2
	      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {
	        throw webidl.errors.exception({
	          header: 'Cache.addAll',
	          message: 'Expected http/s scheme when method is not GET.'
	        })
	      }
	    }

	    // 4.
	    /** @type {ReturnType<typeof fetching>[]} */
	    const fetchControllers = [];

	    // 5.
	    for (const request of requests) {
	      // 5.1
	      const r = new Request(request)[kState];

	      // 5.2
	      if (!urlIsHttpHttpsScheme(r.url)) {
	        throw webidl.errors.exception({
	          header: 'Cache.addAll',
	          message: 'Expected http/s scheme.'
	        })
	      }

	      // 5.4
	      r.initiator = 'fetch';
	      r.destination = 'subresource';

	      // 5.5
	      requestList.push(r);

	      // 5.6
	      const responsePromise = createDeferredPromise();

	      // 5.7
	      fetchControllers.push(fetching({
	        request: r,
	        dispatcher: getGlobalDispatcher(),
	        processResponse (response) {
	          // 1.
	          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {
	            responsePromise.reject(webidl.errors.exception({
	              header: 'Cache.addAll',
	              message: 'Received an invalid status code or the request failed.'
	            }));
	          } else if (response.headersList.contains('vary')) { // 2.
	            // 2.1
	            const fieldValues = getFieldValues(response.headersList.get('vary'));

	            // 2.2
	            for (const fieldValue of fieldValues) {
	              // 2.2.1
	              if (fieldValue === '*') {
	                responsePromise.reject(webidl.errors.exception({
	                  header: 'Cache.addAll',
	                  message: 'invalid vary field value'
	                }));

	                for (const controller of fetchControllers) {
	                  controller.abort();
	                }

	                return
	              }
	            }
	          }
	        },
	        processResponseEndOfBody (response) {
	          // 1.
	          if (response.aborted) {
	            responsePromise.reject(new DOMException('aborted', 'AbortError'));
	            return
	          }

	          // 2.
	          responsePromise.resolve(response);
	        }
	      }));

	      // 5.8
	      responsePromises.push(responsePromise.promise);
	    }

	    // 6.
	    const p = Promise.all(responsePromises);

	    // 7.
	    const responses = await p;

	    // 7.1
	    const operations = [];

	    // 7.2
	    let index = 0;

	    // 7.3
	    for (const response of responses) {
	      // 7.3.1
	      /** @type {CacheBatchOperation} */
	      const operation = {
	        type: 'put', // 7.3.2
	        request: requestList[index], // 7.3.3
	        response // 7.3.4
	      };

	      operations.push(operation); // 7.3.5

	      index++; // 7.3.6
	    }

	    // 7.5
	    const cacheJobPromise = createDeferredPromise();

	    // 7.6.1
	    let errorData = null;

	    // 7.6.2
	    try {
	      this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    // 7.6.3
	    queueMicrotask(() => {
	      // 7.6.3.1
	      if (errorData === null) {
	        cacheJobPromise.resolve(undefined);
	      } else {
	        // 7.6.3.2
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    // 7.7
	    return cacheJobPromise.promise
	  }

	  async put (request, response) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' });

	    request = webidl.converters.RequestInfo(request);
	    response = webidl.converters.Response(response);

	    // 1.
	    let innerRequest = null;

	    // 2.
	    if (request instanceof Request) {
	      innerRequest = request[kState];
	    } else { // 3.
	      innerRequest = new Request(request)[kState];
	    }

	    // 4.
	    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Expected an http/s scheme when method is not GET'
	      })
	    }

	    // 5.
	    const innerResponse = response[kState];

	    // 6.
	    if (innerResponse.status === 206) {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Got 206 status'
	      })
	    }

	    // 7.
	    if (innerResponse.headersList.contains('vary')) {
	      // 7.1.
	      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));

	      // 7.2.
	      for (const fieldValue of fieldValues) {
	        // 7.2.1
	        if (fieldValue === '*') {
	          throw webidl.errors.exception({
	            header: 'Cache.put',
	            message: 'Got * vary field value'
	          })
	        }
	      }
	    }

	    // 8.
	    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Response body is locked or disturbed'
	      })
	    }

	    // 9.
	    const clonedResponse = cloneResponse(innerResponse);

	    // 10.
	    const bodyReadPromise = createDeferredPromise();

	    // 11.
	    if (innerResponse.body != null) {
	      // 11.1
	      const stream = innerResponse.body.stream;

	      // 11.2
	      const reader = stream.getReader();

	      // 11.3
	      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
	    } else {
	      bodyReadPromise.resolve(undefined);
	    }

	    // 12.
	    /** @type {CacheBatchOperation[]} */
	    const operations = [];

	    // 13.
	    /** @type {CacheBatchOperation} */
	    const operation = {
	      type: 'put', // 14.
	      request: innerRequest, // 15.
	      response: clonedResponse // 16.
	    };

	    // 17.
	    operations.push(operation);

	    // 19.
	    const bytes = await bodyReadPromise.promise;

	    if (clonedResponse.body != null) {
	      clonedResponse.body.source = bytes;
	    }

	    // 19.1
	    const cacheJobPromise = createDeferredPromise();

	    // 19.2.1
	    let errorData = null;

	    // 19.2.2
	    try {
	      this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    // 19.2.3
	    queueMicrotask(() => {
	      // 19.2.3.1
	      if (errorData === null) {
	        cacheJobPromise.resolve();
	      } else { // 19.2.3.2
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    return cacheJobPromise.promise
	  }

	  async delete (request, options = {}) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    /**
	     * @type {Request}
	     */
	    let r = null;

	    if (request instanceof Request) {
	      r = request[kState];

	      if (r.method !== 'GET' && !options.ignoreMethod) {
	        return false
	      }
	    } else {
	      assert(typeof request === 'string');

	      r = new Request(request)[kState];
	    }

	    /** @type {CacheBatchOperation[]} */
	    const operations = [];

	    /** @type {CacheBatchOperation} */
	    const operation = {
	      type: 'delete',
	      request: r,
	      options
	    };

	    operations.push(operation);

	    const cacheJobPromise = createDeferredPromise();

	    let errorData = null;
	    let requestResponses;

	    try {
	      requestResponses = this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    queueMicrotask(() => {
	      if (errorData === null) {
	        cacheJobPromise.resolve(!!requestResponses?.length);
	      } else {
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    return cacheJobPromise.promise
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
	   * @param {any} request
	   * @param {import('../../types/cache').CacheQueryOptions} options
	   * @returns {readonly Request[]}
	   */
	  async keys (request = undefined, options = {}) {
	    webidl.brandCheck(this, Cache);

	    if (request !== undefined) request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    // 1.
	    let r = null;

	    // 2.
	    if (request !== undefined) {
	      // 2.1
	      if (request instanceof Request) {
	        // 2.1.1
	        r = request[kState];

	        // 2.1.2
	        if (r.method !== 'GET' && !options.ignoreMethod) {
	          return []
	        }
	      } else if (typeof request === 'string') { // 2.2
	        r = new Request(request)[kState];
	      }
	    }

	    // 4.
	    const promise = createDeferredPromise();

	    // 5.
	    // 5.1
	    const requests = [];

	    // 5.2
	    if (request === undefined) {
	      // 5.2.1
	      for (const requestResponse of this.#relevantRequestResponseList) {
	        // 5.2.1.1
	        requests.push(requestResponse[0]);
	      }
	    } else { // 5.3
	      // 5.3.1
	      const requestResponses = this.#queryCache(r, options);

	      // 5.3.2
	      for (const requestResponse of requestResponses) {
	        // 5.3.2.1
	        requests.push(requestResponse[0]);
	      }
	    }

	    // 5.4
	    queueMicrotask(() => {
	      // 5.4.1
	      const requestList = [];

	      // 5.4.2
	      for (const request of requests) {
	        const requestObject = new Request('https://a');
	        requestObject[kState] = request;
	        requestObject[kHeaders][kHeadersList] = request.headersList;
	        requestObject[kHeaders][kGuard] = 'immutable';
	        requestObject[kRealm] = request.client;

	        // 5.4.2.1
	        requestList.push(requestObject);
	      }

	      // 5.4.3
	      promise.resolve(Object.freeze(requestList));
	    });

	    return promise.promise
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
	   * @param {CacheBatchOperation[]} operations
	   * @returns {requestResponseList}
	   */
	  #batchCacheOperations (operations) {
	    // 1.
	    const cache = this.#relevantRequestResponseList;

	    // 2.
	    const backupCache = [...cache];

	    // 3.
	    const addedItems = [];

	    // 4.1
	    const resultList = [];

	    try {
	      // 4.2
	      for (const operation of operations) {
	        // 4.2.1
	        if (operation.type !== 'delete' && operation.type !== 'put') {
	          throw webidl.errors.exception({
	            header: 'Cache.#batchCacheOperations',
	            message: 'operation type does not match "delete" or "put"'
	          })
	        }

	        // 4.2.2
	        if (operation.type === 'delete' && operation.response != null) {
	          throw webidl.errors.exception({
	            header: 'Cache.#batchCacheOperations',
	            message: 'delete operation should not have an associated response'
	          })
	        }

	        // 4.2.3
	        if (this.#queryCache(operation.request, operation.options, addedItems).length) {
	          throw new DOMException('???', 'InvalidStateError')
	        }

	        // 4.2.4
	        let requestResponses;

	        // 4.2.5
	        if (operation.type === 'delete') {
	          // 4.2.5.1
	          requestResponses = this.#queryCache(operation.request, operation.options);

	          // TODO: the spec is wrong, this is needed to pass WPTs
	          if (requestResponses.length === 0) {
	            return []
	          }

	          // 4.2.5.2
	          for (const requestResponse of requestResponses) {
	            const idx = cache.indexOf(requestResponse);
	            assert(idx !== -1);

	            // 4.2.5.2.1
	            cache.splice(idx, 1);
	          }
	        } else if (operation.type === 'put') { // 4.2.6
	          // 4.2.6.1
	          if (operation.response == null) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'put operation should have an associated response'
	            })
	          }

	          // 4.2.6.2
	          const r = operation.request;

	          // 4.2.6.3
	          if (!urlIsHttpHttpsScheme(r.url)) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'expected http or https scheme'
	            })
	          }

	          // 4.2.6.4
	          if (r.method !== 'GET') {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'not get method'
	            })
	          }

	          // 4.2.6.5
	          if (operation.options != null) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'options must not be defined'
	            })
	          }

	          // 4.2.6.6
	          requestResponses = this.#queryCache(operation.request);

	          // 4.2.6.7
	          for (const requestResponse of requestResponses) {
	            const idx = cache.indexOf(requestResponse);
	            assert(idx !== -1);

	            // 4.2.6.7.1
	            cache.splice(idx, 1);
	          }

	          // 4.2.6.8
	          cache.push([operation.request, operation.response]);

	          // 4.2.6.10
	          addedItems.push([operation.request, operation.response]);
	        }

	        // 4.2.7
	        resultList.push([operation.request, operation.response]);
	      }

	      // 4.3
	      return resultList
	    } catch (e) { // 5.
	      // 5.1
	      this.#relevantRequestResponseList.length = 0;

	      // 5.2
	      this.#relevantRequestResponseList = backupCache;

	      // 5.3
	      throw e
	    }
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#query-cache
	   * @param {any} requestQuery
	   * @param {import('../../types/cache').CacheQueryOptions} options
	   * @param {requestResponseList} targetStorage
	   * @returns {requestResponseList}
	   */
	  #queryCache (requestQuery, options, targetStorage) {
	    /** @type {requestResponseList} */
	    const resultList = [];

	    const storage = targetStorage ?? this.#relevantRequestResponseList;

	    for (const requestResponse of storage) {
	      const [cachedRequest, cachedResponse] = requestResponse;
	      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
	        resultList.push(requestResponse);
	      }
	    }

	    return resultList
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
	   * @param {any} requestQuery
	   * @param {any} request
	   * @param {any | null} response
	   * @param {import('../../types/cache').CacheQueryOptions | undefined} options
	   * @returns {boolean}
	   */
	  #requestMatchesCachedItem (requestQuery, request, response = null, options) {
	    // if (options?.ignoreMethod === false && request.method === 'GET') {
	    //   return false
	    // }

	    const queryURL = new URL(requestQuery.url);

	    const cachedURL = new URL(request.url);

	    if (options?.ignoreSearch) {
	      cachedURL.search = '';

	      queryURL.search = '';
	    }

	    if (!urlEquals(queryURL, cachedURL, true)) {
	      return false
	    }

	    if (
	      response == null ||
	      options?.ignoreVary ||
	      !response.headersList.contains('vary')
	    ) {
	      return true
	    }

	    const fieldValues = getFieldValues(response.headersList.get('vary'));

	    for (const fieldValue of fieldValues) {
	      if (fieldValue === '*') {
	        return false
	      }

	      const requestValue = request.headersList.get(fieldValue);
	      const queryValue = requestQuery.headersList.get(fieldValue);

	      // If one has the header and the other doesn't, or one has
	      // a different value than the other, return false
	      if (requestValue !== queryValue) {
	        return false
	      }
	    }

	    return true
	  }
	}

	Object.defineProperties(Cache.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'Cache',
	    configurable: true
	  },
	  match: kEnumerableProperty,
	  matchAll: kEnumerableProperty,
	  add: kEnumerableProperty,
	  addAll: kEnumerableProperty,
	  put: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  keys: kEnumerableProperty
	});

	const cacheQueryOptionConverters = [
	  {
	    key: 'ignoreSearch',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'ignoreMethod',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'ignoreVary',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	];

	webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);

	webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
	  ...cacheQueryOptionConverters,
	  {
	    key: 'cacheName',
	    converter: webidl.converters.DOMString
	  }
	]);

	webidl.converters.Response = webidl.interfaceConverter(Response);

	webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(
	  webidl.converters.RequestInfo
	);

	cache = {
	  Cache
	};
	return cache;
}

var cachestorage;
var hasRequiredCachestorage;

function requireCachestorage () {
	if (hasRequiredCachestorage) return cachestorage;
	hasRequiredCachestorage = 1;

	const { kConstruct } = requireSymbols$1();
	const { Cache } = requireCache();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$6();

	class CacheStorage {
	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
	   * @type {Map<string, import('./cache').requestResponseList}
	   */
	  #caches = new Map()

	  constructor () {
	    if (arguments[0] !== kConstruct) {
	      webidl.illegalConstructor();
	    }
	  }

	  async match (request, options = {}) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.match' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.MultiCacheQueryOptions(options);

	    // 1.
	    if (options.cacheName != null) {
	      // 1.1.1.1
	      if (this.#caches.has(options.cacheName)) {
	        // 1.1.1.1.1
	        const cacheList = this.#caches.get(options.cacheName);
	        const cache = new Cache(kConstruct, cacheList);

	        return await cache.match(request, options)
	      }
	    } else { // 2.
	      // 2.2
	      for (const cacheList of this.#caches.values()) {
	        const cache = new Cache(kConstruct, cacheList);

	        // 2.2.1.2
	        const response = await cache.match(request, options);

	        if (response !== undefined) {
	          return response
	        }
	      }
	    }
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
	   * @param {string} cacheName
	   * @returns {Promise<boolean>}
	   */
	  async has (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.has' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    // 2.1.1
	    // 2.2
	    return this.#caches.has(cacheName)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
	   * @param {string} cacheName
	   * @returns {Promise<Cache>}
	   */
	  async open (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.open' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    // 2.1
	    if (this.#caches.has(cacheName)) {
	      // await caches.open('v1') !== await caches.open('v1')

	      // 2.1.1
	      const cache = this.#caches.get(cacheName);

	      // 2.1.1.1
	      return new Cache(kConstruct, cache)
	    }

	    // 2.2
	    const cache = [];

	    // 2.3
	    this.#caches.set(cacheName, cache);

	    // 2.4
	    return new Cache(kConstruct, cache)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
	   * @param {string} cacheName
	   * @returns {Promise<boolean>}
	   */
	  async delete (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.delete' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    return this.#caches.delete(cacheName)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
	   * @returns {string[]}
	   */
	  async keys () {
	    webidl.brandCheck(this, CacheStorage);

	    // 2.1
	    const keys = this.#caches.keys();

	    // 2.2
	    return [...keys]
	  }
	}

	Object.defineProperties(CacheStorage.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'CacheStorage',
	    configurable: true
	  },
	  match: kEnumerableProperty,
	  has: kEnumerableProperty,
	  open: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  keys: kEnumerableProperty
	});

	cachestorage = {
	  CacheStorage
	};
	return cachestorage;
}

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;

	// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size
	const maxAttributeValueSize = 1024;

	// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size
	const maxNameValuePairSize = 4096;

	constants$1 = {
	  maxAttributeValueSize,
	  maxNameValuePairSize
	};
	return constants$1;
}

var util$1;
var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;

	/**
	 * @param {string} value
	 * @returns {boolean}
	 */
	function isCTLExcludingHtab (value) {
	  if (value.length === 0) {
	    return false
	  }

	  for (const char of value) {
	    const code = char.charCodeAt(0);

	    if (
	      (code >= 0x00 || code <= 0x08) ||
	      (code >= 0x0A || code <= 0x1F) ||
	      code === 0x7F
	    ) {
	      return false
	    }
	  }
	}

	/**
	 CHAR           = <any US-ASCII character (octets 0 - 127)>
	 token          = 1*<any CHAR except CTLs or separators>
	 separators     = "(" | ")" | "<" | ">" | "@"
	                | "," | ";" | ":" | "\" | <">
	                | "/" | "[" | "]" | "?" | "="
	                | "{" | "}" | SP | HT
	 * @param {string} name
	 */
	function validateCookieName (name) {
	  for (const char of name) {
	    const code = char.charCodeAt(0);

	    if (
	      (code <= 0x20 || code > 0x7F) ||
	      char === '(' ||
	      char === ')' ||
	      char === '>' ||
	      char === '<' ||
	      char === '@' ||
	      char === ',' ||
	      char === ';' ||
	      char === ':' ||
	      char === '\\' ||
	      char === '"' ||
	      char === '/' ||
	      char === '[' ||
	      char === ']' ||
	      char === '?' ||
	      char === '=' ||
	      char === '{' ||
	      char === '}'
	    ) {
	      throw new Error('Invalid cookie name')
	    }
	  }
	}

	/**
	 cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	                       ; US-ASCII characters excluding CTLs,
	                       ; whitespace DQUOTE, comma, semicolon,
	                       ; and backslash
	 * @param {string} value
	 */
	function validateCookieValue (value) {
	  for (const char of value) {
	    const code = char.charCodeAt(0);

	    if (
	      code < 0x21 || // exclude CTLs (0-31)
	      code === 0x22 ||
	      code === 0x2C ||
	      code === 0x3B ||
	      code === 0x5C ||
	      code > 0x7E // non-ascii
	    ) {
	      throw new Error('Invalid header value')
	    }
	  }
	}

	/**
	 * path-value        = <any CHAR except CTLs or ";">
	 * @param {string} path
	 */
	function validateCookiePath (path) {
	  for (const char of path) {
	    const code = char.charCodeAt(0);

	    if (code < 0x21 || char === ';') {
	      throw new Error('Invalid cookie path')
	    }
	  }
	}

	/**
	 * I have no idea why these values aren't allowed to be honest,
	 * but Deno tests these. - Khafra
	 * @param {string} domain
	 */
	function validateCookieDomain (domain) {
	  if (
	    domain.startsWith('-') ||
	    domain.endsWith('.') ||
	    domain.endsWith('-')
	  ) {
	    throw new Error('Invalid cookie domain')
	  }
	}

	/**
	 * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	 * @param {number|Date} date
	  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	  ; fixed length/zone/capitalization subset of the format
	  ; see Section 3.3 of [RFC5322]

	  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	              / %x54.75.65 ; "Tue", case-sensitive
	              / %x57.65.64 ; "Wed", case-sensitive
	              / %x54.68.75 ; "Thu", case-sensitive
	              / %x46.72.69 ; "Fri", case-sensitive
	              / %x53.61.74 ; "Sat", case-sensitive
	              / %x53.75.6E ; "Sun", case-sensitive
	  date1        = day SP month SP year
	                  ; e.g., 02 Jun 1982

	  day          = 2DIGIT
	  month        = %x4A.61.6E ; "Jan", case-sensitive
	              / %x46.65.62 ; "Feb", case-sensitive
	              / %x4D.61.72 ; "Mar", case-sensitive
	              / %x41.70.72 ; "Apr", case-sensitive
	              / %x4D.61.79 ; "May", case-sensitive
	              / %x4A.75.6E ; "Jun", case-sensitive
	              / %x4A.75.6C ; "Jul", case-sensitive
	              / %x41.75.67 ; "Aug", case-sensitive
	              / %x53.65.70 ; "Sep", case-sensitive
	              / %x4F.63.74 ; "Oct", case-sensitive
	              / %x4E.6F.76 ; "Nov", case-sensitive
	              / %x44.65.63 ; "Dec", case-sensitive
	  year         = 4DIGIT

	  GMT          = %x47.4D.54 ; "GMT", case-sensitive

	  time-of-day  = hour ":" minute ":" second
	              ; 00:00:00 - 23:59:60 (leap second)

	  hour         = 2DIGIT
	  minute       = 2DIGIT
	  second       = 2DIGIT
	 */
	function toIMFDate (date) {
	  if (typeof date === 'number') {
	    date = new Date(date);
	  }

	  const days = [
	    'Sun', 'Mon', 'Tue', 'Wed',
	    'Thu', 'Fri', 'Sat'
	  ];

	  const months = [
	    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
	  ];

	  const dayName = days[date.getUTCDay()];
	  const day = date.getUTCDate().toString().padStart(2, '0');
	  const month = months[date.getUTCMonth()];
	  const year = date.getUTCFullYear();
	  const hour = date.getUTCHours().toString().padStart(2, '0');
	  const minute = date.getUTCMinutes().toString().padStart(2, '0');
	  const second = date.getUTCSeconds().toString().padStart(2, '0');

	  return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`
	}

	/**
	 max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	                       ; In practice, both expires-av and max-age-av
	                       ; are limited to dates representable by the
	                       ; user agent.
	 * @param {number} maxAge
	 */
	function validateCookieMaxAge (maxAge) {
	  if (maxAge < 0) {
	    throw new Error('Invalid cookie max-age')
	  }
	}

	/**
	 * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	 * @param {import('./index').Cookie} cookie
	 */
	function stringify (cookie) {
	  if (cookie.name.length === 0) {
	    return null
	  }

	  validateCookieName(cookie.name);
	  validateCookieValue(cookie.value);

	  const out = [`${cookie.name}=${cookie.value}`];

	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1
	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2
	  if (cookie.name.startsWith('__Secure-')) {
	    cookie.secure = true;
	  }

	  if (cookie.name.startsWith('__Host-')) {
	    cookie.secure = true;
	    cookie.domain = null;
	    cookie.path = '/';
	  }

	  if (cookie.secure) {
	    out.push('Secure');
	  }

	  if (cookie.httpOnly) {
	    out.push('HttpOnly');
	  }

	  if (typeof cookie.maxAge === 'number') {
	    validateCookieMaxAge(cookie.maxAge);
	    out.push(`Max-Age=${cookie.maxAge}`);
	  }

	  if (cookie.domain) {
	    validateCookieDomain(cookie.domain);
	    out.push(`Domain=${cookie.domain}`);
	  }

	  if (cookie.path) {
	    validateCookiePath(cookie.path);
	    out.push(`Path=${cookie.path}`);
	  }

	  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {
	    out.push(`Expires=${toIMFDate(cookie.expires)}`);
	  }

	  if (cookie.sameSite) {
	    out.push(`SameSite=${cookie.sameSite}`);
	  }

	  for (const part of cookie.unparsed) {
	    if (!part.includes('=')) {
	      throw new Error('Invalid unparsed')
	    }

	    const [key, ...value] = part.split('=');

	    out.push(`${key.trim()}=${value.join('=')}`);
	  }

	  return out.join('; ')
	}

	util$1 = {
	  isCTLExcludingHtab,
	  validateCookieName,
	  validateCookiePath,
	  validateCookieValue,
	  toIMFDate,
	  stringify
	};
	return util$1;
}

var parse$1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse$1;
	hasRequiredParse = 1;

	const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$1();
	const { isCTLExcludingHtab } = requireUtil$1();
	const { collectASequenceOfCodePointsFast } = requireDataURL();
	const assert = require$$0$2;

	/**
	 * @description Parses the field-value attributes of a set-cookie header string.
	 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	 * @param {string} header
	 * @returns if the header is invalid, null will be returned
	 */
	function parseSetCookie (header) {
	  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F
	  //    character (CTL characters excluding HTAB): Abort these steps and
	  //    ignore the set-cookie-string entirely.
	  if (isCTLExcludingHtab(header)) {
	    return null
	  }

	  let nameValuePair = '';
	  let unparsedAttributes = '';
	  let name = '';
	  let value = '';

	  // 2. If the set-cookie-string contains a %x3B (";") character:
	  if (header.includes(';')) {
	    // 1. The name-value-pair string consists of the characters up to,
	    //    but not including, the first %x3B (";"), and the unparsed-
	    //    attributes consist of the remainder of the set-cookie-string
	    //    (including the %x3B (";") in question).
	    const position = { position: 0 };

	    nameValuePair = collectASequenceOfCodePointsFast(';', header, position);
	    unparsedAttributes = header.slice(position.position);
	  } else {
	    // Otherwise:

	    // 1. The name-value-pair string consists of all the characters
	    //    contained in the set-cookie-string, and the unparsed-
	    //    attributes is the empty string.
	    nameValuePair = header;
	  }

	  // 3. If the name-value-pair string lacks a %x3D ("=") character, then
	  //    the name string is empty, and the value string is the value of
	  //    name-value-pair.
	  if (!nameValuePair.includes('=')) {
	    value = nameValuePair;
	  } else {
	    //    Otherwise, the name string consists of the characters up to, but
	    //    not including, the first %x3D ("=") character, and the (possibly
	    //    empty) value string consists of the characters after the first
	    //    %x3D ("=") character.
	    const position = { position: 0 };
	    name = collectASequenceOfCodePointsFast(
	      '=',
	      nameValuePair,
	      position
	    );
	    value = nameValuePair.slice(position.position + 1);
	  }

	  // 4. Remove any leading or trailing WSP characters from the name
	  //    string and the value string.
	  name = name.trim();
	  value = value.trim();

	  // 5. If the sum of the lengths of the name string and the value string
	  //    is more than 4096 octets, abort these steps and ignore the set-
	  //    cookie-string entirely.
	  if (name.length + value.length > maxNameValuePairSize) {
	    return null
	  }

	  // 6. The cookie-name is the name string, and the cookie-value is the
	  //    value string.
	  return {
	    name, value, ...parseUnparsedAttributes(unparsedAttributes)
	  }
	}

	/**
	 * Parses the remaining attributes of a set-cookie header
	 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	 * @param {string} unparsedAttributes
	 * @param {[Object.<string, unknown>]={}} cookieAttributeList
	 */
	function parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {
	  // 1. If the unparsed-attributes string is empty, skip the rest of
	  //    these steps.
	  if (unparsedAttributes.length === 0) {
	    return cookieAttributeList
	  }

	  // 2. Discard the first character of the unparsed-attributes (which
	  //    will be a %x3B (";") character).
	  assert(unparsedAttributes[0] === ';');
	  unparsedAttributes = unparsedAttributes.slice(1);

	  let cookieAv = '';

	  // 3. If the remaining unparsed-attributes contains a %x3B (";")
	  //    character:
	  if (unparsedAttributes.includes(';')) {
	    // 1. Consume the characters of the unparsed-attributes up to, but
	    //    not including, the first %x3B (";") character.
	    cookieAv = collectASequenceOfCodePointsFast(
	      ';',
	      unparsedAttributes,
	      { position: 0 }
	    );
	    unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
	  } else {
	    // Otherwise:

	    // 1. Consume the remainder of the unparsed-attributes.
	    cookieAv = unparsedAttributes;
	    unparsedAttributes = '';
	  }

	  // Let the cookie-av string be the characters consumed in this step.

	  let attributeName = '';
	  let attributeValue = '';

	  // 4. If the cookie-av string contains a %x3D ("=") character:
	  if (cookieAv.includes('=')) {
	    // 1. The (possibly empty) attribute-name string consists of the
	    //    characters up to, but not including, the first %x3D ("=")
	    //    character, and the (possibly empty) attribute-value string
	    //    consists of the characters after the first %x3D ("=")
	    //    character.
	    const position = { position: 0 };

	    attributeName = collectASequenceOfCodePointsFast(
	      '=',
	      cookieAv,
	      position
	    );
	    attributeValue = cookieAv.slice(position.position + 1);
	  } else {
	    // Otherwise:

	    // 1. The attribute-name string consists of the entire cookie-av
	    //    string, and the attribute-value string is empty.
	    attributeName = cookieAv;
	  }

	  // 5. Remove any leading or trailing WSP characters from the attribute-
	  //    name string and the attribute-value string.
	  attributeName = attributeName.trim();
	  attributeValue = attributeValue.trim();

	  // 6. If the attribute-value is longer than 1024 octets, ignore the
	  //    cookie-av string and return to Step 1 of this algorithm.
	  if (attributeValue.length > maxAttributeValueSize) {
	    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	  }

	  // 7. Process the attribute-name and attribute-value according to the
	  //    requirements in the following subsections.  (Notice that
	  //    attributes with unrecognized attribute-names are ignored.)
	  const attributeNameLowercase = attributeName.toLowerCase();

	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1
	  // If the attribute-name case-insensitively matches the string
	  // "Expires", the user agent MUST process the cookie-av as follows.
	  if (attributeNameLowercase === 'expires') {
	    // 1. Let the expiry-time be the result of parsing the attribute-value
	    //    as cookie-date (see Section 5.1.1).
	    const expiryTime = new Date(attributeValue);

	    // 2. If the attribute-value failed to parse as a cookie date, ignore
	    //    the cookie-av.

	    cookieAttributeList.expires = expiryTime;
	  } else if (attributeNameLowercase === 'max-age') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2
	    // If the attribute-name case-insensitively matches the string "Max-
	    // Age", the user agent MUST process the cookie-av as follows.

	    // 1. If the first character of the attribute-value is not a DIGIT or a
	    //    "-" character, ignore the cookie-av.
	    const charCode = attributeValue.charCodeAt(0);

	    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {
	      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	    }

	    // 2. If the remainder of attribute-value contains a non-DIGIT
	    //    character, ignore the cookie-av.
	    if (!/^\d+$/.test(attributeValue)) {
	      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	    }

	    // 3. Let delta-seconds be the attribute-value converted to an integer.
	    const deltaSeconds = Number(attributeValue);

	    // 4. Let cookie-age-limit be the maximum age of the cookie (which
	    //    SHOULD be 400 days or less, see Section 4.1.2.2).

	    // 5. Set delta-seconds to the smaller of its present value and cookie-
	    //    age-limit.
	    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)

	    // 6. If delta-seconds is less than or equal to zero (0), let expiry-
	    //    time be the earliest representable date and time.  Otherwise, let
	    //    the expiry-time be the current date and time plus delta-seconds
	    //    seconds.
	    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds

	    // 7. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Max-Age and an attribute-value of expiry-time.
	    cookieAttributeList.maxAge = deltaSeconds;
	  } else if (attributeNameLowercase === 'domain') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3
	    // If the attribute-name case-insensitively matches the string "Domain",
	    // the user agent MUST process the cookie-av as follows.

	    // 1. Let cookie-domain be the attribute-value.
	    let cookieDomain = attributeValue;

	    // 2. If cookie-domain starts with %x2E ("."), let cookie-domain be
	    //    cookie-domain without its leading %x2E (".").
	    if (cookieDomain[0] === '.') {
	      cookieDomain = cookieDomain.slice(1);
	    }

	    // 3. Convert the cookie-domain to lower case.
	    cookieDomain = cookieDomain.toLowerCase();

	    // 4. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Domain and an attribute-value of cookie-domain.
	    cookieAttributeList.domain = cookieDomain;
	  } else if (attributeNameLowercase === 'path') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4
	    // If the attribute-name case-insensitively matches the string "Path",
	    // the user agent MUST process the cookie-av as follows.

	    // 1. If the attribute-value is empty or if the first character of the
	    //    attribute-value is not %x2F ("/"):
	    let cookiePath = '';
	    if (attributeValue.length === 0 || attributeValue[0] !== '/') {
	      // 1. Let cookie-path be the default-path.
	      cookiePath = '/';
	    } else {
	      // Otherwise:

	      // 1. Let cookie-path be the attribute-value.
	      cookiePath = attributeValue;
	    }

	    // 2. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Path and an attribute-value of cookie-path.
	    cookieAttributeList.path = cookiePath;
	  } else if (attributeNameLowercase === 'secure') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5
	    // If the attribute-name case-insensitively matches the string "Secure",
	    // the user agent MUST append an attribute to the cookie-attribute-list
	    // with an attribute-name of Secure and an empty attribute-value.

	    cookieAttributeList.secure = true;
	  } else if (attributeNameLowercase === 'httponly') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6
	    // If the attribute-name case-insensitively matches the string
	    // "HttpOnly", the user agent MUST append an attribute to the cookie-
	    // attribute-list with an attribute-name of HttpOnly and an empty
	    // attribute-value.

	    cookieAttributeList.httpOnly = true;
	  } else if (attributeNameLowercase === 'samesite') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7
	    // If the attribute-name case-insensitively matches the string
	    // "SameSite", the user agent MUST process the cookie-av as follows:

	    // 1. Let enforcement be "Default".
	    let enforcement = 'Default';

	    const attributeValueLowercase = attributeValue.toLowerCase();
	    // 2. If cookie-av's attribute-value is a case-insensitive match for
	    //    "None", set enforcement to "None".
	    if (attributeValueLowercase.includes('none')) {
	      enforcement = 'None';
	    }

	    // 3. If cookie-av's attribute-value is a case-insensitive match for
	    //    "Strict", set enforcement to "Strict".
	    if (attributeValueLowercase.includes('strict')) {
	      enforcement = 'Strict';
	    }

	    // 4. If cookie-av's attribute-value is a case-insensitive match for
	    //    "Lax", set enforcement to "Lax".
	    if (attributeValueLowercase.includes('lax')) {
	      enforcement = 'Lax';
	    }

	    // 5. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of "SameSite" and an attribute-value of
	    //    enforcement.
	    cookieAttributeList.sameSite = enforcement;
	  } else {
	    cookieAttributeList.unparsed ??= [];

	    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
	  }

	  // 8. Return to Step 1 of this algorithm.
	  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	}

	parse$1 = {
	  parseSetCookie,
	  parseUnparsedAttributes
	};
	return parse$1;
}

var cookies;
var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	const { parseSetCookie } = requireParse();
	const { stringify } = requireUtil$1();
	const { webidl } = requireWebidl();
	const { Headers } = requireHeaders();

	/**
	 * @typedef {Object} Cookie
	 * @property {string} name
	 * @property {string} value
	 * @property {Date|number|undefined} expires
	 * @property {number|undefined} maxAge
	 * @property {string|undefined} domain
	 * @property {string|undefined} path
	 * @property {boolean|undefined} secure
	 * @property {boolean|undefined} httpOnly
	 * @property {'Strict'|'Lax'|'None'} sameSite
	 * @property {string[]} unparsed
	 */

	/**
	 * @param {Headers} headers
	 * @returns {Record<string, string>}
	 */
	function getCookies (headers) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  const cookie = headers.get('cookie');
	  const out = {};

	  if (!cookie) {
	    return out
	  }

	  for (const piece of cookie.split(';')) {
	    const [name, ...value] = piece.split('=');

	    out[name.trim()] = value.join('=');
	  }

	  return out
	}

	/**
	 * @param {Headers} headers
	 * @param {string} name
	 * @param {{ path?: string, domain?: string }|undefined} attributes
	 * @returns {void}
	 */
	function deleteCookie (headers, name, attributes) {
	  webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  name = webidl.converters.DOMString(name);
	  attributes = webidl.converters.DeleteCookieAttributes(attributes);

	  // Matches behavior of
	  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278
	  setCookie(headers, {
	    name,
	    value: '',
	    expires: new Date(0),
	    ...attributes
	  });
	}

	/**
	 * @param {Headers} headers
	 * @returns {Cookie[]}
	 */
	function getSetCookies (headers) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  const cookies = headers.getSetCookie();

	  if (!cookies) {
	    return []
	  }

	  return cookies.map((pair) => parseSetCookie(pair))
	}

	/**
	 * @param {Headers} headers
	 * @param {Cookie} cookie
	 * @returns {void}
	 */
	function setCookie (headers, cookie) {
	  webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  cookie = webidl.converters.Cookie(cookie);

	  const str = stringify(cookie);

	  if (str) {
	    headers.append('Set-Cookie', stringify(cookie));
	  }
	}

	webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'path',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'domain',
	    defaultValue: null
	  }
	]);

	webidl.converters.Cookie = webidl.dictionaryConverter([
	  {
	    converter: webidl.converters.DOMString,
	    key: 'name'
	  },
	  {
	    converter: webidl.converters.DOMString,
	    key: 'value'
	  },
	  {
	    converter: webidl.nullableConverter((value) => {
	      if (typeof value === 'number') {
	        return webidl.converters['unsigned long long'](value)
	      }

	      return new Date(value)
	    }),
	    key: 'expires',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters['long long']),
	    key: 'maxAge',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'domain',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'path',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.boolean),
	    key: 'secure',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.boolean),
	    key: 'httpOnly',
	    defaultValue: null
	  },
	  {
	    converter: webidl.converters.USVString,
	    key: 'sameSite',
	    allowedValues: ['Strict', 'Lax', 'None']
	  },
	  {
	    converter: webidl.sequenceConverter(webidl.converters.DOMString),
	    key: 'unparsed',
	    defaultValue: []
	  }
	]);

	cookies = {
	  getCookies,
	  deleteCookie,
	  getSetCookies,
	  setCookie
	};
	return cookies;
}

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	// This is a Globally Unique Identifier unique used
	// to validate that the endpoint accepts websocket
	// connections.
	// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3
	const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
	  enumerable: true,
	  writable: false,
	  configurable: false
	};

	const states = {
	  CONNECTING: 0,
	  OPEN: 1,
	  CLOSING: 2,
	  CLOSED: 3
	};

	const opcodes = {
	  CONTINUATION: 0x0,
	  TEXT: 0x1,
	  BINARY: 0x2,
	  CLOSE: 0x8,
	  PING: 0x9,
	  PONG: 0xA
	};

	const maxUnsigned16Bit = 2 ** 16 - 1; // 65535

	const parserStates = {
	  INFO: 0,
	  PAYLOADLENGTH_16: 2,
	  PAYLOADLENGTH_64: 3,
	  READ_DATA: 4
	};

	const emptyBuffer = Buffer.allocUnsafe(0);

	constants = {
	  uid,
	  staticPropertyDescriptors,
	  states,
	  opcodes,
	  maxUnsigned16Bit,
	  parserStates,
	  emptyBuffer
	};
	return constants;
}

var symbols;
var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	symbols = {
	  kWebSocketURL: Symbol('url'),
	  kReadyState: Symbol('ready state'),
	  kController: Symbol('controller'),
	  kResponse: Symbol('response'),
	  kBinaryType: Symbol('binary type'),
	  kSentClose: Symbol('sent close'),
	  kReceivedClose: Symbol('received close'),
	  kByteParser: Symbol('byte parser')
	};
	return symbols;
}

var events;
var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;

	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$6();
	const { MessagePort } = require$$0$8;

	/**
	 * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	 */
	class MessageEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent constructor' });

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.MessageEventInit(eventInitDict);

	    super(type, eventInitDict);

	    this.#eventInit = eventInitDict;
	  }

	  get data () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.data
	  }

	  get origin () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.origin
	  }

	  get lastEventId () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.lastEventId
	  }

	  get source () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.source
	  }

	  get ports () {
	    webidl.brandCheck(this, MessageEvent);

	    if (!Object.isFrozen(this.#eventInit.ports)) {
	      Object.freeze(this.#eventInit.ports);
	    }

	    return this.#eventInit.ports
	  }

	  initMessageEvent (
	    type,
	    bubbles = false,
	    cancelable = false,
	    data = null,
	    origin = '',
	    lastEventId = '',
	    source = null,
	    ports = []
	  ) {
	    webidl.brandCheck(this, MessageEvent);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent.initMessageEvent' });

	    return new MessageEvent(type, {
	      bubbles, cancelable, data, origin, lastEventId, source, ports
	    })
	  }
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	 */
	class CloseEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CloseEvent constructor' });

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.CloseEventInit(eventInitDict);

	    super(type, eventInitDict);

	    this.#eventInit = eventInitDict;
	  }

	  get wasClean () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.wasClean
	  }

	  get code () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.code
	  }

	  get reason () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.reason
	  }
	}

	// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface
	class ErrorEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'ErrorEvent constructor' });

	    super(type, eventInitDict);

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});

	    this.#eventInit = eventInitDict;
	  }

	  get message () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.message
	  }

	  get filename () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.filename
	  }

	  get lineno () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.lineno
	  }

	  get colno () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.colno
	  }

	  get error () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.error
	  }
	}

	Object.defineProperties(MessageEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'MessageEvent',
	    configurable: true
	  },
	  data: kEnumerableProperty,
	  origin: kEnumerableProperty,
	  lastEventId: kEnumerableProperty,
	  source: kEnumerableProperty,
	  ports: kEnumerableProperty,
	  initMessageEvent: kEnumerableProperty
	});

	Object.defineProperties(CloseEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'CloseEvent',
	    configurable: true
	  },
	  reason: kEnumerableProperty,
	  code: kEnumerableProperty,
	  wasClean: kEnumerableProperty
	});

	Object.defineProperties(ErrorEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'ErrorEvent',
	    configurable: true
	  },
	  message: kEnumerableProperty,
	  filename: kEnumerableProperty,
	  lineno: kEnumerableProperty,
	  colno: kEnumerableProperty,
	  error: kEnumerableProperty
	});

	webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);

	webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(
	  webidl.converters.MessagePort
	);

	const eventInit = [
	  {
	    key: 'bubbles',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'cancelable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'composed',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	];

	webidl.converters.MessageEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'data',
	    converter: webidl.converters.any,
	    defaultValue: null
	  },
	  {
	    key: 'origin',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  },
	  {
	    key: 'lastEventId',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'source',
	    // Node doesn't implement WindowProxy or ServiceWorker, so the only
	    // valid value for source is a MessagePort.
	    converter: webidl.nullableConverter(webidl.converters.MessagePort),
	    defaultValue: null
	  },
	  {
	    key: 'ports',
	    converter: webidl.converters['sequence<MessagePort>'],
	    get defaultValue () {
	      return []
	    }
	  }
	]);

	webidl.converters.CloseEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'wasClean',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'code',
	    converter: webidl.converters['unsigned short'],
	    defaultValue: 0
	  },
	  {
	    key: 'reason',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  }
	]);

	webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'message',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'filename',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  },
	  {
	    key: 'lineno',
	    converter: webidl.converters['unsigned long'],
	    defaultValue: 0
	  },
	  {
	    key: 'colno',
	    converter: webidl.converters['unsigned long'],
	    defaultValue: 0
	  },
	  {
	    key: 'error',
	    converter: webidl.converters.any
	  }
	]);

	events = {
	  MessageEvent,
	  CloseEvent,
	  ErrorEvent
	};
	return events;
}

var util;
var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;

	const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = requireSymbols();
	const { states, opcodes } = requireConstants();
	const { MessageEvent, ErrorEvent } = requireEvents();

	/* globals Blob */

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isEstablished (ws) {
	  // If the server's response is validated as provided for above, it is
	  // said that _The WebSocket Connection is Established_ and that the
	  // WebSocket Connection is in the OPEN state.
	  return ws[kReadyState] === states.OPEN
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isClosing (ws) {
	  // Upon either sending or receiving a Close control frame, it is said
	  // that _The WebSocket Closing Handshake is Started_ and that the
	  // WebSocket connection is in the CLOSING state.
	  return ws[kReadyState] === states.CLOSING
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isClosed (ws) {
	  return ws[kReadyState] === states.CLOSED
	}

	/**
	 * @see https://dom.spec.whatwg.org/#concept-event-fire
	 * @param {string} e
	 * @param {EventTarget} target
	 * @param {EventInit | undefined} eventInitDict
	 */
	function fireEvent (e, target, eventConstructor = Event, eventInitDict) {
	  // 1. If eventConstructor is not given, then let eventConstructor be Event.

	  // 2. Let event be the result of creating an event given eventConstructor,
	  //    in the relevant realm of target.
	  // 3. Initialize events type attribute to e.
	  const event = new eventConstructor(e, eventInitDict); // eslint-disable-line new-cap

	  // 4. Initialize any other IDL attributes of event as described in the
	  //    invocation of this algorithm.

	  // 5. Return the result of dispatching event at target, with legacy target
	  //    override flag set if set.
	  target.dispatchEvent(event);
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	 * @param {import('./websocket').WebSocket} ws
	 * @param {number} type Opcode
	 * @param {Buffer} data application data
	 */
	function websocketMessageReceived (ws, type, data) {
	  // 1. If ready state is not OPEN (1), then return.
	  if (ws[kReadyState] !== states.OPEN) {
	    return
	  }

	  // 2. Let dataForEvent be determined by switching on type and binary type:
	  let dataForEvent;

	  if (type === opcodes.TEXT) {
	    // -> type indicates that the data is Text
	    //      a new DOMString containing data
	    try {
	      dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data);
	    } catch {
	      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');
	      return
	    }
	  } else if (type === opcodes.BINARY) {
	    if (ws[kBinaryType] === 'blob') {
	      // -> type indicates that the data is Binary and binary type is "blob"
	      //      a new Blob object, created in the relevant Realm of the WebSocket
	      //      object, that represents data as its raw data
	      dataForEvent = new Blob([data]);
	    } else {
	      // -> type indicates that the data is Binary and binary type is "arraybuffer"
	      //      a new ArrayBuffer object, created in the relevant Realm of the
	      //      WebSocket object, whose contents are data
	      dataForEvent = new Uint8Array(data).buffer;
	    }
	  }

	  // 3. Fire an event named message at the WebSocket object, using MessageEvent,
	  //    with the origin attribute initialized to the serialization of the WebSocket
	  //    objects url's origin, and the data attribute initialized to dataForEvent.
	  fireEvent('message', ws, MessageEvent, {
	    origin: ws[kWebSocketURL].origin,
	    data: dataForEvent
	  });
	}

	/**
	 * @see https://datatracker.ietf.org/doc/html/rfc6455
	 * @see https://datatracker.ietf.org/doc/html/rfc2616
	 * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	 * @param {string} protocol
	 */
	function isValidSubprotocol (protocol) {
	  // If present, this value indicates one
	  // or more comma-separated subprotocol the client wishes to speak,
	  // ordered by preference.  The elements that comprise this value
	  // MUST be non-empty strings with characters in the range U+0021 to
	  // U+007E not including separator characters as defined in
	  // [RFC2616] and MUST all be unique strings.
	  if (protocol.length === 0) {
	    return false
	  }

	  for (const char of protocol) {
	    const code = char.charCodeAt(0);

	    if (
	      code < 0x21 ||
	      code > 0x7E ||
	      char === '(' ||
	      char === ')' ||
	      char === '<' ||
	      char === '>' ||
	      char === '@' ||
	      char === ',' ||
	      char === ';' ||
	      char === ':' ||
	      char === '\\' ||
	      char === '"' ||
	      char === '/' ||
	      char === '[' ||
	      char === ']' ||
	      char === '?' ||
	      char === '=' ||
	      char === '{' ||
	      char === '}' ||
	      code === 32 || // SP
	      code === 9 // HT
	    ) {
	      return false
	    }
	  }

	  return true
	}

	/**
	 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	 * @param {number} code
	 */
	function isValidStatusCode (code) {
	  if (code >= 1000 && code < 1015) {
	    return (
	      code !== 1004 && // reserved
	      code !== 1005 && // "MUST NOT be set as a status code"
	      code !== 1006 // "MUST NOT be set as a status code"
	    )
	  }

	  return code >= 3000 && code <= 4999
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 * @param {string|undefined} reason
	 */
	function failWebsocketConnection (ws, reason) {
	  const { [kController]: controller, [kResponse]: response } = ws;

	  controller.abort();

	  if (response?.socket && !response.socket.destroyed) {
	    response.socket.destroy();
	  }

	  if (reason) {
	    fireEvent('error', ws, ErrorEvent, {
	      error: new Error(reason)
	    });
	  }
	}

	util = {
	  isEstablished,
	  isClosing,
	  isClosed,
	  fireEvent,
	  isValidSubprotocol,
	  isValidStatusCode,
	  failWebsocketConnection,
	  websocketMessageReceived
	};
	return util;
}

var connection;
var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection;
	hasRequiredConnection = 1;

	const diagnosticsChannel = require$$0$9;
	const { uid, states } = requireConstants();
	const {
	  kReadyState,
	  kSentClose,
	  kByteParser,
	  kReceivedClose
	} = requireSymbols();
	const { fireEvent, failWebsocketConnection } = requireUtil();
	const { CloseEvent } = requireEvents();
	const { makeRequest } = requireRequest();
	const { fetching } = requireFetch();
	const { Headers } = requireHeaders();
	const { getGlobalDispatcher } = requireGlobal();
	const { kHeadersList } = requireSymbols$4();

	const channels = {};
	channels.open = diagnosticsChannel.channel('undici:websocket:open');
	channels.close = diagnosticsChannel.channel('undici:websocket:close');
	channels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');

	/** @type {import('crypto')} */
	let crypto;
	try {
	  crypto = require('crypto');
	} catch {

	}

	/**
	 * @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	 * @param {URL} url
	 * @param {string|string[]} protocols
	 * @param {import('./websocket').WebSocket} ws
	 * @param {(response: any) => void} onEstablish
	 * @param {Partial<import('../../types/websocket').WebSocketInit>} options
	 */
	function establishWebSocketConnection (url, protocols, ws, onEstablish, options) {
	  // 1. Let requestURL be a copy of url, with its scheme set to "http", if urls
	  //    scheme is "ws", and to "https" otherwise.
	  const requestURL = url;

	  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';

	  // 2. Let request be a new request, whose URL is requestURL, client is client,
	  //    service-workers mode is "none", referrer is "no-referrer", mode is
	  //    "websocket", credentials mode is "include", cache mode is "no-store" ,
	  //    and redirect mode is "error".
	  const request = makeRequest({
	    urlList: [requestURL],
	    serviceWorkers: 'none',
	    referrer: 'no-referrer',
	    mode: 'websocket',
	    credentials: 'include',
	    cache: 'no-store',
	    redirect: 'error'
	  });

	  // Note: undici extension, allow setting custom headers.
	  if (options.headers) {
	    const headersList = new Headers(options.headers)[kHeadersList];

	    request.headersList = headersList;
	  }

	  // 3. Append (`Upgrade`, `websocket`) to requests header list.
	  // 4. Append (`Connection`, `Upgrade`) to requests header list.
	  // Note: both of these are handled by undici currently.
	  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397

	  // 5. Let keyValue be a nonce consisting of a randomly selected
	  //    16-byte value that has been forgiving-base64-encoded and
	  //    isomorphic encoded.
	  const keyValue = crypto.randomBytes(16).toString('base64');

	  // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests
	  //    header list.
	  request.headersList.append('sec-websocket-key', keyValue);

	  // 7. Append (`Sec-WebSocket-Version`, `13`) to requests
	  //    header list.
	  request.headersList.append('sec-websocket-version', '13');

	  // 8. For each protocol in protocols, combine
	  //    (`Sec-WebSocket-Protocol`, protocol) in requests header
	  //    list.
	  for (const protocol of protocols) {
	    request.headersList.append('sec-websocket-protocol', protocol);
	  }

	  // 9. Let permessageDeflate be a user-agent defined
	  //    "permessage-deflate" extension header value.
	  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673
	  // TODO: enable once permessage-deflate is supported
	  const permessageDeflate = ''; // 'permessage-deflate; 15'

	  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to
	  //     requests header list.
	  // request.headersList.append('sec-websocket-extensions', permessageDeflate)

	  // 11. Fetch request with useParallelQueue set to true, and
	  //     processResponse given response being these steps:
	  const controller = fetching({
	    request,
	    useParallelQueue: true,
	    dispatcher: options.dispatcher ?? getGlobalDispatcher(),
	    processResponse (response) {
	      // 1. If response is a network error or its status is not 101,
	      //    fail the WebSocket connection.
	      if (response.type === 'error' || response.status !== 101) {
	        failWebsocketConnection(ws, 'Received network error or non-101 status code.');
	        return
	      }

	      // 2. If protocols is not the empty list and extracting header
	      //    list values given `Sec-WebSocket-Protocol` and responses
	      //    header list results in null, failure, or the empty byte
	      //    sequence, then fail the WebSocket connection.
	      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {
	        failWebsocketConnection(ws, 'Server did not respond with sent protocols.');
	        return
	      }

	      // 3. Follow the requirements stated step 2 to step 6, inclusive,
	      //    of the last set of steps in section 4.1 of The WebSocket
	      //    Protocol to validate response. This either results in fail
	      //    the WebSocket connection or the WebSocket connection is
	      //    established.

	      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|
	      //    header field contains a value that is not an ASCII case-
	      //    insensitive match for the value "websocket", the client MUST
	      //    _Fail the WebSocket Connection_.
	      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {
	        failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
	        return
	      }

	      // 3. If the response lacks a |Connection| header field or the
	      //    |Connection| header field doesn't contain a token that is an
	      //    ASCII case-insensitive match for the value "Upgrade", the client
	      //    MUST _Fail the WebSocket Connection_.
	      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {
	        failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
	        return
	      }

	      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or
	      //    the |Sec-WebSocket-Accept| contains a value other than the
	      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-
	      //    Key| (as a string, not base64-decoded) with the string "258EAFA5-
	      //    E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and
	      //    trailing whitespace, the client MUST _Fail the WebSocket
	      //    Connection_.
	      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');
	      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');
	      if (secWSAccept !== digest) {
	        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');
	        return
	      }

	      // 5. If the response includes a |Sec-WebSocket-Extensions| header
	      //    field and this header field indicates the use of an extension
	      //    that was not present in the client's handshake (the server has
	      //    indicated an extension not requested by the client), the client
	      //    MUST _Fail the WebSocket Connection_.  (The parsing of this
	      //    header field to determine which extensions are requested is
	      //    discussed in Section 9.1.)
	      const secExtension = response.headersList.get('Sec-WebSocket-Extensions');

	      if (secExtension !== null && secExtension !== permessageDeflate) {
	        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');
	        return
	      }

	      // 6. If the response includes a |Sec-WebSocket-Protocol| header field
	      //    and this header field indicates the use of a subprotocol that was
	      //    not present in the client's handshake (the server has indicated a
	      //    subprotocol not requested by the client), the client MUST _Fail
	      //    the WebSocket Connection_.
	      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');

	      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {
	        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');
	        return
	      }

	      response.socket.on('data', onSocketData);
	      response.socket.on('close', onSocketClose);
	      response.socket.on('error', onSocketError);

	      if (channels.open.hasSubscribers) {
	        channels.open.publish({
	          address: response.socket.address(),
	          protocol: secProtocol,
	          extensions: secExtension
	        });
	      }

	      onEstablish(response);
	    }
	  });

	  return controller
	}

	/**
	 * @param {Buffer} chunk
	 */
	function onSocketData (chunk) {
	  if (!this.ws[kByteParser].write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	 */
	function onSocketClose () {
	  const { ws } = this;

	  // If the TCP connection was closed after the
	  // WebSocket closing handshake was completed, the WebSocket connection
	  // is said to have been closed _cleanly_.
	  const wasClean = ws[kSentClose] && ws[kReceivedClose];

	  let code = 1005;
	  let reason = '';

	  const result = ws[kByteParser].closingInfo;

	  if (result) {
	    code = result.code ?? 1005;
	    reason = result.reason;
	  } else if (!ws[kSentClose]) {
	    // If _The WebSocket
	    // Connection is Closed_ and no Close control frame was received by the
	    // endpoint (such as could occur if the underlying transport connection
	    // is lost), _The WebSocket Connection Close Code_ is considered to be
	    // 1006.
	    code = 1006;
	  }

	  // 1. Change the ready state to CLOSED (3).
	  ws[kReadyState] = states.CLOSED;

	  // 2. If the user agent was required to fail the WebSocket
	  //    connection, or if the WebSocket connection was closed
	  //    after being flagged as full, fire an event named error
	  //    at the WebSocket object.
	  // TODO

	  // 3. Fire an event named close at the WebSocket object,
	  //    using CloseEvent, with the wasClean attribute
	  //    initialized to true if the connection closed cleanly
	  //    and false otherwise, the code attribute initialized to
	  //    the WebSocket connection close code, and the reason
	  //    attribute initialized to the result of applying UTF-8
	  //    decode without BOM to the WebSocket connection close
	  //    reason.
	  fireEvent('close', ws, CloseEvent, {
	    wasClean, code, reason
	  });

	  if (channels.close.hasSubscribers) {
	    channels.close.publish({
	      websocket: ws,
	      code,
	      reason
	    });
	  }
	}

	function onSocketError (error) {
	  const { ws } = this;

	  ws[kReadyState] = states.CLOSING;

	  if (channels.socketError.hasSubscribers) {
	    channels.socketError.publish(error);
	  }

	  this.destroy();
	}

	connection = {
	  establishWebSocketConnection
	};
	return connection;
}

var frame;
var hasRequiredFrame;

function requireFrame () {
	if (hasRequiredFrame) return frame;
	hasRequiredFrame = 1;

	const { maxUnsigned16Bit } = requireConstants();

	/** @type {import('crypto')} */
	let crypto;
	try {
	  crypto = require('crypto');
	} catch {

	}

	class WebsocketFrameSend {
	  /**
	   * @param {Buffer|undefined} data
	   */
	  constructor (data) {
	    this.frameData = data;
	    this.maskKey = crypto.randomBytes(4);
	  }

	  createFrame (opcode) {
	    const bodyLength = this.frameData?.byteLength ?? 0;

	    /** @type {number} */
	    let payloadLength = bodyLength; // 0-125
	    let offset = 6;

	    if (bodyLength > maxUnsigned16Bit) {
	      offset += 8; // payload length is next 8 bytes
	      payloadLength = 127;
	    } else if (bodyLength > 125) {
	      offset += 2; // payload length is next 2 bytes
	      payloadLength = 126;
	    }

	    const buffer = Buffer.allocUnsafe(bodyLength + offset);

	    // Clear first 2 bytes, everything else is overwritten
	    buffer[0] = buffer[1] = 0;
	    buffer[0] |= 0x80; // FIN
	    buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode

	    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
	    buffer[offset - 4] = this.maskKey[0];
	    buffer[offset - 3] = this.maskKey[1];
	    buffer[offset - 2] = this.maskKey[2];
	    buffer[offset - 1] = this.maskKey[3];

	    buffer[1] = payloadLength;

	    if (payloadLength === 126) {
	      buffer.writeUInt16BE(bodyLength, 2);
	    } else if (payloadLength === 127) {
	      // Clear extended payload length
	      buffer[2] = buffer[3] = 0;
	      buffer.writeUIntBE(bodyLength, 4, 6);
	    }

	    buffer[1] |= 0x80; // MASK

	    // mask body
	    for (let i = 0; i < bodyLength; i++) {
	      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
	    }

	    return buffer
	  }
	}

	frame = {
	  WebsocketFrameSend
	};
	return frame;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$1;
	const diagnosticsChannel = require$$0$9;
	const { parserStates, opcodes, states, emptyBuffer } = requireConstants();
	const { kReadyState, kSentClose, kResponse, kReceivedClose } = requireSymbols();
	const { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = requireUtil();
	const { WebsocketFrameSend } = requireFrame();

	// This code was influenced by ws released under the MIT license.
	// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
	// Copyright (c) 2013 Arnout Kazemier and contributors
	// Copyright (c) 2016 Luigi Pinca and contributors

	const channels = {};
	channels.ping = diagnosticsChannel.channel('undici:websocket:ping');
	channels.pong = diagnosticsChannel.channel('undici:websocket:pong');

	class ByteParser extends Writable {
	  #buffers = []
	  #byteOffset = 0

	  #state = parserStates.INFO

	  #info = {}
	  #fragments = []

	  constructor (ws) {
	    super();

	    this.ws = ws;
	  }

	  /**
	   * @param {Buffer} chunk
	   * @param {() => void} callback
	   */
	  _write (chunk, _, callback) {
	    this.#buffers.push(chunk);
	    this.#byteOffset += chunk.length;

	    this.run(callback);
	  }

	  /**
	   * Runs whenever a new chunk is received.
	   * Callback is called whenever there are no more chunks buffering,
	   * or not enough bytes are buffered to parse.
	   */
	  run (callback) {
	    while (true) {
	      if (this.#state === parserStates.INFO) {
	        // If there aren't enough bytes to parse the payload length, etc.
	        if (this.#byteOffset < 2) {
	          return callback()
	        }

	        const buffer = this.consume(2);

	        this.#info.fin = (buffer[0] & 0x80) !== 0;
	        this.#info.opcode = buffer[0] & 0x0F;

	        // If we receive a fragmented message, we use the type of the first
	        // frame to parse the full message as binary/text, when it's terminated
	        this.#info.originalOpcode ??= this.#info.opcode;

	        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;

	        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
	          // Only text and binary frames can be fragmented
	          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');
	          return
	        }

	        const payloadLength = buffer[1] & 0x7F;

	        if (payloadLength <= 125) {
	          this.#info.payloadLength = payloadLength;
	          this.#state = parserStates.READ_DATA;
	        } else if (payloadLength === 126) {
	          this.#state = parserStates.PAYLOADLENGTH_16;
	        } else if (payloadLength === 127) {
	          this.#state = parserStates.PAYLOADLENGTH_64;
	        }

	        if (this.#info.fragmented && payloadLength > 125) {
	          // A fragmented frame can't be fragmented itself
	          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');
	          return
	        } else if (
	          (this.#info.opcode === opcodes.PING ||
	            this.#info.opcode === opcodes.PONG ||
	            this.#info.opcode === opcodes.CLOSE) &&
	          payloadLength > 125
	        ) {
	          // Control frames can have a payload length of 125 bytes MAX
	          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');
	          return
	        } else if (this.#info.opcode === opcodes.CLOSE) {
	          if (payloadLength === 1) {
	            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');
	            return
	          }

	          const body = this.consume(payloadLength);

	          this.#info.closeInfo = this.parseCloseBody(false, body);

	          if (!this.ws[kSentClose]) {
	            // If an endpoint receives a Close frame and did not previously send a
	            // Close frame, the endpoint MUST send a Close frame in response.  (When
	            // sending a Close frame in response, the endpoint typically echos the
	            // status code it received.)
	            const body = Buffer.allocUnsafe(2);
	            body.writeUInt16BE(this.#info.closeInfo.code, 0);
	            const closeFrame = new WebsocketFrameSend(body);

	            this.ws[kResponse].socket.write(
	              closeFrame.createFrame(opcodes.CLOSE),
	              (err) => {
	                if (!err) {
	                  this.ws[kSentClose] = true;
	                }
	              }
	            );
	          }

	          // Upon either sending or receiving a Close control frame, it is said
	          // that _The WebSocket Closing Handshake is Started_ and that the
	          // WebSocket connection is in the CLOSING state.
	          this.ws[kReadyState] = states.CLOSING;
	          this.ws[kReceivedClose] = true;

	          this.end();

	          return
	        } else if (this.#info.opcode === opcodes.PING) {
	          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in
	          // response, unless it already received a Close frame.
	          // A Pong frame sent in response to a Ping frame must have identical
	          // "Application data"

	          const body = this.consume(payloadLength);

	          if (!this.ws[kReceivedClose]) {
	            const frame = new WebsocketFrameSend(body);

	            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));

	            if (channels.ping.hasSubscribers) {
	              channels.ping.publish({
	                payload: body
	              });
	            }
	          }

	          this.#state = parserStates.INFO;

	          if (this.#byteOffset > 0) {
	            continue
	          } else {
	            callback();
	            return
	          }
	        } else if (this.#info.opcode === opcodes.PONG) {
	          // A Pong frame MAY be sent unsolicited.  This serves as a
	          // unidirectional heartbeat.  A response to an unsolicited Pong frame is
	          // not expected.

	          const body = this.consume(payloadLength);

	          if (channels.pong.hasSubscribers) {
	            channels.pong.publish({
	              payload: body
	            });
	          }

	          if (this.#byteOffset > 0) {
	            continue
	          } else {
	            callback();
	            return
	          }
	        }
	      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
	        if (this.#byteOffset < 2) {
	          return callback()
	        }

	        const buffer = this.consume(2);

	        this.#info.payloadLength = buffer.readUInt16BE(0);
	        this.#state = parserStates.READ_DATA;
	      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
	        if (this.#byteOffset < 8) {
	          return callback()
	        }

	        const buffer = this.consume(8);
	        const upper = buffer.readUInt32BE(0);

	        // 2^31 is the maxinimum bytes an arraybuffer can contain
	        // on 32-bit systems. Although, on 64-bit systems, this is
	        // 2^53-1 bytes.
	        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
	        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275
	        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e
	        if (upper > 2 ** 31 - 1) {
	          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');
	          return
	        }

	        const lower = buffer.readUInt32BE(4);

	        this.#info.payloadLength = (upper << 8) + lower;
	        this.#state = parserStates.READ_DATA;
	      } else if (this.#state === parserStates.READ_DATA) {
	        if (this.#byteOffset < this.#info.payloadLength) {
	          // If there is still more data in this chunk that needs to be read
	          return callback()
	        } else if (this.#byteOffset >= this.#info.payloadLength) {
	          // If the server sent multiple frames in a single chunk

	          const body = this.consume(this.#info.payloadLength);

	          this.#fragments.push(body);

	          // If the frame is unfragmented, or a fragmented frame was terminated,
	          // a message was received
	          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {
	            const fullMessage = Buffer.concat(this.#fragments);

	            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);

	            this.#info = {};
	            this.#fragments.length = 0;
	          }

	          this.#state = parserStates.INFO;
	        }
	      }

	      if (this.#byteOffset > 0) {
	        continue
	      } else {
	        callback();
	        break
	      }
	    }
	  }

	  /**
	   * Take n bytes from the buffered Buffers
	   * @param {number} n
	   * @returns {Buffer|null}
	   */
	  consume (n) {
	    if (n > this.#byteOffset) {
	      return null
	    } else if (n === 0) {
	      return emptyBuffer
	    }

	    if (this.#buffers[0].length === n) {
	      this.#byteOffset -= this.#buffers[0].length;
	      return this.#buffers.shift()
	    }

	    const buffer = Buffer.allocUnsafe(n);
	    let offset = 0;

	    while (offset !== n) {
	      const next = this.#buffers[0];
	      const { length } = next;

	      if (length + offset === n) {
	        buffer.set(this.#buffers.shift(), offset);
	        break
	      } else if (length + offset > n) {
	        buffer.set(next.subarray(0, n - offset), offset);
	        this.#buffers[0] = next.subarray(n - offset);
	        break
	      } else {
	        buffer.set(this.#buffers.shift(), offset);
	        offset += next.length;
	      }
	    }

	    this.#byteOffset -= n;

	    return buffer
	  }

	  parseCloseBody (onlyCode, data) {
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5
	    /** @type {number|undefined} */
	    let code;

	    if (data.length >= 2) {
	      // _The WebSocket Connection Close Code_ is
	      // defined as the status code (Section 7.4) contained in the first Close
	      // control frame received by the application
	      code = data.readUInt16BE(0);
	    }

	    if (onlyCode) {
	      if (!isValidStatusCode(code)) {
	        return null
	      }

	      return { code }
	    }

	    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6
	    /** @type {Buffer} */
	    let reason = data.subarray(2);

	    // Remove BOM
	    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {
	      reason = reason.subarray(3);
	    }

	    if (code !== undefined && !isValidStatusCode(code)) {
	      return null
	    }

	    try {
	      // TODO: optimize this
	      reason = new TextDecoder('utf-8', { fatal: true }).decode(reason);
	    } catch {
	      return null
	    }

	    return { code, reason }
	  }

	  get closingInfo () {
	    return this.#info.closeInfo
	  }
	}

	receiver = {
	  ByteParser
	};
	return receiver;
}

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;

	const { webidl } = requireWebidl();
	const { DOMException } = requireConstants$3();
	const { URLSerializer } = requireDataURL();
	const { getGlobalOrigin } = requireGlobal$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = requireConstants();
	const {
	  kWebSocketURL,
	  kReadyState,
	  kController,
	  kBinaryType,
	  kResponse,
	  kSentClose,
	  kByteParser
	} = requireSymbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = requireUtil();
	const { establishWebSocketConnection } = requireConnection();
	const { WebsocketFrameSend } = requireFrame();
	const { ByteParser } = requireReceiver();
	const { kEnumerableProperty, isBlobLike } = requireUtil$6();
	const { getGlobalDispatcher } = requireGlobal();
	const { types } = require$$0$1;

	let experimentalWarned = false;

	// https://websockets.spec.whatwg.org/#interface-definition
	class WebSocket extends EventTarget {
	  #events = {
	    open: null,
	    error: null,
	    close: null,
	    message: null
	  }

	  #bufferedAmount = 0
	  #protocol = ''
	  #extensions = ''

	  /**
	   * @param {string} url
	   * @param {string|string[]} protocols
	   */
	  constructor (url, protocols = []) {
	    super();

	    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' });

	    if (!experimentalWarned) {
	      experimentalWarned = true;
	      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {
	        code: 'UNDICI-WS'
	      });
	    }

	    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);

	    url = webidl.converters.USVString(url);
	    protocols = options.protocols;

	    // 1. Let baseURL be this's relevant settings object's API base URL.
	    const baseURL = getGlobalOrigin();

	    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.
	    let urlRecord;

	    try {
	      urlRecord = new URL(url, baseURL);
	    } catch (e) {
	      // 3. If urlRecord is failure, then throw a "SyntaxError" DOMException.
	      throw new DOMException(e, 'SyntaxError')
	    }

	    // 4. If urlRecords scheme is "http", then set urlRecords scheme to "ws".
	    if (urlRecord.protocol === 'http:') {
	      urlRecord.protocol = 'ws:';
	    } else if (urlRecord.protocol === 'https:') {
	      // 5. Otherwise, if urlRecords scheme is "https", set urlRecords scheme to "wss".
	      urlRecord.protocol = 'wss:';
	    }

	    // 6. If urlRecords scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
	    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {
	      throw new DOMException(
	        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
	        'SyntaxError'
	      )
	    }

	    // 7. If urlRecords fragment is non-null, then throw a "SyntaxError"
	    //    DOMException.
	    if (urlRecord.hash || urlRecord.href.endsWith('#')) {
	      throw new DOMException('Got fragment', 'SyntaxError')
	    }

	    // 8. If protocols is a string, set protocols to a sequence consisting
	    //    of just that string.
	    if (typeof protocols === 'string') {
	      protocols = [protocols];
	    }

	    // 9. If any of the values in protocols occur more than once or otherwise
	    //    fail to match the requirements for elements that comprise the value
	    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket
	    //    protocol, then throw a "SyntaxError" DOMException.
	    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {
	      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
	    }

	    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {
	      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
	    }

	    // 10. Set this's url to urlRecord.
	    this[kWebSocketURL] = new URL(urlRecord.href);

	    // 11. Let client be this's relevant settings object.

	    // 12. Run this step in parallel:

	    //    1. Establish a WebSocket connection given urlRecord, protocols,
	    //       and client.
	    this[kController] = establishWebSocketConnection(
	      urlRecord,
	      protocols,
	      this,
	      (response) => this.#onConnectionEstablished(response),
	      options
	    );

	    // Each WebSocket object has an associated ready state, which is a
	    // number representing the state of the connection. Initially it must
	    // be CONNECTING (0).
	    this[kReadyState] = WebSocket.CONNECTING;

	    // The extensions attribute must initially return the empty string.

	    // The protocol attribute must initially return the empty string.

	    // Each WebSocket object has an associated binary type, which is a
	    // BinaryType. Initially it must be "blob".
	    this[kBinaryType] = 'blob';
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#dom-websocket-close
	   * @param {number|undefined} code
	   * @param {string|undefined} reason
	   */
	  close (code = undefined, reason = undefined) {
	    webidl.brandCheck(this, WebSocket);

	    if (code !== undefined) {
	      code = webidl.converters['unsigned short'](code, { clamp: true });
	    }

	    if (reason !== undefined) {
	      reason = webidl.converters.USVString(reason);
	    }

	    // 1. If code is present, but is neither an integer equal to 1000 nor an
	    //    integer in the range 3000 to 4999, inclusive, throw an
	    //    "InvalidAccessError" DOMException.
	    if (code !== undefined) {
	      if (code !== 1000 && (code < 3000 || code > 4999)) {
	        throw new DOMException('invalid code', 'InvalidAccessError')
	      }
	    }

	    let reasonByteLength = 0;

	    // 2. If reason is present, then run these substeps:
	    if (reason !== undefined) {
	      // 1. Let reasonBytes be the result of encoding reason.
	      // 2. If reasonBytes is longer than 123 bytes, then throw a
	      //    "SyntaxError" DOMException.
	      reasonByteLength = Buffer.byteLength(reason);

	      if (reasonByteLength > 123) {
	        throw new DOMException(
	          `Reason must be less than 123 bytes; received ${reasonByteLength}`,
	          'SyntaxError'
	        )
	      }
	    }

	    // 3. Run the first matching steps from the following list:
	    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) ; else if (!isEstablished(this)) {
	      // If the WebSocket connection is not yet established
	      // Fail the WebSocket connection and set this's ready state
	      // to CLOSING (2).
	      failWebsocketConnection(this, 'Connection was closed before it was established.');
	      this[kReadyState] = WebSocket.CLOSING;
	    } else if (!isClosing(this)) {
	      // If the WebSocket closing handshake has not yet been started
	      // Start the WebSocket closing handshake and set this's ready
	      // state to CLOSING (2).
	      // - If neither code nor reason is present, the WebSocket Close
	      //   message must not have a body.
	      // - If code is present, then the status code to use in the
	      //   WebSocket Close message must be the integer given by code.
	      // - If reason is also present, then reasonBytes must be
	      //   provided in the Close message after the status code.

	      const frame = new WebsocketFrameSend();

	      // If neither code nor reason is present, the WebSocket Close
	      // message must not have a body.

	      // If code is present, then the status code to use in the
	      // WebSocket Close message must be the integer given by code.
	      if (code !== undefined && reason === undefined) {
	        frame.frameData = Buffer.allocUnsafe(2);
	        frame.frameData.writeUInt16BE(code, 0);
	      } else if (code !== undefined && reason !== undefined) {
	        // If reason is also present, then reasonBytes must be
	        // provided in the Close message after the status code.
	        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
	        frame.frameData.writeUInt16BE(code, 0);
	        // the body MAY contain UTF-8-encoded data with value /reason/
	        frame.frameData.write(reason, 2, 'utf-8');
	      } else {
	        frame.frameData = emptyBuffer;
	      }

	      /** @type {import('stream').Duplex} */
	      const socket = this[kResponse].socket;

	      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
	        if (!err) {
	          this[kSentClose] = true;
	        }
	      });

	      // Upon either sending or receiving a Close control frame, it is said
	      // that _The WebSocket Closing Handshake is Started_ and that the
	      // WebSocket connection is in the CLOSING state.
	      this[kReadyState] = states.CLOSING;
	    } else {
	      // Otherwise
	      // Set this's ready state to CLOSING (2).
	      this[kReadyState] = WebSocket.CLOSING;
	    }
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#dom-websocket-send
	   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
	   */
	  send (data) {
	    webidl.brandCheck(this, WebSocket);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' });

	    data = webidl.converters.WebSocketSendData(data);

	    // 1. If this's ready state is CONNECTING, then throw an
	    //    "InvalidStateError" DOMException.
	    if (this[kReadyState] === WebSocket.CONNECTING) {
	      throw new DOMException('Sent before connected.', 'InvalidStateError')
	    }

	    // 2. Run the appropriate set of steps from the following list:
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2

	    if (!isEstablished(this) || isClosing(this)) {
	      return
	    }

	    /** @type {import('stream').Duplex} */
	    const socket = this[kResponse].socket;

	    // If data is a string
	    if (typeof data === 'string') {
	      // If the WebSocket connection is established and the WebSocket
	      // closing handshake has not yet started, then the user agent
	      // must send a WebSocket Message comprised of the data argument
	      // using a text frame opcode; if the data cannot be sent, e.g.
	      // because it would need to be buffered but the buffer is full,
	      // the user agent must flag the WebSocket as full and then close
	      // the WebSocket connection. Any invocation of this method with a
	      // string argument that does not throw an exception must increase
	      // the bufferedAmount attribute by the number of bytes needed to
	      // express the argument as UTF-8.

	      const value = Buffer.from(data);
	      const frame = new WebsocketFrameSend(value);
	      const buffer = frame.createFrame(opcodes.TEXT);

	      this.#bufferedAmount += value.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= value.byteLength;
	      });
	    } else if (types.isArrayBuffer(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need
	      // to be buffered but the buffer is full, the user agent must flag
	      // the WebSocket as full and then close the WebSocket connection.
	      // The data to be sent is the data stored in the buffer described
	      // by the ArrayBuffer object. Any invocation of this method with an
	      // ArrayBuffer argument that does not throw an exception must
	      // increase the bufferedAmount attribute by the length of the
	      // ArrayBuffer in bytes.

	      const value = Buffer.from(data);
	      const frame = new WebsocketFrameSend(value);
	      const buffer = frame.createFrame(opcodes.BINARY);

	      this.#bufferedAmount += value.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= value.byteLength;
	      });
	    } else if (ArrayBuffer.isView(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need to
	      // be buffered but the buffer is full, the user agent must flag the
	      // WebSocket as full and then close the WebSocket connection. The
	      // data to be sent is the data stored in the section of the buffer
	      // described by the ArrayBuffer object that data references. Any
	      // invocation of this method with this kind of argument that does
	      // not throw an exception must increase the bufferedAmount attribute
	      // by the length of datas buffer in bytes.

	      const ab = Buffer.from(data, data.byteOffset, data.byteLength);

	      const frame = new WebsocketFrameSend(ab);
	      const buffer = frame.createFrame(opcodes.BINARY);

	      this.#bufferedAmount += ab.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= ab.byteLength;
	      });
	    } else if (isBlobLike(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need to
	      // be buffered but the buffer is full, the user agent must flag the
	      // WebSocket as full and then close the WebSocket connection. The data
	      // to be sent is the raw data represented by the Blob object. Any
	      // invocation of this method with a Blob argument that does not throw
	      // an exception must increase the bufferedAmount attribute by the size
	      // of the Blob objects raw data, in bytes.

	      const frame = new WebsocketFrameSend();

	      data.arrayBuffer().then((ab) => {
	        const value = Buffer.from(ab);
	        frame.frameData = value;
	        const buffer = frame.createFrame(opcodes.BINARY);

	        this.#bufferedAmount += value.byteLength;
	        socket.write(buffer, () => {
	          this.#bufferedAmount -= value.byteLength;
	        });
	      });
	    }
	  }

	  get readyState () {
	    webidl.brandCheck(this, WebSocket);

	    // The readyState getter steps are to return this's ready state.
	    return this[kReadyState]
	  }

	  get bufferedAmount () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#bufferedAmount
	  }

	  get url () {
	    webidl.brandCheck(this, WebSocket);

	    // The url getter steps are to return this's url, serialized.
	    return URLSerializer(this[kWebSocketURL])
	  }

	  get extensions () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#extensions
	  }

	  get protocol () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#protocol
	  }

	  get onopen () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.open
	  }

	  set onopen (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.open) {
	      this.removeEventListener('open', this.#events.open);
	    }

	    if (typeof fn === 'function') {
	      this.#events.open = fn;
	      this.addEventListener('open', fn);
	    } else {
	      this.#events.open = null;
	    }
	  }

	  get onerror () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.error
	  }

	  set onerror (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.error) {
	      this.removeEventListener('error', this.#events.error);
	    }

	    if (typeof fn === 'function') {
	      this.#events.error = fn;
	      this.addEventListener('error', fn);
	    } else {
	      this.#events.error = null;
	    }
	  }

	  get onclose () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.close
	  }

	  set onclose (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.close) {
	      this.removeEventListener('close', this.#events.close);
	    }

	    if (typeof fn === 'function') {
	      this.#events.close = fn;
	      this.addEventListener('close', fn);
	    } else {
	      this.#events.close = null;
	    }
	  }

	  get onmessage () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.message
	  }

	  set onmessage (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.message) {
	      this.removeEventListener('message', this.#events.message);
	    }

	    if (typeof fn === 'function') {
	      this.#events.message = fn;
	      this.addEventListener('message', fn);
	    } else {
	      this.#events.message = null;
	    }
	  }

	  get binaryType () {
	    webidl.brandCheck(this, WebSocket);

	    return this[kBinaryType]
	  }

	  set binaryType (type) {
	    webidl.brandCheck(this, WebSocket);

	    if (type !== 'blob' && type !== 'arraybuffer') {
	      this[kBinaryType] = 'blob';
	    } else {
	      this[kBinaryType] = type;
	    }
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	   */
	  #onConnectionEstablished (response) {
	    // processResponse is called when the "responses header list has been received and initialized."
	    // once this happens, the connection is open
	    this[kResponse] = response;

	    const parser = new ByteParser(this);
	    parser.on('drain', function onParserDrain () {
	      this.ws[kResponse].socket.resume();
	    });

	    response.socket.ws = this;
	    this[kByteParser] = parser;

	    // 1. Change the ready state to OPEN (1).
	    this[kReadyState] = states.OPEN;

	    // 2. Change the extensions attributes value to the extensions in use, if
	    //    it is not the null value.
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1
	    const extensions = response.headersList.get('sec-websocket-extensions');

	    if (extensions !== null) {
	      this.#extensions = extensions;
	    }

	    // 3. Change the protocol attributes value to the subprotocol in use, if
	    //    it is not the null value.
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
	    const protocol = response.headersList.get('sec-websocket-protocol');

	    if (protocol !== null) {
	      this.#protocol = protocol;
	    }

	    // 4. Fire an event named open at the WebSocket object.
	    fireEvent('open', this);
	  }
	}

	// https://websockets.spec.whatwg.org/#dom-websocket-connecting
	WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
	// https://websockets.spec.whatwg.org/#dom-websocket-open
	WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
	// https://websockets.spec.whatwg.org/#dom-websocket-closing
	WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
	// https://websockets.spec.whatwg.org/#dom-websocket-closed
	WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;

	Object.defineProperties(WebSocket.prototype, {
	  CONNECTING: staticPropertyDescriptors,
	  OPEN: staticPropertyDescriptors,
	  CLOSING: staticPropertyDescriptors,
	  CLOSED: staticPropertyDescriptors,
	  url: kEnumerableProperty,
	  readyState: kEnumerableProperty,
	  bufferedAmount: kEnumerableProperty,
	  onopen: kEnumerableProperty,
	  onerror: kEnumerableProperty,
	  onclose: kEnumerableProperty,
	  close: kEnumerableProperty,
	  onmessage: kEnumerableProperty,
	  binaryType: kEnumerableProperty,
	  send: kEnumerableProperty,
	  extensions: kEnumerableProperty,
	  protocol: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'WebSocket',
	    writable: false,
	    enumerable: false,
	    configurable: true
	  }
	});

	Object.defineProperties(WebSocket, {
	  CONNECTING: staticPropertyDescriptors,
	  OPEN: staticPropertyDescriptors,
	  CLOSING: staticPropertyDescriptors,
	  CLOSED: staticPropertyDescriptors
	});

	webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(
	  webidl.converters.DOMString
	);

	webidl.converters['DOMString or sequence<DOMString>'] = function (V) {
	  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {
	    return webidl.converters['sequence<DOMString>'](V)
	  }

	  return webidl.converters.DOMString(V)
	};

	// This implements the propsal made in https://github.com/whatwg/websockets/issues/42
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
	  {
	    key: 'protocols',
	    converter: webidl.converters['DOMString or sequence<DOMString>'],
	    get defaultValue () {
	      return []
	    }
	  },
	  {
	    key: 'dispatcher',
	    converter: (V) => V,
	    get defaultValue () {
	      return getGlobalDispatcher()
	    }
	  },
	  {
	    key: 'headers',
	    converter: webidl.nullableConverter(webidl.converters.HeadersInit)
	  }
	]);

	webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {
	  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {
	    return webidl.converters.WebSocketInit(V)
	  }

	  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }
	};

	webidl.converters.WebSocketSendData = function (V) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (isBlobLike(V)) {
	      return webidl.converters.Blob(V, { strict: false })
	    }

	    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
	      return webidl.converters.BufferSource(V)
	    }
	  }

	  return webidl.converters.USVString(V)
	};

	websocket = {
	  WebSocket
	};
	return websocket;
}

var hasRequiredUndici;

function requireUndici () {
	if (hasRequiredUndici) return undici;
	hasRequiredUndici = 1;

	const Client = requireClient();
	const Dispatcher = requireDispatcher();
	const errors = requireErrors();
	const Pool = requirePool();
	const BalancedPool = requireBalancedPool();
	const Agent = requireAgent();
	const util = requireUtil$6();
	const { InvalidArgumentError } = errors;
	const api = requireApi();
	const buildConnector = requireConnect();
	const MockClient = requireMockClient();
	const MockAgent = requireMockAgent();
	const MockPool = requireMockPool();
	const mockErrors = requireMockErrors();
	const ProxyAgent = requireProxyAgent();
	const RetryHandler = requireRetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = requireGlobal();
	const DecoratorHandler = requireDecoratorHandler();
	const RedirectHandler = requireRedirectHandler();
	const createRedirectInterceptor = requireRedirectInterceptor();

	let hasCrypto;
	try {
	  require('crypto');
	  hasCrypto = true;
	} catch {
	  hasCrypto = false;
	}

	Object.assign(Dispatcher.prototype, api);

	undici.Dispatcher = Dispatcher;
	undici.Client = Client;
	undici.Pool = Pool;
	undici.BalancedPool = BalancedPool;
	undici.Agent = Agent;
	undici.ProxyAgent = ProxyAgent;
	undici.RetryHandler = RetryHandler;

	undici.DecoratorHandler = DecoratorHandler;
	undici.RedirectHandler = RedirectHandler;
	undici.createRedirectInterceptor = createRedirectInterceptor;

	undici.buildConnector = buildConnector;
	undici.errors = errors;

	function makeDispatcher (fn) {
	  return (url, opts, handler) => {
	    if (typeof opts === 'function') {
	      handler = opts;
	      opts = null;
	    }

	    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
	      throw new InvalidArgumentError('invalid url')
	    }

	    if (opts != null && typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (opts && opts.path != null) {
	      if (typeof opts.path !== 'string') {
	        throw new InvalidArgumentError('invalid opts.path')
	      }

	      let path = opts.path;
	      if (!opts.path.startsWith('/')) {
	        path = `/${path}`;
	      }

	      url = new URL(util.parseOrigin(url).origin + path);
	    } else {
	      if (!opts) {
	        opts = typeof url === 'object' ? url : {};
	      }

	      url = util.parseURL(url);
	    }

	    const { agent, dispatcher = getGlobalDispatcher() } = opts;

	    if (agent) {
	      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')
	    }

	    return fn.call(dispatcher, {
	      ...opts,
	      origin: url.origin,
	      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
	      method: opts.method || (opts.body ? 'PUT' : 'GET')
	    }, handler)
	  }
	}

	undici.setGlobalDispatcher = setGlobalDispatcher;
	undici.getGlobalDispatcher = getGlobalDispatcher;

	if (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {
	  let fetchImpl = null;
	  undici.fetch = async function fetch (resource) {
	    if (!fetchImpl) {
	      fetchImpl = requireFetch().fetch;
	    }

	    try {
	      return await fetchImpl(...arguments)
	    } catch (err) {
	      if (typeof err === 'object') {
	        Error.captureStackTrace(err, this);
	      }

	      throw err
	    }
	  };
	  undici.Headers = requireHeaders().Headers;
	  undici.Response = requireResponse().Response;
	  undici.Request = requireRequest().Request;
	  undici.FormData = requireFormdata().FormData;
	  undici.File = requireFile().File;
	  undici.FileReader = requireFilereader().FileReader;

	  const { setGlobalOrigin, getGlobalOrigin } = requireGlobal$1();

	  undici.setGlobalOrigin = setGlobalOrigin;
	  undici.getGlobalOrigin = getGlobalOrigin;

	  const { CacheStorage } = requireCachestorage();
	  const { kConstruct } = requireSymbols$1();

	  // Cache & CacheStorage are tightly coupled with fetch. Even if it may run
	  // in an older version of Node, it doesn't have any use without fetch.
	  undici.caches = new CacheStorage(kConstruct);
	}

	if (util.nodeMajor >= 16) {
	  const { deleteCookie, getCookies, getSetCookies, setCookie } = requireCookies();

	  undici.deleteCookie = deleteCookie;
	  undici.getCookies = getCookies;
	  undici.getSetCookies = getSetCookies;
	  undici.setCookie = setCookie;

	  const { parseMIMEType, serializeAMimeType } = requireDataURL();

	  undici.parseMIMEType = parseMIMEType;
	  undici.serializeAMimeType = serializeAMimeType;
	}

	if (util.nodeMajor >= 18 && hasCrypto) {
	  const { WebSocket } = requireWebsocket();

	  undici.WebSocket = WebSocket;
	}

	undici.request = makeDispatcher(api.request);
	undici.stream = makeDispatcher(api.stream);
	undici.pipeline = makeDispatcher(api.pipeline);
	undici.connect = makeDispatcher(api.connect);
	undici.upgrade = makeDispatcher(api.upgrade);

	undici.MockClient = MockClient;
	undici.MockPool = MockPool;
	undici.MockAgent = MockAgent;
	undici.mockErrors = mockErrors;
	return undici;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	/* eslint-disable @typescript-eslint/no-explicit-any */
	var __createBinding = (lib && lib.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lib && lib.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lib && lib.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (lib && lib.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(lib, "__esModule", { value: true });
	lib.HttpClient = lib.isHttps = lib.HttpClientResponse = lib.HttpClientError = lib.getProxyUrl = lib.MediaTypes = lib.Headers = lib.HttpCodes = void 0;
	const http = __importStar(require$$2$1);
	const https = __importStar(require$$3$1);
	const pm = __importStar(requireProxy());
	const tunnel = __importStar(requireTunnel());
	const undici_1 = requireUndici();
	var HttpCodes;
	(function (HttpCodes) {
	    HttpCodes[HttpCodes["OK"] = 200] = "OK";
	    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
	    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
	    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
	    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
	    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
	    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
	    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
	    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
	    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
	    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
	    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
	    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
	    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
	    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
	    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
	    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
	    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
	    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
	    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
	    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
	    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
	    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
	    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
	    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
	    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
	    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (lib.HttpCodes = HttpCodes = {}));
	var Headers;
	(function (Headers) {
	    Headers["Accept"] = "accept";
	    Headers["ContentType"] = "content-type";
	})(Headers || (lib.Headers = Headers = {}));
	var MediaTypes;
	(function (MediaTypes) {
	    MediaTypes["ApplicationJson"] = "application/json";
	})(MediaTypes || (lib.MediaTypes = MediaTypes = {}));
	/**
	 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	 */
	function getProxyUrl(serverUrl) {
	    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
	    return proxyUrl ? proxyUrl.href : '';
	}
	lib.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
	    HttpCodes.MovedPermanently,
	    HttpCodes.ResourceMoved,
	    HttpCodes.SeeOther,
	    HttpCodes.TemporaryRedirect,
	    HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
	    HttpCodes.BadGateway,
	    HttpCodes.ServiceUnavailable,
	    HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	class HttpClientError extends Error {
	    constructor(message, statusCode) {
	        super(message);
	        this.name = 'HttpClientError';
	        this.statusCode = statusCode;
	        Object.setPrototypeOf(this, HttpClientError.prototype);
	    }
	}
	lib.HttpClientError = HttpClientError;
	class HttpClientResponse {
	    constructor(message) {
	        this.message = message;
	    }
	    readBody() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
	                let output = Buffer.alloc(0);
	                this.message.on('data', (chunk) => {
	                    output = Buffer.concat([output, chunk]);
	                });
	                this.message.on('end', () => {
	                    resolve(output.toString());
	                });
	            }));
	        });
	    }
	    readBodyBuffer() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
	                const chunks = [];
	                this.message.on('data', (chunk) => {
	                    chunks.push(chunk);
	                });
	                this.message.on('end', () => {
	                    resolve(Buffer.concat(chunks));
	                });
	            }));
	        });
	    }
	}
	lib.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
	    const parsedUrl = new URL(requestUrl);
	    return parsedUrl.protocol === 'https:';
	}
	lib.isHttps = isHttps;
	class HttpClient {
	    constructor(userAgent, handlers, requestOptions) {
	        this._ignoreSslError = false;
	        this._allowRedirects = true;
	        this._allowRedirectDowngrade = false;
	        this._maxRedirects = 50;
	        this._allowRetries = false;
	        this._maxRetries = 1;
	        this._keepAlive = false;
	        this._disposed = false;
	        this.userAgent = userAgent;
	        this.handlers = handlers || [];
	        this.requestOptions = requestOptions;
	        if (requestOptions) {
	            if (requestOptions.ignoreSslError != null) {
	                this._ignoreSslError = requestOptions.ignoreSslError;
	            }
	            this._socketTimeout = requestOptions.socketTimeout;
	            if (requestOptions.allowRedirects != null) {
	                this._allowRedirects = requestOptions.allowRedirects;
	            }
	            if (requestOptions.allowRedirectDowngrade != null) {
	                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
	            }
	            if (requestOptions.maxRedirects != null) {
	                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
	            }
	            if (requestOptions.keepAlive != null) {
	                this._keepAlive = requestOptions.keepAlive;
	            }
	            if (requestOptions.allowRetries != null) {
	                this._allowRetries = requestOptions.allowRetries;
	            }
	            if (requestOptions.maxRetries != null) {
	                this._maxRetries = requestOptions.maxRetries;
	            }
	        }
	    }
	    options(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    get(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('GET', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    del(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    post(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('POST', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    patch(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    put(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('PUT', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    head(requestUrl, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    sendStream(verb, requestUrl, stream, additionalHeaders) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.request(verb, requestUrl, stream, additionalHeaders);
	        });
	    }
	    /**
	     * Gets a typed object from an endpoint
	     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
	     */
	    getJson(requestUrl, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            const res = yield this.get(requestUrl, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    postJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.post(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    putJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.put(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    patchJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.patch(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    /**
	     * Makes a raw http request.
	     * All other methods such as get, post, patch, and request ultimately call this.
	     * Prefer get, del, post and patch
	     */
	    request(verb, requestUrl, data, headers) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._disposed) {
	                throw new Error('Client has already been disposed.');
	            }
	            const parsedUrl = new URL(requestUrl);
	            let info = this._prepareRequest(verb, parsedUrl, headers);
	            // Only perform retries on reads since writes may not be idempotent.
	            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
	                ? this._maxRetries + 1
	                : 1;
	            let numTries = 0;
	            let response;
	            do {
	                response = yield this.requestRaw(info, data);
	                // Check if it's an authentication challenge
	                if (response &&
	                    response.message &&
	                    response.message.statusCode === HttpCodes.Unauthorized) {
	                    let authenticationHandler;
	                    for (const handler of this.handlers) {
	                        if (handler.canHandleAuthentication(response)) {
	                            authenticationHandler = handler;
	                            break;
	                        }
	                    }
	                    if (authenticationHandler) {
	                        return authenticationHandler.handleAuthentication(this, info, data);
	                    }
	                    else {
	                        // We have received an unauthorized response but have no handlers to handle it.
	                        // Let the response return to the caller.
	                        return response;
	                    }
	                }
	                let redirectsRemaining = this._maxRedirects;
	                while (response.message.statusCode &&
	                    HttpRedirectCodes.includes(response.message.statusCode) &&
	                    this._allowRedirects &&
	                    redirectsRemaining > 0) {
	                    const redirectUrl = response.message.headers['location'];
	                    if (!redirectUrl) {
	                        // if there's no location to redirect to, we won't
	                        break;
	                    }
	                    const parsedRedirectUrl = new URL(redirectUrl);
	                    if (parsedUrl.protocol === 'https:' &&
	                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
	                        !this._allowRedirectDowngrade) {
	                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
	                    }
	                    // we need to finish reading the response before reassigning response
	                    // which will leak the open socket.
	                    yield response.readBody();
	                    // strip authorization header if redirected to a different hostname
	                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
	                        for (const header in headers) {
	                            // header names are case insensitive
	                            if (header.toLowerCase() === 'authorization') {
	                                delete headers[header];
	                            }
	                        }
	                    }
	                    // let's make the request with the new redirectUrl
	                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
	                    response = yield this.requestRaw(info, data);
	                    redirectsRemaining--;
	                }
	                if (!response.message.statusCode ||
	                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
	                    // If not a retry code, return immediately instead of retrying
	                    return response;
	                }
	                numTries += 1;
	                if (numTries < maxTries) {
	                    yield response.readBody();
	                    yield this._performExponentialBackoff(numTries);
	                }
	            } while (numTries < maxTries);
	            return response;
	        });
	    }
	    /**
	     * Needs to be called if keepAlive is set to true in request options.
	     */
	    dispose() {
	        if (this._agent) {
	            this._agent.destroy();
	        }
	        this._disposed = true;
	    }
	    /**
	     * Raw request.
	     * @param info
	     * @param data
	     */
	    requestRaw(info, data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => {
	                function callbackForResult(err, res) {
	                    if (err) {
	                        reject(err);
	                    }
	                    else if (!res) {
	                        // If `err` is not passed, then `res` must be passed.
	                        reject(new Error('Unknown error'));
	                    }
	                    else {
	                        resolve(res);
	                    }
	                }
	                this.requestRawWithCallback(info, data, callbackForResult);
	            });
	        });
	    }
	    /**
	     * Raw request with callback.
	     * @param info
	     * @param data
	     * @param onResult
	     */
	    requestRawWithCallback(info, data, onResult) {
	        if (typeof data === 'string') {
	            if (!info.options.headers) {
	                info.options.headers = {};
	            }
	            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
	        }
	        let callbackCalled = false;
	        function handleResult(err, res) {
	            if (!callbackCalled) {
	                callbackCalled = true;
	                onResult(err, res);
	            }
	        }
	        const req = info.httpModule.request(info.options, (msg) => {
	            const res = new HttpClientResponse(msg);
	            handleResult(undefined, res);
	        });
	        let socket;
	        req.on('socket', sock => {
	            socket = sock;
	        });
	        // If we ever get disconnected, we want the socket to timeout eventually
	        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
	            if (socket) {
	                socket.end();
	            }
	            handleResult(new Error(`Request timeout: ${info.options.path}`));
	        });
	        req.on('error', function (err) {
	            // err has statusCode property
	            // res should have headers
	            handleResult(err);
	        });
	        if (data && typeof data === 'string') {
	            req.write(data, 'utf8');
	        }
	        if (data && typeof data !== 'string') {
	            data.on('close', function () {
	                req.end();
	            });
	            data.pipe(req);
	        }
	        else {
	            req.end();
	        }
	    }
	    /**
	     * Gets an http agent. This function is useful when you need an http agent that handles
	     * routing through a proxy server - depending upon the url and proxy environment variables.
	     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	     */
	    getAgent(serverUrl) {
	        const parsedUrl = new URL(serverUrl);
	        return this._getAgent(parsedUrl);
	    }
	    getAgentDispatcher(serverUrl) {
	        const parsedUrl = new URL(serverUrl);
	        const proxyUrl = pm.getProxyUrl(parsedUrl);
	        const useProxy = proxyUrl && proxyUrl.hostname;
	        if (!useProxy) {
	            return;
	        }
	        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
	    }
	    _prepareRequest(method, requestUrl, headers) {
	        const info = {};
	        info.parsedUrl = requestUrl;
	        const usingSsl = info.parsedUrl.protocol === 'https:';
	        info.httpModule = usingSsl ? https : http;
	        const defaultPort = usingSsl ? 443 : 80;
	        info.options = {};
	        info.options.host = info.parsedUrl.hostname;
	        info.options.port = info.parsedUrl.port
	            ? parseInt(info.parsedUrl.port)
	            : defaultPort;
	        info.options.path =
	            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
	        info.options.method = method;
	        info.options.headers = this._mergeHeaders(headers);
	        if (this.userAgent != null) {
	            info.options.headers['user-agent'] = this.userAgent;
	        }
	        info.options.agent = this._getAgent(info.parsedUrl);
	        // gives handlers an opportunity to participate
	        if (this.handlers) {
	            for (const handler of this.handlers) {
	                handler.prepareRequest(info.options);
	            }
	        }
	        return info;
	    }
	    _mergeHeaders(headers) {
	        if (this.requestOptions && this.requestOptions.headers) {
	            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
	        }
	        return lowercaseKeys(headers || {});
	    }
	    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
	        let clientHeader;
	        if (this.requestOptions && this.requestOptions.headers) {
	            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
	        }
	        return additionalHeaders[header] || clientHeader || _default;
	    }
	    _getAgent(parsedUrl) {
	        let agent;
	        const proxyUrl = pm.getProxyUrl(parsedUrl);
	        const useProxy = proxyUrl && proxyUrl.hostname;
	        if (this._keepAlive && useProxy) {
	            agent = this._proxyAgent;
	        }
	        if (!useProxy) {
	            agent = this._agent;
	        }
	        // if agent is already assigned use that agent.
	        if (agent) {
	            return agent;
	        }
	        const usingSsl = parsedUrl.protocol === 'https:';
	        let maxSockets = 100;
	        if (this.requestOptions) {
	            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
	        }
	        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
	        if (proxyUrl && proxyUrl.hostname) {
	            const agentOptions = {
	                maxSockets,
	                keepAlive: this._keepAlive,
	                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
	                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
	                })), { host: proxyUrl.hostname, port: proxyUrl.port })
	            };
	            let tunnelAgent;
	            const overHttps = proxyUrl.protocol === 'https:';
	            if (usingSsl) {
	                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
	            }
	            else {
	                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
	            }
	            agent = tunnelAgent(agentOptions);
	            this._proxyAgent = agent;
	        }
	        // if tunneling agent isn't assigned create a new agent
	        if (!agent) {
	            const options = { keepAlive: this._keepAlive, maxSockets };
	            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
	            this._agent = agent;
	        }
	        if (usingSsl && this._ignoreSslError) {
	            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
	            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
	            // we have to cast it to any and change it directly
	            agent.options = Object.assign(agent.options || {}, {
	                rejectUnauthorized: false
	            });
	        }
	        return agent;
	    }
	    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
	        let proxyAgent;
	        if (this._keepAlive) {
	            proxyAgent = this._proxyAgentDispatcher;
	        }
	        // if agent is already assigned use that agent.
	        if (proxyAgent) {
	            return proxyAgent;
	        }
	        const usingSsl = parsedUrl.protocol === 'https:';
	        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, ((proxyUrl.username || proxyUrl.password) && {
	            token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString('base64')}`
	        })));
	        this._proxyAgentDispatcher = proxyAgent;
	        if (usingSsl && this._ignoreSslError) {
	            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
	            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
	            // we have to cast it to any and change it directly
	            proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
	                rejectUnauthorized: false
	            });
	        }
	        return proxyAgent;
	    }
	    _performExponentialBackoff(retryNumber) {
	        return __awaiter(this, void 0, void 0, function* () {
	            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
	            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
	            return new Promise(resolve => setTimeout(() => resolve(), ms));
	        });
	    }
	    _processResponse(res, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                const statusCode = res.message.statusCode || 0;
	                const response = {
	                    statusCode,
	                    result: null,
	                    headers: {}
	                };
	                // not found leads to null obj returned
	                if (statusCode === HttpCodes.NotFound) {
	                    resolve(response);
	                }
	                // get the result from the body
	                function dateTimeDeserializer(key, value) {
	                    if (typeof value === 'string') {
	                        const a = new Date(value);
	                        if (!isNaN(a.valueOf())) {
	                            return a;
	                        }
	                    }
	                    return value;
	                }
	                let obj;
	                let contents;
	                try {
	                    contents = yield res.readBody();
	                    if (contents && contents.length > 0) {
	                        if (options && options.deserializeDates) {
	                            obj = JSON.parse(contents, dateTimeDeserializer);
	                        }
	                        else {
	                            obj = JSON.parse(contents);
	                        }
	                        response.result = obj;
	                    }
	                    response.headers = res.message.headers;
	                }
	                catch (err) {
	                    // Invalid resource (contents not json);  leaving result obj null
	                }
	                // note that 3xx redirects are handled by the http layer.
	                if (statusCode > 299) {
	                    let msg;
	                    // if exception/error in body, attempt to get better error
	                    if (obj && obj.message) {
	                        msg = obj.message;
	                    }
	                    else if (contents && contents.length > 0) {
	                        // it may be the case that the exception is in the body message as string
	                        msg = contents;
	                    }
	                    else {
	                        msg = `Failed request: (${statusCode})`;
	                    }
	                    const err = new HttpClientError(msg, statusCode);
	                    err.result = response.result;
	                    reject(err);
	                }
	                else {
	                    resolve(response);
	                }
	            }));
	        });
	    }
	}
	lib.HttpClient = HttpClient;
	const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
	
	return lib;
}

var auth$1 = {};

var hasRequiredAuth;

function requireAuth () {
	if (hasRequiredAuth) return auth$1;
	hasRequiredAuth = 1;
	var __awaiter = (auth$1 && auth$1.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(auth$1, "__esModule", { value: true });
	auth$1.PersonalAccessTokenCredentialHandler = auth$1.BearerCredentialHandler = auth$1.BasicCredentialHandler = void 0;
	class BasicCredentialHandler {
	    constructor(username, password) {
	        this.username = username;
	        this.password = password;
	    }
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth$1.BasicCredentialHandler = BasicCredentialHandler;
	class BearerCredentialHandler {
	    constructor(token) {
	        this.token = token;
	    }
	    // currently implements pre-authorization
	    // TODO: support preAuth = false where it hooks on 401
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Bearer ${this.token}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth$1.BearerCredentialHandler = BearerCredentialHandler;
	class PersonalAccessTokenCredentialHandler {
	    constructor(token) {
	        this.token = token;
	    }
	    // currently implements pre-authorization
	    // TODO: support preAuth = false where it hooks on 401
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth$1.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
	
	return auth$1;
}

var hasRequiredOidcUtils;

function requireOidcUtils () {
	if (hasRequiredOidcUtils) return oidcUtils;
	hasRequiredOidcUtils = 1;
	var __awaiter = (oidcUtils && oidcUtils.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(oidcUtils, "__esModule", { value: true });
	oidcUtils.OidcClient = void 0;
	const http_client_1 = requireLib();
	const auth_1 = requireAuth();
	const core_1 = requireCore();
	class OidcClient {
	    static createHttpClient(allowRetry = true, maxRetry = 10) {
	        const requestOptions = {
	            allowRetries: allowRetry,
	            maxRetries: maxRetry
	        };
	        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
	    }
	    static getRequestToken() {
	        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
	        if (!token) {
	            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
	        }
	        return token;
	    }
	    static getIDTokenUrl() {
	        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
	        if (!runtimeUrl) {
	            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
	        }
	        return runtimeUrl;
	    }
	    static getCall(id_token_url) {
	        var _a;
	        return __awaiter(this, void 0, void 0, function* () {
	            const httpclient = OidcClient.createHttpClient();
	            const res = yield httpclient
	                .getJson(id_token_url)
	                .catch(error => {
	                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
	            });
	            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
	            if (!id_token) {
	                throw new Error('Response json body do not have ID Token field');
	            }
	            return id_token;
	        });
	    }
	    static getIDToken(audience) {
	        return __awaiter(this, void 0, void 0, function* () {
	            try {
	                // New ID Token is requested from action service
	                let id_token_url = OidcClient.getIDTokenUrl();
	                if (audience) {
	                    const encodedAudience = encodeURIComponent(audience);
	                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
	                }
	                (0, core_1.debug)(`ID token url is ${id_token_url}`);
	                const id_token = yield OidcClient.getCall(id_token_url);
	                (0, core_1.setSecret)(id_token);
	                return id_token;
	            }
	            catch (error) {
	                throw new Error(`Error message: ${error.message}`);
	            }
	        });
	    }
	}
	oidcUtils.OidcClient = OidcClient;
	
	return oidcUtils;
}

var summary = {};

var hasRequiredSummary;

function requireSummary () {
	if (hasRequiredSummary) return summary;
	hasRequiredSummary = 1;
	(function (exports) {
		var __awaiter = (summary && summary.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
		const os_1 = require$$0$3;
		const fs_1 = require$$0;
		const { access, appendFile, writeFile } = fs_1.promises;
		exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
		exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
		class Summary {
		    constructor() {
		        this._buffer = '';
		    }
		    /**
		     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		     * Also checks r/w permissions.
		     *
		     * @returns step summary file path
		     */
		    filePath() {
		        return __awaiter(this, void 0, void 0, function* () {
		            if (this._filePath) {
		                return this._filePath;
		            }
		            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
		            if (!pathFromEnv) {
		                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
		            }
		            try {
		                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
		            }
		            catch (_a) {
		                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
		            }
		            this._filePath = pathFromEnv;
		            return this._filePath;
		        });
		    }
		    /**
		     * Wraps content in an HTML tag, adding any HTML attributes
		     *
		     * @param {string} tag HTML tag to wrap
		     * @param {string | null} content content within the tag
		     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		     *
		     * @returns {string} content wrapped in HTML element
		     */
		    wrap(tag, content, attrs = {}) {
		        const htmlAttrs = Object.entries(attrs)
		            .map(([key, value]) => ` ${key}="${value}"`)
		            .join('');
		        if (!content) {
		            return `<${tag}${htmlAttrs}>`;
		        }
		        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		    }
		    /**
		     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		     *
		     * @param {SummaryWriteOptions} [options] (optional) options for write operation
		     *
		     * @returns {Promise<Summary>} summary instance
		     */
		    write(options) {
		        return __awaiter(this, void 0, void 0, function* () {
		            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
		            const filePath = yield this.filePath();
		            const writeFunc = overwrite ? writeFile : appendFile;
		            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
		            return this.emptyBuffer();
		        });
		    }
		    /**
		     * Clears the summary buffer and wipes the summary file
		     *
		     * @returns {Summary} summary instance
		     */
		    clear() {
		        return __awaiter(this, void 0, void 0, function* () {
		            return this.emptyBuffer().write({ overwrite: true });
		        });
		    }
		    /**
		     * Returns the current summary buffer as a string
		     *
		     * @returns {string} string of summary buffer
		     */
		    stringify() {
		        return this._buffer;
		    }
		    /**
		     * If the summary buffer is empty
		     *
		     * @returns {boolen} true if the buffer is empty
		     */
		    isEmptyBuffer() {
		        return this._buffer.length === 0;
		    }
		    /**
		     * Resets the summary buffer without writing to summary file
		     *
		     * @returns {Summary} summary instance
		     */
		    emptyBuffer() {
		        this._buffer = '';
		        return this;
		    }
		    /**
		     * Adds raw text to the summary buffer
		     *
		     * @param {string} text content to add
		     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		     *
		     * @returns {Summary} summary instance
		     */
		    addRaw(text, addEOL = false) {
		        this._buffer += text;
		        return addEOL ? this.addEOL() : this;
		    }
		    /**
		     * Adds the operating system-specific end-of-line marker to the buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addEOL() {
		        return this.addRaw(os_1.EOL);
		    }
		    /**
		     * Adds an HTML codeblock to the summary buffer
		     *
		     * @param {string} code content to render within fenced code block
		     * @param {string} lang (optional) language to syntax highlight code
		     *
		     * @returns {Summary} summary instance
		     */
		    addCodeBlock(code, lang) {
		        const attrs = Object.assign({}, (lang && { lang }));
		        const element = this.wrap('pre', this.wrap('code', code), attrs);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML list to the summary buffer
		     *
		     * @param {string[]} items list of items to render
		     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		     *
		     * @returns {Summary} summary instance
		     */
		    addList(items, ordered = false) {
		        const tag = ordered ? 'ol' : 'ul';
		        const listItems = items.map(item => this.wrap('li', item)).join('');
		        const element = this.wrap(tag, listItems);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML table to the summary buffer
		     *
		     * @param {SummaryTableCell[]} rows table rows
		     *
		     * @returns {Summary} summary instance
		     */
		    addTable(rows) {
		        const tableBody = rows
		            .map(row => {
		            const cells = row
		                .map(cell => {
		                if (typeof cell === 'string') {
		                    return this.wrap('td', cell);
		                }
		                const { header, data, colspan, rowspan } = cell;
		                const tag = header ? 'th' : 'td';
		                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
		                return this.wrap(tag, data, attrs);
		            })
		                .join('');
		            return this.wrap('tr', cells);
		        })
		            .join('');
		        const element = this.wrap('table', tableBody);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds a collapsable HTML details element to the summary buffer
		     *
		     * @param {string} label text for the closed state
		     * @param {string} content collapsable content
		     *
		     * @returns {Summary} summary instance
		     */
		    addDetails(label, content) {
		        const element = this.wrap('details', this.wrap('summary', label) + content);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML image tag to the summary buffer
		     *
		     * @param {string} src path to the image you to embed
		     * @param {string} alt text description of the image
		     * @param {SummaryImageOptions} options (optional) addition image attributes
		     *
		     * @returns {Summary} summary instance
		     */
		    addImage(src, alt, options) {
		        const { width, height } = options || {};
		        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
		        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML section heading element
		     *
		     * @param {string} text heading text
		     * @param {number | string} [level=1] (optional) the heading level, default: 1
		     *
		     * @returns {Summary} summary instance
		     */
		    addHeading(text, level) {
		        const tag = `h${level}`;
		        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
		            ? tag
		            : 'h1';
		        const element = this.wrap(allowedTag, text);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML thematic break (<hr>) to the summary buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addSeparator() {
		        const element = this.wrap('hr', null);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML line break (<br>) to the summary buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addBreak() {
		        const element = this.wrap('br', null);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML blockquote to the summary buffer
		     *
		     * @param {string} text quote text
		     * @param {string} cite (optional) citation url
		     *
		     * @returns {Summary} summary instance
		     */
		    addQuote(text, cite) {
		        const attrs = Object.assign({}, (cite && { cite }));
		        const element = this.wrap('blockquote', text, attrs);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML anchor tag to the summary buffer
		     *
		     * @param {string} text link text/content
		     * @param {string} href hyperlink
		     *
		     * @returns {Summary} summary instance
		     */
		    addLink(text, href) {
		        const element = this.wrap('a', text, { href });
		        return this.addRaw(element).addEOL();
		    }
		}
		const _summary = new Summary();
		/**
		 * @deprecated use `core.summary`
		 */
		exports.markdownSummary = _summary;
		exports.summary = _summary;
		
	} (summary));
	return summary;
}

var pathUtils = {};

var hasRequiredPathUtils;

function requirePathUtils () {
	if (hasRequiredPathUtils) return pathUtils;
	hasRequiredPathUtils = 1;
	var __createBinding = (pathUtils && pathUtils.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (pathUtils && pathUtils.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (pathUtils && pathUtils.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(pathUtils, "__esModule", { value: true });
	pathUtils.toPlatformPath = pathUtils.toWin32Path = pathUtils.toPosixPath = void 0;
	const path = __importStar(require$$1$2);
	/**
	 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
	 * replaced with /.
	 *
	 * @param pth. Path to transform.
	 * @return string Posix path.
	 */
	function toPosixPath(pth) {
	    return pth.replace(/[\\]/g, '/');
	}
	pathUtils.toPosixPath = toPosixPath;
	/**
	 * toWin32Path converts the given path to the win32 form. On Linux, / will be
	 * replaced with \\.
	 *
	 * @param pth. Path to transform.
	 * @return string Win32 path.
	 */
	function toWin32Path(pth) {
	    return pth.replace(/[/]/g, '\\');
	}
	pathUtils.toWin32Path = toWin32Path;
	/**
	 * toPlatformPath converts the given path to a platform-specific path. It does
	 * this by replacing instances of / and \ with the platform-specific path
	 * separator.
	 *
	 * @param pth The path to platformize.
	 * @return string The platform-specific path.
	 */
	function toPlatformPath(pth) {
	    return pth.replace(/[/\\]/g, path.sep);
	}
	pathUtils.toPlatformPath = toPlatformPath;
	
	return pathUtils;
}

var platform = {};

var exec = {};

var toolrunner = {};

var io = {};

var ioUtil = {};

var hasRequiredIoUtil;

function requireIoUtil () {
	if (hasRequiredIoUtil) return ioUtil;
	hasRequiredIoUtil = 1;
	(function (exports) {
		var __createBinding = (ioUtil && ioUtil.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (ioUtil && ioUtil.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (ioUtil && ioUtil.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (ioUtil && ioUtil.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var _a;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
		const fs = __importStar(require$$0);
		const path = __importStar(require$$1$2);
		_a = fs.promises
		// export const {open} = 'fs'
		, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
		// export const {open} = 'fs'
		exports.IS_WINDOWS = process.platform === 'win32';
		// See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691
		exports.UV_FS_O_EXLOCK = 0x10000000;
		exports.READONLY = fs.constants.O_RDONLY;
		function exists(fsPath) {
		    return __awaiter(this, void 0, void 0, function* () {
		        try {
		            yield exports.stat(fsPath);
		        }
		        catch (err) {
		            if (err.code === 'ENOENT') {
		                return false;
		            }
		            throw err;
		        }
		        return true;
		    });
		}
		exports.exists = exists;
		function isDirectory(fsPath, useStat = false) {
		    return __awaiter(this, void 0, void 0, function* () {
		        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
		        return stats.isDirectory();
		    });
		}
		exports.isDirectory = isDirectory;
		/**
		 * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
		 * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
		 */
		function isRooted(p) {
		    p = normalizeSeparators(p);
		    if (!p) {
		        throw new Error('isRooted() parameter "p" cannot be empty');
		    }
		    if (exports.IS_WINDOWS) {
		        return (p.startsWith('\\') || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
		        ); // e.g. C: or C:\hello
		    }
		    return p.startsWith('/');
		}
		exports.isRooted = isRooted;
		/**
		 * Best effort attempt to determine whether a file exists and is executable.
		 * @param filePath    file path to check
		 * @param extensions  additional file extensions to try
		 * @return if file exists and is executable, returns the file path. otherwise empty string.
		 */
		function tryGetExecutablePath(filePath, extensions) {
		    return __awaiter(this, void 0, void 0, function* () {
		        let stats = undefined;
		        try {
		            // test file exists
		            stats = yield exports.stat(filePath);
		        }
		        catch (err) {
		            if (err.code !== 'ENOENT') {
		                // eslint-disable-next-line no-console
		                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
		            }
		        }
		        if (stats && stats.isFile()) {
		            if (exports.IS_WINDOWS) {
		                // on Windows, test for valid extension
		                const upperExt = path.extname(filePath).toUpperCase();
		                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {
		                    return filePath;
		                }
		            }
		            else {
		                if (isUnixExecutable(stats)) {
		                    return filePath;
		                }
		            }
		        }
		        // try each extension
		        const originalFilePath = filePath;
		        for (const extension of extensions) {
		            filePath = originalFilePath + extension;
		            stats = undefined;
		            try {
		                stats = yield exports.stat(filePath);
		            }
		            catch (err) {
		                if (err.code !== 'ENOENT') {
		                    // eslint-disable-next-line no-console
		                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
		                }
		            }
		            if (stats && stats.isFile()) {
		                if (exports.IS_WINDOWS) {
		                    // preserve the case of the actual file (since an extension was appended)
		                    try {
		                        const directory = path.dirname(filePath);
		                        const upperName = path.basename(filePath).toUpperCase();
		                        for (const actualName of yield exports.readdir(directory)) {
		                            if (upperName === actualName.toUpperCase()) {
		                                filePath = path.join(directory, actualName);
		                                break;
		                            }
		                        }
		                    }
		                    catch (err) {
		                        // eslint-disable-next-line no-console
		                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
		                    }
		                    return filePath;
		                }
		                else {
		                    if (isUnixExecutable(stats)) {
		                        return filePath;
		                    }
		                }
		            }
		        }
		        return '';
		    });
		}
		exports.tryGetExecutablePath = tryGetExecutablePath;
		function normalizeSeparators(p) {
		    p = p || '';
		    if (exports.IS_WINDOWS) {
		        // convert slashes on Windows
		        p = p.replace(/\//g, '\\');
		        // remove redundant slashes
		        return p.replace(/\\\\+/g, '\\');
		    }
		    // remove redundant slashes
		    return p.replace(/\/\/+/g, '/');
		}
		// on Mac/Linux, test the execute bit
		//     R   W  X  R  W X R W X
		//   256 128 64 32 16 8 4 2 1
		function isUnixExecutable(stats) {
		    return ((stats.mode & 1) > 0 ||
		        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
		        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));
		}
		// Get the path of cmd.exe in windows
		function getCmdPath() {
		    var _a;
		    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;
		}
		exports.getCmdPath = getCmdPath;
		
	} (ioUtil));
	return ioUtil;
}

var hasRequiredIo;

function requireIo () {
	if (hasRequiredIo) return io;
	hasRequiredIo = 1;
	var __createBinding = (io && io.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (io && io.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (io && io.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (io && io.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(io, "__esModule", { value: true });
	io.findInPath = io.which = io.mkdirP = io.rmRF = io.mv = io.cp = void 0;
	const assert_1 = require$$0$2;
	const path = __importStar(require$$1$2);
	const ioUtil = __importStar(requireIoUtil());
	/**
	 * Copies a file or folder.
	 * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	 *
	 * @param     source    source path
	 * @param     dest      destination path
	 * @param     options   optional. See CopyOptions.
	 */
	function cp(source, dest, options = {}) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
	        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
	        // Dest is an existing file, but not forcing
	        if (destStat && destStat.isFile() && !force) {
	            return;
	        }
	        // If dest is an existing directory, should copy inside.
	        const newDest = destStat && destStat.isDirectory() && copySourceDirectory
	            ? path.join(dest, path.basename(source))
	            : dest;
	        if (!(yield ioUtil.exists(source))) {
	            throw new Error(`no such file or directory: ${source}`);
	        }
	        const sourceStat = yield ioUtil.stat(source);
	        if (sourceStat.isDirectory()) {
	            if (!recursive) {
	                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
	            }
	            else {
	                yield cpDirRecursive(source, newDest, 0, force);
	            }
	        }
	        else {
	            if (path.relative(source, newDest) === '') {
	                // a file cannot be copied to itself
	                throw new Error(`'${newDest}' and '${source}' are the same file`);
	            }
	            yield copyFile(source, newDest, force);
	        }
	    });
	}
	io.cp = cp;
	/**
	 * Moves a path.
	 *
	 * @param     source    source path
	 * @param     dest      destination path
	 * @param     options   optional. See MoveOptions.
	 */
	function mv(source, dest, options = {}) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (yield ioUtil.exists(dest)) {
	            let destExists = true;
	            if (yield ioUtil.isDirectory(dest)) {
	                // If dest is directory copy src into dest
	                dest = path.join(dest, path.basename(source));
	                destExists = yield ioUtil.exists(dest);
	            }
	            if (destExists) {
	                if (options.force == null || options.force) {
	                    yield rmRF(dest);
	                }
	                else {
	                    throw new Error('Destination already exists');
	                }
	            }
	        }
	        yield mkdirP(path.dirname(dest));
	        yield ioUtil.rename(source, dest);
	    });
	}
	io.mv = mv;
	/**
	 * Remove a path recursively with force
	 *
	 * @param inputPath path to remove
	 */
	function rmRF(inputPath) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (ioUtil.IS_WINDOWS) {
	            // Check for invalid characters
	            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
	            if (/[*"<>|]/.test(inputPath)) {
	                throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
	            }
	        }
	        try {
	            // note if path does not exist, error is silent
	            yield ioUtil.rm(inputPath, {
	                force: true,
	                maxRetries: 3,
	                recursive: true,
	                retryDelay: 300
	            });
	        }
	        catch (err) {
	            throw new Error(`File was unable to be removed ${err}`);
	        }
	    });
	}
	io.rmRF = rmRF;
	/**
	 * Make a directory.  Creates the full path with folders in between
	 * Will throw if it fails
	 *
	 * @param   fsPath        path to create
	 * @returns Promise<void>
	 */
	function mkdirP(fsPath) {
	    return __awaiter(this, void 0, void 0, function* () {
	        assert_1.ok(fsPath, 'a path argument must be provided');
	        yield ioUtil.mkdir(fsPath, { recursive: true });
	    });
	}
	io.mkdirP = mkdirP;
	/**
	 * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	 * If you check and the tool does not exist, it will throw.
	 *
	 * @param     tool              name of the tool
	 * @param     check             whether to check if tool exists
	 * @returns   Promise<string>   path to tool
	 */
	function which(tool, check) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (!tool) {
	            throw new Error("parameter 'tool' is required");
	        }
	        // recursive when check=true
	        if (check) {
	            const result = yield which(tool, false);
	            if (!result) {
	                if (ioUtil.IS_WINDOWS) {
	                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
	                }
	                else {
	                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
	                }
	            }
	            return result;
	        }
	        const matches = yield findInPath(tool);
	        if (matches && matches.length > 0) {
	            return matches[0];
	        }
	        return '';
	    });
	}
	io.which = which;
	/**
	 * Returns a list of all occurrences of the given tool on the system path.
	 *
	 * @returns   Promise<string[]>  the paths of the tool
	 */
	function findInPath(tool) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if (!tool) {
	            throw new Error("parameter 'tool' is required");
	        }
	        // build the list of extensions to try
	        const extensions = [];
	        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {
	            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {
	                if (extension) {
	                    extensions.push(extension);
	                }
	            }
	        }
	        // if it's rooted, return it if exists. otherwise return empty.
	        if (ioUtil.isRooted(tool)) {
	            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
	            if (filePath) {
	                return [filePath];
	            }
	            return [];
	        }
	        // if any path separators, return empty
	        if (tool.includes(path.sep)) {
	            return [];
	        }
	        // build the list of directories
	        //
	        // Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
	        // it feels like we should not do this. Checking the current directory seems like more of a use
	        // case of a shell, and the which() function exposed by the toolkit should strive for consistency
	        // across platforms.
	        const directories = [];
	        if (process.env.PATH) {
	            for (const p of process.env.PATH.split(path.delimiter)) {
	                if (p) {
	                    directories.push(p);
	                }
	            }
	        }
	        // find all matches
	        const matches = [];
	        for (const directory of directories) {
	            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
	            if (filePath) {
	                matches.push(filePath);
	            }
	        }
	        return matches;
	    });
	}
	io.findInPath = findInPath;
	function readCopyOptions(options) {
	    const force = options.force == null ? true : options.force;
	    const recursive = Boolean(options.recursive);
	    const copySourceDirectory = options.copySourceDirectory == null
	        ? true
	        : Boolean(options.copySourceDirectory);
	    return { force, recursive, copySourceDirectory };
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
	    return __awaiter(this, void 0, void 0, function* () {
	        // Ensure there is not a run away recursive copy
	        if (currentDepth >= 255)
	            return;
	        currentDepth++;
	        yield mkdirP(destDir);
	        const files = yield ioUtil.readdir(sourceDir);
	        for (const fileName of files) {
	            const srcFile = `${sourceDir}/${fileName}`;
	            const destFile = `${destDir}/${fileName}`;
	            const srcFileStat = yield ioUtil.lstat(srcFile);
	            if (srcFileStat.isDirectory()) {
	                // Recurse
	                yield cpDirRecursive(srcFile, destFile, currentDepth, force);
	            }
	            else {
	                yield copyFile(srcFile, destFile, force);
	            }
	        }
	        // Change the mode for the newly created directory
	        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
	    });
	}
	// Buffered file copy
	function copyFile(srcFile, destFile, force) {
	    return __awaiter(this, void 0, void 0, function* () {
	        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
	            // unlink/re-link it
	            try {
	                yield ioUtil.lstat(destFile);
	                yield ioUtil.unlink(destFile);
	            }
	            catch (e) {
	                // Try to override file permission
	                if (e.code === 'EPERM') {
	                    yield ioUtil.chmod(destFile, '0666');
	                    yield ioUtil.unlink(destFile);
	                }
	                // other errors = it doesn't exist, no work to do
	            }
	            // Copy over symlink
	            const symlinkFull = yield ioUtil.readlink(srcFile);
	            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);
	        }
	        else if (!(yield ioUtil.exists(destFile)) || force) {
	            yield ioUtil.copyFile(srcFile, destFile);
	        }
	    });
	}
	
	return io;
}

var hasRequiredToolrunner;

function requireToolrunner () {
	if (hasRequiredToolrunner) return toolrunner;
	hasRequiredToolrunner = 1;
	var __createBinding = (toolrunner && toolrunner.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (toolrunner && toolrunner.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (toolrunner && toolrunner.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (toolrunner && toolrunner.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(toolrunner, "__esModule", { value: true });
	toolrunner.argStringToArray = toolrunner.ToolRunner = void 0;
	const os = __importStar(require$$0$3);
	const events = __importStar(require$$4$1);
	const child = __importStar(require$$2$3);
	const path = __importStar(require$$1$2);
	const io = __importStar(requireIo());
	const ioUtil = __importStar(requireIoUtil());
	const timers_1 = require$$4$3;
	/* eslint-disable @typescript-eslint/unbound-method */
	const IS_WINDOWS = process.platform === 'win32';
	/*
	 * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
	 */
	class ToolRunner extends events.EventEmitter {
	    constructor(toolPath, args, options) {
	        super();
	        if (!toolPath) {
	            throw new Error("Parameter 'toolPath' cannot be null or empty.");
	        }
	        this.toolPath = toolPath;
	        this.args = args || [];
	        this.options = options || {};
	    }
	    _debug(message) {
	        if (this.options.listeners && this.options.listeners.debug) {
	            this.options.listeners.debug(message);
	        }
	    }
	    _getCommandString(options, noPrefix) {
	        const toolPath = this._getSpawnFileName();
	        const args = this._getSpawnArgs(options);
	        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool
	        if (IS_WINDOWS) {
	            // Windows + cmd file
	            if (this._isCmdFile()) {
	                cmd += toolPath;
	                for (const a of args) {
	                    cmd += ` ${a}`;
	                }
	            }
	            // Windows + verbatim
	            else if (options.windowsVerbatimArguments) {
	                cmd += `"${toolPath}"`;
	                for (const a of args) {
	                    cmd += ` ${a}`;
	                }
	            }
	            // Windows (regular)
	            else {
	                cmd += this._windowsQuoteCmdArg(toolPath);
	                for (const a of args) {
	                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;
	                }
	            }
	        }
	        else {
	            // OSX/Linux - this can likely be improved with some form of quoting.
	            // creating processes on Unix is fundamentally different than Windows.
	            // on Unix, execvp() takes an arg array.
	            cmd += toolPath;
	            for (const a of args) {
	                cmd += ` ${a}`;
	            }
	        }
	        return cmd;
	    }
	    _processLineBuffer(data, strBuffer, onLine) {
	        try {
	            let s = strBuffer + data.toString();
	            let n = s.indexOf(os.EOL);
	            while (n > -1) {
	                const line = s.substring(0, n);
	                onLine(line);
	                // the rest of the string ...
	                s = s.substring(n + os.EOL.length);
	                n = s.indexOf(os.EOL);
	            }
	            return s;
	        }
	        catch (err) {
	            // streaming lines to console is best effort.  Don't fail a build.
	            this._debug(`error processing line. Failed with error ${err}`);
	            return '';
	        }
	    }
	    _getSpawnFileName() {
	        if (IS_WINDOWS) {
	            if (this._isCmdFile()) {
	                return process.env['COMSPEC'] || 'cmd.exe';
	            }
	        }
	        return this.toolPath;
	    }
	    _getSpawnArgs(options) {
	        if (IS_WINDOWS) {
	            if (this._isCmdFile()) {
	                let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
	                for (const a of this.args) {
	                    argline += ' ';
	                    argline += options.windowsVerbatimArguments
	                        ? a
	                        : this._windowsQuoteCmdArg(a);
	                }
	                argline += '"';
	                return [argline];
	            }
	        }
	        return this.args;
	    }
	    _endsWith(str, end) {
	        return str.endsWith(end);
	    }
	    _isCmdFile() {
	        const upperToolPath = this.toolPath.toUpperCase();
	        return (this._endsWith(upperToolPath, '.CMD') ||
	            this._endsWith(upperToolPath, '.BAT'));
	    }
	    _windowsQuoteCmdArg(arg) {
	        // for .exe, apply the normal quoting rules that libuv applies
	        if (!this._isCmdFile()) {
	            return this._uvQuoteCmdArg(arg);
	        }
	        // otherwise apply quoting rules specific to the cmd.exe command line parser.
	        // the libuv rules are generic and are not designed specifically for cmd.exe
	        // command line parser.
	        //
	        // for a detailed description of the cmd.exe command line parser, refer to
	        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
	        // need quotes for empty arg
	        if (!arg) {
	            return '""';
	        }
	        // determine whether the arg needs to be quoted
	        const cmdSpecialChars = [
	            ' ',
	            '\t',
	            '&',
	            '(',
	            ')',
	            '[',
	            ']',
	            '{',
	            '}',
	            '^',
	            '=',
	            ';',
	            '!',
	            "'",
	            '+',
	            ',',
	            '`',
	            '~',
	            '|',
	            '<',
	            '>',
	            '"'
	        ];
	        let needsQuotes = false;
	        for (const char of arg) {
	            if (cmdSpecialChars.some(x => x === char)) {
	                needsQuotes = true;
	                break;
	            }
	        }
	        // short-circuit if quotes not needed
	        if (!needsQuotes) {
	            return arg;
	        }
	        // the following quoting rules are very similar to the rules that by libuv applies.
	        //
	        // 1) wrap the string in quotes
	        //
	        // 2) double-up quotes - i.e. " => ""
	        //
	        //    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
	        //    doesn't work well with a cmd.exe command line.
	        //
	        //    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
	        //    for example, the command line:
	        //          foo.exe "myarg:""my val"""
	        //    is parsed by a .NET console app into an arg array:
	        //          [ "myarg:\"my val\"" ]
	        //    which is the same end result when applying libuv quoting rules. although the actual
	        //    command line from libuv quoting rules would look like:
	        //          foo.exe "myarg:\"my val\""
	        //
	        // 3) double-up slashes that precede a quote,
	        //    e.g.  hello \world    => "hello \world"
	        //          hello\"world    => "hello\\""world"
	        //          hello\\"world   => "hello\\\\""world"
	        //          hello world\    => "hello world\\"
	        //
	        //    technically this is not required for a cmd.exe command line, or the batch argument parser.
	        //    the reasons for including this as a .cmd quoting rule are:
	        //
	        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
	        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
	        //
	        //    b) it's what we've been doing previously (by deferring to node default behavior) and we
	        //       haven't heard any complaints about that aspect.
	        //
	        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
	        // escaped when used on the command line directly - even though within a .cmd file % can be escaped
	        // by using %%.
	        //
	        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
	        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
	        //
	        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
	        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
	        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
	        // to an external program.
	        //
	        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
	        // % can be escaped within a .cmd file.
	        let reverse = '"';
	        let quoteHit = true;
	        for (let i = arg.length; i > 0; i--) {
	            // walk the string in reverse
	            reverse += arg[i - 1];
	            if (quoteHit && arg[i - 1] === '\\') {
	                reverse += '\\'; // double the slash
	            }
	            else if (arg[i - 1] === '"') {
	                quoteHit = true;
	                reverse += '"'; // double the quote
	            }
	            else {
	                quoteHit = false;
	            }
	        }
	        reverse += '"';
	        return reverse
	            .split('')
	            .reverse()
	            .join('');
	    }
	    _uvQuoteCmdArg(arg) {
	        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as
	        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments
	        // is used.
	        //
	        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
	        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
	        // pasting copyright notice from Node within this function:
	        //
	        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
	        //
	        //      Permission is hereby granted, free of charge, to any person obtaining a copy
	        //      of this software and associated documentation files (the "Software"), to
	        //      deal in the Software without restriction, including without limitation the
	        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	        //      sell copies of the Software, and to permit persons to whom the Software is
	        //      furnished to do so, subject to the following conditions:
	        //
	        //      The above copyright notice and this permission notice shall be included in
	        //      all copies or substantial portions of the Software.
	        //
	        //      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	        //      IN THE SOFTWARE.
	        if (!arg) {
	            // Need double quotation for empty argument
	            return '""';
	        }
	        if (!arg.includes(' ') && !arg.includes('\t') && !arg.includes('"')) {
	            // No quotation needed
	            return arg;
	        }
	        if (!arg.includes('"') && !arg.includes('\\')) {
	            // No embedded double quotes or backslashes, so I can just wrap
	            // quote marks around the whole thing.
	            return `"${arg}"`;
	        }
	        // Expected input/output:
	        //   input : hello"world
	        //   output: "hello\"world"
	        //   input : hello""world
	        //   output: "hello\"\"world"
	        //   input : hello\world
	        //   output: hello\world
	        //   input : hello\\world
	        //   output: hello\\world
	        //   input : hello\"world
	        //   output: "hello\\\"world"
	        //   input : hello\\"world
	        //   output: "hello\\\\\"world"
	        //   input : hello world\
	        //   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
	        //                             but it appears the comment is wrong, it should be "hello world\\"
	        let reverse = '"';
	        let quoteHit = true;
	        for (let i = arg.length; i > 0; i--) {
	            // walk the string in reverse
	            reverse += arg[i - 1];
	            if (quoteHit && arg[i - 1] === '\\') {
	                reverse += '\\';
	            }
	            else if (arg[i - 1] === '"') {
	                quoteHit = true;
	                reverse += '\\';
	            }
	            else {
	                quoteHit = false;
	            }
	        }
	        reverse += '"';
	        return reverse
	            .split('')
	            .reverse()
	            .join('');
	    }
	    _cloneExecOptions(options) {
	        options = options || {};
	        const result = {
	            cwd: options.cwd || process.cwd(),
	            env: options.env || process.env,
	            silent: options.silent || false,
	            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
	            failOnStdErr: options.failOnStdErr || false,
	            ignoreReturnCode: options.ignoreReturnCode || false,
	            delay: options.delay || 10000
	        };
	        result.outStream = options.outStream || process.stdout;
	        result.errStream = options.errStream || process.stderr;
	        return result;
	    }
	    _getSpawnOptions(options, toolPath) {
	        options = options || {};
	        const result = {};
	        result.cwd = options.cwd;
	        result.env = options.env;
	        result['windowsVerbatimArguments'] =
	            options.windowsVerbatimArguments || this._isCmdFile();
	        if (options.windowsVerbatimArguments) {
	            result.argv0 = `"${toolPath}"`;
	        }
	        return result;
	    }
	    /**
	     * Exec a tool.
	     * Output will be streamed to the live console.
	     * Returns promise with return code
	     *
	     * @param     tool     path to tool to exec
	     * @param     options  optional exec options.  See ExecOptions
	     * @returns   number
	     */
	    exec() {
	        return __awaiter(this, void 0, void 0, function* () {
	            // root the tool path if it is unrooted and contains relative pathing
	            if (!ioUtil.isRooted(this.toolPath) &&
	                (this.toolPath.includes('/') ||
	                    (IS_WINDOWS && this.toolPath.includes('\\')))) {
	                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted
	                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
	            }
	            // if the tool is only a file name, then resolve it from the PATH
	            // otherwise verify it exists (add extension on Windows if necessary)
	            this.toolPath = yield io.which(this.toolPath, true);
	            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
	                this._debug(`exec tool: ${this.toolPath}`);
	                this._debug('arguments:');
	                for (const arg of this.args) {
	                    this._debug(`   ${arg}`);
	                }
	                const optionsNonNull = this._cloneExecOptions(this.options);
	                if (!optionsNonNull.silent && optionsNonNull.outStream) {
	                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
	                }
	                const state = new ExecState(optionsNonNull, this.toolPath);
	                state.on('debug', (message) => {
	                    this._debug(message);
	                });
	                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
	                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
	                }
	                const fileName = this._getSpawnFileName();
	                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
	                let stdbuffer = '';
	                if (cp.stdout) {
	                    cp.stdout.on('data', (data) => {
	                        if (this.options.listeners && this.options.listeners.stdout) {
	                            this.options.listeners.stdout(data);
	                        }
	                        if (!optionsNonNull.silent && optionsNonNull.outStream) {
	                            optionsNonNull.outStream.write(data);
	                        }
	                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
	                            if (this.options.listeners && this.options.listeners.stdline) {
	                                this.options.listeners.stdline(line);
	                            }
	                        });
	                    });
	                }
	                let errbuffer = '';
	                if (cp.stderr) {
	                    cp.stderr.on('data', (data) => {
	                        state.processStderr = true;
	                        if (this.options.listeners && this.options.listeners.stderr) {
	                            this.options.listeners.stderr(data);
	                        }
	                        if (!optionsNonNull.silent &&
	                            optionsNonNull.errStream &&
	                            optionsNonNull.outStream) {
	                            const s = optionsNonNull.failOnStdErr
	                                ? optionsNonNull.errStream
	                                : optionsNonNull.outStream;
	                            s.write(data);
	                        }
	                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
	                            if (this.options.listeners && this.options.listeners.errline) {
	                                this.options.listeners.errline(line);
	                            }
	                        });
	                    });
	                }
	                cp.on('error', (err) => {
	                    state.processError = err.message;
	                    state.processExited = true;
	                    state.processClosed = true;
	                    state.CheckComplete();
	                });
	                cp.on('exit', (code) => {
	                    state.processExitCode = code;
	                    state.processExited = true;
	                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
	                    state.CheckComplete();
	                });
	                cp.on('close', (code) => {
	                    state.processExitCode = code;
	                    state.processExited = true;
	                    state.processClosed = true;
	                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
	                    state.CheckComplete();
	                });
	                state.on('done', (error, exitCode) => {
	                    if (stdbuffer.length > 0) {
	                        this.emit('stdline', stdbuffer);
	                    }
	                    if (errbuffer.length > 0) {
	                        this.emit('errline', errbuffer);
	                    }
	                    cp.removeAllListeners();
	                    if (error) {
	                        reject(error);
	                    }
	                    else {
	                        resolve(exitCode);
	                    }
	                });
	                if (this.options.input) {
	                    if (!cp.stdin) {
	                        throw new Error('child process missing stdin');
	                    }
	                    cp.stdin.end(this.options.input);
	                }
	            }));
	        });
	    }
	}
	toolrunner.ToolRunner = ToolRunner;
	/**
	 * Convert an arg string to an array of args. Handles escaping
	 *
	 * @param    argString   string of arguments
	 * @returns  string[]    array of arguments
	 */
	function argStringToArray(argString) {
	    const args = [];
	    let inQuotes = false;
	    let escaped = false;
	    let arg = '';
	    function append(c) {
	        // we only escape double quotes.
	        if (escaped && c !== '"') {
	            arg += '\\';
	        }
	        arg += c;
	        escaped = false;
	    }
	    for (let i = 0; i < argString.length; i++) {
	        const c = argString.charAt(i);
	        if (c === '"') {
	            if (!escaped) {
	                inQuotes = !inQuotes;
	            }
	            else {
	                append(c);
	            }
	            continue;
	        }
	        if (c === '\\' && escaped) {
	            append(c);
	            continue;
	        }
	        if (c === '\\' && inQuotes) {
	            escaped = true;
	            continue;
	        }
	        if (c === ' ' && !inQuotes) {
	            if (arg.length > 0) {
	                args.push(arg);
	                arg = '';
	            }
	            continue;
	        }
	        append(c);
	    }
	    if (arg.length > 0) {
	        args.push(arg.trim());
	    }
	    return args;
	}
	toolrunner.argStringToArray = argStringToArray;
	class ExecState extends events.EventEmitter {
	    constructor(options, toolPath) {
	        super();
	        this.processClosed = false; // tracks whether the process has exited and stdio is closed
	        this.processError = '';
	        this.processExitCode = 0;
	        this.processExited = false; // tracks whether the process has exited
	        this.processStderr = false; // tracks whether stderr was written to
	        this.delay = 10000; // 10 seconds
	        this.done = false;
	        this.timeout = null;
	        if (!toolPath) {
	            throw new Error('toolPath must not be empty');
	        }
	        this.options = options;
	        this.toolPath = toolPath;
	        if (options.delay) {
	            this.delay = options.delay;
	        }
	    }
	    CheckComplete() {
	        if (this.done) {
	            return;
	        }
	        if (this.processClosed) {
	            this._setResult();
	        }
	        else if (this.processExited) {
	            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
	        }
	    }
	    _debug(message) {
	        this.emit('debug', message);
	    }
	    _setResult() {
	        // determine whether there is an error
	        let error;
	        if (this.processExited) {
	            if (this.processError) {
	                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
	            }
	            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
	                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
	            }
	            else if (this.processStderr && this.options.failOnStdErr) {
	                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
	            }
	        }
	        // clear the timeout
	        if (this.timeout) {
	            clearTimeout(this.timeout);
	            this.timeout = null;
	        }
	        this.done = true;
	        this.emit('done', error, this.processExitCode);
	    }
	    static HandleTimeout(state) {
	        if (state.done) {
	            return;
	        }
	        if (!state.processClosed && state.processExited) {
	            const message = `The STDIO streams did not close within ${state.delay /
	                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
	            state._debug(message);
	        }
	        state._setResult();
	    }
	}
	
	return toolrunner;
}

var hasRequiredExec;

function requireExec () {
	if (hasRequiredExec) return exec;
	hasRequiredExec = 1;
	var __createBinding = (exec && exec.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (exec && exec.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (exec && exec.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (exec && exec.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(exec, "__esModule", { value: true });
	exec.getExecOutput = exec.exec = void 0;
	const string_decoder_1 = require$$1$7;
	const tr = __importStar(requireToolrunner());
	/**
	 * Exec a command.
	 * Output will be streamed to the live console.
	 * Returns promise with return code
	 *
	 * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	 * @param     args               optional arguments for tool. Escaping is handled by the lib.
	 * @param     options            optional exec options.  See ExecOptions
	 * @returns   Promise<number>    exit code
	 */
	function exec$1(commandLine, args, options) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const commandArgs = tr.argStringToArray(commandLine);
	        if (commandArgs.length === 0) {
	            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
	        }
	        // Path to tool to execute should be first arg
	        const toolPath = commandArgs[0];
	        args = commandArgs.slice(1).concat(args || []);
	        const runner = new tr.ToolRunner(toolPath, args, options);
	        return runner.exec();
	    });
	}
	exec.exec = exec$1;
	/**
	 * Exec a command and get the output.
	 * Output will be streamed to the live console.
	 * Returns promise with the exit code and collected stdout and stderr
	 *
	 * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	 * @param     args                  optional arguments for tool. Escaping is handled by the lib.
	 * @param     options               optional exec options.  See ExecOptions
	 * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	 */
	function getExecOutput(commandLine, args, options) {
	    var _a, _b;
	    return __awaiter(this, void 0, void 0, function* () {
	        let stdout = '';
	        let stderr = '';
	        //Using string decoder covers the case where a mult-byte character is split
	        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');
	        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');
	        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
	        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
	        const stdErrListener = (data) => {
	            stderr += stderrDecoder.write(data);
	            if (originalStdErrListener) {
	                originalStdErrListener(data);
	            }
	        };
	        const stdOutListener = (data) => {
	            stdout += stdoutDecoder.write(data);
	            if (originalStdoutListener) {
	                originalStdoutListener(data);
	            }
	        };
	        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
	        const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
	        //flush any remaining characters
	        stdout += stdoutDecoder.end();
	        stderr += stderrDecoder.end();
	        return {
	            exitCode,
	            stdout,
	            stderr
	        };
	    });
	}
	exec.getExecOutput = getExecOutput;
	
	return exec;
}

var hasRequiredPlatform;

function requirePlatform () {
	if (hasRequiredPlatform) return platform;
	hasRequiredPlatform = 1;
	(function (exports) {
		var __createBinding = (platform && platform.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (platform && platform.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (platform && platform.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (platform && platform.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var __importDefault = (platform && platform.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
		const os_1 = __importDefault(require$$0$3);
		const exec = __importStar(requireExec());
		const getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		    const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', undefined, {
		        silent: true
		    });
		    const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', undefined, {
		        silent: true
		    });
		    return {
		        name: name.trim(),
		        version: version.trim()
		    };
		});
		const getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		    var _a, _b, _c, _d;
		    const { stdout } = yield exec.getExecOutput('sw_vers', undefined, {
		        silent: true
		    });
		    const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '';
		    const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : '';
		    return {
		        name,
		        version
		    };
		});
		const getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		    const { stdout } = yield exec.getExecOutput('lsb_release', ['-i', '-r', '-s'], {
		        silent: true
		    });
		    const [name, version] = stdout.trim().split('\n');
		    return {
		        name,
		        version
		    };
		});
		exports.platform = os_1.default.platform();
		exports.arch = os_1.default.arch();
		exports.isWindows = exports.platform === 'win32';
		exports.isMacOS = exports.platform === 'darwin';
		exports.isLinux = exports.platform === 'linux';
		function getDetails() {
		    return __awaiter(this, void 0, void 0, function* () {
		        return Object.assign(Object.assign({}, (yield (exports.isWindows
		            ? getWindowsInfo()
		            : exports.isMacOS
		                ? getMacOsInfo()
		                : getLinuxInfo()))), { platform: exports.platform,
		            arch: exports.arch,
		            isWindows: exports.isWindows,
		            isMacOS: exports.isMacOS,
		            isLinux: exports.isLinux });
		    });
		}
		exports.getDetails = getDetails;
		
	} (platform));
	return platform;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	(function (exports) {
		var __createBinding = (core && core.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (core && core.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (core && core.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (core && core.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
		const command_1 = requireCommand();
		const file_command_1 = requireFileCommand();
		const utils_1 = requireUtils$3();
		const os = __importStar(require$$0$3);
		const path = __importStar(require$$1$2);
		const oidc_utils_1 = requireOidcUtils();
		/**
		 * The code to exit an action
		 */
		var ExitCode;
		(function (ExitCode) {
		    /**
		     * A code indicating that the action was successful
		     */
		    ExitCode[ExitCode["Success"] = 0] = "Success";
		    /**
		     * A code indicating that the action was a failure
		     */
		    ExitCode[ExitCode["Failure"] = 1] = "Failure";
		})(ExitCode || (exports.ExitCode = ExitCode = {}));
		//-----------------------------------------------------------------------
		// Variables
		//-----------------------------------------------------------------------
		/**
		 * Sets env variable for this action and future actions in the job
		 * @param name the name of the variable to set
		 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function exportVariable(name, val) {
		    const convertedVal = (0, utils_1.toCommandValue)(val);
		    process.env[name] = convertedVal;
		    const filePath = process.env['GITHUB_ENV'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('ENV', (0, file_command_1.prepareKeyValueMessage)(name, val));
		    }
		    (0, command_1.issueCommand)('set-env', { name }, convertedVal);
		}
		exports.exportVariable = exportVariable;
		/**
		 * Registers a secret which will get masked from logs
		 * @param secret value of the secret
		 */
		function setSecret(secret) {
		    (0, command_1.issueCommand)('add-mask', {}, secret);
		}
		exports.setSecret = setSecret;
		/**
		 * Prepends inputPath to the PATH (for this action and future actions)
		 * @param inputPath
		 */
		function addPath(inputPath) {
		    const filePath = process.env['GITHUB_PATH'] || '';
		    if (filePath) {
		        (0, file_command_1.issueFileCommand)('PATH', inputPath);
		    }
		    else {
		        (0, command_1.issueCommand)('add-path', {}, inputPath);
		    }
		    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
		}
		exports.addPath = addPath;
		/**
		 * Gets the value of an input.
		 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
		 * Returns an empty string if the value is not defined.
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   string
		 */
		function getInput(name, options) {
		    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
		    if (options && options.required && !val) {
		        throw new Error(`Input required and not supplied: ${name}`);
		    }
		    if (options && options.trimWhitespace === false) {
		        return val;
		    }
		    return val.trim();
		}
		exports.getInput = getInput;
		/**
		 * Gets the values of an multiline input.  Each value is also trimmed.
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   string[]
		 *
		 */
		function getMultilineInput(name, options) {
		    const inputs = getInput(name, options)
		        .split('\n')
		        .filter(x => x !== '');
		    if (options && options.trimWhitespace === false) {
		        return inputs;
		    }
		    return inputs.map(input => input.trim());
		}
		exports.getMultilineInput = getMultilineInput;
		/**
		 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
		 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
		 * The return value is also in boolean type.
		 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   boolean
		 */
		function getBooleanInput(name, options) {
		    const trueValue = ['true', 'True', 'TRUE'];
		    const falseValue = ['false', 'False', 'FALSE'];
		    const val = getInput(name, options);
		    if (trueValue.includes(val))
		        return true;
		    if (falseValue.includes(val))
		        return false;
		    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
		        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
		}
		exports.getBooleanInput = getBooleanInput;
		/**
		 * Sets the value of an output.
		 *
		 * @param     name     name of the output to set
		 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function setOutput(name, value) {
		    const filePath = process.env['GITHUB_OUTPUT'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('OUTPUT', (0, file_command_1.prepareKeyValueMessage)(name, value));
		    }
		    process.stdout.write(os.EOL);
		    (0, command_1.issueCommand)('set-output', { name }, (0, utils_1.toCommandValue)(value));
		}
		exports.setOutput = setOutput;
		/**
		 * Enables or disables the echoing of commands into stdout for the rest of the step.
		 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
		 *
		 */
		function setCommandEcho(enabled) {
		    (0, command_1.issue)('echo', enabled ? 'on' : 'off');
		}
		exports.setCommandEcho = setCommandEcho;
		//-----------------------------------------------------------------------
		// Results
		//-----------------------------------------------------------------------
		/**
		 * Sets the action status to failed.
		 * When the action exits it will be with an exit code of 1
		 * @param message add error issue message
		 */
		function setFailed(message) {
		    process.exitCode = ExitCode.Failure;
		    error(message);
		}
		exports.setFailed = setFailed;
		//-----------------------------------------------------------------------
		// Logging Commands
		//-----------------------------------------------------------------------
		/**
		 * Gets whether Actions Step Debug is on or not
		 */
		function isDebug() {
		    return process.env['RUNNER_DEBUG'] === '1';
		}
		exports.isDebug = isDebug;
		/**
		 * Writes debug message to user log
		 * @param message debug message
		 */
		function debug(message) {
		    (0, command_1.issueCommand)('debug', {}, message);
		}
		exports.debug = debug;
		/**
		 * Adds an error issue
		 * @param message error issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function error(message, properties = {}) {
		    (0, command_1.issueCommand)('error', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.error = error;
		/**
		 * Adds a warning issue
		 * @param message warning issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function warning(message, properties = {}) {
		    (0, command_1.issueCommand)('warning', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.warning = warning;
		/**
		 * Adds a notice issue
		 * @param message notice issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function notice(message, properties = {}) {
		    (0, command_1.issueCommand)('notice', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.notice = notice;
		/**
		 * Writes info to log with console.log.
		 * @param message info message
		 */
		function info(message) {
		    process.stdout.write(message + os.EOL);
		}
		exports.info = info;
		/**
		 * Begin an output group.
		 *
		 * Output until the next `groupEnd` will be foldable in this group
		 *
		 * @param name The name of the output group
		 */
		function startGroup(name) {
		    (0, command_1.issue)('group', name);
		}
		exports.startGroup = startGroup;
		/**
		 * End an output group.
		 */
		function endGroup() {
		    (0, command_1.issue)('endgroup');
		}
		exports.endGroup = endGroup;
		/**
		 * Wrap an asynchronous function call in a group.
		 *
		 * Returns the same type as the function itself.
		 *
		 * @param name The name of the group
		 * @param fn The function to wrap in the group
		 */
		function group(name, fn) {
		    return __awaiter(this, void 0, void 0, function* () {
		        startGroup(name);
		        let result;
		        try {
		            result = yield fn();
		        }
		        finally {
		            endGroup();
		        }
		        return result;
		    });
		}
		exports.group = group;
		//-----------------------------------------------------------------------
		// Wrapper action state
		//-----------------------------------------------------------------------
		/**
		 * Saves state for current action, the state can only be retrieved by this action's post job execution.
		 *
		 * @param     name     name of the state to store
		 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function saveState(name, value) {
		    const filePath = process.env['GITHUB_STATE'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('STATE', (0, file_command_1.prepareKeyValueMessage)(name, value));
		    }
		    (0, command_1.issueCommand)('save-state', { name }, (0, utils_1.toCommandValue)(value));
		}
		exports.saveState = saveState;
		/**
		 * Gets the value of an state set by this action's main execution.
		 *
		 * @param     name     name of the state to get
		 * @returns   string
		 */
		function getState(name) {
		    return process.env[`STATE_${name}`] || '';
		}
		exports.getState = getState;
		function getIDToken(aud) {
		    return __awaiter(this, void 0, void 0, function* () {
		        return yield oidc_utils_1.OidcClient.getIDToken(aud);
		    });
		}
		exports.getIDToken = getIDToken;
		/**
		 * Summary exports
		 */
		var summary_1 = requireSummary();
		Object.defineProperty(exports, "summary", { enumerable: true, get: function () { return summary_1.summary; } });
		/**
		 * @deprecated use core.summary
		 */
		var summary_2 = requireSummary();
		Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function () { return summary_2.markdownSummary; } });
		/**
		 * Path exports
		 */
		var path_utils_1 = requirePathUtils();
		Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });
		Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });
		Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });
		/**
		 * Platform utilities exports
		 */
		exports.platform = __importStar(requirePlatform());
		
	} (core));
	return core;
}

var coreExports = requireCore();

var github = {};

var context = {};

var hasRequiredContext;

function requireContext () {
	if (hasRequiredContext) return context;
	hasRequiredContext = 1;
	Object.defineProperty(context, "__esModule", { value: true });
	context.Context = void 0;
	const fs_1 = require$$0;
	const os_1 = require$$0$3;
	class Context {
	    /**
	     * Hydrate the context from the environment
	     */
	    constructor() {
	        var _a, _b, _c;
	        this.payload = {};
	        if (process.env.GITHUB_EVENT_PATH) {
	            if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
	                this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
	            }
	            else {
	                const path = process.env.GITHUB_EVENT_PATH;
	                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
	            }
	        }
	        this.eventName = process.env.GITHUB_EVENT_NAME;
	        this.sha = process.env.GITHUB_SHA;
	        this.ref = process.env.GITHUB_REF;
	        this.workflow = process.env.GITHUB_WORKFLOW;
	        this.action = process.env.GITHUB_ACTION;
	        this.actor = process.env.GITHUB_ACTOR;
	        this.job = process.env.GITHUB_JOB;
	        this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
	        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
	        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
	        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
	        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
	        this.graphqlUrl =
	            (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
	    }
	    get issue() {
	        const payload = this.payload;
	        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
	    }
	    get repo() {
	        if (process.env.GITHUB_REPOSITORY) {
	            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
	            return { owner, repo };
	        }
	        if (this.payload.repository) {
	            return {
	                owner: this.payload.repository.owner.login,
	                repo: this.payload.repository.name
	            };
	        }
	        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
	    }
	}
	context.Context = Context;
	
	return context;
}

var utils$1 = {};

var utils = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils;
	hasRequiredUtils$1 = 1;
	var __createBinding = (utils && utils.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (utils && utils.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (utils && utils.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (utils && utils.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.getApiBaseUrl = utils.getProxyFetch = utils.getProxyAgentDispatcher = utils.getProxyAgent = utils.getAuthString = void 0;
	const httpClient = __importStar(requireLib());
	const undici_1 = requireUndici();
	function getAuthString(token, options) {
	    if (!token && !options.auth) {
	        throw new Error('Parameter token or opts.auth is required');
	    }
	    else if (token && options.auth) {
	        throw new Error('Parameters token and opts.auth may not both be specified');
	    }
	    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
	}
	utils.getAuthString = getAuthString;
	function getProxyAgent(destinationUrl) {
	    const hc = new httpClient.HttpClient();
	    return hc.getAgent(destinationUrl);
	}
	utils.getProxyAgent = getProxyAgent;
	function getProxyAgentDispatcher(destinationUrl) {
	    const hc = new httpClient.HttpClient();
	    return hc.getAgentDispatcher(destinationUrl);
	}
	utils.getProxyAgentDispatcher = getProxyAgentDispatcher;
	function getProxyFetch(destinationUrl) {
	    const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
	    const proxyFetch = (url, opts) => __awaiter(this, void 0, void 0, function* () {
	        return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
	    });
	    return proxyFetch;
	}
	utils.getProxyFetch = getProxyFetch;
	function getApiBaseUrl() {
	    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
	}
	utils.getApiBaseUrl = getApiBaseUrl;
	
	return utils;
}

function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
    }
    if (typeof process === "object" && process.version !== undefined) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
}

var beforeAfterHook = {exports: {}};

var register_1;
var hasRequiredRegister;

function requireRegister () {
	if (hasRequiredRegister) return register_1;
	hasRequiredRegister = 1;
	register_1 = register;

	function register(state, name, method, options) {
	  if (typeof method !== "function") {
	    throw new Error("method for before hook must be a function");
	  }

	  if (!options) {
	    options = {};
	  }

	  if (Array.isArray(name)) {
	    return name.reverse().reduce(function (callback, name) {
	      return register.bind(null, state, name, callback, options);
	    }, method)();
	  }

	  return Promise.resolve().then(function () {
	    if (!state.registry[name]) {
	      return method(options);
	    }

	    return state.registry[name].reduce(function (method, registered) {
	      return registered.hook.bind(null, method, options);
	    }, method)();
	  });
	}
	return register_1;
}

var add;
var hasRequiredAdd;

function requireAdd () {
	if (hasRequiredAdd) return add;
	hasRequiredAdd = 1;
	add = addHook;

	function addHook(state, kind, name, hook) {
	  var orig = hook;
	  if (!state.registry[name]) {
	    state.registry[name] = [];
	  }

	  if (kind === "before") {
	    hook = function (method, options) {
	      return Promise.resolve()
	        .then(orig.bind(null, options))
	        .then(method.bind(null, options));
	    };
	  }

	  if (kind === "after") {
	    hook = function (method, options) {
	      var result;
	      return Promise.resolve()
	        .then(method.bind(null, options))
	        .then(function (result_) {
	          result = result_;
	          return orig(result, options);
	        })
	        .then(function () {
	          return result;
	        });
	    };
	  }

	  if (kind === "error") {
	    hook = function (method, options) {
	      return Promise.resolve()
	        .then(method.bind(null, options))
	        .catch(function (error) {
	          return orig(error, options);
	        });
	    };
	  }

	  state.registry[name].push({
	    hook: hook,
	    orig: orig,
	  });
	}
	return add;
}

var remove;
var hasRequiredRemove;

function requireRemove () {
	if (hasRequiredRemove) return remove;
	hasRequiredRemove = 1;
	remove = removeHook;

	function removeHook(state, name, method) {
	  if (!state.registry[name]) {
	    return;
	  }

	  var index = state.registry[name]
	    .map(function (registered) {
	      return registered.orig;
	    })
	    .indexOf(method);

	  if (index === -1) {
	    return;
	  }

	  state.registry[name].splice(index, 1);
	}
	return remove;
}

var hasRequiredBeforeAfterHook;

function requireBeforeAfterHook () {
	if (hasRequiredBeforeAfterHook) return beforeAfterHook.exports;
	hasRequiredBeforeAfterHook = 1;
	var register = requireRegister();
	var addHook = requireAdd();
	var removeHook = requireRemove();

	// bind with array of arguments: https://stackoverflow.com/a/21792913
	var bind = Function.bind;
	var bindable = bind.bind(bind);

	function bindApi(hook, state, name) {
	  var removeHookRef = bindable(removeHook, null).apply(
	    null,
	    name ? [state, name] : [state]
	  );
	  hook.api = { remove: removeHookRef };
	  hook.remove = removeHookRef;
	  ["before", "error", "after", "wrap"].forEach(function (kind) {
	    var args = name ? [state, kind, name] : [state, kind];
	    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
	  });
	}

	function HookSingular() {
	  var singularHookName = "h";
	  var singularHookState = {
	    registry: {},
	  };
	  var singularHook = register.bind(null, singularHookState, singularHookName);
	  bindApi(singularHook, singularHookState, singularHookName);
	  return singularHook;
	}

	function HookCollection() {
	  var state = {
	    registry: {},
	  };

	  var hook = register.bind(null, state);
	  bindApi(hook, state);

	  return hook;
	}

	var collectionHookDeprecationMessageDisplayed = false;
	function Hook() {
	  if (!collectionHookDeprecationMessageDisplayed) {
	    console.warn(
	      '[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'
	    );
	    collectionHookDeprecationMessageDisplayed = true;
	  }
	  return HookCollection();
	}

	Hook.Singular = HookSingular.bind();
	Hook.Collection = HookCollection.bind();

	beforeAfterHook.exports = Hook;
	// expose constructors as a named property for TypeScript
	beforeAfterHook.exports.Hook = Hook;
	beforeAfterHook.exports.Singular = Hook.Singular;
	beforeAfterHook.exports.Collection = Hook.Collection;
	return beforeAfterHook.exports;
}

var beforeAfterHookExports = requireBeforeAfterHook();

const VERSION$5 = "9.0.6";

const userAgent = `octokit-endpoint.js/${VERSION$5} ${getUserAgent()}`;
const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};

function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}

function isPlainObject$1(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}

function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject$1(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}

function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}

function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}

function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}

const urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}

function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}

function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}

function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}

function withDefaults$2(oldDefaults, newDefaults) {
  const DEFAULTS = merge(oldDefaults, newDefaults);
  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
  return Object.assign(endpoint, {
    DEFAULTS,
    defaults: withDefaults$2.bind(null, DEFAULTS),
    merge: merge.bind(null, DEFAULTS),
    parse
  });
}

const endpoint = withDefaults$2(null, DEFAULTS);

const VERSION$4 = "8.4.1";

function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}

class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}

var once$1 = {exports: {}};

var wrappy_1;
var hasRequiredWrappy;

function requireWrappy () {
	if (hasRequiredWrappy) return wrappy_1;
	hasRequiredWrappy = 1;
	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	wrappy_1 = wrappy;
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k];
	  });

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    var ret = fn.apply(this, args);
	    var cb = args[args.length-1];
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k];
	      });
	    }
	    return ret
	  }
	}
	return wrappy_1;
}

var hasRequiredOnce;

function requireOnce () {
	if (hasRequiredOnce) return once$1.exports;
	hasRequiredOnce = 1;
	var wrappy = requireWrappy();
	once$1.exports = wrappy(once);
	once$1.exports.strict = wrappy(onceStrict);

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  });

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  });
	});

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  f.called = false;
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  var name = fn.name || 'Function wrapped with `once`';
	  f.onceError = name + " shouldn't be called more than once";
	  f.called = false;
	  return f
	}
	return once$1.exports;
}

var onceExports = requireOnce();
var once = /*@__PURE__*/getDefaultExportFromCjs(onceExports);

const logOnceCode = once((deprecation) => console.warn(deprecation));
const logOnceHeaders = once((deprecation) => console.warn(deprecation));
class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          /(?<! ) .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(
          new Deprecation(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        );
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(
          new Deprecation(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        );
        return headers || {};
      }
    });
  }
}

function getBufferResponse(response) {
  return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if (requestOptions.request?.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    redirect: requestOptions.request?.redirect,
    headers: requestOptions.headers,
    signal: requestOptions.request?.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults$1(oldEndpoint, newDefaults) {
  const endpoint = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint.parse(endpointOptions));
    }
    const request = (route2, parameters2) => {
      return fetchWrapper(
        endpoint.parse(endpoint.merge(route2, parameters2))
      );
    };
    Object.assign(request, {
      endpoint,
      defaults: withDefaults$1.bind(null, endpoint)
    });
    return endpointOptions.request.hook(request, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint,
    defaults: withDefaults$1.bind(null, endpoint)
  });
}

const request = withDefaults$1(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION$4} ${getUserAgent()}`
  }
});

// pkg/dist-src/index.js

// pkg/dist-src/version.js
var VERSION$3 = "7.1.1";

// pkg/dist-src/error.js
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};

// pkg/dist-src/graphql.js
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}

// pkg/dist-src/with-defaults.js
function withDefaults(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}

// pkg/dist-src/index.js
withDefaults(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION$3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}

function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}

async function hook(token, request, route, parameters) {
  const endpoint = request.endpoint.merge(
    route,
    parameters
  );
  endpoint.headers.authorization = withAuthorizationPrefix(token);
  return request(endpoint);
}

const createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// pkg/dist-src/index.js

// pkg/dist-src/version.js
var VERSION$2 = "5.2.2";

// pkg/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
function createLogger(logger = {}) {
  if (typeof logger.debug !== "function") {
    logger.debug = noop;
  }
  if (typeof logger.info !== "function") {
    logger.info = noop;
  }
  if (typeof logger.warn !== "function") {
    logger.warn = consoleWarn;
  }
  if (typeof logger.error !== "function") {
    logger.error = consoleError;
  }
  return logger;
}
var userAgentTrail = `octokit-core.js/${VERSION$2} ${getUserAgent()}`;
var Octokit = class {
  static {
    this.VERSION = VERSION$2;
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  static {
    this.plugins = [];
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static {
        this.plugins = currentPlugins.concat(
          newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
        );
      }
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook = new beforeAfterHookExports.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = createLogger(options.log);
    this.hook = hook;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth = createTokenAuth(options.auth);
        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook.wrap("request", auth.hook);
      this.auth = auth;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
};

var distWeb$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Octokit: Octokit
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(distWeb$1);

const VERSION$1 = "10.4.1";

const Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: [
      "DELETE /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
      }
    ],
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getCommitAuthors: [
      "GET /repos/{owner}/{repo}/import/authors",
      {},
      {
        deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
      }
    ],
    getImportStatus: [
      "GET /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
      }
    ],
    getLargeFiles: [
      "GET /repos/{owner}/{repo}/import/large_files",
      {},
      {
        deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
      }
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    mapCommitAuthor: [
      "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
      {},
      {
        deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
      }
    ],
    setLfsPreference: [
      "PATCH /repos/{owner}/{repo}/import/lfs",
      {},
      {
        deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
      }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: [
      "PUT /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
      }
    ],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    updateImport: [
      "PATCH /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
      }
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteCustomOrganizationRole: [
      "DELETE /orgs/{org}/organization-roles/{role_id}"
    ],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    patchCustomOrganizationRole: [
      "PATCH /orgs/{org}/organization-roles/{role_id}"
    ],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

const endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
const handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return target.cache[methodName] = value;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return void 0;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name in options2) {
          octokit.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION$1;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION$1;

var distSrc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    legacyRestEndpointMethods: legacyRestEndpointMethods,
    restEndpointMethods: restEndpointMethods
});

var require$$3 = /*@__PURE__*/getAugmentedNamespace(distSrc);

// pkg/dist-src/version.js
var VERSION = "9.2.2";

// pkg/dist-src/normalize-paginated-list-response.js
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}

// pkg/dist-src/iterator.js
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^<>]+)>;\s*rel="next"/
          ) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}

// pkg/dist-src/paginate.js
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}

// pkg/dist-src/compose-paginate.js
var composePaginateRest = Object.assign(paginate, {
  iterator
});

// pkg/dist-src/generated/paginating-endpoints.js
var paginatingEndpoints = [
  "GET /advisories",
  "GET /app/hook/deliveries",
  "GET /app/installation-requests",
  "GET /app/installations",
  "GET /assignments/{assignment_id}/accepted_assignments",
  "GET /classrooms",
  "GET /classrooms/{classroom_id}/assignments",
  "GET /enterprises/{enterprise}/dependabot/alerts",
  "GET /enterprises/{enterprise}/secret-scanning/alerts",
  "GET /events",
  "GET /gists",
  "GET /gists/public",
  "GET /gists/starred",
  "GET /gists/{gist_id}/comments",
  "GET /gists/{gist_id}/commits",
  "GET /gists/{gist_id}/forks",
  "GET /installation/repositories",
  "GET /issues",
  "GET /licenses",
  "GET /marketplace_listing/plans",
  "GET /marketplace_listing/plans/{plan_id}/accounts",
  "GET /marketplace_listing/stubbed/plans",
  "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
  "GET /networks/{owner}/{repo}/events",
  "GET /notifications",
  "GET /organizations",
  "GET /orgs/{org}/actions/cache/usage-by-repository",
  "GET /orgs/{org}/actions/permissions/repositories",
  "GET /orgs/{org}/actions/runners",
  "GET /orgs/{org}/actions/secrets",
  "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/actions/variables",
  "GET /orgs/{org}/actions/variables/{name}/repositories",
  "GET /orgs/{org}/blocks",
  "GET /orgs/{org}/code-scanning/alerts",
  "GET /orgs/{org}/codespaces",
  "GET /orgs/{org}/codespaces/secrets",
  "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/copilot/billing/seats",
  "GET /orgs/{org}/dependabot/alerts",
  "GET /orgs/{org}/dependabot/secrets",
  "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/events",
  "GET /orgs/{org}/failed_invitations",
  "GET /orgs/{org}/hooks",
  "GET /orgs/{org}/hooks/{hook_id}/deliveries",
  "GET /orgs/{org}/installations",
  "GET /orgs/{org}/invitations",
  "GET /orgs/{org}/invitations/{invitation_id}/teams",
  "GET /orgs/{org}/issues",
  "GET /orgs/{org}/members",
  "GET /orgs/{org}/members/{username}/codespaces",
  "GET /orgs/{org}/migrations",
  "GET /orgs/{org}/migrations/{migration_id}/repositories",
  "GET /orgs/{org}/organization-roles/{role_id}/teams",
  "GET /orgs/{org}/organization-roles/{role_id}/users",
  "GET /orgs/{org}/outside_collaborators",
  "GET /orgs/{org}/packages",
  "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
  "GET /orgs/{org}/personal-access-token-requests",
  "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
  "GET /orgs/{org}/personal-access-tokens",
  "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
  "GET /orgs/{org}/projects",
  "GET /orgs/{org}/properties/values",
  "GET /orgs/{org}/public_members",
  "GET /orgs/{org}/repos",
  "GET /orgs/{org}/rulesets",
  "GET /orgs/{org}/rulesets/rule-suites",
  "GET /orgs/{org}/secret-scanning/alerts",
  "GET /orgs/{org}/security-advisories",
  "GET /orgs/{org}/teams",
  "GET /orgs/{org}/teams/{team_slug}/discussions",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
  "GET /orgs/{org}/teams/{team_slug}/invitations",
  "GET /orgs/{org}/teams/{team_slug}/members",
  "GET /orgs/{org}/teams/{team_slug}/projects",
  "GET /orgs/{org}/teams/{team_slug}/repos",
  "GET /orgs/{org}/teams/{team_slug}/teams",
  "GET /projects/columns/{column_id}/cards",
  "GET /projects/{project_id}/collaborators",
  "GET /projects/{project_id}/columns",
  "GET /repos/{owner}/{repo}/actions/artifacts",
  "GET /repos/{owner}/{repo}/actions/caches",
  "GET /repos/{owner}/{repo}/actions/organization-secrets",
  "GET /repos/{owner}/{repo}/actions/organization-variables",
  "GET /repos/{owner}/{repo}/actions/runners",
  "GET /repos/{owner}/{repo}/actions/runs",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
  "GET /repos/{owner}/{repo}/actions/secrets",
  "GET /repos/{owner}/{repo}/actions/variables",
  "GET /repos/{owner}/{repo}/actions/workflows",
  "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
  "GET /repos/{owner}/{repo}/activity",
  "GET /repos/{owner}/{repo}/assignees",
  "GET /repos/{owner}/{repo}/branches",
  "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
  "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
  "GET /repos/{owner}/{repo}/code-scanning/alerts",
  "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
  "GET /repos/{owner}/{repo}/code-scanning/analyses",
  "GET /repos/{owner}/{repo}/codespaces",
  "GET /repos/{owner}/{repo}/codespaces/devcontainers",
  "GET /repos/{owner}/{repo}/codespaces/secrets",
  "GET /repos/{owner}/{repo}/collaborators",
  "GET /repos/{owner}/{repo}/comments",
  "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/commits",
  "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
  "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
  "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
  "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
  "GET /repos/{owner}/{repo}/commits/{ref}/status",
  "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
  "GET /repos/{owner}/{repo}/contributors",
  "GET /repos/{owner}/{repo}/dependabot/alerts",
  "GET /repos/{owner}/{repo}/dependabot/secrets",
  "GET /repos/{owner}/{repo}/deployments",
  "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
  "GET /repos/{owner}/{repo}/environments",
  "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
  "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
  "GET /repos/{owner}/{repo}/events",
  "GET /repos/{owner}/{repo}/forks",
  "GET /repos/{owner}/{repo}/hooks",
  "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
  "GET /repos/{owner}/{repo}/invitations",
  "GET /repos/{owner}/{repo}/issues",
  "GET /repos/{owner}/{repo}/issues/comments",
  "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/issues/events",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
  "GET /repos/{owner}/{repo}/keys",
  "GET /repos/{owner}/{repo}/labels",
  "GET /repos/{owner}/{repo}/milestones",
  "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
  "GET /repos/{owner}/{repo}/notifications",
  "GET /repos/{owner}/{repo}/pages/builds",
  "GET /repos/{owner}/{repo}/projects",
  "GET /repos/{owner}/{repo}/pulls",
  "GET /repos/{owner}/{repo}/pulls/comments",
  "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
  "GET /repos/{owner}/{repo}/releases",
  "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
  "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
  "GET /repos/{owner}/{repo}/rules/branches/{branch}",
  "GET /repos/{owner}/{repo}/rulesets",
  "GET /repos/{owner}/{repo}/rulesets/rule-suites",
  "GET /repos/{owner}/{repo}/secret-scanning/alerts",
  "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
  "GET /repos/{owner}/{repo}/security-advisories",
  "GET /repos/{owner}/{repo}/stargazers",
  "GET /repos/{owner}/{repo}/subscribers",
  "GET /repos/{owner}/{repo}/tags",
  "GET /repos/{owner}/{repo}/teams",
  "GET /repos/{owner}/{repo}/topics",
  "GET /repositories",
  "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
  "GET /repositories/{repository_id}/environments/{environment_name}/variables",
  "GET /search/code",
  "GET /search/commits",
  "GET /search/issues",
  "GET /search/labels",
  "GET /search/repositories",
  "GET /search/topics",
  "GET /search/users",
  "GET /teams/{team_id}/discussions",
  "GET /teams/{team_id}/discussions/{discussion_number}/comments",
  "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
  "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
  "GET /teams/{team_id}/invitations",
  "GET /teams/{team_id}/members",
  "GET /teams/{team_id}/projects",
  "GET /teams/{team_id}/repos",
  "GET /teams/{team_id}/teams",
  "GET /user/blocks",
  "GET /user/codespaces",
  "GET /user/codespaces/secrets",
  "GET /user/emails",
  "GET /user/followers",
  "GET /user/following",
  "GET /user/gpg_keys",
  "GET /user/installations",
  "GET /user/installations/{installation_id}/repositories",
  "GET /user/issues",
  "GET /user/keys",
  "GET /user/marketplace_purchases",
  "GET /user/marketplace_purchases/stubbed",
  "GET /user/memberships/orgs",
  "GET /user/migrations",
  "GET /user/migrations/{migration_id}/repositories",
  "GET /user/orgs",
  "GET /user/packages",
  "GET /user/packages/{package_type}/{package_name}/versions",
  "GET /user/public_emails",
  "GET /user/repos",
  "GET /user/repository_invitations",
  "GET /user/social_accounts",
  "GET /user/ssh_signing_keys",
  "GET /user/starred",
  "GET /user/subscriptions",
  "GET /user/teams",
  "GET /users",
  "GET /users/{username}/events",
  "GET /users/{username}/events/orgs/{org}",
  "GET /users/{username}/events/public",
  "GET /users/{username}/followers",
  "GET /users/{username}/following",
  "GET /users/{username}/gists",
  "GET /users/{username}/gpg_keys",
  "GET /users/{username}/keys",
  "GET /users/{username}/orgs",
  "GET /users/{username}/packages",
  "GET /users/{username}/projects",
  "GET /users/{username}/received_events",
  "GET /users/{username}/received_events/public",
  "GET /users/{username}/repos",
  "GET /users/{username}/social_accounts",
  "GET /users/{username}/ssh_signing_keys",
  "GET /users/{username}/starred",
  "GET /users/{username}/subscriptions"
];

// pkg/dist-src/paginating-endpoints.js
function isPaginatingEndpoint(arg) {
  if (typeof arg === "string") {
    return paginatingEndpoints.includes(arg);
  } else {
    return false;
  }
}

// pkg/dist-src/index.js
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION;

var distWeb = /*#__PURE__*/Object.freeze({
    __proto__: null,
    composePaginateRest: composePaginateRest,
    isPaginatingEndpoint: isPaginatingEndpoint,
    paginateRest: paginateRest,
    paginatingEndpoints: paginatingEndpoints
});

var require$$4 = /*@__PURE__*/getAugmentedNamespace(distWeb);

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$1;
	hasRequiredUtils = 1;
	(function (exports) {
		var __createBinding = (utils$1 && utils$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (utils$1 && utils$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (utils$1 && utils$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
		const Context = __importStar(requireContext());
		const Utils = __importStar(requireUtils$1());
		// octokit + plugins
		const core_1 = require$$2;
		const plugin_rest_endpoint_methods_1 = require$$3;
		const plugin_paginate_rest_1 = require$$4;
		exports.context = new Context.Context();
		const baseUrl = Utils.getApiBaseUrl();
		exports.defaults = {
		    baseUrl,
		    request: {
		        agent: Utils.getProxyAgent(baseUrl),
		        fetch: Utils.getProxyFetch(baseUrl)
		    }
		};
		exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
		/**
		 * Convience function to correctly format Octokit Options to pass into the constructor.
		 *
		 * @param     token    the repo PAT or GITHUB_TOKEN
		 * @param     options  other options to set
		 */
		function getOctokitOptions(token, options) {
		    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
		    // Auth
		    const auth = Utils.getAuthString(token, opts);
		    if (auth) {
		        opts.auth = auth;
		    }
		    return opts;
		}
		exports.getOctokitOptions = getOctokitOptions;
		
	} (utils$1));
	return utils$1;
}

var hasRequiredGithub;

function requireGithub () {
	if (hasRequiredGithub) return github;
	hasRequiredGithub = 1;
	var __createBinding = (github && github.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (github && github.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (github && github.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(github, "__esModule", { value: true });
	github.getOctokit = github.context = void 0;
	const Context = __importStar(requireContext());
	const utils_1 = requireUtils();
	github.context = new Context.Context();
	/**
	 * Returns a hydrated octokit ready to use for GitHub Actions
	 *
	 * @param     token    the repo PAT or GITHUB_TOKEN
	 * @param     options  other options to set
	 */
	function getOctokit(token, options, ...additionalPlugins) {
	    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
	    return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
	}
	github.getOctokit = getOctokit;
	
	return github;
}

requireGithub();

async function get_logo() {
    let image = await Jimp.read(coreExports.getInput("logo"));

    return {
        width: image.bitmap.width,
        height: image.bitmap.height,
        data: image.bitmap.data,
    };
}

async function get_font() {
    try {
        const response = await fetch(coreExports.getInput("font"));
        if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
        }

        const arrayBuffer = await response.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        return bytes;
    } catch (error) {
        console.error("Error fetching file:", error);
        return null;
  }
}

async function create_badge() {
    let icon = await get_logo();
    web_spfExports.load_layout_from_file("badge-font", await get_font(), true);

    let label_socket = new web_spfExports.PrintSocket();
    label_socket.text = coreExports.getInput("label");
    label_socket.letter_spacing = 1;
    
    let message_socket = new web_spfExports.PrintSocket();
    message_socket.text = coreExports.getInput("message");
    message_socket.letter_spacing = 1;

    let socket = new web_spfExports.BadgeSocket();
    socket.label = label_socket;
    socket.message = message_socket;
    socket.label_color = coreExports.getInput("labelColor");
    socket.color = coreExports.getInput("color");

    let logo_texture = new web_spfExports.Texture();
    logo_texture.width = icon.width;
    logo_texture.height = icon.height;
    logo_texture.texture_data = icon.data;
    socket.logo = logo_texture;
    const texture = web_spfExports.print_badge(socket);
    console.log("we good so far!");

    const width = texture.width;
    const height = texture.height;
    const texture_data = texture.texture_data;

    const image = new Jimp({data: texture_data, width: width, height: height});
    image.write(coreExports.getInput("filename"));
}

try {
    create_badge();
} catch (error) {
    coreExports.setFailed(error.message);
}
//# sourceMappingURL=index.js.map
